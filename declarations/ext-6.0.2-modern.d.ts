/*
Premium TypeScript type definitions for Sencha Ext JS
ExtTS for ExtJS 6.0.2.437

Copyright (C) 2015-2016 ExtFX.NET
Contact: thanhptr@gmail.com

Build date: 2016-04-12 17:53:20 (GMT)
Version: 1.0.0.0

*/

/**
 * The Ext namespace (global object) encapsulates all classes, singletons, and
 * utility methods provided by Sencha's libraries.
 *
 * Most user interface Components are at a lower level of nesting in the namespace,
 * but many common utility functions are provided as direct properties of the Ext namespace.
 *
 * Also many frequently used methods from other classes are provided as shortcuts
 * within the Ext namespace. For example {@link Ext#getCmp Ext.getCmp} aliases
 * {@link Ext.ComponentManager#get Ext.ComponentManager.get}.
 *
 * Many applications are initiated with {@link Ext#application Ext.application} which is
 * called once the DOM is ready. This ensures all scripts have been loaded, preventing
 * dependency issues. For example:
 *
 *      Ext.application({
 *          name: 'MyApp',
 *
 *          launch: function () {
 *              Ext.Msg.alert(this.name, 'Ready to go!');
 *          }
 *      });
 *
 * <b><a href="http://www.sencha.com/products/sencha-cmd/">Sencha Cmd</a></b> is a free tool
 * for helping you generate and build Ext JS (and Sencha Touch) applications. See
 * '{@link Ext.app.Application Application}' for more information about creating an app.
 *
 * A lower-level technique that does not use the 'Ext.app.Application' architecture is
 * {@link Ext#onReady Ext.onReady}.
 *
 * For more information about how to use the Ext classes, see:
 *
 * - <a href="http://www.sencha.com/learn/">The Learning Center</a>
 * - <a href="http://www.sencha.com/learn/Ext_FAQ">The FAQ</a>
 * - <a href="http://www.sencha.com/forum/">The forums</a>
 */
declare class Ext {
    /**
     * The base prefix to use for all 'Ext' components. To configure this property, you should use the
     * Ext.buildSettings object before the framework is loaded:
     *
     *     Ext.buildSettings = {
     *         baseCSSPrefix : 'abc-'
     *     };
     *
     * or you can change it before any components are rendered:
     *
     *     Ext.baseCSSPrefix = Ext.buildSettings.baseCSSPrefix = 'abc-';
     *
     * This will change what CSS classes components will use and you should
     * then recompile the SASS changing the '$prefix' SASS variable to match.
     *
     * Optional, Defaults to: 'x-'
     */
    static baseCSSPrefix: string;

    /**
     * URL to a 1x1 transparent gif image used by Ext to create inline icons with
     * CSS background images.
     */
    static BLANK_IMAGE_URL: string;

    /**
     * The current version of Chrome (0 if the browser is not Chrome).
     * @readonly
     */
    static chromeVersion: number;

    /**
     * A reusable empty function.
     */
    static emptyFn: any;

    /**
     * A zero length string which will pass a truth test. Useful for passing to methods
     * which use a truth test to reject <i>falsy</i> values where a string value must be cleared.
     */
    static emptyString: any;

    /**
     * This property is provided for backward
     * compatibility with previous versions of Ext JS. Accessibility is always enabled
     * in Ext JS 6.0+.
     *
     * This property is deprecated. To disable WAI-ARIA compatibility warnings,
     * override 'Ext.ariaWarn' function in your application startup code:
     *
     *      Ext.application({
     *          launch: function() {
     *              Ext.ariaWarn = Ext.emptyFn;
     *          }
     *      });
     *
     * For stricter compatibility with WAI-ARIA requirements, replace 'Ext.ariaWarn'
     * with a function that will raise an error instead:
     *
     *      Ext.application({
     *          launch: function() {
     *              Ext.ariaWarn = function(target, msg) {
     *                  Ext.raise({
     *                      msg: msg,
     *                      component: target
     *                  });
     *              };
     *          }
     *      });
     *
     * @since 6.0.0
     * @deprecated 6.0.2
     *
     * Optional, Defaults to: true
     */
    static enableAria: boolean;

    /**
     * 'true' to automatically uncache orphaned Ext.Elements periodically. If set to
     * 'false', the application will be required to clean up orphaned Ext.Elements and
     * it's listeners as to not cause memory leakage.
     */
    static enableGarbageCollector: any;

    /**
     * True to automatically purge event listeners during garbageCollection.
     */
    static enableListenerCollection: any;

    /**
     * An array containing extra enumerables for old browsers
     */
    static enumerables: any;

    /**
     * The current version of Firefox (0 if the browser is not Firefox).
     * @readonly
     */
    static firefoxVersion: number;

    /**
     * This indicate the start timestamp of current cycle.
     * It is only reliable during dom-event-initiated cycles and
     * {@link Ext.draw.Animator} initiated cycles.
     */
    static frameStartTime: any;

    /**
     * A reusable identity function that simply returns its first argument.
     */
    static identityFn: any;

    /**
     * The current version of IE (0 if the browser is not IE). This does not account
     * for the documentMode of the current page, which is factored into {@link #isIE8},
     * and {@link #isIE9}. Thus this is not always true:
     *
     *     Ext.isIE8 == (Ext.ieVersion == 8)
     *
     * @readonly
     */
    static ieVersion: number;

    /**
     * True if the detected browser is Chrome.
     * @readonly
     */
    static isChrome: boolean;

    /**
     * 'true' when the document body is ready for use.
     * @readonly
     */
    static isDomReady: boolean;

    /**
     * True if the detected browser is Edge.
     * @readonly
     */
    static isEdge: boolean;

    /**
     * True if the detected browser uses the Gecko layout engine (e.g. Mozilla, Firefox).
     * @readonly
     */
    static isGecko: boolean;

    /**
     * True if the detected browser is Internet Explorer.
     * @readonly
     */
    static isIE: boolean;

    /**
     * True if the detected browser is Internet Explorer 10.x.
     * @readonly
     */
    static isIE10: boolean;

    /**
     * True if the detected browser is Internet Explorer 10.x or lower.
     * @readonly
     */
    static isIE10m: boolean;

    /**
     * True if the detected browser is Internet Explorer 10.x or higher.
     * @readonly
     */
    static isIE10p: boolean;

    /**
     * True if the detected browser is Internet Explorer 11.x.
     * @readonly
     */
    static isIE11: boolean;

    /**
     * True if the detected browser is Internet Explorer 11.x or lower.
     * @readonly
     */
    static isIE11m: boolean;

    /**
     * True if the detected browser is Internet Explorer 11.x or higher.
     * @readonly
     */
    static isIE11p: boolean;

    /**
     * True if the detected browser is Internet Explorer 8.x.
     * @readonly
     */
    static isIE8: boolean;

    /**
     * True if the detected browser is Internet Explorer 8.x or lower.
     * @readonly
     */
    static isIE8m: boolean;

    /**
     * True if the detected browser is Internet Explorer 8.x or higher.
     * @readonly
     */
    static isIE8p: boolean;

    /**
     * True if the detected browser is Internet Explorer 9.x.
     * @readonly
     */
    static isIE9: boolean;

    /**
     * True if the detected browser is Internet Explorer 9.x or lower.
     * @readonly
     */
    static isIE9m: boolean;

    /**
     * True if the detected browser is Internet Explorer 9.x or higher.
     * @readonly
     */
    static isIE9p: boolean;

    /**
     * True if the detected platform is Linux.
     * @readonly
     */
    static isLinux: boolean;

    /**
     * True if the detected platform is Mac OS.
     * @readonly
     */
    static isMac: boolean;

    /**
     * True if the detected browser is Opera.
     * @readonly
     */
    static isOpera: boolean;

    /**
     * 'true' when 'isDomReady' is true and the Framework is ready for use.
     * @readonly
     */
    static isReady: boolean;

    /**
     * True if the detected browser is Safari.
     * @readonly
     */
    static isSafari: boolean;

    /**
     * True if the page is running over SSL
     * @readonly
     */
    static isSecure: boolean;

    /**
     * True if the detected browser uses WebKit.
     * @readonly
     */
    static isWebKit: boolean;

    /**
     * True if the detected platform is Windows.
     * @readonly
     */
    static isWindows: boolean;

    /**
     * <p>The name of the property in the global namespace (The <code>window</code> in browser environments) which refers to the current instance of Ext.</p>
     * <p>This is usually <code>"Ext"</code>, but if a sandboxed build of ExtJS is being used, this will be an alternative name.</p>
     * <p>If code is being generated for use by <code>eval</code> or to create a <code>new Function</code>, and the global instance
     * of Ext must be referenced, this is the name that should be built into the code.</p>
     *
     * Optional, Defaults to: 'Ext'
     */
    static name: string;

    /**
     * The current version of Opera (0 if the browser is not Opera).
     * @readonly
     */
    static operaVersion: number;

    /**
     * This object contains properties that describe the current device or platform. These
     * values can be used in '{@link Ext.Class#platformConfig platformConfig}' as well as
     * '{@link Ext.mixin.Responsive#responsiveConfig responsiveConfig}' statements.
     *
     * This object can be modified to include tags that are useful for the application. To
     * add custom properties, it is advisable to use a sub-object. For example:
     *
     *      Ext.platformTags.app = {
     *          mobile: true
     *      };
     *
     * Indicates touch inputs are available.
     * True for iPad, iPhone and iPod.
     */
    static platformTags: any;

    /**
     * A reusable empty function for use as 'privates' members.
     *
     *      Ext.define('MyClass', {
     *          nothing: Ext.emptyFn,
     *
     *          privates: {
     *              privateNothing: Ext.privateFn
     *          }
     *      });
     */
    static privateFn: any;

    /**
     * The current version of Safari (0 if the browser is not Safari).
     * @readonly
     */
    static safariVersion: number;

    /**
     * URL to a blank file used by Ext when in secure mode for iframe src and onReady src
     * to prevent the IE insecure content warning (''about:blank'', except for IE
     * in secure mode, which is ''javascript:""'').
     */
    static SSL_SECURE_URL: string;

    /**
     * Indicates whether to use native browser parsing for JSON methods.
     * This option is ignored if the browser does not support native JSON methods.
     *
     * **Note:** Native JSON methods will not work with objects that have functions.
     * Also, property names must be quoted, otherwise the data will not parse.
     *
     * Optional, Defaults to: false
     */
    static USE_NATIVE_JSON: boolean;

    /**
     * The current version of WebKit (0 if the browser does not use WebKit).
     * @readonly
     */
    static webKitVersion: number;

    /**
     * This object is used to enable or disable debugging for classes or namespaces. The
     * default instance looks like this:
     *
     *      Ext.debugConfig = {
     *          hooks: {
     *              '*': true
     *          }
     *      };
     *
     * Typically applications will set this in their '"app.json"' like so:
     *
     *      {
     *          "debug": {
     *              "hooks": {
     *                  // Default for all namespaces:
     *                  '*': true,
     *
     *                  // Except for Ext namespace which is disabled
     *                  'Ext': false,
     *
     *                  // Except for Ext.layout namespace which is enabled
     *                  'Ext.layout': true
     *              }
     *          }
     *      }
     *
     * Alternatively, because this property is consumed very early in the load process of
     * the framework, this can be set in a 'script' tag that is defined prior to loading
     * the framework itself.
     *
     * For example, to enable debugging for the 'Ext.layout' namespace only:
     *
     *      var Ext = Ext || {};
     *      Ext.debugConfig = {
     *          hooks: {
     *              //...
     *          }
     *      };
     *
     * For any class declared, the longest matching namespace specified determines if its
     * 'debugHooks' will be enabled. The default setting is specified by the '*' property.
     *
     * **NOTE:** This option only applies to debug builds. All debugging is disabled in
     * production builds.
     *
     * Optional
     */
    static debugConfig: any;

    /**
     * This object is initialized prior to loading the framework (Ext JS or Sencha
     * Touch) and contains settings and other information describing the application.
     *
     * For applications built using Sencha Cmd, this is produced from the '"app.json"'
     * file with information extracted from all of the required packages' '"package.json"'
     * files. This can be set to a string when your application is using the
     * (microloader)[#/guide/microloader]. In this case, the string of "foo" will be
     * requested as '"foo.json"' and the object in that JSON file will parsed and set
     * as this object.
     *
     *
     * An object keyed by package name with
     * the value being to desired compatibility level as a version number. If this is
     * just a string, this version is assumed to apply to the framework ('ext' or
     * 'touch'). Setting this value to less than 5 for 'ext' will enable the compatibility
     * layer to assist in the application upgrade process. For details on the upgrade
     * process, see the (Upgrade Guide)[#/guides/upgrade_50].
     *
     * An object configuring the debugging characteristics
     * of the framework. See 'Ext.debugConfig' which is set to this value.
     *
     * An object keyed by package name with the value
     * being a subset of the package's '"package.json"' descriptor.
     * @since 5.0.0
     */
    static manifest: string|any;

    /**
     * Same as {@link Ext.ComponentQuery#query}.
     * @param {String} selector The selector string to filter returned Components.
     * @param {Ext.container.Container} [root] The Container within which to perform the query.
     * If omitted, all Components within the document are included in the search.
     *
     * This parameter may also be an array of Components to filter according to the selector.
     * @return {Ext.Component[]} The matched Components.
     */
    static all(selector: string, root?: Ext.Container): Ext.Component;

    /**
     * Loads Ext.app.Application class and starts it up with given configuration after the
     * page is ready.
     *
     * See 'Ext.app.Application' for details.
     *
     * @param {Object/String} config Application config object or name of a class derived
     * from Ext.app.Application.
     */
    static application(config: any|string);

    /**
     * Copies all the properties of 'config' to the specified 'object'. There are two levels
     * of defaulting supported:
     *
     *      Ext.apply(obj, { a: 1 }, { a: 2 });
     *      //obj.a === 1
     *
     *      Ext.apply(obj, {  }, { a: 2 });
     *      //obj.a === 2
     *
     * Note that if recursive merging and cloning without referencing the original objects
     * or arrays is needed, use {@link Ext.Object#merge} instead.
     *
     * @param {Object} object The receiver of the properties.
     * @param {Object} config The primary source of the properties.
     * @param {Object} [defaults] An object that will also be applied for default values.
     * @return {Object} returns 'object'.
     */
    static apply(object: any, config: any, defaults?: any): any;

    /**
     * Copies all the properties of config to object if they don't already exist.
     * @param {Object} object The receiver of the properties
     * @param {Object} config The source of the properties
     * @return {Object} returns obj
     */
    static applyIf(object: any, config: any): any;

    /**
     * Schedules the specified callback function to be executed on the next turn of the
     * event loop. Where available, this method uses the browser's 'setImmediate' API. If
     * not available, this method substitutes 'setTimeout(0)'. Though not a perfect
     * replacement for 'setImmediate' it is sufficient for many use cases.
     *
     * For more details see [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Window/setImmediate).
     *
     * @param {Function} fn Callback function.
     * @param {Object} [scope] The scope for the callback ('this' pointer).
     * @param {Mixed[]} [parameters] Additional parameters to pass to 'fn'.
     * @return {Number} A cancelation id for '{@link Ext#asapCancel}'.
     */
    static asap(fn: Function, scope?: any, parameters?: any): number;

    /**
     * Cancels a previously scheduled call to '{@link Ext#asap}'.
     *
     *      var asapId = Ext.asap(me.method, me);
     *      ...
     *
     *      if (nevermind) {
     *          Ext.apasCancel(asapId);
     *      }
     *
     * @param {Number} id The id returned by '{@link Ext#asap}'.
     */
    static asapCancel(id: number);

    static bind();

    /**
     * Execute a callback function in a particular scope. If 'callback' argument is a
     * function reference, that is called. If it is a string, the string is assumed to
     * be the name of a method on the given 'scope'. If no function is passed the call
     * is ignored.
     *
     * For example, these calls are equivalent:
     *
     *      var myFunc = this.myFunc;
     *
     *      Ext.callback('myFunc', this, [arg1, arg2]);
     *      Ext.callback(myFunc, this, [arg1, arg2]);
     *
     *      Ext.isFunction(myFunc) && this.myFunc(arg1, arg2);
     *
     * @param {Function/String} callback The callback function to execute or the name of
     * the callback method on the provided 'scope'.
     * @param {Object} [scope] The scope in which 'callback' should be invoked. If 'callback'
     * is a string this object provides the method by that name. If this is 'null' then
     * the 'caller' is used to resolve the scope to a 'ViewController' or the proper
     * 'defaultListenerScope'.
     * @param {Array} [args] The arguments to pass to the function.
     * @param {Number} [delay] Pass a number to delay the call by a number of milliseconds.
     * @param {Object} [caller] The object calling the callback. This is used to resolve
     * named methods when no explicit 'scope' is provided.
     * @param {Object} [defaultScope=caller] The default scope to return if none is found.
     * @return The value returned by the callback or 'undefined' (if there is a 'delay'
     * or if the 'callback' is not a function).
     */
    static callback(callback: Function|string, scope?: any, args?: any[], delay?: number, caller?: any, defaultScope?: any);

    /**
     * This method checks the registered package versions against the provided version
     * 'specs'. A 'spec' is either a string or an object indicating a boolean operator.
     * This method accepts either form or an array of these as the first argument. The
     * second argument applies only when the first is an array and indicates whether
     * all 'specs' must match or just one.
     *
     * ## Package Version Specifications
     * The string form of a 'spec' is used to indicate a version or range of versions
     * for a particular package. This form of 'spec' consists of three (3) parts:
     *
     *  * Package name followed by "@". If not provided, the framework is assumed.
     *  * Minimum version.
     *  * Maximum version.
     *
     * At least one version number must be provided. If both minimum and maximum are
     * provided, these must be separated by a "-".
     *
     * Some examples of package version specifications:
     *
     *      4.2.2           (exactly version 4.2.2 of the framework)
     *      4.2.2+          (version 4.2.2 or higher of the framework)
     *      4.2.2-          (version 4.2.2 or higher of the framework)
     *      4.2.1 - 4.2.3   (versions from 4.2.1 up to 4.2.3 of the framework)
     *      - 4.2.2         (any version up to version 4.2.1 of the framework)
     *
     *      foo@1.0         (exactly version 1.0 of package "foo")
     *      foo@1.0-1.3     (versions 1.0 up to 1.3 of package "foo")
     *
     * **NOTE:** This syntax is the same as that used in Sencha Cmd's package
     * requirements declarations.
     *
     * ## Boolean Operator Specifications
     * Instead of a string, an object can be used to describe a boolean operation to
     * perform on one or more 'specs'. The operator is either **'and'** or **'or'**
     * and can contain an optional **'not'**.
     *
     * For example:
     *
     *      {
     *          not: true,  // negates boolean result
     *          and: [
     *              '4.2.2',
     *              'foo@1.0.1 - 2.0.1'
     *          ]
     *      }
     *
     * Each element of the array can in turn be a string or object spec. In other
     * words, the value is passed to this method (recursively) as the first argument
     * so these two calls are equivalent:
     *
     *      Ext.checkVersion({
     *          not: true,  // negates boolean result
     *          and: [
     *              '4.2.2',
     *              'foo@1.0.1 - 2.0.1'
     *          ]
     *      });
     *
     *      !Ext.checkVersion([
     *              '4.2.2',
     *              'foo@1.0.1 - 2.0.1'
     *          ], true);
     *
     * ## Examples
     *
     *      // A specific framework version
     *      Ext.checkVersion('4.2.2');
     *
     *      // A range of framework versions:
     *      Ext.checkVersion('4.2.1-4.2.3');
     *
     *      // A specific version of a package:
     *      Ext.checkVersion('foo@1.0.1');
     *
     *      // A single spec that requires both a framework version and package
     *      // version range to match:
     *      Ext.checkVersion({
     *          and: [
     *              '4.2.2',
     *              'foo@1.0.1-1.0.2'
     *          ]
     *      });
     *
     *      // These checks can be nested:
     *      Ext.checkVersion({
     *          and: [
     *              '4.2.2',  // exactly version 4.2.2 of the framework *AND*
     *              {
     *                  // either (or both) of these package specs:
     *                  or: [
     *                      'foo@1.0.1-1.0.2',
     *                      'bar@3.0+'
     *                  ]
     *              }
     *          ]
     *      });
     *
     * ## Version Comparisons
     * Version comparsions are assumed to be "prefix" based. That is to say, '"foo@1.2"'
     * matches any version of "foo" that has a major version 1 and a minor version of 2.
     *
     * This also applies to ranges. For example '"foo@1.2-2.2"' matches all versions
     * of "foo" from 1.2 up to 2.2 regardless of the specific patch and build.
     *
     * ## Use in Overrides
     * This methods primary use is in support of conditional overrides on an
     * 'Ext.define' declaration.
     *
     * @param {String/Array/Object} specs A version specification string, an object
     * containing 'or' or 'and' with a value that is equivalent to 'specs' or an array
     * of either of these.
     * @param {Boolean} [matchAll=false] Pass 'true' to require all specs to match.
     * @return {Boolean} True if 'specs' matches the registered package versions.
     */
    static checkVersion(specs: string|any[]|any, matchAll?: boolean): boolean;

    /**
     * Old alias to {@link Ext.Array#clean}
     * @deprecated 4.0.0 Use {@link Ext.Array#clean} instead
     */
    static clean();

    /**
     * Clone simple variables including array, {}-like objects, DOM nodes and Date without keeping the old reference.
     * A reference for the object itself is returned if it's not a direct descendant of Object. For model cloning,
     * see {@link Ext.data.Model#copy Model.copy}.
     *
     * @param {Object} item The variable to clone
     * @return {Object} clone
     */
    static clone(item: any): any;

    /**
     * Coerces the first value if possible so that it is comparable to the second value.
     *
     * Coercion only works between the basic atomic data types String, Boolean, Number, Date, null and undefined.
     *
     * Numbers and numeric strings are coerced to Dates using the value as the millisecond era value.
     *
     * Strings are coerced to Dates by parsing using the {@link Ext.Date#defaultFormat defaultFormat}.
     *
     * For example
     *
     *     Ext.coerce('false', true);
     *
     * returns the boolean value 'false' because the second parameter is of type 'Boolean'.
     *
     * @param {Mixed} from The value to coerce
     * @param {Mixed} to The value it must be compared against
     * @return The coerced value.
     */
    static coerce(from: any, to: any);

    /**
     * Copies a set of named properties fom the source object to the destination object.
     *
     * Example:
     *
     *     var foo = { a: 1, b: 2, c: 3 };
     *
     *     var bar = Ext.copy({}, foo, 'a,c');
     *     // bar = { a: 1, c: 3 };
     *
     * Important note: To borrow class prototype methods, use {@link Ext.Base#borrow} instead.
     *
     * @param {Object} dest The destination object.
     * @param {Object} source The source object.
     * @param {String/String[]} names Either an Array of property names, or a comma-delimited list
     * of property names to copy.
     * @param {Boolean} [usePrototypeKeys=false] Pass 'true' to copy keys off of the
     * prototype as well as the instance.
     * @return {Object} The 'dest' object.
     */
    static copy(dest: any, source: any, names: string, usePrototypeKeys?: boolean): any;

    /**
     * Copies a set of named properties fom the source object to the destination object
     * if the destination object does not already have them.
     *
     * Example:
     *
     *     var foo = { a: 1, b: 2, c: 3 };
     *
     *     var bar = Ext.copyIf({ a:42 }, foo, 'a,c');
     *     // bar = { a: 42, c: 3 };
     *
     * @param {Object} destination The destination object.
     * @param {Object} source The source object.
     * @param {String/String[]} names Either an Array of property names, or a single string
     * with a list of property names separated by ",", ";" or spaces.
     * @return {Object} The 'dest' object.
     */
    static copyIf(destination: any, source: any, names: string): any;

    /**
     * Copies a set of named properties fom the source object to the destination object.
     *
     * Example:
     *
     *     var foo = { a: 1, b: 2, c: 3 };
     *
     *     var bar = Ext.copyTo({}, foo, 'a,c');
     *     // bar = { a: 1, c: 3 };
     *
     * Important note: To borrow class prototype methods, use {@link Ext.Base#borrow} instead.
     *
     * @param {Object} dest The destination object.
     * @param {Object} source The source object.
     * @param {String/String[]} names Either an Array of property names, or a comma-delimited list
     * of property names to copy.
     * @param {Boolean} [usePrototypeKeys=false] Pass 'true' to copy keys off of the
     * prototype as well as the instance.
     * @return {Object} The 'dest' object.
     * @deprecated 6.0.1 Use {@link Ext#copy Ext.copy} instead. This old method
     * would copy the named preoperties even if they did not exist in the source which
     * could produce 'undefined' values in the destination.
     */
    static copyTo(dest: any, source: any, names: string, usePrototypeKeys?: boolean): any;

    /**
     * Copies a set of named properties fom the source object to the destination object
     * if the destination object does not already have them.
     *
     * Example:
     *
     *     var foo = { a: 1, b: 2, c: 3 };
     *
     *     var bar = Ext.copyToIf({ a:42 }, foo, 'a,c');
     *     // bar = { a: 42, c: 3 };
     *
     * @param {Object} destination The destination object.
     * @param {Object} source The source object.
     * @param {String/String[]} names Either an Array of property names, or a single string
     * with a list of property names separated by ",", ";" or spaces.
     * @return {Object} The 'dest' object.
     * @deprecated 6.0.1 Use {@link Ext#copyIf Ext.copyIf} instead. This old method
     * would copy the named preoperties even if they did not exist in the source which
     * could produce 'undefined' values in the destination.
     */
    static copyToIf(destination: any, source: any, names: string): any;

    /**
     * Instantiate a class by either full name, alias or alternate name.
     *
     * If {@link Ext.Loader} is {@link Ext.Loader#setConfig enabled} and the class has
     * not been defined yet, it will attempt to load the class via synchronous loading.
     *
     * For example, all these three lines return the same result:
     *
     *      // xtype
     *      var window = Ext.create({
     *          xtype: 'window',
     *          width: 600,
     *          height: 800,
     *          ...
     *      });
     *
     *      // alias
     *      var window = Ext.create('widget.window', {
     *          width: 600,
     *          height: 800,
     *          ...
     *      });
     *
     *      // alternate name
     *      var window = Ext.create('Ext.Window', {
     *          width: 600,
     *          height: 800,
     *          ...
     *      });
     *
     *      // full class name
     *      var window = Ext.create('Ext.window.Window', {
     *          width: 600,
     *          height: 800,
     *          ...
     *      });
     *
     *      // single object with xclass property:
     *      var window = Ext.create({
     *          xclass: 'Ext.window.Window', // any valid value for 'name' (above)
     *          width: 600,
     *          height: 800,
     *          ...
     *      });
     *
     * @param {String} [name] The class name or alias. Can be specified as 'xclass'
     * property if only one object parameter is specified.
     * @param {Object...} [args] Additional arguments after the name will be passed to
     * the class' constructor.
     * @return {Object} instance
     */
    static create(name?: string, args?: any): any;

    static createByAlias();

    /**
     * Shorthand for {@link Ext.JSON#decode}
     */
    static decode();

    static defer();

    /**
     * Defines a class or override. A basic class is defined like this:
     *
     *      Ext.define('My.awesome.Class', {
     *          someProperty: 'something',
     *
     *          someMethod: function(s) {
     *              alert(s + this.someProperty);
     *          }
     *
     *          ...
     *      });
     *
     *      var obj = new My.awesome.Class();
     *
     *      obj.someMethod('Say '); // alerts 'Say something'
     *
     * To create an anonymous class, pass 'null' for the 'className':
     *
     *      Ext.define(null, {
     *          constructor: function () {
     *              // ...
     *          }
     *      });
     *
     * In some cases, it is helpful to create a nested scope to contain some private
     * properties. The best way to do this is to pass a function instead of an object
     * as the second parameter. This function will be called to produce the class
     * body:
     *
     *      Ext.define('MyApp.foo.Bar', function () {
     *          var id = 0;
     *
     *          return {
     *              nextId: function () {
     *                  return ++id;
     *              }
     *          };
     *      });
     *
     * _Note_ that when using override, the above syntax will not override successfully, because
     * the passed function would need to be executed first to determine whether or not the result
     * is an override or defining a new object. As such, an alternative syntax that immediately
     * invokes the function can be used:
     *
     *      Ext.define('MyApp.override.BaseOverride', function () {
     *          var counter = 0;
     *
     *          return {
     *              override: 'Ext.Component',
     *              logId: function () {
     *                  console.log(++counter, this.id);
     *              }
     *          };
     *      }());
     *
     *
     * When using this form of 'Ext.define', the function is passed a reference to its
     * class. This can be used as an efficient way to access any static properties you
     * may have:
     *
     *      Ext.define('MyApp.foo.Bar', function (Bar) {
     *          return {
     *              statics: {
     *                  staticMethod: function () {
     *                      // ...
     *                  }
     *              },
     *
     *              method: function () {
     *                  return Bar.staticMethod();
     *              }
     *          };
     *      });
     *
     * To define an override, include the 'override' property. The content of an
     * override is aggregated with the specified class in order to extend or modify
     * that class. This can be as simple as setting default property values or it can
     * extend and/or replace methods. This can also extend the statics of the class.
     *
     * One use for an override is to break a large class into manageable pieces.
     *
     *      // File: /src/app/Panel.js
     *
     *      Ext.define('My.app.Panel', {
     *          extend: 'Ext.panel.Panel',
     *          requires: [
     *              'My.app.PanelPart2',
     *              'My.app.PanelPart3'
     *          ]
     *
     *          constructor: function (config) {
     *              this.callParent(arguments); // calls Ext.panel.Panel's constructor
     *              //...
     *          },
     *
     *          statics: {
     *              method: function () {
     *                  return 'abc';
     *              }
     *          }
     *      });
     *
     *      // File: /src/app/PanelPart2.js
     *      Ext.define('My.app.PanelPart2', {
     *          override: 'My.app.Panel',
     *
     *          constructor: function (config) {
     *              this.callParent(arguments); // calls My.app.Panel's constructor
     *              //...
     *          }
     *      });
     *
     * Another use of overrides is to provide optional parts of classes that can be
     * independently required. In this case, the class may even be unaware of the
     * override altogether.
     *
     *      Ext.define('My.ux.CoolTip', {
     *          override: 'Ext.tip.ToolTip',
     *
     *          constructor: function (config) {
     *              this.callParent(arguments); // calls Ext.tip.ToolTip's constructor
     *              //...
     *          }
     *      });
     *
     * The above override can now be required as normal.
     *
     *      Ext.define('My.app.App', {
     *          requires: [
     *              'My.ux.CoolTip'
     *          ]
     *      });
     *
     * Overrides can also contain statics, inheritableStatics, or privates:
     *
     *      Ext.define('My.app.BarMod', {
     *          override: 'Ext.foo.Bar',
     *
     *          statics: {
     *              method: function (x) {
     *                  return this.callParent([x * 2]); // call Ext.foo.Bar.method
     *              }
     *          }
     *      });
     *
     * Starting in version 4.2.2, overrides can declare their 'compatibility' based
     * on the framework version or on versions of other packages. For details on the
     * syntax and options for these checks, see 'Ext.checkVersion'.
     *
     * The simplest use case is to test framework version for compatibility:
     *
     *      Ext.define('App.overrides.grid.Panel', {
     *          override: 'Ext.grid.Panel',
     *
     *          compatibility: '4.2.2', // only if framework version is 4.2.2
     *
     *          //...
     *      });
     *
     * An array is treated as an OR, so if any specs match, the override is
     * compatible.
     *
     *      Ext.define('App.overrides.some.Thing', {
     *          override: 'Foo.some.Thing',
     *
     *          compatibility: [
     *              '4.2.2',
     *              'foo@1.0.1-1.0.2'
     *          ],
     *
     *          //...
     *      });
     *
     * To require that all specifications match, an object can be provided:
     *
     *      Ext.define('App.overrides.some.Thing', {
     *          override: 'Foo.some.Thing',
     *
     *          compatibility: {
     *              and: [
     *                  '4.2.2',
     *                  'foo@1.0.1-1.0.2'
     *              ]
     *          },
     *
     *          //...
     *      });
     *
     * Because the object form is just a recursive check, these can be nested:
     *
     *      Ext.define('App.overrides.some.Thing', {
     *          override: 'Foo.some.Thing',
     *
     *          compatibility: {
     *              and: [
     *                  '4.2.2',  // exactly version 4.2.2 of the framework *AND*
     *                  {
     *                      // either (or both) of these package specs:
     *                      or: [
     *                          'foo@1.0.1-1.0.2',
     *                          'bar@3.0+'
     *                      ]
     *                  }
     *              ]
     *          },
     *
     *          //...
     *      });
     *
     * IMPORTANT: An override is only included in a build if the class it overrides is
     * required. Otherwise, the override, like the target class, is not included. In
     * Sencha Cmd v4, the 'compatibility' declaration can likewise be used to remove
     * incompatible overrides from a build.
     *
     * @param {String} className The class name to create in string dot-namespaced format, for example:
     * 'My.very.awesome.Class', 'FeedViewer.plugin.CoolPager'
     * It is highly recommended to follow this simple convention:
     *  - The root and the class name are 'CamelCased'
     *  - Everything else is lower-cased
     * Pass 'null' to create an anonymous class.
     * @param {Object} data The key - value pairs of properties to apply to this class. Property names can be of any valid
     * strings, except those in the reserved listed below:
     *
     *  - {@link Ext.Class#cfg-alias alias}
     *  - {@link Ext.Class#cfg-alternateClassName alternateClassName}
     *  - {@link Ext.Class#cfg-cachedConfig cachedConfig}
     *  - {@link Ext.Class#cfg-config config}
     *  - {@link Ext.Class#cfg-extend extend}
     *  - {@link Ext.Class#cfg-inheritableStatics inheritableStatics}
     *  - {@link Ext.Class#cfg-mixins mixins}
     *  - {@link Ext.Class#cfg-override override}
     *  - {@link Ext.Class#cfg-platformConfig platformConfig}
     *  - {@link Ext.Class#cfg-privates privates}
     *  - {@link Ext.Class#cfg-requires requires}
     *  - 'self'
     *  - {@link Ext.Class#cfg-singleton singleton}
     *  - {@link Ext.Class#cfg-statics statics}
     *  - {@link Ext.Class#cfg-uses uses}
     *  - {@link Ext.Class#cfg-xtype xtype} (for {@link Ext.Component Components} only)
     *
     * @param {Function} [createdFn] Callback to execute after the class is created, the execution scope of which
     * ('this') will be the newly created class itself.
     * @return {Ext.Base}
     */
    static define(className: string, data: any, createdFn?: Function): Ext.Base;

    /**
     * Destroys all of the given objects. If arrays are passed, the elements of these
     * are destroyed recursively.
     *
     * What it means to "destroy" an object depends on the type of object.
     *
     *  * 'Array': Each element of the array is destroyed recursively.
     *  * 'Object': Any object with a 'destroy' method will have that method called.
     *
     * @param {Mixed...} args Any number of objects or arrays.
     */
    static destroy(args: any);

    /**
     * Destroys the specified named members of the given object using 'Ext.destroy'. These
     * properties will be set to 'null'.
     * @param {Object} object The object who's properties you wish to destroy.
     * @param {String...} args One or more names of the properties to destroy and remove from the object.
     */
    static destroyMembers(object: any, args: string);

    static each();

    /**
     * Shorthand for {@link Ext.JSON#encode}
     */
    static encode();

    /**
     * Explicitly exclude files from being loaded. Useful when used in conjunction with a
     * broad include expression. Can be chained with more 'require' and 'exclude' methods,
     * for example:
     *
     *     Ext.exclude('Ext.data.*').require('*');
     *
     *     Ext.exclude('widget.button*').require('widget.*');
     *
     * @return {Object} Contains 'exclude', 'require' and 'syncRequire' methods for chaining.
     */
    static exclude(excludes: string): any;

    /**
     * This method deprecated. Use {@link Ext#define Ext.define} instead.
     * @return {Function} The subclass constructor from the <tt>overrides</tt> parameter, or a generated one if not provided.
     * @deprecated 4.0.0 Use {@link Ext#define Ext.define} instead
     */
    static extend(superclass: Function, overrides: any): Function;

    /**
     * A global factory method to instantiate a class from a config object. For example,
     * these two calls are equivalent:
     *
     *     Ext.factory({ text: 'My Button' }, 'Ext.Button');
     *     Ext.create('Ext.Button', { text: 'My Button' });
     *
     * If an existing instance is also specified, it will be updated with the supplied config object. This is useful
     * if you need to either create or update an object, depending on if an instance already exists. For example:
     *
     *     var button;
     *     button = Ext.factory({ text: 'New Button' }, 'Ext.Button', button);     // Button created
     *     button = Ext.factory({ text: 'Updated Button' }, 'Ext.Button', button); // Button updated
     *
     * @param {Object} config  The config object to instantiate or update an instance with.
     * @param {String} [classReference]  The class to instantiate from (if there is a default).
     * @param {Object} [instance]  The instance to update.
     */
    static factory(config: any, classReference?: string, instance?: any);

    /**
     * Returns the first match to the given component query.
     * See {@link Ext.ComponentQuery#query}.
     * @param {String} selector The selector string to filter returned Component.
     * @param {Ext.container.Container} [root] The Container within which to perform the query.
     * If omitted, all Components within the document are included in the search.
     *
     * This parameter may also be an array of Components to filter according to the selector.
     * @return {Ext.Component} The first matched Component or 'null'.
     */
    static first(selector: string, root?: Ext.Container): Ext.Component;

    /**
     * Old alias to {@link Ext.Array#flatten}
     * @deprecated 4.0.0 Use {@link Ext.Array#flatten} instead
     */
    static flatten();

    /**
     * Gets the globally shared flyweight Element, with the passed node as the active
     * element. Do not store a reference to this element - the dom node can be overwritten
     * by other code. {@link Ext#fly} is alias for {@link Ext.dom.Element#fly}.
     *
     * Use this to make one-time references to DOM elements which are not going to be
     * accessed again either by application code, or by Ext's classes. If accessing an
     * element which will be processed regularly, then {@link Ext#get Ext.get} will be
     * more appropriate to take advantage of the caching provided by the
     * {@link Ext.dom.Element} class.
     *
     * If this method is called with and id or element that has already been cached by
     * a previous call to Ext.get() it will return the cached Element instead of the
     * flyweight instance.
     *
     * @param {String/HTMLElement} dom The DOM node or 'id'.
     * @param {String} [named] Allows for creation of named reusable flyweights to prevent
     * conflicts (e.g. internally Ext uses "_global").
     * @return {Ext.dom.Element} The shared Element object (or 'null' if no matching
     * element was found).
     */
    static fly(dom: string|HTMLElement, named?: string): Ext.dom.Element;

    static get();

    /**
     * Returns the current document body as an {@link Ext.dom.Element}.
     * @return {Ext.dom.Element} The document body.
     */
    static getBody(): Ext.dom.Element;

    static getClass();

    static getClassName();

    /**
     * This is shorthand reference to {@link Ext.ComponentManager#get}.
     * Looks up an existing {@link Ext.Component Component} by {@link Ext.Component#id id}
     *
     * @param {String} id The component {@link Ext.Component#id id}
     * @return {Ext.Component} The Component, 'undefined' if not found, or 'null' if a
     * Class was found.
     */
    static getCmp(id: string): Ext.Component;

    /**
     * Returns the current HTML document object as an {@link Ext.dom.Element}.
     * Typically used for attaching event listeners to the document.  Note: since
     * the document object is not an HTMLElement many of the Ext.dom.Element methods
     * are not applicable and may throw errors if called on the returned
     * Element instance.
     * @return {Ext.dom.Element} The document.
     */
    static getDoc(): Ext.dom.Element;

    /**
     * Return the dom node for the passed String (id), dom node, or Ext.Element.
     * Here are some examples:
     *
     *     // gets dom node based on id
     *     var elDom = Ext.getDom('elId');
     *
     *     // gets dom node based on the dom node
     *     var elDom1 = Ext.getDom(elDom);
     *
     *     // If we don't know if we are working with an
     *     // Ext.Element or a dom node use Ext.getDom
     *     function(el){
     *         var dom = Ext.getDom(el);
     *         // do something with the dom node
     *     }
     *
     * __Note:__ the dom node to be found actually needs to exist (be rendered, etc)
     * when this method is called to be successful.
     *
     * @return {HTMLElement}
     */
    static getDom(el: string|HTMLElement|Ext.dom.Element): HTMLElement;

    /**
     * Returns the current document head as an {@link Ext.dom.Element}.
     * @return {Ext.dom.Element} The document head.
     */
    static getHead(): Ext.dom.Element;

    /**
     * @return {String} Namespace prefix if it's known, otherwise undefined
     */
    static getNamespace(className: string): string;

    /**
     * Returns the size of the browser scrollbars. This can differ depending on
     * operating system settings, such as the theme or font size.
     * @param {Boolean} [force] true to force a recalculation of the value.
     * @return {Object} An object containing scrollbar sizes.
     * @return {Number} return.width The width of the vertical scrollbar.
     * @return {Number} return.height The height of the horizontal scrollbar.
     */
    static getScrollbarSize(force?: boolean): any;

    /**
     * Shortcut to {@link Ext.data.StoreManager#lookup}.
     */
    static getStore();

    /**
     * Get the version number of the supplied package name; will return the version of
     * the framework.
     *
     * @param {String} [packageName] The package name, e.g., 'core', 'touch', 'ext'.
     * @return {Ext.Version} The version.
     */
    static getVersion(packageName?: string): Ext.Version;

    /**
     * Returns the current window object as an {@link Ext.dom.Element}.
     * Typically used for attaching event listeners to the window.  Note: since
     * the window object is not an HTMLElement many of the Ext.dom.Element methods
     * are not applicable and may throw errors if called on the returned
     * Element instance.
     * @return {Ext.dom.Element} The window.
     */
    static getWin(): Ext.dom.Element;

    /**
     * Old alias to {@link Ext.String#htmlDecode}
     * @deprecated Use {@link Ext.String#htmlDecode} instead
     */
    static htmlDecode();

    /**
     * Old alias to {@link Ext.String#htmlEncode}
     * @deprecated Use {@link Ext.String#htmlEncode} instead
     */
    static htmlEncode();

    /**
     * Generates unique ids. If the object/element is passes and it already has an 'id', it is unchanged.
     * @param {Object} [o] The object to generate an id for.
     * @param {String} [prefix=ext-gen] (optional) The 'id' prefix.
     * @return {String} The generated 'id'.
     */
    static id(o?: any, prefix?: string): string;

    static interval();

    /**
     * Returns 'true' if the passed value is a JavaScript Array, 'false' otherwise.
     *
     * @param {Object} target The target to test.
     * @return {Boolean}
     */
    static isArray(target: any): boolean;

    /**
     * Returns 'true' if the passed value is a boolean.
     *
     * @param {Object} value The value to test.
     * @return {Boolean}
     */
    static isBoolean(value: any): boolean;

    /**
     * Returns 'true' if the passed value is a JavaScript Date object, 'false' otherwise.
     * @param {Object} object The object to test.
     * @return {Boolean}
     */
    static isDate(object: any): boolean;

    /**
     * This method returns 'true' if debug is enabled for the specified class. This is
     * done by checking the 'Ext.debugConfig.hooks' config for the closest match to the
     * given 'className'.
     * @param {String} className The name of the class.
     * @return {Boolean} 'true' if debug is enabled for the specified class.
     */
    static isDebugEnabled(className: string): boolean;

    /**
     * Returns 'true' if the passed value is defined.
     * @param {Object} value The value to test.
     * @return {Boolean}
     */
    static isDefined(value: any): boolean;

    /**
     * Returns 'true' if the passed value is an HTMLElement
     * @param {Object} value The value to test.
     * @return {Boolean}
     */
    static isElement(value: any): boolean;

    /**
     * Returns true if the passed value is empty, false otherwise. The value is deemed to be empty if it is either:
     *
     * - 'null'
     * - 'undefined'
     * - a zero-length array
     * - a zero-length string (Unless the 'allowEmptyString' parameter is set to 'true')
     *
     * @param {Object} value The value to test.
     * @param {Boolean} [allowEmptyString=false] 'true' to allow empty strings.
     * @return {Boolean}
     */
    static isEmpty(value: any, allowEmptyString?: boolean): boolean;

    /**
     * Returns 'true' if the passed value is a JavaScript Function, 'false' otherwise.
     * @param {Object} value The value to test.
     * @return {Boolean}
     */
    static isFunction(value: any): boolean;

    /**
     * Returns 'true' if the passed value is iterable, that is, if elements of it are addressable using array
     * notation with numeric indices, 'false' otherwise.
     *
     * Arrays and function 'arguments' objects are iterable. Also HTML collections such as 'NodeList' and 'HTMLCollection'
     * are iterable.
     *
     * @param {Object} value The value to test
     * @return {Boolean}
     */
    static isIterable(value: any): boolean;

    /**
     * Returns 'true' if the passed value is a String that matches the MS Date JSON
     * encoding format.
     * @param {String} value The string to test.
     * @return {Boolean}
     */
    static isMSDate(value: string): boolean;

    /**
     * Returns 'true' if the passed value is a number. Returns 'false' for non-finite numbers.
     * @param {Object} value The value to test.
     * @return {Boolean}
     */
    static isNumber(value: any): boolean;

    /**
     * Validates that a value is numeric.
     * @param {Object} value Examples: 1, '1', '2.34'
     * @return {Boolean} True if numeric, false otherwise
     */
    static isNumeric(value: any): boolean;

    /**
     * Returns 'true' if the passed value is a JavaScript Object, 'false' otherwise.
     * @param {Object} value The value to test.
     * @return {Boolean}
     */
    static isObject(value: any): boolean;

    /**
     * Returns 'true' if the passed value is a JavaScript 'primitive', a string, number
     * or boolean.
     * @param {Object} value The value to test.
     * @return {Boolean}
     */
    static isPrimitive(value: any): boolean;

    /**
     * Returns 'true 'if the passed value is a string.
     * @param {Object} value The value to test.
     * @return {Boolean}
     */
    static isString(value: any): boolean;

    /**
     * Returns 'true' if the passed value is a TextNode
     * @param {Object} value The value to test.
     * @return {Boolean}
     */
    static isTextNode(value: any): boolean;

    /**
     * Iterates either an array or an object. This method delegates to
     * {@link Ext.Array#each Ext.Array.each} if the given value is iterable, and {@link Ext.Object#each Ext.Object.each} otherwise.
     *
     * @param {Object/Array} object The object or array to be iterated.
     * @param {Function} fn The function to be called for each iteration. See and {@link Ext.Array#each Ext.Array.each} and
     * {@link Ext.Object#each Ext.Object.each} for detailed lists of arguments passed to this function depending on the given object
     * type that is being iterated.
     * @param {Object} [scope] The scope ('this' reference) in which the specified function is executed.
     * Defaults to the object being iterated itself.
     */
    static iterate(object: any|any[], fn: Function, scope?: any);

    /**
     * Logs a message. If a console is present it will be used. On Opera, the method
     * "opera.postError" is called. In other cases, the message is logged to an array
     * "Ext.log.out". An attached debugger can watch this array and view the log. The
     * log buffer is limited to a maximum of "Ext.log.max" entries (defaults to 250).
     *
     * If additional parameters are passed, they are joined and appended to the message.
     * A technique for tracing entry and exit of a function is this:
     *
     *     function foo () {
     *         Ext.log({ indent: 1 }, '>> foo');
     *
     *         // log statements in here or methods called from here will be indented
     *         // by one step
     *
     *         Ext.log({ outdent: 1 }, '<< foo');
     *     }
     *
     * This method does nothing in a release build.
     *
     * @param {String/Object} [options] The message to log or an options object with any
     * of the following properties:
     *
     *  - 'msg': The message to log (required).
     *  - 'level': One of: "error", "warn", "info" or "log" (the default is "log").
     *  - 'dump': An object to dump to the log as part of the message.
     *  - 'stack': True to include a stack trace in the log.
     *  - 'indent': Cause subsequent log statements to be indented one step.
     *  - 'outdent': Cause this and following statements to be one step less indented.
     *
     * @param {String...} [message] The message to log (required unless specified in
     * options object).
     */
    static log(options?: string|any, message?: string);

    /**
     * Old alias to {@link Ext.Array#max}
     * @deprecated 4.0.0 Use {@link Ext.Array#max} instead
     */
    static max();

    /**
     * Old alias to {@link Ext.Array#mean}
     * @deprecated 4.0.0 Use {@link Ext.Array#mean} instead
     */
    static mean();

    /**
     * A convenient alias method for {@link Ext.Object#merge}.
     */
    static merge();

    /**
     * Old alias to {@link Ext.Array#min}
     * @deprecated 4.0.0 Use {@link Ext.Array#min} instead
     */
    static min();

    /**
     * Creates namespaces to be used for scoping variables and classes so that they are not global.
     * Specifying the last node of a namespace implicitly creates all other nodes. Usage:
     *
     *     Ext.namespace('Company', 'Company.data');
     *
     *     // equivalent and preferable to the above syntax
     *     Ext.ns('Company.data');
     *
     *     Company.Widget = function() { ... };
     *
     *     Company.data.CustomStore = function(config) { ... };
     *
     * @return {Object} The (last) namespace object created.
     */
    static namespace(namespaces: string): any;

    /**
     * Returns the current timestamp.
     * @return {Number} Milliseconds since UNIX epoch.
     */
    static now(): number;

    /**
     * Convenient alias for {@link Ext#namespace Ext.namespace}.
     */
    static ns();

    /**
     * @deprecated 4.0.0 Please use {@link Ext.Number#from} instead.
     */
    static num();

    /**
     * Shorthand for {@link Ext.GlobalEvents#addListener}.
     */
    static on();

    /**
     * Adds a listener to be notified when the document is ready (before onload and before
     * images are loaded).
     *
     * @param {Function} fn The method to call.
     * @param {Object} [scope] The scope ('this' reference) in which the handler function
     * executes. Defaults to the browser window.
     * @param {Object} [options] An object with extra options.
     * @param {Number} [options.delay=0] A number of milliseconds to delay.
     * @param {Number} [options.priority=0] Relative priority of this callback. A larger
     * number will result in the callback being sorted before the others.  Priorities
     * 1000 or greater and -1000 or lesser are reserved for internal framework use only.
     * @param {Boolean} [options.dom=false] Pass 'true' to only wait for DOM ready, 'false'
     * means full Framework and DOM readiness.
     * numbers are reserved.
     */
    static onReady(fn: Function, scope?: any, options?: any, options_delay?: number, options_priority?: number, options_dom?: boolean);

    /**
     * Overrides members of the specified 'target' with the given values.
     *
     * If the 'target' is a class declared using {@link Ext#define Ext.define}, the
     * 'override' method of that class is called (see {@link Ext.Base#override}) given
     * the 'overrides'.
     *
     * If the 'target' is a function, it is assumed to be a constructor and the contents
     * of 'overrides' are applied to its 'prototype' using {@link Ext#apply Ext.apply}.
     *
     * If the 'target' is an instance of a class declared using {@link Ext#define Ext.define},
     * the 'overrides' are applied to only that instance. In this case, methods are
     * specially processed to allow them to use {@link Ext.Base#callParent}.
     *
     *      var panel = new Ext.Panel({ ... });
     *
     *      Ext.override(panel, {
     *          initComponent: function () {
     *              // extra processing...
     *
     *              this.callParent();
     *          }
     *      });
     *
     * If the 'target' is none of these, the 'overrides' are applied to the 'target'
     * using {@link Ext#apply Ext.apply}.
     *
     * Please refer to {@link Ext#define Ext.define} and {@link Ext.Base#override} for
     * further details.
     *
     * @param {Object} target The target to override.
     * @param {Object} overrides The properties to add or replace on 'target'.
     */
    static override(target: any, overrides: any);

    static pass();

    /**
     * Old alias to {@link Ext.Array#pluck Ext.Array.pluck}
     * @deprecated 4.0.0 Use {@link Ext.Array#pluck Ext.Array.pluck} instead
     */
    static pluck();

    static query();

    /**
     * Raise an error that can include additional data and supports automatic console logging
     * if available. You can pass a string error message or an object with the 'msg' attribute
     * which will be used as the error message. The object can contain any other name-value
     * attributes (or objects) to be logged along with the error.
     *
     * Note that after displaying the error message a JavaScript error will ultimately be
     * thrown so that execution will halt.
     *
     * Example usage:
     *
     *     Ext.raise('A simple string error message');
     *
     *     // or...
     *
     *     Ext.define('Ext.Foo', {
     *         doSomething: function(option){
     *             if (someCondition === false) {
     *                 Ext.raise({
     *                     msg: 'You cannot do that!',
     *                     option: option,   // whatever was passed into the method
     *                     code: 100 // other arbitrary info
     *                 });
     *             }
     *         }
     *     });
     *
     * @param {String/Object} err The error message string, or an object containing the
     * attribute "msg" that will be used as the error message. Any other data included in the
     * object will also be logged to the browser console, if available.
     */
    static raise(err: string|any);

    /**
     * Creates a new store for the given id and config, then registers it with the {@link Ext.data.StoreManager Store Manager}.
     * Sample usage:
     *
     *     Ext.regStore('AllUsers', {
     *         model: 'User'
     *     });
     *
     *     // the store can now easily be used throughout the application
     *     new Ext.List({
     *         store: 'AllUsers',
     *         ... other config
     *     });
     *
     * @param {String} id The id to set on the new store
     * @param {Object} config The store config
     */
    static regStore(id: string, config: any);

    /**
     * Removes an HTMLElement from the document.  If the HTMLElement was previously
     * cached by a call to Ext.get(), removeNode will call the {@link Ext.Element#destroy
     * destroy} method of the {@link Ext.dom.Element} instance, which removes all DOM
     * event listeners, and deletes the cache reference.
     * @param {HTMLElement} node The node to remove
     */
    static removeNode(node: HTMLElement);

    /**
     * Loads all classes by the given names and all their direct dependencies; optionally
     * executes the given callback function when finishes, within the optional scope.
     *
     * @param {String/String[]} expressions The class, classes or wildcards to load.
     * @param {Function} [fn] The callback function.
     * @param {Object} [scope] The execution scope ('this') of the callback function.
     */
    static require(expressions: string, fn?: Function, scope?: any);

    /**
     * Resolves a resource URL that may contain a resource pool identifier token at the
     * front. The tokens are formatted as HTML tags "&lt;poolName@packageName&gt;" followed
     * by a normal relative path. This token is only processed if present at the first
     * character of the given string.
     *
     * These tokens are parsed and the pieces are then passed to the
     * {@link Ext#getResourcePath} method.
     *
     * For example:
     *
     *      [{
     *          xtype: 'image',
     *          src: '<shared>images/foo.png'
     *      },{
     *          xtype: 'image',
     *          src: '<@package>images/foo.png'
     *      },{
     *          xtype: 'image',
     *          src: '<shared@package>images/foo.png'
     *      }]
     *
     * In the above example, "shared" is the name of a Sencha Cmd resource pool and
     * "package" is the name of a Sencha Cmd package.
     * @param {String} url The URL that may contain a resource pool token at the front.
     * @return {String}
     * @since 6.0.1
     */
    static resolveResource(url: string): string;

    /**
     * A reusable function which returns the value of 'getId()' called upon a single passed parameter.
     * Useful when creating a {@link Ext.util.MixedCollection} of objects keyed by an identifier returned from a 'getId' method.
     */
    static returnId();

    /**
     * A reusable function which returns 'true'.
     */
    static returnTrue();

    static select();

    /**
     * Set version number for the given package name.
     *
     * @param {String} packageName The package name, e.g. 'core', 'touch', 'ext'.
     * @param {String/Ext.Version} version The version, e.g. '1.2.3alpha', '2.4.0-dev'.
     * @return {Ext}
     */
    static setVersion(packageName: string, version: string|Ext.Version): Ext;

    /**
     * Old alias to {@link Ext.Array#sum}
     * @deprecated 4.0.0 Use {@link Ext.Array#sum} instead
     */
    static sum();

    /**
     * Synchronously loads all classes by the given names and all their direct dependencies; optionally
     * executes the given callback function when finishes, within the optional scope.
     *
     * @param {String/String[]} expressions The class, classes or wildcards to load.
     * @param {Function} [fn] The callback function.
     * @param {Object} [scope] The execution scope ('this') of the callback function.
     */
    static syncRequire(expressions: string, fn?: Function, scope?: any);

    /**
     * Returns the current high-resolution timestamp.
     * @return {Number} Milliseconds ellapsed since arbitrary epoch.
     * @since 6.0.1
     */
    static ticks(): number;

    static toArray();

    /**
     * Returns the type of the given variable in string format. List of possible values are:
     *
     * - 'undefined': If the given value is 'undefined'
     * - 'null': If the given value is 'null'
     * - 'string': If the given value is a string
     * - 'number': If the given value is a number
     * - 'boolean': If the given value is a boolean value
     * - 'date': If the given value is a 'Date' object
     * - 'function': If the given value is a function reference
     * - 'object': If the given value is an object
     * - 'array': If the given value is an array
     * - 'regexp': If the given value is a regular expression
     * - 'element': If the given value is a DOM Element
     * - 'textnode': If the given value is a DOM text node and contains something other than whitespace
     * - 'whitespace': If the given value is a DOM text node and contains only whitespace
     *
     * @return {String}
     */
    static typeOf(value: any): string;

    /**
     * Shorthand for {@link Ext.GlobalEvents#removeListener}.
     */
    static un();

    /**
     * Old alias to {@link Ext.Array#unique}
     * @deprecated 4.0.0 Use {@link Ext.Array#unique} instead
     */
    static unique();

    /**
     * Old alias to {@link Ext.String#urlAppend}
     * @deprecated Use {@link Ext.String#urlAppend} instead
     */
    static urlAppend();

    /**
     * Alias for {@link Ext.Object#fromQueryString}.
     *
     * @deprecated 4.0.0 Use {@link Ext.Object#fromQueryString} instead
     */
    static urlDecode();

    /**
     * @deprecated 4.0.0 Use {@link Ext.Object#toQueryString} instead
     */
    static urlEncode();

    /**
     * Returns the given value itself if it's not empty, as described in {@link Ext#isEmpty}; returns the default
     * value (second argument) otherwise.
     *
     * @param {Object} value The value to test.
     * @param {Object} defaultValue The value to return if the original value is empty.
     * @param {Boolean} [allowBlank=false] 'true' to allow zero length strings to qualify as non-empty.
     * @return {Object} value, if non-empty, else defaultValue.
     */
    static valueFrom(value: any, defaultValue: any, allowBlank?: boolean): any;

    /**
     * Convenient shorthand to create a widget by its xtype or a config object.
     *
     *      var button = Ext.widget('button'); // Equivalent to Ext.create('widget.button');
     *
     *      var panel = Ext.widget('panel', { // Equivalent to Ext.create('widget.panel')
     *          title: 'Panel'
     *      });
     *
     *      var grid = Ext.widget({
     *          xtype: 'grid',
     *          ...
     *      });
     *
     * If a {@link Ext.Component component} instance is passed, it is simply returned.
     *
     * @param {String} [name] The xtype of the widget to create.
     * @param {Object} [config] The configuration object for the widget constructor.
     * @return {Object} The widget instance
     */
    static widget(name?: string, config?: any): any;
}

declare module Ext {
    /**
     * For backward compatibility only.  Use Ext.Widget instead
     */
    export class AbstractComponent extends Ext.Widget {
        constructor(config: Ext.ProgressConfig);
    }

    /**
     * Base Manager class
     * @deprecated
     */
    export class AbstractManager extends Ext.Base {
        /**
         * Contains all of the items currently managed
         */
        all: Ext.util.HashMap;

        constructor(config: any);

        /**
         * Executes the specified function once for each item in the collection.
         * @param {Function} fn The function to execute.
         * @param {String} fn.key The key of the item
         * @param {Number} fn.value The value of the item
         * @param {Number} fn.length The total number of items in the collection
         * @param {Boolean} fn.return False to cease iteration.
         * @param {Object} scope The scope to execute in. Defaults to 'this'.
         */
        each(fn: Function, fn_key: string, fn_value: number, fn_length: number, fn_return: boolean, scope: any);

        /**
         * Returns an item by id.
         * For additional details see {@link Ext.util.HashMap#get}.
         * @param {String} id The id of the item
         * @return {Object} The item, undefined if not found.
         */
        get(id: string): any;

        /**
         * Gets the number of items in the collection.
         * @return {Number} The number of items in the collection.
         */
        getCount(): number;

        /**
         * Checks if an item type is registered.
         * @param {String} type The mnemonic string by which the class may be looked up
         * @return {Boolean} Whether the type is registered.
         */
        isRegistered(type: string): boolean;

        /**
         * Registers a function that will be called when an item with the specified id is added to the manager.
         * This will happen on instantiation.
         * @param {String} id The item id
         * @param {Function} fn The callback function. Called with a single parameter, the item.
         * @param {Object} scope The scope (this reference) in which the callback is executed.
         * Defaults to the item.
         */
        onAvailable(id: string, fn: Function, scope: any);

        /**
         * Registers an item to be managed
         * @param {Object} item The item to register
         */
        register(item: any);

        /**
         * Registers a new item constructor, keyed by a type key.
         * @param {String} type The mnemonic string by which the class may be looked up.
         * @param {Function} cls The new instance class.
         */
        registerType(type: string, cls: Function);

        /**
         * Unregisters an item by removing it from this manager
         * @param {Object} item The item to unregister
         */
        unregister(item: any);
    }

    interface ActionSheetConfig extends Ext.SheetConfig {
        baseCls?: any;

        bottom?: any;

        defaultType?: any;

        height?: any;

        left?: any;

        right?: any;
    }

    /**
     * {@link Ext.ActionSheet ActionSheets} are used to display a list of {@link Ext.Button buttons} in a popup dialog.
     *
     * The key difference between ActionSheet and {@link Ext.Sheet} is that ActionSheets are docked at the bottom of the
     * screen, and the {@link #defaultType} is set to {@link Ext.Button button}.
     *
     * ## Example
     *
     *     @example preview miniphone
     *     var actionSheet = Ext.create('Ext.ActionSheet', {
     *         items: [
     *             {
     *                 text: 'Delete draft',
     *                 ui  : 'decline'
     *             },
     *             {
     *                 text: 'Save draft'
     *             },
     *             {
     *                 text: 'Cancel',
     *                 ui  : 'confirm'
     *             }
     *         ]
     *     });
     *
     *     Ext.Viewport.add(actionSheet);
     *     actionSheet.show();
     *
     * As you can see from the code above, you no longer have to specify a 'xtype' when creating buttons within a {@link Ext.ActionSheet ActionSheet},
     * because the {@link #defaultType} is set to {@link Ext.Button button}.
     */
    export class ActionSheet extends Ext.Sheet implements Ext.ActionSheetConfig {
        baseCls: string;

        /**
         * The absolute bottom position of this Component; must be a valid CSS length value, e.g: '300', '100px', '30%', etc.
         * Explicitly setting this value will make this Component become 'floating', which means its layout will no
         * longer be affected by the Container that it resides in.
         */
        bottom: number|string;

        /** @cfg {String} defaultType
         * The default {@link Ext.Component xtype} of child Components to create in this Container when a child item
         * is specified as a raw configuration object, rather than as an instantiated Component.
         */
        defaultType: any;

        /**
         * The height of this Component; must be a valid CSS length value, e.g: '300', '100px', '30%', etc.
         * By default, if this is not explicitly set, this Component's element will simply have its own natural size.
         * If set to 'auto', it will set the width to 'null' meaning it will have its own natural size.
         */
        height: number|string;

        /**
         * The absolute left position of this Component; must be a valid CSS length value, e.g: '300', '100px', '30%', etc.
         * Explicitly setting this value will make this Component become 'floating', which means its layout will no
         * longer be affected by the Container that it resides in.
         */
        left: number|string;

        /**
         * The absolute right position of this Component; must be a valid CSS length value, e.g: '300', '100px', '30%', etc.
         * Explicitly setting this value will make this Component become 'floating', which means its layout will no
         * longer be affected by the Container that it resides in.
         */
        right: number|string;

        constructor(config: Ext.ActionSheetConfig);

        getBaseCls();

        getBottom();

        getDefaultType();

        getHeight();

        getLeft();

        getRight();

        setBaseCls();

        setBottom();

        setDefaultType();

        setHeight();

        setLeft();

        setRight();
    }

    /**
     * A singleton instance of an '{@link Ext.data.Connection}'. This class is used to
     * communicate with your server side code. It can be used as follows:
     *
     *      Ext.Ajax.request({
     *          url: 'ajax_demo/sample.json',
     *
     *          success: function(response, opts) {
     *              var obj = Ext.decode(response.responseText);
     *              console.dir(obj);
     *          },
     *
     *          failure: function(response, opts) {
     *              console.log('server-side failure with status code ' + response.status);
     *          }
     *      });
     *
     * Default options for all requests can be set by changing a property on the Ext.Ajax class:
     *
     *      Ext.Ajax.setTimeout(60000); // 60 seconds
     *
     * Any options specified in the request method for the Ajax request will override any
     * defaults set on the 'Ext.Ajax' singleton. In the code sample below, the timeout for the
     * request will be 60 seconds.
     *
     *      Ext.Ajax.setTimeout(120000); // 120 seconds
     *
     *      Ext.Ajax.request({
     *          url: 'page.aspx',
     *          timeout: 60000
     *      });
     *
     * In general, this class will be used for all Ajax requests in your application. The main
     * reason for creating a separate '{@link Ext.data.Connection}' is for a series of
     * requests that share common settings that are different to all other requests in the
     * application.
     */
    export class Ajax {
    }

    /**
     * Ext.Anim is used to execute simple animations defined in {@link Ext.anims}. The {@link #run} method can take any of the
     * properties defined below.
     *
     *     Ext.Anim.run(this, 'fade', {
     *         out: false,
     *         autoClear: true
     *     });
     *
     * When using {@link Ext.Anim#run}, ensure you require {@link Ext.Anim} in your application. Either do this using {@link Ext#require}:
     *
     *     Ext.requires('Ext.Anim');
     *
     * when using {@link Ext#setup}:
     *
     *     Ext.setup({
     *         requires: ['Ext.Anim'],
     *         onReady: function() {
     *             //do something
     *         }
     *     });
     *
     * or when using {@link Ext#application}:
     *
     *     Ext.application({
     *         requires: ['Ext.Anim'],
     *         launch: function() {
     *             //do something
     *         }
     *     });
     */
    export class Anim {
        /**
         * Code to execute after the animation ends.
         */
        static after: Function;

        /**
         * 'true' to remove all custom CSS defined in the {@link #to} config when the animation is over.
         */
        static autoClear: boolean;

        /**
         * Code to execute before starting the animation.
         */
        static before: Function;

        /**
         * Time to delay before starting the animation.
         */
        static delay: number;

        /**
         * Valid values are: 'left', 'right', 'up', 'down', and 'null'.
         */
        static direction: string;

        /**
         * 'true' to disable animations.
         */
        static disableAnimations: boolean;

        /**
         * Time in milliseconds for the animation to last.
         */
        static duration: number;

        /**
         * Valid values are 'ease', 'linear', ease-in', 'ease-out', 'ease-in-out', or a cubic-bezier curve as defined by CSS.
         */
        static easing: string;

        /**
         * An object of CSS values which the animation begins with. If you define a CSS property here, you must also
         * define it in the {@link #to} config.
         */
        static from: any;

        /**
         * 'true' if you want the animation to slide out of the screen.
         */
        static out: boolean;

        /**
         * 'true' to reverse the animation direction. For example, if the animation direction was set to 'left', it would
         * then use 'right'.
         */
        static reverse: boolean;

        /**
         * Scope to run the {@link #before} function in.
         */
        static scope: any;

        /**
         * An object of CSS values which the animation ends with. If you define a CSS property here, you must also
         * define it in the {@link #from} config.
         */
        static to: any;

        /**
         * Used to run an animation on a specific element. Use the config argument to customize the animation.
         * @param {Ext.Element/HTMLElement} el The element to animate.
         * @param {String} anim The animation type, defined in {@link Ext.anims}.
         * @param {Object} config The config object for the animation.
         */
        static run(el: Ext.dom.Element|HTMLElement, anim: string, config: any);
    }

    export class AnimationQueue {
        /**
         * @param {Number} fps Frames per second.
         * @param {Number} count Actual number of frames rendered during interval.
         * @param {Number} interval Interval duration.
         */
        static showFps(fps: number, count: number, interval: number);

        /**
         * @param {Object} [scope]
         * @param {Object} [args]
         */
        static start(fn: Function, scope?: any, args?: any);

        /**
         * @param {Object} [scope]
         * @param {Object} [args]
         */
        static stop(fn: Function, scope?: any, args?: any);
    }

    /**
     * Defines different types of animations.
     *
     * __Note:__ _flip_, _cube_, and _wipe_ animations do not work on Android.
     *
     * Please refer to {@link Ext.Anim} on how to use animations.
     */
    export class anims {
        /**
         * Cube Animation
         */
        static cube: any;

        /**
         * Fade Animation
         */
        static fade: any;

        /**
         * Flip Animation
         */
        static flip: any;

        /**
         * Pop Animation
         */
        static pop: any;

        /**
         * Slide Animation
         */
        static slide: any;

        /**
         * Wipe Animation.
         * Because of the amount of calculations involved, this animation is best used on small display
         * changes or specifically for phone environments. Does not currently accept any parameters.
         */
        static wipe: any;
    }

    /**
     * A set of useful static methods to deal with arrays; provide missing methods for
     * older browsers.
     */
    export class Array {
        /**
         * This method returns the index that a given item would be inserted into the
         * given (sorted) 'array'. Note that the given 'item' may or may not be in the
         * array. This method will return the index of where the item *should* be.
         *
         * For example:
         *
         *      var array = [ 'A', 'D', 'G', 'K', 'O', 'R', 'X' ];
         *      var index = Ext.Array.binarySearch(array, 'E');
         *
         *      console.log('index: ' + index);
         *      // logs "index: 2"
         *
         *      array.splice(index, 0, 'E');
         *
         *      console.log('array : ' + array.join(''));
         *      // logs "array: ADEGKORX"
         *
         * @param {Object[]} array The array to search.
         * @param {Object} item The item that you want to insert into the 'array'.
         * @param {Number} [begin=0] The first index in the 'array' to consider.
         * @param {Number} [end=array.length] The index that marks the end of the range
         * to consider. The item at this index is *not* considered.
         * @param {Function} [compareFn] The comparison function that matches the sort
         * order of the 'array'. The default 'compareFn' compares items using less-than
         * and greater-than operators.
         * @return {Number} The index for the given item in the given array based on
         * the current sorters.
         */
        static binarySearch(array: any, item: any, begin?: number, end?: number, compareFn?: Function): number;

        /**
         * Filter through an array and remove empty item as defined in {@link Ext#isEmpty Ext.isEmpty}.
         *
         * See {@link Ext.Array#filter}
         *
         * @return {Array} results
         */
        static clean(array: any[]): any[];

        /**
         * Clone a flat array without referencing the previous one. Note that this is different
         * from 'Ext.clone' since it doesn't handle recursive cloning. It's simply a convenient, easy-to-remember method
         * for 'Array.prototype.slice.call(array)'.
         *
         * @param {Array} array The array.
         * @return {Array} The clone array.
         */
        static clone(array: any[]): any[];

        /**
         * Checks whether or not the given 'array' contains the specified 'item'.
         *
         * @param {Array} array The array to check.
         * @param {Object} item The item to find.
         * @return {Boolean} 'true' if the array contains the item, 'false' otherwise.
         */
        static contains(array: any[], item: any): boolean;

        /**
         * Perform a set difference A-B by subtracting all items in array B from array A.
         *
         * @return {Array} difference
         */
        static difference(arrayA: any[], arrayB: any[]): any[];

        /**
         * Iterates an array or an iterable value and invoke the given callback function for each item.
         *
         *     var countries = ['Vietnam', 'Singapore', 'United States', 'Russia'];
         *
         *     Ext.Array.each(countries, function(name, index, countriesItSelf) {
         *         console.log(name);
         *     });
         *
         *     var sum = function() {
         *         var sum = 0;
         *
         *         Ext.Array.each(arguments, function(value) {
         *             sum += value;
         *         });
         *
         *         return sum;
         *     };
         *
         *     sum(1, 2, 3); // returns 6
         *
         * The iteration can be stopped by returning 'false' from the callback function.
         * Returning 'undefined' (i.e 'return;') will only exit the callback function and
         * proceed with the next iteration of the loop.
         *
         *     Ext.Array.each(countries, function(name, index, countriesItSelf) {
         *         if (name === 'Singapore') {
         *             return false; // break here
         *         }
         *     });
         *
         * {@link Ext#each Ext.each} is alias for {@link Ext.Array#each Ext.Array.each}
         *
         * @param {Array/NodeList/Object} iterable The value to be iterated. If this
         * argument is not iterable, the callback function is called once.
         * @param {Function} fn The callback function. If it returns 'false', the iteration
         * stops and this method returns the current 'index'. Returning 'undefined' (i.e
         * 'return;') will only exit the callback function and proceed with the next iteration
         * in the loop.
         * @param {Object} fn.item The item at the current 'index' in the passed 'array'
         * @param {Number} fn.index The current 'index' within the 'array'
         * @param {Array} fn.allItems The 'array' itself which was passed as the first argument
         * @param {Boolean} fn.return Return 'false' to stop iteration.
         * @param {Object} [scope] The scope ('this' reference) in which the specified function is executed.
         * @param {Boolean} [reverse=false] Reverse the iteration order (loop from the end to the beginning).
         * @return {Boolean} See description for the 'fn' parameter.
         */
        static each(iterable: any[]|any, fn: Function, fn_item: any, fn_index: number, fn_allItems: any[], fn_return: boolean, scope?: any, reverse?: boolean): boolean;

        /**
         * Shallow compares the contents of 2 arrays using strict equality.
         * @return {Boolean} 'true' if the arrays are equal.
         */
        static equals(array1: any[], array2: any[]): boolean;

        /**
         * Removes items from an array. This is functionally equivalent to the splice method
         * of Array, but works around bugs in IE8's splice method and does not copy the
         * removed elements in order to return them (because very often they are ignored).
         *
         * @param {Array} array The Array on which to replace.
         * @param {Number} index The index in the array at which to operate.
         * @param {Number} removeCount The number of items to remove at index.
         * @return {Array} The array passed.
         */
        static erase(array: any[], index: number, removeCount: number): any[];

        /**
         * Executes the specified function for each array element until the function returns a falsy value.
         * If such an item is found, the function will return 'false' immediately.
         * Otherwise, it will return 'true'.
         *
         * @param {Function} fn Callback function for each item.
         * @param {Mixed} fn.item Current item.
         * @param {Number} fn.index Index of the item.
         * @param {Array} fn.array The whole array that's being iterated.
         * @param {Object} scope Callback function scope.
         * @return {Boolean} 'treu' if no false value is returned by the callback function.
         */
        static every(array: any[], fn: Function, fn_item: any, fn_index: number, fn_array: any[], scope: any): boolean;

        /**
         * Creates a new array with all of the elements of this array for which
         * the provided filtering function returns a truthy value.
         *
         * @param {Function} fn Callback function for each item.
         * @param {Mixed} fn.item Current item.
         * @param {Number} fn.index Index of the item.
         * @param {Array} fn.array The whole array that's being iterated.
         * @param {Object} scope Callback function scope.
         * @return {Array} results
         */
        static filter(array: any[], fn: Function, fn_item: any, fn_index: number, fn_array: any[], scope: any): any[];

        /**
         * Returns the first item in the array which elicits a truthy return value from the
         * passed selection function.
         * @param {Array} array The array to search
         * @param {Function} fn The selection function to execute for each item.
         * @param {Mixed} fn.item The array item.
         * @param {String} fn.index The index of the array item.
         * @param {Object} scope (optional) The scope (<code>this</code> reference) in which the
         * function is executed. Defaults to the array
         * @return {Object} The first item in the array which returned true from the selection
         * function, or null if none was found.
         */
        static findBy(array: any[], fn: Function, fn_item: any, fn_index: string, scope: any): any;

        /**
         * Recursively flattens into 1-d Array. Injects Arrays inline.
         *
         * @param {Array} array The array to flatten
         * @return {Array} The 1-d array.
         */
        static flatten(array: any[]): any[];

        /**
         * Iterates an array and invoke the given callback function for each item. Note that this will simply
         * delegate to the native 'Array.prototype.forEach' method if supported. It doesn't support stopping the
         * iteration by returning 'false' in the callback function like {@link Ext.Array#each}. However, performance
         * could be much better in modern browsers comparing with {@link Ext.Array#each}
         *
         * @param {Array} array The array to iterate.
         * @param {Function} fn The callback function.
         * @param {Object} fn.item The item at the current 'index' in the passed 'array'.
         * @param {Number} fn.index The current 'index' within the 'array'.
         * @param {Array}  fn.allItems The 'array' itself which was passed as the first argument.
         * @param {Object} scope (Optional) The execution scope ('this') in which the
         * specified function is executed.
         */
        static forEach(array: any[], fn: Function, fn_item: any, fn_index: number, fn_allItems: any[], scope: any);

        /**
         * Converts a value to an array if it's not already an array; returns:
         *
         * - An empty array if given value is 'undefined' or 'null'
         * - Itself if given value is already an array
         * - An array copy if given value is {@link Ext#isIterable iterable} (arguments, NodeList and alike)
         * - An array with one item which is the given value, otherwise
         *
         * @param {Object} value The value to convert to an array if it's not already is an array.
         * @param {Boolean} [newReference] 'true' to clone the given array and return a new reference if necessary.
         * @return {Array} array
         */
        static from(value: any, newReference?: boolean): any[];

        /**
         * Push an item into the array only if the array doesn't contain it yet.
         *
         * @param {Array} array The array.
         * @param {Object} item The item to include.
         */
        static include(array: any[], item: any);

        /**
         * Get the index of the provided 'item' in the given 'array', a supplement for the
         * missing arrayPrototype.indexOf in Internet Explorer.
         *
         * @param {Array} array The array to check.
         * @param {Object} item The item to find.
         * @param {Number} from (Optional) The index at which to begin the search.
         * @return {Number} The index of item in the array (or -1 if it is not found).
         */
        static indexOf(array: any[], item: any, from: number): number;

        /**
         * Inserts items in to an array.
         *
         * @param {Array} array The Array in which to insert.
         * @param {Number} index The index in the array at which to operate.
         * @param {Array} items The array of items to insert at index.
         * @return {Array} The array passed.
         */
        static insert(array: any[], index: number, items: any[]): any[];

        /**
         * Merge multiple arrays into one with unique items that exist in all of the arrays.
         *
         * @return {Array} intersect
         */
        static intersect(array1: any[], array2: any[], etc: any[]): any[];

        /**
         * Creates a new array with the results of calling a provided function on every element in this array.
         *
         * @param {Function} fn Callback function for each item.
         * @param {Mixed} fn.item Current item.
         * @param {Number} fn.index Index of the item.
         * @param {Array} fn.array The whole array that's being iterated.
         * @param {Object} [scope] Callback function scope
         * @return {Array} results
         */
        static map(array: any[], fn: Function, fn_item: any, fn_index: number, fn_array: any[], scope?: any): any[];

        /**
         * Returns the maximum value in the Array.
         *
         * @param {Array/NodeList} array The Array from which to select the maximum value.
         * @param {Function} comparisonFn (optional) a function to perform the comparison which determines maximization.
         * If omitted the ">" operator will be used.
         * __Note:__ gt = 1; eq = 0; lt = -1
         * @param {Mixed} comparisonFn.max Current maximum value.
         * @param {Mixed} comparisonFn.item The value to compare with the current maximum.
         * @return {Object} maxValue The maximum value.
         */
        static max(array: any[]|any, comparisonFn: Function, comparisonFn_max: any, comparisonFn_item: any): any;

        /**
         * Calculates the mean of all items in the array.
         *
         * @param {Array} array The Array to calculate the mean value of.
         * @return {Number} The mean.
         */
        static mean(array: any[]): number;

        /**
         * Merge multiple arrays into one with unique items.
         *
         * {@link Ext.Array#union} is alias for {@link Ext.Array#merge}
         *
         * @return {Array} merged
         */
        static merge(array1: any[], array2: any[], etc: any[]): any[];

        /**
         * Returns the minimum value in the Array.
         *
         * @param {Array/NodeList} array The Array from which to select the minimum value.
         * @param {Function} comparisonFn (optional) a function to perform the comparison which determines minimization.
         * If omitted the "<" operator will be used.
         * __Note:__ gt = 1; eq = 0; lt = -1
         * @param {Mixed} comparisonFn.min Current minimum value.
         * @param {Mixed} comparisonFn.item The value to compare with the current minimum.
         * @return {Object} minValue The minimum value.
         */
        static min(array: any[]|any, comparisonFn: Function, comparisonFn_min: any, comparisonFn_item: any): any;

        /**
         * A function used to sort an array by numeric value. By default, javascript array values
         * are coerced to strings when sorting, which can be problematic when using numeric values. To
         * ensure that the values are sorted numerically, this method can be passed to the sort method:
         *
         *     Ext.Array.sort(myArray, Ext.Array.numericSortFn);
         */
        static numericSortFn();

        /**
         * Plucks the value of a property from each item in the Array. Example:
         *
         *     Ext.Array.pluck(Ext.query("p"), "className"); // [el1.className, el2.className, ..., elN.className]
         *
         * @param {Array/NodeList} array The Array of items to pluck the value from.
         * @param {String} propertyName The property name to pluck from each element.
         * @return {Array} The value from each item in the Array.
         */
        static pluck(array: any[]|any, propertyName: string): any[];

        /**
         * Pushes new items onto the end of an Array.
         *
         * Passed parameters may be single items, or arrays of items. If an Array is found in the argument list, all its
         * elements are pushed into the end of the target Array.
         *
         * @param {Array} target The Array onto which to push new items
         * @param {Object...} elements The elements to add to the array. Each parameter may
         * be an Array, in which case all the elements of that Array will be pushed into the end of the
         * destination Array.
         * @return {Array} An array containing all the new items push onto the end.
         */
        static push(target: any[], elements: any): any[];

        /**
         * This method applies the 'reduceFn' function against an accumulator and each
         * value of the 'array' (from left-to-right) to reduce it to a single value.
         *
         * If no 'initialValue' is specified, the first element of the array is used as
         * the initial value. For example:
         *
         *      function reducer (previous, value, index) {
         *          console.log('[' + index + ']: (' + previous + ',' + value + '}');
         *          return previous * 10 + value;
         *      }
         *
         *      v = Ext.Array.reduce([2, 3, 4], reducer);
         *      console.log('v = ' + v);
         *
         *      > [1]: (2, 3)
         *      > [2]: (23, 4)
         *      > v = 234
         *
         *      v = Ext.Array.reduce([2, 3, 4], reducer, 1);
         *      console.log('v = ' + v);
         *
         *      > [0]: (1, 2)
         *      > [1]: (12, 3)
         *      > [2]: (123, 4)
         *      > v = 1234
         *
         * @param {Array} array The array to process.
         * @param {Function} reduceFn The reducing callback function.
         * @param {Mixed} reduceFn.previous The previous value.
         * @param {Mixed} reduceFn.value The current value.
         * @param {Number} reduceFn.index The index in the array of the current 'value'.
         * @param {Array} reduceFn.array The array to being processed.
         * @param {Mixed} [initialValue] The starting value.
         * @return {Mixed} The reduced value.
         * @since 6.0.0
         */
        static reduce(array: any[], reduceFn: Function, reduceFn_previous: any, reduceFn_value: any, reduceFn_index: number, reduceFn_array: any[], initialValue?: any): any;

        /**
         * Removes the specified item from the array if it exists.
         *
         * @param {Array} array The array.
         * @param {Object} item The item to remove.
         * @return {Array} The passed array.
         */
        static remove(array: any[], item: any): any[];

        /**
         * Removes item/s at the specified index.
         *
         * @param {Array} array The array.
         * @param {Number} index The index of the item to be removed.
         * @param {Number} [count=1] The number of items to be removed.
         * @return {Array} The passed array.
         */
        static removeAt(array: any[], index: number, count?: number): any[];

        /**
         * Replaces items in an array. This is functionally equivalent to the splice method
         * of Array, but works around bugs in IE8's splice method and is often more convenient
         * to call because it accepts an array of items to insert rather than use a variadic
         * argument list.
         *
         * @param {Array} array The Array on which to replace.
         * @param {Number} index The index in the array at which to operate.
         * @param {Number} removeCount The number of items to remove at index (can be 0).
         * @param {Array} insert (optional) An array of items to insert at index.
         * @return {Array} The array passed.
         */
        static replace(array: any[], index: number, removeCount: number, insert: any[]): any[];

        /**
         * Returns a shallow copy of a part of an array. This is equivalent to the native
         * call 'Array.prototype.slice.call(array, begin, end)'. This is often used when "array"
         * is "arguments" since the arguments object does not supply a slice method but can
         * be the context object to 'Array.prototype.slice'.
         *
         * @param {Array} array The array (or arguments object).
         * @param {Number} begin The index at which to begin. Negative values are offsets from
         * the end of the array.
         * @param {Number} end The index at which to end. The copied items do not include
         * end. Negative values are offsets from the end of the array. If end is omitted,
         * all items up to the end of the array are copied.
         * @return {Array} The copied piece of the array.
         */
        static slice(array: any[], begin: number, end: number): any[];

        /**
         * Executes the specified function for each array element until the function returns a truthy value.
         * If such an item is found, the function will return 'true' immediately. Otherwise, it will return 'false'.
         *
         * @param {Function} fn Callback function for each item.
         * @param {Mixed} fn.item Current item.
         * @param {Number} fn.index Index of the item.
         * @param {Array} fn.array The whole array that's being iterated.
         * @param {Object} scope Callback function scope.
         * @return {Boolean} 'true' if the callback function returns a truthy value.
         */
        static some(array: any[], fn: Function, fn_item: any, fn_index: number, fn_array: any[], scope: any): boolean;

        /**
         * Sorts the elements of an Array in a stable manner (equivalently keyed values do not move relative to each other).
         * By default, this method sorts the elements alphabetically and ascending.
         * **Note:** This method modifies the passed array, in the same manner as the
         * native javascript Array.sort.
         *
         * @param {Array} array The array to sort.
         * @param {Function} [sortFn] The comparison function.
         * @param {Mixed} sortFn.a The first item to compare.
         * @param {Mixed} sortFn.b The second item to compare.
         * @param {Number} sortFn.return '-1' if a < b, '1' if a > b, otherwise '0'.
         * @return {Array} The sorted array.
         */
        static sort(array: any[], sortFn?: Function, sortFn_a?: any, sortFn_b?: any, sortFn_return?: number): any[];

        /**
         * Replaces items in an array. This is equivalent to the splice method of Array, but
         * works around bugs in IE8's splice method. The signature is exactly the same as the
         * splice method except that the array is the first argument. All arguments following
         * removeCount are inserted in the array at index.
         *
         * @param {Array} array The Array on which to replace.
         * @param {Number} index The index in the array at which to operate.
         * @param {Number} removeCount The number of items to remove at index (can be 0).
         * @param {Object...} elements The elements to add to the array. If you don't specify
         * any elements, splice simply removes elements from the array.
         * @return {Array} An array containing the removed items.
         */
        static splice(array: any[], index: number, removeCount: number, elements: any): any[];

        /**
         * Calculates the sum of all items in the given array.
         *
         * @param {Array} array The Array to calculate the sum value of.
         * @return {Number} The sum.
         */
        static sum(array: any[]): number;

        /**
         * Converts any iterable (numeric indices and a length property) into a true array.
         *
         *     function test() {
         *         var args = Ext.Array.toArray(arguments),
         *             fromSecondToLastArgs = Ext.Array.toArray(arguments, 1);
         *
         *         alert(args.join(' '));
         *         alert(fromSecondToLastArgs.join(' '));
         *     }
         *
         *     test('just', 'testing', 'here'); // alerts 'just testing here';
         *                                      // alerts 'testing here';
         *
         *     Ext.Array.toArray(document.getElementsByTagName('div')); // will convert the NodeList into an array
         *     Ext.Array.toArray('splitted'); // returns ['s', 'p', 'l', 'i', 't', 't', 'e', 'd']
         *     Ext.Array.toArray('splitted', 0, 3); // returns ['s', 'p', 'l']
         *
         * {@link Ext#toArray Ext.toArray} is alias for {@link Ext.Array#toArray Ext.Array.toArray}
         *
         * @param {Object} iterable the iterable object to be turned into a true Array.
         * @param {Number} [start=0] a zero-based index that specifies the start of extraction.
         * @param {Number} [end=-1] a 1-based index that specifies the end of extraction.
         * @return {Array}
         */
        static toArray(iterable: any, start?: number, end?: number): any[];

        /**
         * Creates a map (object) keyed by the elements of the given array. The values in
         * the map are the index+1 of the array element. For example:
         *
         *      var map = Ext.Array.toMap(['a','b','c']);
         *
         *      // map = { a: 1, b: 2, c: 3 };
         *
         * Or a key property can be specified:
         *
         *      var map = Ext.Array.toMap([
         *              { name: 'a' },
         *              { name: 'b' },
         *              { name: 'c' }
         *          ], 'name');
         *
         *      // map = { a: 1, b: 2, c: 3 };
         *
         * Lastly, a key extractor can be provided:
         *
         *      var map = Ext.Array.toMap([
         *              { name: 'a' },
         *              { name: 'b' },
         *              { name: 'c' }
         *          ], function (obj) { return obj.name.toUpperCase(); });
         *
         *      // map = { A: 1, B: 2, C: 3 };
         *
         * @param {Array} array The Array to create the map from.
         * @param {String/Function} [getKey] Name of the object property to use
         * as a key or a function to extract the key.
         * @param {Object} [scope] Value of 'this' inside callback specified for 'getKey'.
         * @return {Object} The resulting map.
         */
        static toMap(array: any[], getKey?: string|Function, scope?: any): any;

        /**
         * Creates a map (object) keyed by a property of elements of the given array. The values in
         * the map are the array element. For example:
         *
         *      var map = Ext.Array.toValueMap(['a','b','c']);
         *
         *      // map = { a: 'a', b: 'b', c: 'c' };
         *
         * Or a key property can be specified:
         *
         *      var map = Ext.Array.toValueMap([
         *              { name: 'a' },
         *              { name: 'b' },
         *              { name: 'c' }
         *          ], 'name');
         *
         *      // map = { a: {name: 'a'}, b: {name: 'b'}, c: {name: 'c'} };
         *
         * Lastly, a key extractor can be provided:
         *
         *      var map = Ext.Array.toValueMap([
         *              { name: 'a' },
         *              { name: 'b' },
         *              { name: 'c' }
         *          ], function (obj) { return obj.name.toUpperCase(); });
         *
         *      // map = { A: {name: 'a'}, B: {name: 'b'}, C: {name: 'c'} };
         *
         * @param {Array} array The Array to create the map from.
         * @param {String/Function} [getKey] Name of the object property to use
         * as a key or a function to extract the key.
         * @param {Object} [scope] Value of this inside callback. This parameter is only
         * passed when 'getKey' is a function. If 'getKey' is not a function, the 3rd
         * argument is 'arrayify'.
         * @param {Number} [arrayify] Pass '1' to create arrays for all map entries
         * or '2' to create arrays for map entries that have 2 or more items with the
         * same key. This only applies when 'getKey' is specified. By default the map will
         * hold the last entry with a given key.
         * @return {Object} The resulting map.
         */
        static toValueMap(array: any[], getKey?: string|Function, scope?: any, arrayify?: number): any;

        static union();

        /**
         * Returns a new array with unique items.
         *
         * @return {Array} results
         */
        static unique(array: any[]): any[];
    }

    /**
     * This class provides help value testing methods useful for diagnostics. These are often
     * used in 'debugHooks':
     *
     *      Ext.define('Foo.bar.Class', {
     *
     *          debugHooks: {
     *              method: function (a) {
     *                  Ext.Assert.truthy(a, 'Expected "a" to be truthy');
     *              },
     *
     *              foo: function (object) {
     *                  Ext.Assert.isFunctionProp(object, 'doSomething');
     *              }
     *          }
     *      });
     *
     * **NOTE:** This class is entirely removed in production builds so all uses of it should
     * be either in 'debug' conditional comments or 'debugHooks'.
     *
     * The following type detection methods from the 'Ext' object are wrapped as assertions
     * by this class:
     *
     *  * 'isEmpty'
     *  * 'isArray'
     *  * 'isDate'
     *  * 'isObject'
     *  * 'isSimpleObject'
     *  * 'isPrimitive'
     *  * 'isFunction'
     *  * 'isNumber'
     *  * 'isNumeric'
     *  * 'isString'
     *  * 'isBoolean'
     *  * 'isElement'
     *  * 'isTextNode'
     *  * 'isDefined'
     *  * 'isIterable'
     *
     * These appear both their exact name and with a "Prop" suffix for checking a property on
     * an object. For example, these are almost identical:
     *
     *      Ext.Assert.isFunction(object.foo);
     *
     *      Ext.Assert.isFunctionProp(object, 'foo');
     *
     * The difference is the default error message generated is better in the second use case
     * than the first.
     *
     * The above list are also expanded for "Not" flavors (and "Not...Prop"):
     *
     *  * 'isNotEmpty'
     *  * 'isNotArray'
     *  * 'isNotDate'
     *  * 'isNotObject'
     *  * 'isNotSimpleObject'
     *  * 'isNotPrimitive'
     *  * 'isNotFunction'
     *  * 'isNotNumber'
     *  * 'isNotNumeric'
     *  * 'isNotString'
     *  * 'isNotBoolean'
     *  * 'isNotElement'
     *  * 'isNotTextNode'
     *  * 'isNotDefined'
     *  * 'isNotIterable'
     */
    export class Assert {
        /**
         * Checks that the first argument is falsey and throws an 'Error' if it is not.
         */
        falsey();

        /**
         * Checks that the first argument is falsey and throws an 'Error' if it is not.
         */
        falseyProp();

        /**
         * Checks that the first argument is truthy and throws an 'Error' if it is not.
         */
        truthy();

        /**
         * Checks that the first argument is truthy and throws an 'Error' if it is not.
         */
        truthyProp();
    }

    interface AudioConfig extends Ext.MediaConfig {
        cls?: any;

        /**
         * The location of the audio to play.
         *
         * ### Recommended file types are:
         * * Uncompressed WAV and AIF audio
         * * MP3 audio
         * * AAC-LC
         * * HE-AAC audio
         */
        url?: string;
    }

    /**
     * {@link Ext.Audio} is a simple class which provides a container for the
     * [HTML5 Audio element](http://developer.mozilla.org/en-US/docs/Using_HTML5_audio_and_video).
     *
     * ## Recommended File Types/Compression:
     *
     * * Uncompressed WAV and AIF audio
     * * MP3 audio
     * * AAC-LC
     * * HE-AAC audio
     *
     * ## Notes
     *
     * On Android devices, the audio tags controls do not show. You must use the {@link #method-play},
     * {@link #method-pause}, and {@link #toggle} methods to control the audio (example below).
     *
     * ## Examples
     *
     * This example shows the use of the {@link Ext.Audio} component in a fullscreen container--change
     * the url: item for the location of an audio file--note that the audio starts on page load:
     *
     *     @example preview
     *     Ext.create('Ext.Container', {
     *         fullscreen: true,
     *         layout: {
     *             type : 'vbox',
     *             pack : 'center',
     *             align: 'stretch'
     *         },
     *         items: [
     *             {
     *                 xtype : 'toolbar',
     *                 docked: 'top',
     *                 title : 'Ext.Audio'
     *             },
     *             {
     *                 xtype: 'audio',
     *                 url  : 'touch-build/examples/audio/crash.mp3'
     *             }
     *         ]
     *     });
     *
     * You can also set the {@link #hidden} configuration of the {@link Ext.Audio} component to true by default,
     * and then control the audio by using the {@link #method-play}, {@link #method-pause}, and {@link #toggle} methods:
     *
     *     @example preview
     *     Ext.create('Ext.Container', {
     *         fullscreen: true,
     *         layout: {
     *             type: 'vbox',
     *             pack: 'center'
     *         },
     *         items: [
     *             {
     *                 xtype : 'toolbar',
     *                 docked: 'top',
     *                 title : 'Ext.Audio'
     *             },
     *             {
     *                 xtype: 'toolbar',
     *                 docked: 'bottom',
     *                 defaults: {
     *                     xtype: 'button',
     *                     handler: function() {
     *                         var container = this.getParent().getParent(),
     *                             // use ComponentQuery to get the audio component (using its xtype)
     *                             audio = container.down('audio');
     *
     *                         audio.toggle();
     *                         this.setText(audio.isPlaying() ? 'Pause' : 'Play');
     *                     }
     *                 },
     *                 items: [
     *                     { text: 'Play', flex: 1 }
     *                 ]
     *             },
     *             {
     *                 html: 'Hidden audio!',
     *                 styleHtmlContent: true
     *             },
     *             {
     *                 xtype : 'audio',
     *                 hidden: true,
     *                 url   : 'touch-build/examples/audio/crash.mp3'
     *             }
     *         ]
     *     });
     */
    export class Audio extends Ext.Media implements Ext.AudioConfig {
        protected template: any[];

        /**
         * The CSS class to add to this component's element, in
         * addition to the {@link #baseCls}. In many cases, this property will be specified
         * by the derived component class. See {@link #userCls} for adding additional CSS
         * classes to component instances (such as items in a {@link Ext.Container}).
         */
        cls: string;

        /**
         * The location of the audio to play.
         *
         * ### Recommended file types are:
         * * Uncompressed WAV and AIF audio
         * * MP3 audio
         * * AAC-LC
         * * HE-AAC audio
         */
        url: string;

        constructor();

        getCls();

        getUrl();

        setCls();

        setUrl();
    }

    /**
     * The root of all classes created with {@link Ext#define}.
     *
     * Ext.Base is the building block of all Ext classes. All classes in Ext inherit from Ext.Base.
     * All prototype and static members of this class are inherited by all other classes.
     */
    export class Base {
        /**
         * This property is set to 'true' after the 'destroy' method is called.
         */
        protected destroyed: boolean;

        /**
         * This property is set to 'true' during the call to 'initConfig'.
         * @readonly
         * @since 5.0.0
         */
        protected isConfiguring: boolean;

        /**
         * This property is set to 'true' if this instance is the first of its class.
         * @readonly
         * @since 5.0.0
         */
        protected isFirstInstance: boolean;

        /**
         * This value is 'true' and is used to identify plain objects from instances of
         * a defined class.
         * @readonly
         */
        protected isInstance: boolean;

        /**
         * Get the reference to the current class from which this object was instantiated. Unlike {@link Ext.Base#statics},
         * 'this.self' is scope-dependent and it's meant to be used for dynamic inheritance. See {@link Ext.Base#statics}
         * for a detailed comparison
         *
         *     Ext.define('My.Cat', {
         *         statics: {
         *             speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
         *         },
         *
         *         constructor: function() {
         *             alert(this.self.speciesName); // dependent on 'this'
         *         },
         *
         *         clone: function() {
         *             return new this.self();
         *         }
         *     });
         *
         *
         *     Ext.define('My.SnowLeopard', {
         *         extend: 'My.Cat',
         *         statics: {
         *             speciesName: 'Snow Leopard'         // My.SnowLeopard.speciesName = 'Snow Leopard'
         *         }
         *     });
         *
         *     var cat = new My.Cat();                     // alerts 'Cat'
         *     var snowLeopard = new My.SnowLeopard();     // alerts 'Snow Leopard'
         *
         *     var clone = snowLeopard.clone();
         *     alert(Ext.getClassName(clone));             // alerts 'My.SnowLeopard'
         */
        protected self: Ext.Class;

        /**
         * Call the original method that was previously overridden with {@link Ext.Base#override}
         *
         *     Ext.define('My.Cat', {
         *         constructor: function() {
         *             alert("I'm a cat!");
         *         }
         *     });
         *
         *     My.Cat.override({
         *         constructor: function() {
         *             alert("I'm going to be a cat!");
         *
         *             this.callOverridden();
         *
         *             alert("Meeeeoooowwww");
         *         }
         *     });
         *
         *     var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
         *                               // alerts "I'm a cat!"
         *                               // alerts "Meeeeoooowwww"
         *
         * @param {Array/Arguments} args The arguments, either an array or the 'arguments' object
         * from the current method, for example: 'this.callOverridden(arguments)'
         * @return {Object} Returns the result of calling the overridden method
         * @deprecated Use {@link #callParent} instead.
         */
        protected callOverridden(args: any[]): any;

        /**
         * This method is called to cleanup an object and its resources. After calling
         * this method, the object should not be used any further.
         */
        destroy();

        /**
         * Returns a specified config property value. If the name parameter is not passed,
         * all current configuration options will be returned as key value pairs.
         * @param {String} [name] The name of the config property to get.
         * @param {Boolean} [peek=false] 'true' to peek at the raw value without calling the getter.
         * @return {Object} The config property value.
         */
        getConfig(name?: string, peek?: boolean): any;

        /**
         * Returns the initial configuration passed to the constructor when
         * instantiating this class.
         *
         * Given this example Ext.button.Button definition and instance:
         *
         *     Ext.define('MyApp.view.Button', {
         *         extend: 'Ext.button.Button',
         *         xtype: 'mybutton',
         *
         *         scale: 'large',
         *         enableToggle: true
         *     });
         *
         *     var btn = Ext.create({
         *         xtype: 'mybutton',
         *         renderTo: Ext.getBody(),
         *         text: 'Test Button'
         *     });
         *
         * Calling 'btn.getInitialConfig()' would return an object including the config
         * options passed to the 'create' method:
         *
         *     xtype: 'mybutton',
         *     renderTo: // The document body itself
         *     text: 'Test Button'
         *
         * Calling 'btn.getInitialConfig('text')'returns **'Test Button'**.
         *
         * @param {String} [name] Name of the config option to return.
         * @return {Object/Mixed} The full config object or a single config value
         * when 'name' parameter specified.
         */
        getInitialConfig(name?: string): any;

        /**
         * Initialize configuration for this class. a typical example:
         *
         *     Ext.define('My.awesome.Class', {
         *         // The default config
         *         config: {
         *             name: 'Awesome',
         *             isAwesome: true
         *         },
         *
         *         constructor: function(config) {
         *             this.initConfig(config);
         *         }
         *     });
         *
         *     var awesome = new My.awesome.Class({
         *         name: 'Super Awesome'
         *     });
         *
         *     alert(awesome.getName()); // 'Super Awesome'
         *
         * @return {Ext.Base} this
         */
        protected initConfig(config: any): Ext.Base;

        /**
         * Sets a single/multiple configuration options.
         * @param {String/Object} name The name of the property to set, or a set of key value pairs to set.
         * @param {Object} [value] The value to set for the name parameter.
         * @return {Ext.Base} this
         */
        setConfig(name: string|any, value?: any): Ext.Base;

        /**
         * Get the reference to the class from which this object was instantiated. Note that unlike {@link Ext.Base#self},
         * 'this.statics()' is scope-independent and it always returns the class from which it was called, regardless of what
         * 'this' points to during run-time
         *
         *     Ext.define('My.Cat', {
         *         statics: {
         *             totalCreated: 0,
         *             speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
         *         },
         *
         *         constructor: function() {
         *             var statics = this.statics();
         *
         *             alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
         *                                             // equivalent to: My.Cat.speciesName
         *
         *             alert(this.self.speciesName);   // dependent on 'this'
         *
         *             statics.totalCreated++;
         *         },
         *
         *         clone: function() {
         *             var cloned = new this.self();   // dependent on 'this'
         *
         *             cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
         *
         *             return cloned;
         *         }
         *     });
         *
         *
         *     Ext.define('My.SnowLeopard', {
         *         extend: 'My.Cat',
         *
         *         statics: {
         *             speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
         *         },
         *
         *         constructor: function() {
         *             this.callParent();
         *         }
         *     });
         *
         *     var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
         *
         *     var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
         *
         *     var clone = snowLeopard.clone();
         *     alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
         *     alert(clone.groupName);                 // alerts 'Cat'
         *
         *     alert(My.Cat.totalCreated);             // alerts 3
         *
         * @return {Ext.Class}
         */
        protected statics(): Ext.Class;

        /**
         * Add methods / properties to the prototype of this class.
         *
         *     Ext.define('My.awesome.Cat', {
         *         constructor: function() {
         *             ...
         *         }
         *     });
         *
         *      My.awesome.Cat.addMembers({
         *          meow: function() {
         *             alert('Meowww...');
         *          }
         *      });
         *
         *      var kitty = new My.awesome.Cat();
         *      kitty.meow();
         *
         * @param {Object} members The members to add to this class.
         * @param {Boolean} [isStatic=false] Pass 'true' if the members are static.
         * @param {Boolean} [privacy=false] Pass 'true' if the members are private. This
         * only has meaning in debug mode and only for methods.
         * @inheritable
         */
        static addMembers(members: any, isStatic?: boolean, privacy?: boolean);

        /**
         * Add / override static properties of this class.
         *
         *     Ext.define('My.cool.Class', {
         *         ...
         *     });
         *
         *     My.cool.Class.addStatics({
         *         someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
         *         method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
         *         method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
         *     });
         *
         * @return {Ext.Base} this
         * @inheritable
         */
        static addStatics(members: any): Ext.Base;

        /**
         * @inheritable
         */
        protected static callParent();

        /**
         * @inheritable
         */
        protected static callSuper();

        /**
         * Create a new instance of this Class.
         *
         *     Ext.define('My.cool.Class', {
         *         ...
         *     });
         *
         *     My.cool.Class.create({
         *         someConfig: true
         *     });
         *
         * All parameters are passed to the constructor of the class.
         *
         * @return {Object} the created instance.
         * @inheritable
         */
        static create(): any;

        /**
         * Create aliases for existing prototype methods. Example:
         *
         *     Ext.define('My.cool.Class', {
         *         method1: function() { ... },
         *         method2: function() { ... }
         *     });
         *
         *     var test = new My.cool.Class();
         *
         *     My.cool.Class.createAlias({
         *         method3: 'method1',
         *         method4: 'method2'
         *     });
         *
         *     test.method3(); // test.method1()
         *
         *     My.cool.Class.createAlias('method5', 'method3');
         *
         *     test.method5(); // test.method3() -> test.method1()
         *
         * @param {String/Object} alias The new method name, or an object to set multiple aliases. See
         * {@link Ext.Function#flexSetter flexSetter}
         * @param {String/Object} origin The original method name
         * @inheritable
         */
        static createAlias(alias: string|any, origin: string|any);

        /**
         * Get the current class' name in string format.
         *
         *     Ext.define('My.cool.Class', {
         *         constructor: function() {
         *             alert(this.self.getName()); // alerts 'My.cool.Class'
         *         }
         *     });
         *
         *     My.cool.Class.getName(); // 'My.cool.Class'
         *
         * @return {String} className
         * @inheritable
         */
        static getName(): string;

        /**
         * Override members of this class. Overridden methods can be invoked via
         * {@link Ext.Base#callParent}.
         *
         *     Ext.define('My.Cat', {
         *         constructor: function() {
         *             alert("I'm a cat!");
         *         }
         *     });
         *
         *     My.Cat.override({
         *         constructor: function() {
         *             alert("I'm going to be a cat!");
         *
         *             this.callParent(arguments);
         *
         *             alert("Meeeeoooowwww");
         *         }
         *     });
         *
         *     var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
         *                               // alerts "I'm a cat!"
         *                               // alerts "Meeeeoooowwww"
         *
         * Direct use of this method should be rare. Use {@link Ext#define Ext.define}
         * instead:
         *
         *     Ext.define('My.CatOverride', {
         *         override: 'My.Cat',
         *         constructor: function() {
         *             alert("I'm going to be a cat!");
         *
         *             this.callParent(arguments);
         *
         *             alert("Meeeeoooowwww");
         *         }
         *     });
         *
         * The above accomplishes the same result but can be managed by the {@link Ext.Loader}
         * which can properly order the override and its target class and the build process
         * can determine whether the override is needed based on the required state of the
         * target class (My.Cat).
         *
         * @param {Object} members The properties to add to this class. This should be
         * specified as an object literal containing one or more properties.
         * @return {Ext.Base} this class
         * @inheritable
         */
        static override(members: any): Ext.Base;
    }

    export class BingMap extends Ext.Map {
        constructor();

        setMapCenter(coordinates: any);
    }

    /**
     * @extends Ext.env.Browser
     * Provides useful information about the current browser.
     *
     * Example:
     *
     *     if (Ext.browser.is.IE) {
     *         // IE specific code here
     *     }
     *
     *     if (Ext.browser.is.WebKit) {
     *         // WebKit specific code here
     *     }
     *
     *     console.log("Version " + Ext.browser.version);
     *
     * For a full list of supported values, refer to {@link #is} property/method.
     */
    export class browser {
    }

    interface ButtonConfig extends Ext.ComponentConfig {
        /**
         * 'true' to allow user interaction to set {@link #pressed} to 'false' when
         * the button is in the {@link #pressed} state. Only valid when {@link #pressed}
         * is configured.
         *
         * @since 6.0.2
         */
        allowDepress?: boolean;

        /**
         * Optional event name that will be fired instead of 'tap' when the Button is tapped on.
         */
        autoEvent?: string;

        /**
         * The CSS class to add to the Button's badge, if it has one.  Badges appear as small numbers, letters, or icons that sit on top of your button.  For instance, a small red number indicating how many updates are available.
         */
        badgeCls?: string;

        /**
         * Optional badge text.  Badges appear as small numbers, letters, or icons that sit on top of your button.  For instance, a small red number indicating how many updates are available.
         */
        badgeText?: string;

        baseCls?: any;

        /**
         * Allows this button to have the pressed state toggled via user
         * interaction.
         *
         * @since 6.0.2
         */
        enableToggle?: boolean;

        /**
         * The handler function to run when the Button is tapped on.
         */
        handler?: Function;

        /**
         * Url to the icon image to use if you want an icon to appear on your button.
         */
        icon?: string;

        /**
         * The position within the Button to render the icon Options are: 'top', 'right', 'bottom', 'left' and 'center' (when you have
         * no {@link #text} set).
         */
        iconAlign?: string;

        /**
         * One or more space separated CSS classes to be applied to the icon element.
         * The CSS rule(s) applied should specify a background image to be used as the
         * icon.
         *
         * An example of specifying a custom icon class would be something like:
         *
         *     // specify the property in the config for the class:
         *     iconCls: 'my-home-icon'
         *
         *     // css rule specifying the background image to be used as the icon image:
         *     .my-home-icon {
         *         background-image: url(../images/my-home-icon.gif) !important;
         *     }
         *
         * In addition to specifying your own classes, you can use the font icons
         * provided in the SDK using the following syntax:
         *
         *     // using Font Awesome
         *     iconCls: 'x-fa fa-home'
         *
         *     // using Pictos
         *     iconCls: 'pictos pictos-home'
         *
         * Depending on the theme you're using, you may need include the font icon
         * packages in your application in order to use the icons included in the
         * SDK.  For more information see:
         *
         *  - [Font Awesome icons](http://fortawesome.github.io/Font-Awesome/cheatsheet/)
         *  - [Pictos icons](http://docs.sencha.com/extjs/6.0/core_concepts/font_ext.html)
         *  - [Theming Guide](http://docs.sencha.com/extjs/6.0/core_concepts/theming.html)
         */
        iconCls?: string;

        /**
         * The CSS class to add to the field's label element.
         */
        labelCls?: string;

        /**
         * Sets the pressed state of the button.
         *
         * @since 6.0.2
         */
        pressed?: boolean;

        /**
         * The amount of delay between the 'tapstart' and the moment we add the 'pressingCls' (in milliseconds).
         * Settings this to 'true' defaults to 100ms.
         */
        pressedDelay?: number|boolean;

        /**
         * The CSS class to add to the Button when it is {@link #pressed}.
         */
        pressingCls?: string;

        /**
         * The scope to fire the configured {@link #handler} in.
         */
        scope?: any;

        /**
         * The Button text.
         */
        text?: string;

        /**
         * @since 6.0.1
         *
         * Optional, Defaults to: "center"
         */
        textAlign?: any;

        /**
         * The ui style to render this button with. The valid default options are:
         *
         * - 'null' - a basic gray button (default).
         * - ''back'' - a back button.
         * - ''forward'' - a forward button.
         * - ''round'' - a round button.
         * - ''plain''
         * - ''action'' - shaded using the {@link Global_CSS#$active-color $active-color} (dark blue by default).
         * - ''decline'' - shaded using the {@link Global_CSS#$alert-color $alert-color} (red by default).
         * - ''confirm'' - shaded using the {@link Global_CSS#$confirm-color $confirm-color} (green by default).
         *
         * You can also append '-round' to each of the last three UI's to give it a round shape:
         *
         * - **action-round**
         * - **decline-round**
         * - **confirm-round**
         */
        ui?: string;

        /**
         * The value of this button.  Only applicable when used as an item of a {@link Ext.SegmentedButton Segmented Button}.
         */
        value?: string|number;
    }

    /**
     * A simple class to display a button.
     *
     * There are various different styles of Button you can create by using the {@link #icon},
     * {@link #iconCls}, {@link #iconAlign}, {@link #ui}, and {@link #text}
     * configurations.
     *
     * ## Simple Button
     *
     * Here is a Button in it's simplest form:
     *
     *     @example miniphone
     *     var button = Ext.create('Ext.Button', {
     *         text: 'Button'
     *     });
     *     Ext.Viewport.add({ xtype: 'container', padding: 10, items: [button] });
     *
     * ## Icons
     *
     * You can also create a Button with just an icon using the {@link #iconCls} configuration:
     *
     *     @example miniphone
     *     var button = Ext.create('Ext.Button', {
     *         iconCls: 'refresh'
     *     });
     *     Ext.Viewport.add({ xtype: 'container', padding: 10, items: [button] });
     *
     * Sencha provides the "Font" and "PNG" icons packs from http://wwww.pictos.cc.
     * Use icons with the {@link Global_CSS#icon icon} mixin in your Sass.
     *
     * ## Badges
     *
     * Buttons can also have a badge on them, by using the {@link #badgeText} configuration:
     *
     *     @example
     *     Ext.create('Ext.Container', {
     *         fullscreen: true,
     *         padding: 10,
     *         items: {
     *             xtype: 'button',
     *             text: 'My Button',
     *             badgeText: '2'
     *         }
     *     });
     *
     * ## UI
     *
     * Buttons also come with a range of different default UIs. Here are the included UIs
     * available (if {@link #$include-button-uis $include-button-uis} is set to 'true'):
     *
     * - **normal** - a basic gray button
     * - **back** - a back button
     * - **forward** - a forward button
     * - **round** - a round button
     * - **action** - shaded using the {@link Global_CSS#$active-color $active-color} (dark blue by default)
     * - **decline** - shaded using the {@link Global_CSS#$alert-color $alert-color} (red by default)
     * - **confirm** - shaded using the {@link Global_CSS#$confirm-color $confirm-color} (green by default)
     *
     * You can also append '-round' to each of the last three UI's to give it a round shape:
     *
     * - **action-round**
     * - **decline-round**
     * - **confirm-round**
     *
     * And setting them is very simple:
     *
     *     var uiButton = Ext.create('Ext.Button', {
     *         text: 'My Button',
     *         ui: 'action'
     *     });
     *
     * And how they look:
     *
     *     @example miniphone preview
     *     Ext.create('Ext.Container', {
     *         fullscreen: true,
     *         padding: 4,
     *         defaults: {
     *             xtype: 'button',
     *             margin: 5
     *         },
     *         layout: {
     *             type: 'vbox',
     *             align: 'center'
     *         },
     *         items: [
     *             { ui: 'normal', text: 'normal' },
     *             { ui: 'round', text: 'round' },
     *             { ui: 'action', text: 'action' },
     *             { ui: 'decline', text: 'decline' },
     *             { ui: 'confirm', text: 'confirm' }
     *         ]
     *     });
     *
     * Note that the default {@link #ui} is **normal**.
     *
     * You can also use the {@link #sencha-button-ui sencha-button-ui} CSS Mixin to create your own UIs.
     *
     * ## Example
     *
     * This example shows a bunch of icons on the screen in two toolbars. When you click on the center
     * button, it switches the {@link #iconCls} on every button on the page.
     *
     *     @example preview
     *     Ext.createWidget('container', {
     *         fullscreen: true,
     *         layout: {
     *             type: 'vbox',
     *             pack:'center',
     *             align: 'center'
     *         },
     *         items: [
     *             {
     *                 xtype: 'button',
     *                 text: 'Change iconCls',
     *                 handler: function() {
     *                     // classes for all the icons to loop through.
     *                     var availableIconCls = [
     *                         'action', 'add', 'arrow_down', 'arrow_left',
     *                         'arrow_right', 'arrow_up', 'compose', 'delete',
     *                         'organize', 'refresh', 'reply', 'search',
     *                         'settings', 'star', 'trash', 'maps', 'locate',
     *                         'home'
     *                     ];
     *                     // get the text of this button,
     *                     // so we know which button we don't want to change
     *                     var text = this.getText();
     *
     *                     // use ComponentQuery to find all buttons on the page
     *                     // and loop through all of them
     *                     Ext.Array.forEach(Ext.ComponentQuery.query('button'), function(button) {
     *                         // if the button is the change iconCls button, continue
     *                         if (button.getText() === text) {
     *                             return;
     *                         }
     *
     *                         // get the index of the new available iconCls
     *                         var index = availableIconCls.indexOf(button.getIconCls()) + 1;
     *
     *                         // update the iconCls of the button with the next iconCls, if one exists.
     *                         // if not, use the first one
     *                         button.setIconCls(availableIconCls[(index === availableIconCls.length) ? 0 : index]);
     *                     });
     *                 }
     *             },
     *             {
     *                 xtype: 'toolbar',
     *                 docked: 'top',
     *                 items: [
     *                     { xtype: 'spacer' },
     *                     { iconCls: 'action' },
     *                     { iconCls: 'add' },
     *                     { iconCls: 'arrow_down' },
     *                     { iconCls: 'arrow_left' },
     *                     { iconCls: 'arrow_up' },
     *                     { iconCls: 'compose' },
     *                     { iconCls: 'delete' },
     *                     { iconCls: 'organize' },
     *                     { iconCls: 'refresh' },
     *                     { xtype: 'spacer' }
     *                 ]
     *             },
     *             {
     *                 xtype: 'toolbar',
     *                 docked: 'bottom',
     *                 ui: 'light',
     *                 items: [
     *                     { xtype: 'spacer' },
     *                     { iconCls: 'reply' },
     *                     { iconCls: 'search' },
     *                     { iconCls: 'settings' },
     *                     { iconCls: 'star' },
     *                     { iconCls: 'trash' },
     *                     { iconCls: 'maps' },
     *                     { iconCls: 'locate' },
     *                     { iconCls: 'home' },
     *                     { xtype: 'spacer' }
     *                 ]
     *             }
     *         ]
     *     });
     */
    export class Button extends Ext.Component implements Ext.ButtonConfig {
        defaultBindProperty: any;

        protected template: any[];

        /**
         * 'true' to allow user interaction to set {@link #pressed} to 'false' when
         * the button is in the {@link #pressed} state. Only valid when {@link #pressed}
         * is configured.
         *
         * @since 6.0.2
         */
        allowDepress: boolean;

        /**
         * Optional event name that will be fired instead of 'tap' when the Button is tapped on.
         */
        autoEvent: string;

        /**
         * The CSS class to add to the Button's badge, if it has one.  Badges appear as small numbers, letters, or icons that sit on top of your button.  For instance, a small red number indicating how many updates are available.
         */
        badgeCls: string;

        /**
         * Optional badge text.  Badges appear as small numbers, letters, or icons that sit on top of your button.  For instance, a small red number indicating how many updates are available.
         */
        badgeText: string;

        /**
         * The base CSS class to apply to this component's element. This will also be prepended to
         * other elements within this component. To add specific styling for sub-classes, use the {@link #cls} config.
         */
        baseCls: string;

        /**
         * Allows this button to have the pressed state toggled via user
         * interaction.
         *
         * @since 6.0.2
         */
        enableToggle: boolean;

        /**
         * The handler function to run when the Button is tapped on.
         */
        handler: Function;

        /**
         * Url to the icon image to use if you want an icon to appear on your button.
         */
        icon: string;

        /**
         * The position within the Button to render the icon Options are: 'top', 'right', 'bottom', 'left' and 'center' (when you have
         * no {@link #text} set).
         */
        iconAlign: string;

        /**
         * One or more space separated CSS classes to be applied to the icon element.
         * The CSS rule(s) applied should specify a background image to be used as the
         * icon.
         *
         * An example of specifying a custom icon class would be something like:
         *
         *     // specify the property in the config for the class:
         *     iconCls: 'my-home-icon'
         *
         *     // css rule specifying the background image to be used as the icon image:
         *     .my-home-icon {
         *         background-image: url(../images/my-home-icon.gif) !important;
         *     }
         *
         * In addition to specifying your own classes, you can use the font icons
         * provided in the SDK using the following syntax:
         *
         *     // using Font Awesome
         *     iconCls: 'x-fa fa-home'
         *
         *     // using Pictos
         *     iconCls: 'pictos pictos-home'
         *
         * Depending on the theme you're using, you may need include the font icon
         * packages in your application in order to use the icons included in the
         * SDK.  For more information see:
         *
         *  - [Font Awesome icons](http://fortawesome.github.io/Font-Awesome/cheatsheet/)
         *  - [Pictos icons](http://docs.sencha.com/extjs/6.0/core_concepts/font_ext.html)
         *  - [Theming Guide](http://docs.sencha.com/extjs/6.0/core_concepts/theming.html)
         */
        iconCls: string;

        /**
         * The CSS class to add to the field's label element.
         */
        labelCls: string;

        /**
         * Sets the pressed state of the button.
         *
         * @since 6.0.2
         */
        pressed: boolean;

        /**
         * The amount of delay between the 'tapstart' and the moment we add the 'pressingCls' (in milliseconds).
         * Settings this to 'true' defaults to 100ms.
         */
        pressedDelay: number|boolean;

        /**
         * The CSS class to add to the Button when it is {@link #pressed}.
         */
        pressingCls: string;

        /**
         * The scope to fire the configured {@link #handler} in.
         */
        scope: any;

        /**
         * The Button text.
         */
        text: string;

        /**
         * @since 6.0.1
         *
         * Optional, Defaults to: "center"
         */
        textAlign: any;

        /**
         * The ui style to render this button with. The valid default options are:
         *
         * - 'null' - a basic gray button (default).
         * - ''back'' - a back button.
         * - ''forward'' - a forward button.
         * - ''round'' - a round button.
         * - ''plain''
         * - ''action'' - shaded using the {@link Global_CSS#$active-color $active-color} (dark blue by default).
         * - ''decline'' - shaded using the {@link Global_CSS#$alert-color $alert-color} (red by default).
         * - ''confirm'' - shaded using the {@link Global_CSS#$confirm-color $confirm-color} (green by default).
         *
         * You can also append '-round' to each of the last three UI's to give it a round shape:
         *
         * - **action-round**
         * - **decline-round**
         * - **confirm-round**
         */
        ui: string;

        /**
         * The value of this button.  Only applicable when used as an item of a {@link Ext.SegmentedButton Segmented Button}.
         */
        value: string|number;

        /**
         * Creates new Component.
         * @param {Object} config The standard configuration object.
         */
        constructor(config: Ext.ButtonConfig);

        destroy();

        getAllowDepress();

        getAutoEvent();

        getBadgeCls();

        getBadgeText();

        getBaseCls();

        getEnableToggle();

        getHandler();

        getIcon();

        getIconAlign();

        getIconCls();

        getLabelCls();

        getPressed();

        getPressedDelay();

        getPressingCls();

        getScope();

        getText();

        getTextAlign();

        getUi();

        getValue();

        protected initialize();

        /**
         * 'true' if this button is currently in a pressed state. See {@link #pressed}.
         * @return {Boolean} The pressed state.
         *
         * @since 6.0.2
         */
        isPressed(): boolean;

        setAllowDepress();

        setAutoEvent();

        setBadgeCls();

        setBadgeText();

        setBaseCls();

        setEnableToggle();

        setHandler();

        setIcon();

        setIconAlign();

        setIconCls();

        setLabelCls();

        setPressed();

        setPressedDelay();

        setPressingCls();

        setScope();

        setText();

        setTextAlign();

        setUi();

        setValue();

        /**
         * Toggles the {@link #pressed} state.
         *
         * @since 6.0.2
         */
        toggle();

        pressedchange();

        /**
         * Fires whenever the button is released.
         * @param {Ext.Button} this The item added to the Container.
         * @param {Ext.EventObject} e The event object.
         */
        release(that: Ext.Button, e: any);

        /**
         * Fires whenever a button is tapped.
         * @param {Ext.Button} this The item added to the Container.
         * @param {Ext.EventObject} e The event object.
         */
        tap(that: Ext.Button, e: any);
    }

    interface ClassConfig {
        /**
         * List of short aliases for class names. An alias consists of a namespace and a name
         * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
         *
         *  - **namespace** - The namespace describes what kind of alias this is and must be
         *  all lowercase.
         *  - **name** - The name of the alias which allows the lazy-instantiation via the
         *  alias. The name shouldn't contain any periods.
         *
         * A list of namespaces and the usages are:
         *
         *  - **feature** - {@link Ext.grid.Panel Grid} features
         *  - **plugin** - Plugins
         *  - **store** - {@link Ext.data.Store}
         *  - **widget** - Components
         *
         * Most useful for defining xtypes for widgets:
         *
         *     Ext.define('MyApp.CoolPanel', {
         *         extend: 'Ext.panel.Panel',
         *         alias: ['widget.coolpanel'],
         *         title: 'Yeah!'
         *     });
         *
         *     // Using Ext.create
         *     Ext.create('widget.coolpanel');
         *
         *     // Using the shorthand for defining widgets by xtype
         *     Ext.widget('panel', {
         *         items: [
         *             {xtype: 'coolpanel', html: 'Foo'},
         *             {xtype: 'coolpanel', html: 'Bar'}
         *         ]
         *     });
         */
        alias?: string;

        /**
         * Defines alternate names for this class.  For example:
         *
         *     Ext.define('Developer', {
         *         alternateClassName: ['Coder', 'Hacker'],
         *         code: function(msg) {
         *             alert('Typing... ' + msg);
         *         }
         *     });
         *
         *     var joe = Ext.create('Developer');
         *     joe.code('stackoverflow');
         *
         *     var rms = Ext.create('Hacker');
         *     rms.code('hack hack');
         */
        alternateClassName?: string;

        /**
         * This configuration works in a very similar manner to the {@link #config} option.
         * The difference is that the configurations are only ever processed when the first instance
         * of that class is created. The processed value is then stored on the class prototype and
         * will not be processed on subsequent instances of the class. Getters/setters will be generated
         * in exactly the same way as {@link #config}.
         *
         * This option is useful for expensive objects that can be shared across class instances.
         * The class itself ensures that the creation only occurs once.
         */
        cachedConfig?: any;

        /**
         * List of configuration options with their default values.
         *
         * __Note:__ You need to make sure {@link Ext.Base#initConfig} is called from your constructor if you are defining
         * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
         * methods will not be initialized.
         *
         * Each config item will have its own setter and getter method automatically generated inside the class prototype
         * during class creation time, if the class does not have those methods explicitly defined.
         *
         * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
         * gender items.
         *
         *     Ext.define('My.sample.Person', {
         *         config: {
         *             name: 'Mr. Unknown',
         *             age: 0,
         *             gender: 'Male'
         *         },
         *
         *         constructor: function(config) {
         *             this.initConfig(config);
         *
         *             return this;
         *         }
         *
         *         // ...
         *     });
         *
         * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
         * without sacrificing encapsulation, via setter and getter methods.
         *
         *     var jacky = new Person({
         *         name: "Jacky",
         *         age: 35
         *     });
         *
         *     alert(jacky.getAge());      // alerts 35
         *     alert(jacky.getGender());   // alerts "Male"
         *
         *     jacky.walk(10);             // alerts "Jacky is walking 10 steps"
         *
         *     jacky.setName("Mr. Nguyen");
         *     alert(jacky.getName());     // alerts "Mr. Nguyen"
         *
         *     jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
         *
         * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
         * Two key things happened:
         *
         *  - The provided config object when the class is instantiated is recursively merged with the default config object.
         *  - All corresponding setter methods are called with the merged values.
         *
         * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
         *
         *  - Filtering / validation / transformation of the given value before it's actually stored within the instance.
         *  - Notification (such as firing events) / post-processing after the value has been set, or changed from a
         *    previous value.
         *
         * By standardize this common pattern, the default generated setters provide two extra template methods that you
         * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
         * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
         * age must be a valid positive number, and fire an 'agechange' if the value is modified.
         *
         *     Ext.define('My.sample.Person', {
         *         config: {
         *             // ...
         *         },
         *
         *         constructor: {
         *             // ...
         *         },
         *
         *         applyAge: function(age) {
         *             if (typeof age !== 'number' || age < 0) {
         *                 console.warn("Invalid age, must be a positive number");
         *                 return;
         *             }
         *
         *             return age;
         *         },
         *
         *         updateAge: function(newAge, oldAge) {
         *             // age has changed from "oldAge" to "newAge"
         *             this.fireEvent('agechange', this, newAge, oldAge);
         *         }
         *
         *         // ...
         *     });
         *
         *     var jacky = new Person({
         *         name: "Jacky",
         *         age: 'invalid'
         *     });
         *
         *     alert(jacky.getAge());      // alerts 0
         *
         *     alert(jacky.setAge(-100));  // alerts 0
         *     alert(jacky.getAge());      // alerts 0
         *
         *     alert(jacky.setAge(35));    // alerts 0
         *     alert(jacky.getAge());      // alerts 35
         *
         * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
         * explicitly. Instead, "apply*" and "update*" methods should be implemented where necessary. Your code will be
         * consistent throughout and only contain the minimal logic that you actually care about.
         *
         * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
         * the child's default config. The same applies for mixins.
         */
        config?: any;

        /**
         * The parent class that this class extends. For example:
         *
         *     Ext.define('Person', {
         *         say: function(text) { alert(text); }
         *     });
         *
         *     Ext.define('Developer', {
         *         extend: 'Person',
         *         say: function(text) { this.callParent(["print "+text]); }
         *     });
         */
        extend?: string;

        /**
         * List of inheritable static methods for this class.
         * Otherwise just like {@link #statics} but subclasses inherit these methods.
         */
        inheritableStatics?: any;

        /**
         * List of classes to mix into this class. For example:
         *
         *     Ext.define('CanSing', {
         *          sing: function() {
         *              alert("For he's a jolly good fellow...")
         *          }
         *     });
         *
         *     Ext.define('Musician', {
         *          mixins: ['CanSing']
         *     })
         *
         * In this case the Musician class will get a 'sing' method from CanSing mixin.
         *
         * But what if the Musician already has a 'sing' method? Or you want to mix
         * in two classes, both of which define 'sing'?  In such a cases it's good
         * to define mixins as an object, where you assign a name to each mixin:
         *
         *     Ext.define('Musician', {
         *          mixins: {
         *              canSing: 'CanSing'
         *          },
         *
         *          sing: function() {
         *              // delegate singing operation to mixin
         *              this.mixins.canSing.sing.call(this);
         *          }
         *     })
         *
         * In this case the 'sing' method of Musician will overwrite the
         * mixed in 'sing' method. But you can access the original mixed in method
         * through special 'mixins' property.
         */
        mixins?: string|any;

        /**
         * Overrides members of the specified 'target' class.
         *
         * **NOTE:** the overridden class must have been defined using
         * {@link Ext#define Ext.define} in order to use the 'override' config.
         *
         * Methods defined on the overriding class will not automatically call the methods of
         * the same name in the ancestor class chain.  To call the parent's method of the
         * same name you must call {@link Ext.Base#callParent callParent}.  To skip the
         * method of the overridden class and call its parent you will instead call
         * {@link Ext.Base#callSuper callSuper}.
         *
         * See {@link Ext#define Ext.define} for additional usage examples.
         */
        override?: string;

        /**
         * Allows setting config values for a class based on specific platforms. The value
         * of this config is an object whose properties are "rules" and whose values are
         * objects containing config values.
         *
         * For example:
         *
         *      Ext.define('App.view.Foo', {
         *          extend: 'Ext.panel.Panel',
         *
         *          platformConfig: {
         *              desktop: {
         *                  title: 'Some Rather Descriptive Title'
         *              },
         *
         *              '!desktop': {
         *                  title: 'Short Title'
         *              }
         *          }
         *      });
         *
         * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
         * evaluates to 'true' will have its configs applied to the class. In this case, only
         * the "title" property, but the object can contain any number of config properties.
         * In this case, the 'platformConfig' is evaluated as part of the class and there is
         * not cost for each instance created.
         *
         * The rules are evaluated expressions in the context of the platform tags contained
         * in '{@link Ext#platformTags Ext.platformTags}'. Any properties of that object are
         * implicitly usable (as shown above).
         *
         * If a 'platformConfig' specifies a config value, it will replace any values declared
         * on the class itself.
         *
         * Use of 'platformConfig' on instances is handled by the config system when classes
         * call '{@link Ext.Base#initConfig initConfig}'. For example:
         *
         *      Ext.create({
         *          xtype: 'panel',
         *
         *          platformConfig: {
         *              desktop: {
         *                  title: 'Some Rather Descriptive Title'
         *              },
         *
         *              '!desktop': {
         *                  title: 'Short Title'
         *              }
         *          }
         *      });
         *
         * The following is equivalent to the above:
         *
         *      if (Ext.platformTags.desktop) {
         *          Ext.create({
         *              xtype: 'panel',
         *              title: 'Some Rather Descriptive Title'
         *          });
         *      } else {
         *          Ext.create({
         *              xtype: 'panel',
         *              title: 'Short Title'
         *          });
         *      }
         *
         * To adjust configs based on dynamic conditions, see '{@link Ext.mixin.Responsive}'.
         */
        platformConfig?: any;

        /**
         * The 'privates' config is a list of methods intended to be used internally by the
         * framework.  Methods are placed in a 'privates' block to prevent developers from
         * accidentally overriding framework methods in custom classes.
         *
         *     Ext.define('Computer', {
         *         privates: {
         *             runFactory: function(brand) {
         *                 // internal only processing of brand passed to factory
         *                 this.factory(brand);
         *             }
         *         },
         *
         *         factory: function (brand) {}
         *     });
         *
         * In order to override a method from a 'privates' block, the overridden method must
         * also be placed in a 'privates' block within the override class.
         *
         *     Ext.define('Override.Computer', {
         *         override: 'Computer',
         *         privates: {
         *             runFactory: function() {
         *                 // overriding logic
         *             }
         *         }
         *     });
         */
        privates?: any;

        /**
         * List of classes that have to be loaded before instantiating this class.
         * For example:
         *
         *     Ext.define('Mother', {
         *         requires: ['Child'],
         *         giveBirth: function() {
         *             // we can be sure that child class is available.
         *             return new Child();
         *         }
         *     });
         */
        requires?: string;

        /**
         * When set to true, the class will be instantiated as singleton.  For example:
         *
         *     Ext.define('Logger', {
         *         singleton: true,
         *         log: function(msg) {
         *             console.log(msg);
         *         }
         *     });
         *
         *     Logger.log('Hello');
         */
        singleton?: boolean;

        /**
         * List of static methods for this class. For example:
         *
         *     Ext.define('Computer', {
         *          statics: {
         *              factory: function(brand) {
         *                  // 'this' in static methods refer to the class itself
         *                  return new this(brand);
         *              }
         *          },
         *
         *          constructor: function() { ... }
         *     });
         *
         *     var dellComputer = Computer.factory('Dell');
         */
        statics?: any;

        /**
         * List of optional classes to load together with this class. These aren't neccessarily loaded before
         * this class is created, but are guaranteed to be available before Ext.onReady listeners are
         * invoked. For example:
         *
         *     Ext.define('Mother', {
         *         uses: ['Child'],
         *         giveBirth: function() {
         *             // This code might, or might not work:
         *             // return new Child();
         *
         *             // Instead use Ext.create() to load the class at the spot if not loaded already:
         *             return Ext.create('Child');
         *         }
         *     });
         */
        uses?: string;

        xtype?: any;
    }

    /**
     * This is a low level factory that is used by {@link Ext#define Ext.define} and should not be used
     * directly in application code.
     *
     * The configs of this class are intended to be used in 'Ext.define' calls to describe the class you
     * are declaring. For example:
     *
     *     Ext.define('App.util.Thing', {
     *         extend: 'App.util.Other',
     *
     *         alias: 'util.thing',
     *
     *         config: {
     *             foo: 42
     *         }
     *     });
     *
     * Ext.Class is the factory and **not** the superclass of everything. For the base class that **all**
     * classes inherit from, see {@link Ext.Base}.
     */
    export class Class implements Ext.ClassConfig {
        /**
         * List of short aliases for class names. An alias consists of a namespace and a name
         * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
         *
         *  - **namespace** - The namespace describes what kind of alias this is and must be
         *  all lowercase.
         *  - **name** - The name of the alias which allows the lazy-instantiation via the
         *  alias. The name shouldn't contain any periods.
         *
         * A list of namespaces and the usages are:
         *
         *  - **feature** - {@link Ext.grid.Panel Grid} features
         *  - **plugin** - Plugins
         *  - **store** - {@link Ext.data.Store}
         *  - **widget** - Components
         *
         * Most useful for defining xtypes for widgets:
         *
         *     Ext.define('MyApp.CoolPanel', {
         *         extend: 'Ext.panel.Panel',
         *         alias: ['widget.coolpanel'],
         *         title: 'Yeah!'
         *     });
         *
         *     // Using Ext.create
         *     Ext.create('widget.coolpanel');
         *
         *     // Using the shorthand for defining widgets by xtype
         *     Ext.widget('panel', {
         *         items: [
         *             {xtype: 'coolpanel', html: 'Foo'},
         *             {xtype: 'coolpanel', html: 'Bar'}
         *         ]
         *     });
         */
        alias: string;

        /**
         * Defines alternate names for this class.  For example:
         *
         *     Ext.define('Developer', {
         *         alternateClassName: ['Coder', 'Hacker'],
         *         code: function(msg) {
         *             alert('Typing... ' + msg);
         *         }
         *     });
         *
         *     var joe = Ext.create('Developer');
         *     joe.code('stackoverflow');
         *
         *     var rms = Ext.create('Hacker');
         *     rms.code('hack hack');
         */
        alternateClassName: string;

        /**
         * This configuration works in a very similar manner to the {@link #config} option.
         * The difference is that the configurations are only ever processed when the first instance
         * of that class is created. The processed value is then stored on the class prototype and
         * will not be processed on subsequent instances of the class. Getters/setters will be generated
         * in exactly the same way as {@link #config}.
         *
         * This option is useful for expensive objects that can be shared across class instances.
         * The class itself ensures that the creation only occurs once.
         */
        cachedConfig: any;

        /**
         * List of configuration options with their default values.
         *
         * __Note:__ You need to make sure {@link Ext.Base#initConfig} is called from your constructor if you are defining
         * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
         * methods will not be initialized.
         *
         * Each config item will have its own setter and getter method automatically generated inside the class prototype
         * during class creation time, if the class does not have those methods explicitly defined.
         *
         * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
         * gender items.
         *
         *     Ext.define('My.sample.Person', {
         *         config: {
         *             name: 'Mr. Unknown',
         *             age: 0,
         *             gender: 'Male'
         *         },
         *
         *         constructor: function(config) {
         *             this.initConfig(config);
         *
         *             return this;
         *         }
         *
         *         // ...
         *     });
         *
         * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
         * without sacrificing encapsulation, via setter and getter methods.
         *
         *     var jacky = new Person({
         *         name: "Jacky",
         *         age: 35
         *     });
         *
         *     alert(jacky.getAge());      // alerts 35
         *     alert(jacky.getGender());   // alerts "Male"
         *
         *     jacky.walk(10);             // alerts "Jacky is walking 10 steps"
         *
         *     jacky.setName("Mr. Nguyen");
         *     alert(jacky.getName());     // alerts "Mr. Nguyen"
         *
         *     jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
         *
         * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
         * Two key things happened:
         *
         *  - The provided config object when the class is instantiated is recursively merged with the default config object.
         *  - All corresponding setter methods are called with the merged values.
         *
         * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
         *
         *  - Filtering / validation / transformation of the given value before it's actually stored within the instance.
         *  - Notification (such as firing events) / post-processing after the value has been set, or changed from a
         *    previous value.
         *
         * By standardize this common pattern, the default generated setters provide two extra template methods that you
         * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
         * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
         * age must be a valid positive number, and fire an 'agechange' if the value is modified.
         *
         *     Ext.define('My.sample.Person', {
         *         config: {
         *             // ...
         *         },
         *
         *         constructor: {
         *             // ...
         *         },
         *
         *         applyAge: function(age) {
         *             if (typeof age !== 'number' || age < 0) {
         *                 console.warn("Invalid age, must be a positive number");
         *                 return;
         *             }
         *
         *             return age;
         *         },
         *
         *         updateAge: function(newAge, oldAge) {
         *             // age has changed from "oldAge" to "newAge"
         *             this.fireEvent('agechange', this, newAge, oldAge);
         *         }
         *
         *         // ...
         *     });
         *
         *     var jacky = new Person({
         *         name: "Jacky",
         *         age: 'invalid'
         *     });
         *
         *     alert(jacky.getAge());      // alerts 0
         *
         *     alert(jacky.setAge(-100));  // alerts 0
         *     alert(jacky.getAge());      // alerts 0
         *
         *     alert(jacky.setAge(35));    // alerts 0
         *     alert(jacky.getAge());      // alerts 35
         *
         * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
         * explicitly. Instead, "apply*" and "update*" methods should be implemented where necessary. Your code will be
         * consistent throughout and only contain the minimal logic that you actually care about.
         *
         * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
         * the child's default config. The same applies for mixins.
         */
        config: any;

        /**
         * The parent class that this class extends. For example:
         *
         *     Ext.define('Person', {
         *         say: function(text) { alert(text); }
         *     });
         *
         *     Ext.define('Developer', {
         *         extend: 'Person',
         *         say: function(text) { this.callParent(["print "+text]); }
         *     });
         */
        extend: string;

        /**
         * List of inheritable static methods for this class.
         * Otherwise just like {@link #statics} but subclasses inherit these methods.
         */
        inheritableStatics: any;

        /**
         * List of classes to mix into this class. For example:
         *
         *     Ext.define('CanSing', {
         *          sing: function() {
         *              alert("For he's a jolly good fellow...")
         *          }
         *     });
         *
         *     Ext.define('Musician', {
         *          mixins: ['CanSing']
         *     })
         *
         * In this case the Musician class will get a 'sing' method from CanSing mixin.
         *
         * But what if the Musician already has a 'sing' method? Or you want to mix
         * in two classes, both of which define 'sing'?  In such a cases it's good
         * to define mixins as an object, where you assign a name to each mixin:
         *
         *     Ext.define('Musician', {
         *          mixins: {
         *              canSing: 'CanSing'
         *          },
         *
         *          sing: function() {
         *              // delegate singing operation to mixin
         *              this.mixins.canSing.sing.call(this);
         *          }
         *     })
         *
         * In this case the 'sing' method of Musician will overwrite the
         * mixed in 'sing' method. But you can access the original mixed in method
         * through special 'mixins' property.
         */
        mixins: string|any;

        /**
         * Overrides members of the specified 'target' class.
         *
         * **NOTE:** the overridden class must have been defined using
         * {@link Ext#define Ext.define} in order to use the 'override' config.
         *
         * Methods defined on the overriding class will not automatically call the methods of
         * the same name in the ancestor class chain.  To call the parent's method of the
         * same name you must call {@link Ext.Base#callParent callParent}.  To skip the
         * method of the overridden class and call its parent you will instead call
         * {@link Ext.Base#callSuper callSuper}.
         *
         * See {@link Ext#define Ext.define} for additional usage examples.
         */
        override: string;

        /**
         * Allows setting config values for a class based on specific platforms. The value
         * of this config is an object whose properties are "rules" and whose values are
         * objects containing config values.
         *
         * For example:
         *
         *      Ext.define('App.view.Foo', {
         *          extend: 'Ext.panel.Panel',
         *
         *          platformConfig: {
         *              desktop: {
         *                  title: 'Some Rather Descriptive Title'
         *              },
         *
         *              '!desktop': {
         *                  title: 'Short Title'
         *              }
         *          }
         *      });
         *
         * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
         * evaluates to 'true' will have its configs applied to the class. In this case, only
         * the "title" property, but the object can contain any number of config properties.
         * In this case, the 'platformConfig' is evaluated as part of the class and there is
         * not cost for each instance created.
         *
         * The rules are evaluated expressions in the context of the platform tags contained
         * in '{@link Ext#platformTags Ext.platformTags}'. Any properties of that object are
         * implicitly usable (as shown above).
         *
         * If a 'platformConfig' specifies a config value, it will replace any values declared
         * on the class itself.
         *
         * Use of 'platformConfig' on instances is handled by the config system when classes
         * call '{@link Ext.Base#initConfig initConfig}'. For example:
         *
         *      Ext.create({
         *          xtype: 'panel',
         *
         *          platformConfig: {
         *              desktop: {
         *                  title: 'Some Rather Descriptive Title'
         *              },
         *
         *              '!desktop': {
         *                  title: 'Short Title'
         *              }
         *          }
         *      });
         *
         * The following is equivalent to the above:
         *
         *      if (Ext.platformTags.desktop) {
         *          Ext.create({
         *              xtype: 'panel',
         *              title: 'Some Rather Descriptive Title'
         *          });
         *      } else {
         *          Ext.create({
         *              xtype: 'panel',
         *              title: 'Short Title'
         *          });
         *      }
         *
         * To adjust configs based on dynamic conditions, see '{@link Ext.mixin.Responsive}'.
         */
        platformConfig: any;

        /**
         * The 'privates' config is a list of methods intended to be used internally by the
         * framework.  Methods are placed in a 'privates' block to prevent developers from
         * accidentally overriding framework methods in custom classes.
         *
         *     Ext.define('Computer', {
         *         privates: {
         *             runFactory: function(brand) {
         *                 // internal only processing of brand passed to factory
         *                 this.factory(brand);
         *             }
         *         },
         *
         *         factory: function (brand) {}
         *     });
         *
         * In order to override a method from a 'privates' block, the overridden method must
         * also be placed in a 'privates' block within the override class.
         *
         *     Ext.define('Override.Computer', {
         *         override: 'Computer',
         *         privates: {
         *             runFactory: function() {
         *                 // overriding logic
         *             }
         *         }
         *     });
         */
        privates: any;

        /**
         * List of classes that have to be loaded before instantiating this class.
         * For example:
         *
         *     Ext.define('Mother', {
         *         requires: ['Child'],
         *         giveBirth: function() {
         *             // we can be sure that child class is available.
         *             return new Child();
         *         }
         *     });
         */
        requires: string;

        /**
         * When set to true, the class will be instantiated as singleton.  For example:
         *
         *     Ext.define('Logger', {
         *         singleton: true,
         *         log: function(msg) {
         *             console.log(msg);
         *         }
         *     });
         *
         *     Logger.log('Hello');
         */
        singleton: boolean;

        /**
         * List of static methods for this class. For example:
         *
         *     Ext.define('Computer', {
         *          statics: {
         *              factory: function(brand) {
         *                  // 'this' in static methods refer to the class itself
         *                  return new this(brand);
         *              }
         *          },
         *
         *          constructor: function() { ... }
         *     });
         *
         *     var dellComputer = Computer.factory('Dell');
         */
        statics: any;

        /**
         * List of optional classes to load together with this class. These aren't neccessarily loaded before
         * this class is created, but are guaranteed to be available before Ext.onReady listeners are
         * invoked. For example:
         *
         *     Ext.define('Mother', {
         *         uses: ['Child'],
         *         giveBirth: function() {
         *             // This code might, or might not work:
         *             // return new Child();
         *
         *             // Instead use Ext.create() to load the class at the spot if not loaded already:
         *             return Ext.create('Child');
         *         }
         *     });
         */
        uses: string;

        xtype: any;

        /**
         * Create a new anonymous class.
         *
         * @param {Object} data An object represent the properties of this class
         * @param {Function} onCreated Optional, the callback function to be executed when this class is fully created.
         * Note that the creation process can be asynchronous depending on the pre-processors used.
         *
         * @return {Ext.Base} The newly created class
         */
        constructor(data: any, onCreated: Function);
    }

    /**
     * Ext.ClassManager manages all classes and handles mapping from string class name to
     * actual class objects throughout the whole framework. It is not generally accessed directly, rather through
     * these convenient shorthands:
     *
     * - {@link Ext#define Ext.define}
     * - {@link Ext#create Ext.create}
     * - {@link Ext#widget Ext.widget}
     * - {@link Ext#getClass Ext.getClass}
     * - {@link Ext#getClassName Ext.getClassName}
     *
     * # Basic syntax:
     *
     *     Ext.define(className, properties);
     *
     * in which 'properties' is an object represent a collection of properties that apply to the class. See
     * {@link Ext.ClassManager#create} for more detailed instructions.
     *
     *     Ext.define('Person', {
     *          name: 'Unknown',
     *
     *          constructor: function(name) {
     *              if (name) {
     *                  this.name = name;
     *              }
     *          },
     *
     *          eat: function(foodType) {
     *              alert("I'm eating: " + foodType);
     *
     *              return this;
     *          }
     *     });
     *
     *     var aaron = new Person("Aaron");
     *     aaron.eat("Sandwich"); // alert("I'm eating: Sandwich");
     *
     * Ext.Class has a powerful set of extensible {@link Ext.Class#registerPreprocessor pre-processors} which takes care of
     * everything related to class creation, including but not limited to inheritance, mixins, configuration, statics, etc.
     *
     * # Inheritance:
     *
     *     Ext.define('Developer', {
     *          extend: 'Person',
     *
     *          constructor: function(name, isGeek) {
     *              this.isGeek = isGeek;
     *
     *              // Apply a method from the parent class' prototype
     *              this.callParent([name]);
     *          },
     *
     *          code: function(language) {
     *              alert("I'm coding in: " + language);
     *
     *              this.eat("Bugs");
     *
     *              return this;
     *          }
     *     });
     *
     *     var jacky = new Developer("Jacky", true);
     *     jacky.code("JavaScript"); // alert("I'm coding in: JavaScript");
     *                               // alert("I'm eating: Bugs");
     *
     * See {@link Ext.Base#callParent} for more details on calling superclass' methods
     *
     * # Mixins:
     *
     *     Ext.define('CanPlayGuitar', {
     *          playGuitar: function() {
     *             alert("F#...G...D...A");
     *          }
     *     });
     *
     *     Ext.define('CanComposeSongs', {
     *          composeSongs: function() { ... }
     *     });
     *
     *     Ext.define('CanSing', {
     *          sing: function() {
     *              alert("For he's a jolly good fellow...")
     *          }
     *     });
     *
     *     Ext.define('Musician', {
     *          extend: 'Person',
     *
     *          mixins: {
     *              canPlayGuitar: 'CanPlayGuitar',
     *              canComposeSongs: 'CanComposeSongs',
     *              canSing: 'CanSing'
     *          }
     *     })
     *
     *     Ext.define('CoolPerson', {
     *          extend: 'Person',
     *
     *          mixins: {
     *              canPlayGuitar: 'CanPlayGuitar',
     *              canSing: 'CanSing'
     *          },
     *
     *          sing: function() {
     *              alert("Ahem....");
     *
     *              this.mixins.canSing.sing.call(this);
     *
     *              alert("[Playing guitar at the same time...]");
     *
     *              this.playGuitar();
     *          }
     *     });
     *
     *     var me = new CoolPerson("Jacky");
     *
     *     me.sing(); // alert("Ahem...");
     *                // alert("For he's a jolly good fellow...");
     *                // alert("[Playing guitar at the same time...]");
     *                // alert("F#...G...D...A");
     *
     * # Config:
     *
     *     Ext.define('SmartPhone', {
     *          config: {
     *              hasTouchScreen: false,
     *              operatingSystem: 'Other',
     *              price: 500
     *          },
     *
     *          isExpensive: false,
     *
     *          constructor: function(config) {
     *              this.initConfig(config);
     *          },
     *
     *          applyPrice: function(price) {
     *              this.isExpensive = (price > 500);
     *
     *              return price;
     *          },
     *
     *          applyOperatingSystem: function(operatingSystem) {
     *              if (!(/^(iOS|Android|BlackBerry)$/i).test(operatingSystem)) {
     *                  return 'Other';
     *              }
     *
     *              return operatingSystem;
     *          }
     *     });
     *
     *     var iPhone = new SmartPhone({
     *          hasTouchScreen: true,
     *          operatingSystem: 'iOS'
     *     });
     *
     *     iPhone.getPrice(); // 500;
     *     iPhone.getOperatingSystem(); // 'iOS'
     *     iPhone.getHasTouchScreen(); // true;
     *
     *     iPhone.isExpensive; // false;
     *     iPhone.setPrice(600);
     *     iPhone.getPrice(); // 600
     *     iPhone.isExpensive; // true;
     *
     *     iPhone.setOperatingSystem('AlienOS');
     *     iPhone.getOperatingSystem(); // 'Other'
     *
     * # Statics:
     *
     *     Ext.define('Computer', {
     *          statics: {
     *              factory: function(brand) {
     *                 // 'this' in static methods refer to the class itself
     *                  return new this(brand);
     *              }
     *          },
     *
     *          constructor: function() { ... }
     *     });
     *
     *     var dellComputer = Computer.factory('Dell');
     *
     * Also see {@link Ext.Base#statics} and {@link Ext.Base#self} for more details on accessing
     * static properties within class methods
     */
    export class ClassManager {
        /**
         * A collection of diagnostic methods to decorate the real methods of the class. These
         * methods are applied as an 'override' if this class has debug enabled as defined by
         * 'Ext.isDebugEnabled'.
         *
         * These will be automatically removed by the Sencha Cmd compiler for production builds.
         *
         * Example usage:
         *
         *      Ext.define('Foo.bar.Class', {
         *          foo: function (a, b, c) {
         *              ...
         *          },
         *
         *          bar: function (a, b) {
         *              ...
         *              return 42;
         *          },
         *
         *          debugHooks: {
         *              foo: function (a, b, c) {
         *                  // check arguments...
         *                  return this.callParent(arguments);
         *              }
         *          }
         *      });
         *
         * If you specify a '$enabled' property in the 'debugHooks' object that will be used
         * as the default enabled state for the hooks. If the '{@link Ext#manifest}' contains
         * a 'debug' object of if '{@link Ext#debugConfig}' is specified, the '$enabled' flag
         * will override its "*" value.
         */
        static debugHooks: any;

        /**
         * The object given has properties that describe the versions at which the deprecations
         * apply.
         *
         * The purpose of the 'deprecated' declaration is to enable development mode to give
         * suitable error messages when deprecated methods or properties are used. Methods can
         * always be injected to provide this feedback, but properties can only be handled on
         * some browsers (those that support 'Object.defineProperty').
         *
         * In some cases, deprecated methods can be restored to their previous behavior or
         * added back if they have been removed.
         *
         * The structure of a 'deprecated' declaration is this:
         *
         *      Ext.define('Foo.bar.Class', {
         *          ...
         *
         *          deprecated: {
         *              // Optional package name - default is the framework (ext or touch)
         *              name: 'foobar',
         *
         *              '5.0': {
         *                  methods: {
         *                      // Throws: '"removedMethod" is deprecated.'
         *                      removedMethod: null,
         *
         *                      // Throws: '"oldMethod" is deprecated. Please use "newMethod" instead.'
         *                      oldMethod: 'newMethod',
         *
         *                      // When this block is enabled, this method is applied as an
         *                      // override. Otherwise you get same as "removeMethod".
         *                      method: function () {
         *                          // Do what v5 "method" did. If "method" exists in newer
         *                          // versions callParent can call it. If 5.1 has "method"
         *                          // then it would be next in line, otherwise 5.2 and last
         *                          // would be the current class.
         *                      },
         *
         *                      moreHelpful: {
         *                          message: 'Something helpful to do instead.',
         *                          fn: function () {
         *                              // The v5 "moreHelpful" method to use when enabled.
         *                          }
         *                      }
         *                  },
         *                  properties: {
         *                      // Throws: '"removedProp" is deprecated.'
         *                      removedProp: null,
         *
         *                      // Throws: '"oldProp" is deprecated. Please use "newProp" instead.'
         *                      oldProp: 'newProp',
         *
         *                      helpful: {
         *                          message: 'Something helpful message about what to do.'
         *                      }
         *                      ...
         *                  },
         *                  statics: {
         *                      methods: {
         *                          ...
         *                      },
         *                      properties: {
         *                          ...
         *                      },
         *                  }
         *              },
         *
         *              '5.1': {
         *                  ...
         *              },
         *
         *              '5.2': {
         *                  ...
         *              }
         *          }
         *      });
         *
         * The primary content of 'deprecated' are the version number keys. These indicate
         * a version number where methods or properties were deprecated. These versions are
         * compared to the version reported by 'Ext.getCompatVersion' to determine the action
         * to take for each "block".
         *
         * When the compatibility version is set to a value less than a version number key,
         * that block is said to be "enabled". For example, if a method was deprecated in
         * version 5.0 but the desired compatibility level is 4.2 then the block is used to
         * patch methods and (to some degree) restore pre-5.0 compatibility.
         *
         * When multiple active blocks have the same method name, each method is applied as
         * an override in reverse order of version. In the above example, if a method appears
         * in the "5.0", "5.1" and "5.2" blocks then the "5.2" method is applied as an override
         * first, followed by the "5.1" method and finally the "5.0" method. This means that
         * the 'callParent' from the "5.0" method calls the "5.1" method which calls the
         * "5.2" method which can (if applicable) call the current version.
         */
        static deprecated: any;

        /**
         * Adds a batch of class name to alias mappings.
         * @param {Object} aliases The set of mappings of the form.
         * className : [values...]
         */
        static addNameAliasMappings(aliases: any);

        /**
         * @param {Object} alternates The set of mappings of the form
         * className : [values...]
         */
        static addNameAlternateMappings(alternates: any);

        /**
         * Retrieve a class by its name.
         *
         * @return {Ext.Class} class
         */
        static get(name: string): Ext.Class;

        /**
         * Get a reference to the class by its alias.
         *
         * @return {Ext.Class} class
         */
        static getByAlias(alias: string): Ext.Class;

        /**
         * Get the class of the provided object; returns null if it's not an instance
         * of any class created with Ext.define. This is usually invoked by the
         * shorthand {@link Ext#getClass}.
         *
         *     var component = new Ext.Component();
         *
         *     Ext.getClass(component); // returns Ext.Component
         *
         * @return {Ext.Class} class
         */
        static getClass(object: any): Ext.Class;

        /**
         * Returns the displayName property or className or object. When all else fails, returns "Anonymous".
         * @return {String}
         */
        static getDisplayName(object: any): string;

        /**
         * Get the name of the class by its reference or its instance. This is
         * usually invoked by the shorthand {@link Ext#getClassName}.
         *
         *     Ext.ClassManager.getName(Ext.Action); // returns "Ext.Action"
         *
         * @return {String} className
         */
        static getName(object: Ext.Class|any): string;

        /**
         * Instantiate a class by either full name, alias or alternate name
         * @param {Mixed} args Additional arguments after the name will be passed to the class' constructor.
         * @return {Object} instance
         * @deprecated 5.0 Use Ext.create() instead.
         */
        static instantiate(name: string, args: any): any;

        /**
         * Instantiate a class by its alias. This is usually invoked by the
         * shorthand {@link Ext#createByAlias}.
         *
         * If {@link Ext.Loader} is {@link Ext.Loader#setConfig enabled} and the class
         * has not been defined yet, it will attempt to load the class via synchronous
         * loading.
         *
         *     var window = Ext.createByAlias('widget.window', { width: 600, height: 800 });
         *
         * @param {Object...} args Additional arguments after the alias will be passed to the
         * class constructor.
         * @return {Object} instance
         */
        static instantiateByAlias(alias: string, args: any): any;

        /**
         * Checks if a class has already been created.
         *
         * @return {Boolean} exist
         */
        static isCreated(className: string): boolean;

        /**
         * Sets a name reference to a class.
         *
         * @return {Ext.ClassManager} this
         */
        static set(name: string, value: any): Ext.ClassManager;

        /**
         * Creates a namespace and assign the 'value' to the created object.
         *
         *     Ext.ClassManager.setNamespace('MyCompany.pkg.Example', someObject);
         *
         *     alert(MyCompany.pkg.Example === someObject); // alerts true
         */
        static setNamespace(name: string, value: any);
    }

    interface ComponentConfig extends Ext.WidgetConfig {
        /**
         * The base CSS class to apply to this component's element. This will also be prepended to
         * other elements within this component. To add specific styling for sub-classes, use the {@link #cls} config.
         */
        baseCls?: string;

        /**
         * Enables or disables bordering on this component.
         * The following values are accepted:
         *
         * - 'null' or 'true (default): Do nothing and allow the border to be specified by the theme.
         * - 'false': suppress the default border provided by the theme.
         *
         * Please note that enabling bordering via this config will not add a 'border-color'
         * or 'border-style' CSS property to the component; you provide the 'border-color'
         * and 'border-style' via CSS rule or {@link #style} configuration
         * (if not already provide by the theme).
         *
         * ## Using {@link #style}:
         *
         *     Ext.Viewport.add({
         *         centered: true,
         *         width: 100,
         *         height: 100,
         *
         *         style: 'border: 1px solid blue;'
         *         // ...
         *     });
         *
         * ## Using CSS:
         *
         *     Ext.Viewport.add({
         *         centered: true,
         *         width: 100,
         *         height: 100,
         *
         *         cls: 'my-component'
         *         // ...
         *     });
         *
         * And your CSS file:
         *
         *     .my-component {
         *         border: 1px solid red;
         *     }
         */
        border?: boolean;

        /**
         * The absolute bottom position of this Component; must be a valid CSS length value, e.g: '300', '100px', '30%', etc.
         * Explicitly setting this value will make this Component become 'floating', which means its layout will no
         * longer be affected by the Container that it resides in.
         */
        bottom?: number|string;

        /**
         * Whether or not this Component is absolutely centered inside its Container
         */
        centered?: boolean;

        /**
         * The CSS class to add to this component's element, in
         * addition to the {@link #baseCls}. In many cases, this property will be specified
         * by the derived component class. See {@link #userCls} for adding additional CSS
         * classes to component instances (such as items in a {@link Ext.Container}).
         */
        cls?: string;

        /**
         * The configured element will automatically be
         * added as the content of this component. When you pass a string, we expect it to be an element id.
         * If the content element is hidden, we will automatically show it.
         */
        contentEl?: Ext.dom.Element|HTMLElement|string;

        /**
         * The initial set of data to apply to the '{@link #tpl}' to
         * update the content area of the Component.
         */
        data?: any;

        /**
         * Whether or not this component is disabled
         */
        disabled?: boolean;

        /**
         * The CSS class to add to the component when it is disabled
         *
         * Optional, Defaults to: "x-item-disabled"
         */
        disabledCls?: string;

        /**
         * The dock position of this component in its container. Can be 'left', 'top', 'right' or 'bottom'.
         *
         * __Notes__
         *
         * You must use a HTML5 doctype for {@link #docked} 'bottom' to work. To do this, simply add the following code to the HTML file:
         *
         *     <!doctype html>
         *
         * So your index.html file should look a little like this:
         *
         *     <!doctype html>
         *     <html>
         *         <head>
         *             <title>MY application title</title>
         *             ...
         */
        docked?: string;

        /**
         * Configuration options to make this Component draggable
         */
        draggable?: any;

        /**
         * Animation effect to apply when the Component is being shown.  Typically you want to use an
         * inbound animation type such as 'fadeIn' or 'slideIn'.
         * @deprecated 2.0.0 Please use {@link #showAnimation} instead.
         */
        enterAnimation?: string|any;

        /**
         * Animation effect to apply when the Component is being hidden.
         * @deprecated 2.0.0 Please use {@link #hideAnimation} instead.  Typically you want to use an
         * outbound animation type such as 'fadeOut' or 'slideOut'.
         */
        exitAnimation?: string|any;

        /**
         * The CSS class to add to this component when it is floatable.
         *
         * Optional, Defaults to: "x-floating"
         */
        floatingCls?: string;

        /**
         * Force the component to take up 100% width and height available, by adding it
         * to {@link Ext.Viewport}.
         */
        fullscreen?: boolean;

        /**
         * Whether or not this Component is hidden (its CSS 'display' property is set to 'none')
         */
        hidden?: boolean;

        /**
         * The CSS class to add to the component when it is hidden
         *
         * Optional, Defaults to: "x-item-hidden"
         */
        hiddenCls?: string;

        /**
         * Animation effect to apply when the Component is being hidden.  Typically you want to use an
         * outbound animation type such as 'fadeOut' or 'slideOut'. For more animations, check the {@link Ext.fx.Animation#type} config.
         */
        hideAnimation?: string|any;

        /**
         * Optional HTML content to render inside this Component, or a reference
         * to an existing element on the page.
         */
        html?: string|Ext.dom.Element|HTMLElement;

        /**
         * The absolute left position of this Component; must be a valid CSS length value, e.g: '300', '100px', '30%', etc.
         * Explicitly setting this value will make this Component become 'floating', which means its layout will no
         * longer be affected by the Container that it resides in.
         */
        left?: number|string;

        /**
         * The margin to use on this Component. Can be specified as a number (in which case
         * all edges get the same margin) or a CSS string like '5 10 10 10'
         */
        margin?: number|string;

        /**
         * The maximum height of this Component; must be a valid CSS length value, e.g: '300', '100px', '30%', etc.
         * If set to 'auto', it will set the width to 'null' meaning it will have its own natural size.
         * Note that this config will not apply if the Component is 'floating' (absolutely positioned or centered)
         */
        maxHeight?: number|string;

        /**
         * The maximum width of this Component; must be a valid CSS length value, e.g: '300', '100px', '30%', etc.
         * If set to 'auto', it will set the width to 'null' meaning it will have its own natural size.
         * Note that this config will not apply if the Component is 'floating' (absolutely positioned or centered)
         */
        maxWidth?: number|string;

        /**
         * The minimum height of this Component; must be a valid CSS length value, e.g: '300', '100px', '30%', etc.
         * If set to 'auto', it will set the width to 'null' meaning it will have its own natural size.
         */
        minHeight?: number|string;

        /**
         * The minimum width of this Component; must be a valid CSS length value, e.g: '300', '100px', '30%', etc.
         * If set to 'auto', it will set the width to 'null' meaning it will have its own natural size.
         */
        minWidth?: number|string;

        /**
         * The padding to use on this Component. Can be specified as a number (in which
         * case all edges get the same padding) or a CSS string like '5 10 10 10'
         */
        padding?: number|string;

        /**
         * An object or array of objects that will provide custom functionality for this component.  The only
         * requirement for a valid plugin is that it contain an init method that accepts a reference of type Ext.Component.
         *
         * When a component is created, if any plugins are available, the component will call the init method on each
         * plugin, passing a reference to itself.  Each plugin can then call methods or respond to events on the
         * component as needed to provide its functionality.
         *
         * For examples of plugins, see Ext.plugin.PullRefresh and Ext.plugin.ListPaging
         *
         * ## Example code
         *
         * A plugin by alias:
         *
         *     Ext.create('Ext.dataview.List', {
         *         config: {
         *             plugins: 'listpaging',
         *             itemTpl: '<div class="item">{title}</div>',
         *             store: 'Items'
         *         }
         *     });
         *
         * Multiple plugins by alias:
         *
         *     Ext.create('Ext.dataview.List', {
         *         config: {
         *             plugins: ['listpaging', 'pullrefresh'],
         *             itemTpl: '<div class="item">{title}</div>',
         *             store: 'Items'
         *         }
         *     });
         *
         * Single plugin by class name with config options:
         *
         *     Ext.create('Ext.dataview.List', {
         *         config: {
         *             plugins: {
         *                 xclass: 'Ext.plugin.ListPaging', // Reference plugin by class
         *                 autoPaging: true
         *             },
         *
         *             itemTpl: '<div class="item">{title}</div>',
         *             store: 'Items'
         *         }
         *     });
         *
         * Multiple plugins by class name with config options:
         *
         *     Ext.create('Ext.dataview.List', {
         *         config: {
         *             plugins: [
         *                 {
         *                     xclass: 'Ext.plugin.PullRefresh',
         *                     pullRefreshText: 'Pull to refresh...'
         *                 },
         *                 {
         *                     xclass: 'Ext.plugin.ListPaging',
         *                     autoPaging: true
         *                 }
         *             ],
         *
         *             itemTpl: '<div class="item">{title}</div>',
         *             store: 'Items'
         *         }
         *     });
         */
        plugins?: any|any[];

        /**
         * A model instance which updates the Component's html based on it's tpl. Similar to the data
         * configuration, but tied to to a record to make allow dynamic updates.  This must be a model
         * instance and not a configuration of one.
         */
        record?: Ext.data.Model;

        /**
         * Optional element to render this Component to. Usually this is not needed because
         * a Component is normally full screen or automatically rendered inside another {@link Ext.Container Container}
         */
        renderTo?: Ext.dom.Element;

        /**
         * The absolute right position of this Component; must be a valid CSS length value, e.g: '300', '100px', '30%', etc.
         * Explicitly setting this value will make this Component become 'floating', which means its layout will no
         * longer be affected by the Container that it resides in.
         */
        right?: number|string;

        /**
         * Configuration options to make this Component scrollable. Acceptable values are:
         *
         * - 'true' to enable auto scrolling.
         * - 'false' (or 'null') to disable scrolling - this is the default.
         * - 'x' or 'horizontal' to enable horizontal scrolling only
         * - 'y' or 'vertical' to enable vertical scrolling only
         *
         * Also accepts a configuration object for a '{@link Ext.scroll.Scroller}' if
         * if advanced configuration is needed.
         *
         * The getter for this config returns the {@link Ext.scroll.Scroller Scroller}
         * instance.  You can use the Scroller API to read or manipulate the scroll position:
         *
         *     // scrolls the component to 5 on the x axis and 10 on the y axis
         *     component.getScrollable().scrollTo(5, 10);
         */
        scrollable?: boolean|string|any;

        /**
         * Animation effect to apply when the Component is being shown.  Typically you want to use an
         * inbound animation type such as 'fadeIn' or 'slideIn'. For more animations, check the {@link Ext.fx.Animation#type} config.
         */
        showAnimation?: string|any;

        /**
         * The class that is added to the content target when you set 'styleHtmlContent' to 'true'.
         *
         * Optional, Defaults to: "x-html"
         */
        styleHtmlCls?: string;

        /**
         * 'true' to automatically style the HTML inside the content target of this component (body for panels).
         *
         * Optional, Defaults to: false
         */
        styleHtmlContent?: boolean;

        /**
         * The absolute top position of this Component; must be a valid CSS length value, e.g: '300', '100px', '30%', etc.
         * Explicitly setting this value will make this Component become 'floating', which means its layout will no
         * longer be affected by the Container that it resides in.
         */
        top?: number|string;

        /**
         * A {@link String}, {@link Ext.Template}, {@link Ext.XTemplate} or an {@link Array} of strings to form an {@link Ext.XTemplate}.
         * Used in conjunction with the {@link #data} and {@link #tplWriteMode} configurations.
         *
         * __Note__
         * The {@link #data} configuration _must_ be set for any content to be shown in the component when using this configuration.
         */
        tpl?: string|Ext.Template|Ext.XTemplate;

        /**
         * The Ext.(X)Template method to use when
         * updating the content area of the Component.
         * Valid modes are:
         *
         * - append
         * - insertAfter
         * - insertBefore
         * - insertFirst
         * - overwrite
         */
        tplWriteMode?: string;

        /**
         * The ui to be used on this Component
         */
        ui?: string;

        /**
         * The 'xtype' configuration option can be used to optimize Component creation and rendering. It serves as a
         * shortcut to the full component name. For example, the component 'Ext.button.Button' has an xtype of 'button'.
         *
         * You can define your own xtype on a custom {@link Ext.Component component} by specifying the
         * {@link Ext.Class#alias alias} config option with a prefix of 'widget'. For example:
         *
         *     Ext.define('PressMeButton', {
         *         extend: 'Ext.button.Button',
         *         alias: 'widget.pressmebutton',
         *         text: 'Press Me'
         *     });
         *
         * Any Component can be created implicitly as an object config with an xtype specified, allowing it to be
         * declared and passed into the rendering pipeline without actually being instantiated as an object. Not only is
         * rendering deferred, but the actual creation of the object itself is also deferred, saving memory and resources
         * until they are actually needed. In complex, nested layouts containing many Components, this can make a
         * noticeable improvement in performance.
         *
         *     // Explicit creation of contained Components:
         *     var panel = new Ext.Panel({
         *        // ...
         *        items: [
         *           Ext.create('Ext.button.Button', {
         *              text: 'OK'
         *           })
         *        ]
         *     });
         *
         *     // Implicit creation using xtype:
         *     var panel = new Ext.Panel({
         *        // ...
         *        items: [{
         *           xtype: 'button',
         *           text: 'OK'
         *        }]
         *     });
         *
         * In the first example, the button will always be created immediately during the panel's initialization. With
         * many added Components, this approach could potentially slow the rendering of the page. In the second example,
         * the button will not be created or rendered until the panel is actually displayed in the browser. If the panel
         * is never displayed (for example, if it is a tab that remains hidden) then the button will never be created and
         * will never consume any resources whatsoever.
         */
        xtype?: string;

        /**
         * The z-index to give this Component when it is rendered
         */
        zIndex?: number;
    }

    /**
     * Most of the visual classes you interact with are Components. Every Component is a
     * subclass of Ext.Component, which means they can all:
     *
     * * Render themselves onto the page using a template
     * * Show and hide themselves at any time
     * * Center themselves on the screen
     * * Enable and disable themselves
     *
     * They can also do a few more advanced things:
     *
     * * Float above other components (windows, message boxes and overlays)
     * * Change size and position on the screen with animation
     * * Dock other Components inside themselves (useful for toolbars)
     * * Align to other components, allow themselves to be dragged around, make their content scrollable & more
     *
     * ## Available Components
     *
     * There are many components.  They are separated into 4 main groups:
     *
     * ### Navigation components
     * * {@link Ext.Toolbar}
     * * {@link Ext.Button}
     * * {@link Ext.TitleBar}
     * * {@link Ext.SegmentedButton}
     * * {@link Ext.Title}
     * * {@link Ext.Spacer}
     *
     * ### Store-bound components
     * * {@link Ext.dataview.DataView}
     * * {@link Ext.Carousel}
     * * {@link Ext.List}
     * * {@link Ext.NestedList}
     *
     * ### Form components
     * * {@link Ext.form.Panel}
     * * {@link Ext.form.FieldSet}
     * * {@link Ext.field.Checkbox}
     * * {@link Ext.field.Hidden}
     * * {@link Ext.field.Slider}
     * * {@link Ext.field.Text}
     * * {@link Ext.picker.Picker}
     * * {@link Ext.picker.Date}
     *
     * ### General components
     * * {@link Ext.Panel}
     * * {@link Ext.tab.Panel}
     * * {@link Ext.Viewport Ext.Viewport}
     * * {@link Ext.Img}
     * * {@link Ext.Map}
     * * {@link Ext.Audio}
     * * {@link Ext.Video}
     * * {@link Ext.Sheet}
     * * {@link Ext.ActionSheet}
     * * {@link Ext.MessageBox}
     *
     *
     * ## Instantiating Components
     *
     * Components are created the same way as all other classes - using Ext.create. Here's how we can
     * create a Text field:
     *
     *     var panel = Ext.create('Ext.Panel', {
     *         html: 'This is my panel'
     *     });
     *
     * This will create a {@link Ext.Panel Panel} instance, configured with some basic HTML content. A Panel is just a
     * simple Component that can render HTML and also contain other items. In this case we've created a Panel instance but
     * it won't show up on the screen yet because items are not rendered immediately after being instantiated. This allows
     * us to create some components and move them around before rendering and laying them out, which is a good deal faster
     * than moving them after rendering.
     *
     * To show this panel on the screen now we can simply add it to the global Viewport:
     *
     *     Ext.Viewport.add(panel);
     *
     * Panels are also Containers, which means they can contain other Components, arranged by a layout. Let's revisit the
     * above example now, this time creating a panel with two child Components and a hbox layout:
     *
     *     @example
     *     var panel = Ext.create('Ext.Panel', {
     *         layout: 'hbox',
     *
     *         items: [
     *             {
     *                 xtype: 'panel',
     *                 flex: 1,
     *                 html: 'Left Panel, 1/3rd of total size',
     *                  style: 'background-color: #5E99CC;'
     *             },
     *             {
     *                 xtype: 'panel',
     *                 flex: 2,
     *                 html: 'Right Panel, 2/3rds of total size',
     *                  style: 'background-color: #759E60;'
     *             }
     *         ]
     *     });
     *
     *     Ext.Viewport.add(panel);
     *
     * This time we created 3 Panels - the first one is created just as before but the inner two are declared inline using
     * an xtype. Xtype is a convenient way of creating Components without having to go through the process of using
     * Ext.create and specifying the full class name, instead you can just provide the xtype for the class inside an object
     * and the framework will create the components for you.
     *
     * We also specified a layout for the top level panel - in this case hbox, which splits the horizontal width of the
     * parent panel based on the 'flex' of each child. For example, if the parent Panel above is 300px wide then the first
     * child will be flexed to 100px wide and the second to 200px because the first one was given 'flex: 1' and the second
     * 'flex: 2'.
     *
     * ## Using xtype
     *
     * xtype is an easy way to create Components without using the full class name. This is especially useful when creating
     * a {@link Ext.Container Container} that contains child Components. An xtype is simply a shorthand way of specifying a
     * Component - for example you can use 'xtype: 'panel'' instead of typing out Ext.panel.Panel.
     *
     * Sample usage:
     *
     *     @example miniphone
     *     Ext.create('Ext.Container', {
     *         fullscreen: true,
     *         layout: 'fit',
     *
     *         items: [
     *             {
     *                 xtype: 'panel',
     *                 html: 'This panel is created by xtype'
     *             },
     *             {
     *                 xtype: 'toolbar',
     *                 title: 'So is the toolbar',
     *                 docked: 'top'
     *             }
     *         ]
     *     });
     *
     *
     * ### Common xtypes
     *
     * <pre>
     xtype                   Class
     -----------------       ---------------------
     actionsheet             Ext.ActionSheet
     audio                   Ext.Audio
     button                  Ext.Button
     image                   Ext.Img
     label                   Ext.Label
     loadmask                Ext.LoadMask
     map                     Ext.Map
     panel                   Ext.Panel
     segmentedbutton         Ext.SegmentedButton
     sheet                   Ext.Sheet
     spacer                  Ext.Spacer
     titlebar                Ext.TitleBar
     toolbar                 Ext.Toolbar
     video                   Ext.Video
     carousel                Ext.carousel.Carousel
     navigationview          Ext.navigation.View
     datepicker              Ext.picker.Date
     picker                  Ext.picker.Picker
     slider                  Ext.slider.Slider
     thumb                   Ext.slider.Thumb
     tabpanel                Ext.tab.Panel
     viewport                Ext.viewport.Default
     DataView Components
     ---------------------------------------------
     dataview                Ext.dataview.DataView
     list                    Ext.dataview.List
     nestedlist              Ext.dataview.NestedList
     Form Components
     ---------------------------------------------
     checkboxfield           Ext.field.Checkbox
     datepickerfield         Ext.field.DatePicker
     emailfield              Ext.field.Email
     hiddenfield             Ext.field.Hidden
     numberfield             Ext.field.Number
     passwordfield           Ext.field.Password
     radiofield              Ext.field.Radio
     searchfield             Ext.field.Search
     selectfield             Ext.field.Select
     sliderfield             Ext.field.Slider
     spinnerfield            Ext.field.Spinner
     textfield               Ext.field.Text
     textareafield           Ext.field.TextArea
     togglefield             Ext.field.Toggle
     urlfield                Ext.field.Url
     fieldset                Ext.form.FieldSet
     formpanel               Ext.form.Panel
     * </pre>
     *
     * ## Configuring Components
     *
     * Whenever you create a new Component you can pass in configuration options. All of the configurations for a given
     * Component are listed in the "Config options" section of its class docs page. You can pass in any number of
     * configuration options when you instantiate the Component, and modify any of them at any point later. For example, we
     * can easily modify the {@link Ext.Panel#html html content} of a Panel after creating it:
     *
     *     @example miniphone
     *     // we can configure the HTML when we instantiate the Component
     *     var panel = Ext.create('Ext.Panel', {
     *         fullscreen: true,
     *         html: 'This is a Panel'
     *     });
     *
     *     // we can update the HTML later using the setHtml method:
     *     panel.setHtml('Some new HTML');
     *
     *     // we can retrieve the current HTML using the getHtml method:
     *     Ext.Msg.alert(panel.getHtml()); // displays "Some new HTML"
     *
     * Every config has a getter method and a setter method - these are automatically generated and always follow the same
     * pattern. For example, a config called 'html' will receive 'getHtml' and 'setHtml' methods, a config called 'defaultType'
     * will receive 'getDefaultType' and 'setDefaultType' methods, and so on.
     */
    export class Component extends Ext.Widget implements Ext.ComponentConfig {
        defaultBindProperty: any;

        protected element: any;

        /**
         * The base CSS class to apply to this component's element. This will also be prepended to
         * other elements within this component. To add specific styling for sub-classes, use the {@link #cls} config.
         */
        baseCls: string;

        /**
         * Enables or disables bordering on this component.
         * The following values are accepted:
         *
         * - 'null' or 'true (default): Do nothing and allow the border to be specified by the theme.
         * - 'false': suppress the default border provided by the theme.
         *
         * Please note that enabling bordering via this config will not add a 'border-color'
         * or 'border-style' CSS property to the component; you provide the 'border-color'
         * and 'border-style' via CSS rule or {@link #style} configuration
         * (if not already provide by the theme).
         *
         * ## Using {@link #style}:
         *
         *     Ext.Viewport.add({
         *         centered: true,
         *         width: 100,
         *         height: 100,
         *
         *         style: 'border: 1px solid blue;'
         *         // ...
         *     });
         *
         * ## Using CSS:
         *
         *     Ext.Viewport.add({
         *         centered: true,
         *         width: 100,
         *         height: 100,
         *
         *         cls: 'my-component'
         *         // ...
         *     });
         *
         * And your CSS file:
         *
         *     .my-component {
         *         border: 1px solid red;
         *     }
         */
        border: boolean;

        /**
         * The absolute bottom position of this Component; must be a valid CSS length value, e.g: '300', '100px', '30%', etc.
         * Explicitly setting this value will make this Component become 'floating', which means its layout will no
         * longer be affected by the Container that it resides in.
         */
        bottom: number|string;

        /**
         * Whether or not this Component is absolutely centered inside its Container
         */
        centered: boolean;

        /**
         * The CSS class to add to this component's element, in
         * addition to the {@link #baseCls}. In many cases, this property will be specified
         * by the derived component class. See {@link #userCls} for adding additional CSS
         * classes to component instances (such as items in a {@link Ext.Container}).
         */
        cls: string;

        /**
         * The configured element will automatically be
         * added as the content of this component. When you pass a string, we expect it to be an element id.
         * If the content element is hidden, we will automatically show it.
         */
        contentEl: Ext.dom.Element|HTMLElement|string;

        /**
         * The initial set of data to apply to the '{@link #tpl}' to
         * update the content area of the Component.
         */
        data: any;

        /**
         * Whether or not this component is disabled
         */
        disabled: boolean;

        /**
         * The CSS class to add to the component when it is disabled
         *
         * Optional, Defaults to: "x-item-disabled"
         */
        disabledCls: string;

        /**
         * The dock position of this component in its container. Can be 'left', 'top', 'right' or 'bottom'.
         *
         * __Notes__
         *
         * You must use a HTML5 doctype for {@link #docked} 'bottom' to work. To do this, simply add the following code to the HTML file:
         *
         *     <!doctype html>
         *
         * So your index.html file should look a little like this:
         *
         *     <!doctype html>
         *     <html>
         *         <head>
         *             <title>MY application title</title>
         *             ...
         */
        docked: string;

        /**
         * Configuration options to make this Component draggable
         */
        draggable: any;

        /**
         * Animation effect to apply when the Component is being shown.  Typically you want to use an
         * inbound animation type such as 'fadeIn' or 'slideIn'.
         * @deprecated 2.0.0 Please use {@link #showAnimation} instead.
         */
        enterAnimation: string|any;

        /**
         * Animation effect to apply when the Component is being hidden.
         * @deprecated 2.0.0 Please use {@link #hideAnimation} instead.  Typically you want to use an
         * outbound animation type such as 'fadeOut' or 'slideOut'.
         */
        exitAnimation: string|any;

        /**
         * The CSS class to add to this component when it is floatable.
         *
         * Optional, Defaults to: "x-floating"
         */
        floatingCls: string;

        /**
         * Force the component to take up 100% width and height available, by adding it
         * to {@link Ext.Viewport}.
         */
        fullscreen: boolean;

        /**
         * Whether or not this Component is hidden (its CSS 'display' property is set to 'none')
         */
        hidden: boolean;

        /**
         * The CSS class to add to the component when it is hidden
         *
         * Optional, Defaults to: "x-item-hidden"
         */
        hiddenCls: string;

        /**
         * Animation effect to apply when the Component is being hidden.  Typically you want to use an
         * outbound animation type such as 'fadeOut' or 'slideOut'. For more animations, check the {@link Ext.fx.Animation#type} config.
         */
        hideAnimation: string|any;

        /**
         * Optional HTML content to render inside this Component, or a reference
         * to an existing element on the page.
         */
        html: string|Ext.dom.Element|HTMLElement;

        /**
         * The absolute left position of this Component; must be a valid CSS length value, e.g: '300', '100px', '30%', etc.
         * Explicitly setting this value will make this Component become 'floating', which means its layout will no
         * longer be affected by the Container that it resides in.
         */
        left: number|string;

        /**
         * The margin to use on this Component. Can be specified as a number (in which case
         * all edges get the same margin) or a CSS string like '5 10 10 10'
         */
        margin: number|string;

        /**
         * The maximum height of this Component; must be a valid CSS length value, e.g: '300', '100px', '30%', etc.
         * If set to 'auto', it will set the width to 'null' meaning it will have its own natural size.
         * Note that this config will not apply if the Component is 'floating' (absolutely positioned or centered)
         */
        maxHeight: number|string;

        /**
         * The maximum width of this Component; must be a valid CSS length value, e.g: '300', '100px', '30%', etc.
         * If set to 'auto', it will set the width to 'null' meaning it will have its own natural size.
         * Note that this config will not apply if the Component is 'floating' (absolutely positioned or centered)
         */
        maxWidth: number|string;

        /**
         * The minimum height of this Component; must be a valid CSS length value, e.g: '300', '100px', '30%', etc.
         * If set to 'auto', it will set the width to 'null' meaning it will have its own natural size.
         */
        minHeight: number|string;

        /**
         * The minimum width of this Component; must be a valid CSS length value, e.g: '300', '100px', '30%', etc.
         * If set to 'auto', it will set the width to 'null' meaning it will have its own natural size.
         */
        minWidth: number|string;

        /**
         * The padding to use on this Component. Can be specified as a number (in which
         * case all edges get the same padding) or a CSS string like '5 10 10 10'
         */
        padding: number|string;

        /**
         * An object or array of objects that will provide custom functionality for this component.  The only
         * requirement for a valid plugin is that it contain an init method that accepts a reference of type Ext.Component.
         *
         * When a component is created, if any plugins are available, the component will call the init method on each
         * plugin, passing a reference to itself.  Each plugin can then call methods or respond to events on the
         * component as needed to provide its functionality.
         *
         * For examples of plugins, see Ext.plugin.PullRefresh and Ext.plugin.ListPaging
         *
         * ## Example code
         *
         * A plugin by alias:
         *
         *     Ext.create('Ext.dataview.List', {
         *         config: {
         *             plugins: 'listpaging',
         *             itemTpl: '<div class="item">{title}</div>',
         *             store: 'Items'
         *         }
         *     });
         *
         * Multiple plugins by alias:
         *
         *     Ext.create('Ext.dataview.List', {
         *         config: {
         *             plugins: ['listpaging', 'pullrefresh'],
         *             itemTpl: '<div class="item">{title}</div>',
         *             store: 'Items'
         *         }
         *     });
         *
         * Single plugin by class name with config options:
         *
         *     Ext.create('Ext.dataview.List', {
         *         config: {
         *             plugins: {
         *                 xclass: 'Ext.plugin.ListPaging', // Reference plugin by class
         *                 autoPaging: true
         *             },
         *
         *             itemTpl: '<div class="item">{title}</div>',
         *             store: 'Items'
         *         }
         *     });
         *
         * Multiple plugins by class name with config options:
         *
         *     Ext.create('Ext.dataview.List', {
         *         config: {
         *             plugins: [
         *                 {
         *                     xclass: 'Ext.plugin.PullRefresh',
         *                     pullRefreshText: 'Pull to refresh...'
         *                 },
         *                 {
         *                     xclass: 'Ext.plugin.ListPaging',
         *                     autoPaging: true
         *                 }
         *             ],
         *
         *             itemTpl: '<div class="item">{title}</div>',
         *             store: 'Items'
         *         }
         *     });
         */
        plugins: any|any[];

        /**
         * A model instance which updates the Component's html based on it's tpl. Similar to the data
         * configuration, but tied to to a record to make allow dynamic updates.  This must be a model
         * instance and not a configuration of one.
         */
        record: Ext.data.Model;

        /**
         * Optional element to render this Component to. Usually this is not needed because
         * a Component is normally full screen or automatically rendered inside another {@link Ext.Container Container}
         */
        renderTo: Ext.dom.Element;

        /**
         * The absolute right position of this Component; must be a valid CSS length value, e.g: '300', '100px', '30%', etc.
         * Explicitly setting this value will make this Component become 'floating', which means its layout will no
         * longer be affected by the Container that it resides in.
         */
        right: number|string;

        /**
         * Configuration options to make this Component scrollable. Acceptable values are:
         *
         * - 'true' to enable auto scrolling.
         * - 'false' (or 'null') to disable scrolling - this is the default.
         * - 'x' or 'horizontal' to enable horizontal scrolling only
         * - 'y' or 'vertical' to enable vertical scrolling only
         *
         * Also accepts a configuration object for a '{@link Ext.scroll.Scroller}' if
         * if advanced configuration is needed.
         *
         * The getter for this config returns the {@link Ext.scroll.Scroller Scroller}
         * instance.  You can use the Scroller API to read or manipulate the scroll position:
         *
         *     // scrolls the component to 5 on the x axis and 10 on the y axis
         *     component.getScrollable().scrollTo(5, 10);
         */
        scrollable: boolean|string|any;

        /**
         * Animation effect to apply when the Component is being shown.  Typically you want to use an
         * inbound animation type such as 'fadeIn' or 'slideIn'. For more animations, check the {@link Ext.fx.Animation#type} config.
         */
        showAnimation: string|any;

        /**
         * The class that is added to the content target when you set 'styleHtmlContent' to 'true'.
         *
         * Optional, Defaults to: "x-html"
         */
        styleHtmlCls: string;

        /**
         * 'true' to automatically style the HTML inside the content target of this component (body for panels).
         *
         * Optional, Defaults to: false
         */
        styleHtmlContent: boolean;

        /**
         * The absolute top position of this Component; must be a valid CSS length value, e.g: '300', '100px', '30%', etc.
         * Explicitly setting this value will make this Component become 'floating', which means its layout will no
         * longer be affected by the Container that it resides in.
         */
        top: number|string;

        /**
         * A {@link String}, {@link Ext.Template}, {@link Ext.XTemplate} or an {@link Array} of strings to form an {@link Ext.XTemplate}.
         * Used in conjunction with the {@link #data} and {@link #tplWriteMode} configurations.
         *
         * __Note__
         * The {@link #data} configuration _must_ be set for any content to be shown in the component when using this configuration.
         */
        tpl: string|Ext.Template|Ext.XTemplate;

        /**
         * The Ext.(X)Template method to use when
         * updating the content area of the Component.
         * Valid modes are:
         *
         * - append
         * - insertAfter
         * - insertBefore
         * - insertFirst
         * - overwrite
         */
        tplWriteMode: string;

        /**
         * The ui to be used on this Component
         */
        ui: string;

        /**
         * The 'xtype' configuration option can be used to optimize Component creation and rendering. It serves as a
         * shortcut to the full component name. For example, the component 'Ext.button.Button' has an xtype of 'button'.
         *
         * You can define your own xtype on a custom {@link Ext.Component component} by specifying the
         * {@link Ext.Class#alias alias} config option with a prefix of 'widget'. For example:
         *
         *     Ext.define('PressMeButton', {
         *         extend: 'Ext.button.Button',
         *         alias: 'widget.pressmebutton',
         *         text: 'Press Me'
         *     });
         *
         * Any Component can be created implicitly as an object config with an xtype specified, allowing it to be
         * declared and passed into the rendering pipeline without actually being instantiated as an object. Not only is
         * rendering deferred, but the actual creation of the object itself is also deferred, saving memory and resources
         * until they are actually needed. In complex, nested layouts containing many Components, this can make a
         * noticeable improvement in performance.
         *
         *     // Explicit creation of contained Components:
         *     var panel = new Ext.Panel({
         *        // ...
         *        items: [
         *           Ext.create('Ext.button.Button', {
         *              text: 'OK'
         *           })
         *        ]
         *     });
         *
         *     // Implicit creation using xtype:
         *     var panel = new Ext.Panel({
         *        // ...
         *        items: [{
         *           xtype: 'button',
         *           text: 'OK'
         *        }]
         *     });
         *
         * In the first example, the button will always be created immediately during the panel's initialization. With
         * many added Components, this approach could potentially slow the rendering of the page. In the second example,
         * the button will not be created or rendered until the panel is actually displayed in the browser. If the panel
         * is never displayed (for example, if it is a tab that remains hidden) then the button will never be created and
         * will never consume any resources whatsoever.
         */
        xtype: string;

        /**
         * The z-index to give this Component when it is rendered
         */
        zIndex: number;

        /**
         * Adds a CSS class (or classes) to this Component's rendered element.
         * @param {String} cls The CSS class to add.
         * @param {String} [prefix=""] Optional prefix to add to each class.
         * @param {String} [suffix=""] Optional suffix to add to each class.
         */
        addCls(cls: string, prefix?: string, suffix?: string);

        /**
         * Creates new Component.
         * @param {Object} config The standard configuration object.
         */
        constructor(config: Ext.ButtonConfig);

        /**
         * Destroys this Component. If it is currently added to a Container it will first be removed from that Container.
         * All Ext.Element references are also deleted and the Component is de-registered from Ext.ComponentManager
         */
        destroy();

        /**
         * Disables this Component
         */
        disable();

        /**
         * Enables this Component
         */
        enable();

        /**
         * Prepares information on aligning this to component using alignment.
         * Also checks to see if this is already aligned to component according to alignment.
         */
        protected getAlignmentInfo();

        getBaseCls();

        getBorder();

        getBottom();

        getCentered();

        getCls();

        getContentEl();

        getData();

        getDisabled();

        getDisabledCls();

        getDocked();

        getEnterAnimation();

        getExitAnimation();

        getFloatingCls();

        getHidden();

        getHiddenCls();

        getHideAnimation();

        getHtml();

        getLeft();

        getMargin();

        getMaxHeight();

        getMaxWidth();

        getMinHeight();

        getMinWidth();

        getPadding();

        getPlugins();

        getRecord();

        getRenderTo();

        getRight();

        getScrollable();

        getShowAnimation();

        getStyleHtmlCls();

        getStyleHtmlContent();

        getTop();

        getTpl();

        getTplWriteMode();

        getUi();

        /**
         * Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all
         * available xtypes, see the {@link Ext.Component} header.
         *
         * __Note:__ If using your own subclasses, be aware that a Component must register its own xtype
         * to participate in determination of inherited xtypes.
         *
         * Example usage:
         *
         *     var t = new Ext.field.Text();
         *     alert(t.getXTypes());  // alerts 'component/field/textfield'
         *
         * @return {String} The xtype hierarchy string.
         */
        getXTypes(): string;

        getZIndex();

        /**
         * Hides this Component optionally using an animation.
         * @param {Object/Boolean} [animation] You can specify an animation here or a bool to use the {@link #hideAnimation} config.
         * @return {Ext.Component}
         */
        hide(animation?: any|boolean): Ext.Component;

        protected initElement();

        /**
         * Allows addition of behavior to the rendering phase.
         */
        protected initialize();

        /**
         * Returns 'true' if this Component is currently disabled.
         * @return {Boolean} 'true' if currently disabled.
         */
        isDisabled(): boolean;

        /**
         * Returns 'true' if this Component is currently hidden.
         * @param {Boolean} [deep=false] 'true' to check if this component
         * is hidden because a parent container is hidden.
         * @return {Boolean} 'true' if currently hidden.
         */
        isHidden(deep?: boolean): boolean;

        /**
         * Returns 'true' if this Component is currently visible.
         * @param {Boolean} [deep=false] 'true' to check if this component
         * is visible and all parents are also visible.
         * @return {Boolean} 'true' if currently visible.
         */
        isVisible(deep?: boolean): boolean;

        /**
         * Invoked when a scroll operation is completed via this component's {@link #scrollable scroller}.
         * @param {Number} x The current x position
         * @param {Number} y The current y position
         */
        protected onScrollEnd(x: number, y: number);

        /**
         * Invoked when this component is scrolled via its {@link #scrollable scroller}.
         * @param {Number} x The current x position
         * @param {Number} y The current y position
         */
        protected onScrollMove(x: number, y: number);

        /**
         * Invoked when a scroll is initiated on this component via its {@link #scrollable scroller}.
         * @param {Number} x The current x position
         * @param {Number} y The current y position
         */
        protected onScrollStart(x: number, y: number);

        /**
         * Removes the given CSS class(es) from this Component's rendered element.
         * @param {String} cls The class(es) to remove.
         * @param {String} [prefix=""] Optional prefix to prepend before each class.
         * @param {String} [suffix=""] Optional suffix to append to each class.
         */
        removeCls(cls: string, prefix?: string, suffix?: string);

        /**
         * Replaces specified classes with the newly specified classes.
         * It uses the {@link #addCls} and {@link #removeCls} methods, so if the class(es) you are removing don't exist, it will
         * still add the new classes.
         * @param {String} oldCls The class(es) to remove.
         * @param {String} newCls The class(es) to add.
         * @param {String} [prefix=""] Optional prefix to prepend before each class.
         * @param {String} [suffix=""] Optional suffix to append to each class.
         */
        replaceCls(oldCls: string, newCls: string, prefix?: string, suffix?: string);

        /**
         * Resets {@link #top}, {@link #right}, {@link #bottom} and {@link #left} configurations to 'null', which
         * will un-float this component.
         */
        resetFloating();

        setBaseCls();

        setBorder();

        setBottom();

        setCentered();

        setCls();

        setContentEl();

        setData();

        setDisabled();

        setDisabledCls();

        setDocked();

        setDraggable();

        setEnterAnimation();

        setExitAnimation();

        setFloatingCls();

        setHidden();

        setHiddenCls();

        setHideAnimation();

        setHtml();

        setLeft();

        setMargin();

        setMaxHeight();

        setMaxWidth();

        setMinHeight();

        setMinWidth();

        setPadding();

        setPlugins();

        setRecord();

        setRenderTo();

        setRight();

        setScrollable();

        setShowAnimation();

        setStyleHtmlCls();

        setStyleHtmlContent();

        setTop();

        setTpl();

        setTplWriteMode();

        setUi();

        setZIndex();

        /**
         * Shows this component optionally using an animation.
         * @param {Object/Boolean} [animation] You can specify an animation here or a bool to use the {@link #showAnimation} config.
         * @return {Ext.Component}
         */
        show(animation?: any|boolean): Ext.Component;

        /**
         * Shows this component by another component. If you specify no alignment, it will automatically
         * position this component relative to the reference component.
         *
         * For example, say we are aligning a Panel next to a Button, the alignment string would look like this:
         *
         *     [panel-vertical (t/b/c)][panel-horizontal (l/r/c)]-[button-vertical (t/b/c)][button-horizontal (l/r/c)]
         *
         * where t = top, b = bottom, c = center, l = left, r = right.
         *
         * ## Examples
         *
         *  - 'tl-tr' means top-left corner of the Panel to the top-right corner of the Button
         *  - 'tc-bc' means top-center of the Panel to the bottom-center of the Button
         *
         * You can put a '?' at the end of the alignment string to constrain the floating element to the
         * {@link Ext.Viewport Viewport}
         *
         *     // show 'panel' by 'button' using the default positioning (auto fit)
         *     panel.showBy(button);
         *
         *     // align the top left corner of 'panel' with the top right corner of 'button' (constrained to viewport)
         *     panel.showBy(button, "tl-tr?");
         *
         *     // align the bottom right corner of 'panel' with the center left edge of 'button' (not constrained by viewport)
         *     panel.showBy(button, "br-cl");
         *
         * @param {Ext.Component} component The target component to show this component by.
         * @param {String} alignment (optional) The specific alignment.
         */
        showBy(component: Ext.Component, alignment: string);

        /**
         * Add or removes a class based on if the class is already added to the Component.
         *
         * @param {String} className The class to toggle.
         * @param {Boolean} [state] If specified as 'true', causes the class to be added. If specified as 'false', causes
         * the class to be removed.
         */
        toggleCls(className: string, state?: boolean);

        /**
         * Walks up the 'ownerCt' axis looking for an ancestor Container which matches
         * the passed simple selector.
         *
         * Example:
         *
         *     var owningTabPanel = grid.up('tabpanel');
         *
         * @param {String} selector (optional) The simple selector to test.
         * @return {Ext.Container} The matching ancestor Container (or 'undefined' if no match was found).
         */
        up(selector: string): Ext.Container;

        /**
         * Updates the {@link #styleHtmlCls} configuration
         */
        updateStyleHtmlCls();

        /**
         * Fires after a Component had been added to a Container.
         * @param {Ext.Container} container Parent Container
         * @param {Number} index The index of the item within the Container.
         */
        added(that: Ext.Component, container: Ext.Container, index: number);

        /**
         * Fires before orientation changes.
         * @removed 2.0.0 This event is now only available 'onBefore' the Viewport's {@link Ext.Viewport#orientationchange}
         */
        beforeorientationchange();

        bottomchange();

        centeredchange();

        disabledchange();

        dockedchange();

        /**
         * Fires when the component is no longer displayed in the DOM.  Listening to this event will
         * degrade performance not recommend for general use.
         * @param {Ext.Component} this The component instance
         */
        erased(that: Ext.Component);

        /**
         * Fires whenever there is a change in the floating status of a component
         * @param {Ext.Component} this The component instance
         * @param {Boolean} floating The component's new floating state
         */
        floatingchange(that: Ext.Component, floating: boolean);

        hiddenchange();

        leftchange();

        maxheightchange();

        maxwidthchange();

        minheightchange();

        minwidthchange();

        /**
         * Fires when a component si moved within its Container.
         * @param {Ext.Container} container Container which holds the component
         * @param {Number} toIndex The new index of the item.
         * @param {Number} fromIndex The old index of the item.
         */
        moved(that: Ext.Component, container: Ext.Container, toIndex: number, fromIndex: number);

        /**
         * Fires when orientation changes.
         * @removed 2.0.0 This event is now only available on the Viewport's {@link Ext.Viewport#orientationchange}
         */
        orientationchange();

        /**
         * @param {Ext.Element} element The component's outer element (this.element)
         */
        painted(element: Ext.dom.Element);

        /**
         * Fires when a component is removed from a Container
         * @param {Ext.Container} container Container which holds the component
         * @param {Number} index The index of the item that was removed.
         */
        removed(that: Ext.Component, container: Ext.Container, index: number);

        /**
         * @param {Ext.Element} element The component's outer element (this.element)
         */
        resize(element: Ext.dom.Element);

        rightchange();

        scrollablechange();

        topchange();

        /**
         * Fires whenever the data of the component is updated
         * @param {Ext.Component} this The component instance
         * @param {Object} newData The new data
         */
        updatedata(that: Ext.Component, newData: any);

        /**
         * Find the Widget or Component to which the given Element belongs.
         *
         * @param {Ext.dom.Element/HTMLElement} el The element from which to start to find an owning Component.
         * @param {Ext.dom.Element/HTMLElement} [limit] The element at which to stop upward searching for an
         * owning Component, or the number of Components to traverse before giving up.
         * Defaults to the document's HTML element.
         * @param {String} [selector] An optional {@link Ext.ComponentQuery} selector to filter the target.
         * @return {Ext.Component/null} Component, or null
         *
         * @since 6.0.1
         */
        static fromElement(el: Ext.dom.Element|HTMLElement, limit?: Ext.dom.Element|HTMLElement, selector?: string): Ext.Component;
    }

    /**
     * Provides a registry of all Components (instances of {@link Ext.Component} or any subclass
     * thereof) on a page so that they can be easily accessed by {@link Ext.Component component}
     * {@link Ext.Component#id id} (see {@link #get}, or the convenience method
     * {@link Ext#getCmp Ext.getCmp}).
     *
     * This object also provides a registry of available Component *classes* indexed by a
     * mnemonic code known as the Component's {@link Ext.Component#xtype xtype}. The 'xtype'
     * provides a way to avoid instantiating child Components when creating a full, nested
     * config object for a complete Ext page.
     *
     * A child Component may be specified simply as a *config object* as long as the correct
     * '{@link Ext.Component#xtype xtype}' is specified so that if and when the Component
     * needs rendering, the correct type can be looked up for lazy instantiation.
     */
    export class ComponentManager {
        /**
         * Executes the specified function once for each item in the collection.
         * @param {Function} fn The function to execute.
         * @param {String} fn.key The key of the item
         * @param {Number} fn.value The value of the item
         * @param {Number} fn.length The total number of items in the collection ** Removed
         * in 5.0 **
         * @param {Boolean} fn.return False to cease iteration.
         * @param {Object} scope The scope to execute in. Defaults to 'this'.
         */
        static each(fn: Function, fn_key: string, fn_value: number, fn_length: number, fn_return: boolean, scope: any);

        /**
         * Returns an item by id.
         * @param {String} id The id of the item
         * @return {Object} The item, undefined if not found.
         */
        static get(id: string): any;

        /**
         * Returns an array of all components
         * @return {Array}
         */
        static getAll(): any[];

        /**
         * Gets the number of items in the collection.
         * @return {Number} The number of items in the collection.
         */
        static getCount(): number;

        /**
         * Checks if an item is registered.
         * @param {String} component The mnemonic string by which the class may be looked up.
         * @return {Boolean} Whether the type is registered.
         * @deprecated 5.0
         */
        static isRegistered(component: string): boolean;

        /**
         * Registers a function that will be called (a single time) when an item with the specified id is added to the manager.
         * This will happen on instantiation.
         * @param {String} id The item id
         * @param {Function} fn The callback function. Called with a single parameter, the item.
         * @param {Object} scope The scope ('this' reference) in which the callback is executed.
         * Defaults to the item.
         */
        static onAvailable(id: string, fn: Function, scope: any);

        /**
         * Registers a new item constructor, keyed by a type key.
         * @param {String} type The mnemonic string by which the class may be looked up.
         * @param {Function} cls The new instance class.
         * @deprecated 5.0
         */
        static registerType(type: string, cls: Function);
    }

    /**
     * Provides searching of Components within Ext.ComponentManager (globally) or a specific
     * Ext.container.Container on the document with a similar syntax to a CSS selector.
     * Returns Array of matching Components, or empty Array.
     *
     * ## Basic Component lookup
     *
     * Components can be retrieved by using their {@link Ext.Component xtype}:
     *
     * - 'component'
     * - 'gridpanel'
     *
     * Matching by 'xtype' matches inherited types, so in the following code, the previous field
     * *of any type which inherits from 'TextField'* will be found:
     *
     *     prevField = myField.previousNode('textfield');
     *
     * To match only the exact type, pass the "shallow" flag by adding '(true)' to xtype
     * (See Component's {@link Ext.Component#isXType isXType} method):
     *
     *     prevTextField = myField.previousNode('textfield(true)');
     *
     * You can search Components by their 'id' or 'itemId' property, prefixed with a #:
     *
     *     #myContainer
     *
     * Component 'xtype' and 'id' or 'itemId' can be used together to avoid possible
     * id collisions between Components of different types:
     *
     *     panel#myPanel
     *
     * When Component's 'id' or 'xtype' contains dots, you can escape them in your selector:
     *
     *     my\.panel#myPanel
     *
     * Keep in mind that JavaScript treats the backslash character in a special way, so you
     * need to escape it, too, in the actual code:
     *
     *     var myPanel = Ext.ComponentQuery.query('my\\.panel#myPanel');
     *
     * ## Traversing Component tree
     *
     * Components can be found by their relation to other Components. There are several
     * relationship operators, mostly taken from CSS selectors:
     *
     * - **'E F'** All descendant Components of E that match F
     * - **'E > F'** All direct children Components of E that match F
     * - **'E ^ F'** All parent Components of E that match F
     *
     * Expressions between relationship operators are matched left to right, i.e. leftmost
     * selector is applied first, then if one or more matches are found, relationship operator
     * itself is applied, then next selector expression, etc. It is possible to combine
     * relationship operators in complex selectors:
     *
     *     window[title="Input form"] textfield[name=login] ^ form > button[action=submit]
     *
     * That selector can be read this way: Find a window with title "Input form", in that
     * window find a TextField with name "login" at any depth (including subpanels and/or
     * FieldSets), then find an 'Ext.form.Panel' that is a parent of the TextField, and in
     * that form find a direct child that is a button with custom property 'action' set to
     * value "submit".
     *
     * Whitespace on both sides of '^' and '>' operators is non-significant, i.e. can be
     * omitted, but usually is used for clarity.
     *
     * ## Searching by Component attributes
     *
     * Components can be searched by their object property values (attributes). To do that,
     * use attribute matching expression in square brackets:
     *
     * - 'component[disabled]' - matches any Component that has 'disabled' property with
     * any truthy (non-empty, not 'false') value.
     * - 'panel[title="Test"]' - matches any Component that has 'title' property set to
     * "Test". Note that if the value does not contain spaces, the quotes are optional.
     *
     * Attributes can use any of the following operators to compare values:
     * '=', '!=', '^=', '$=', '*=', '%=', '|=' and '~='.
     *
     * Prefixing the attribute name with an at sign '@' means that the property must be
     * the object's 'ownProperty', not a property from the prototype chain.
     *
     * Specifications like '[propName]' check that the property is a truthy value. To check
     * that the object has an 'ownProperty' of a certain name, regardless of the value use
     * the form '[?propName]'.
     *
     * The specified value is coerced to match the type of the property found in the
     * candidate Component using {@link Ext#coerce}.
     *
     * If you need to find Components by their 'itemId' property, use the '#id' form; it will
     * do the same as '[itemId=id]' but is easier to read.
     *
     * If you need to include a metacharacter like (, ), [, ], etc., in the query, escape it
     * by prefixing it with a backslash:
     *
     *      var component = Ext.ComponentQuery.query('[myProperty=\\[foo\\]]');
     *
     * ## Attribute matching operators
     *
     * The '=' operator will return the results that **exactly** match the
     * specified object property (attribute):
     *
     *     Ext.ComponentQuery.query('panel[cls=my-cls]');
     *
     * Will match the following Component:
     *
     *     Ext.create('Ext.window.Window', {
     *         cls: 'my-cls'
     *     });
     *
     * But will not match the following Component, because 'my-cls' is one value
     * among others:
     *
     *      Ext.create('Ext.panel.Panel', {
     *          cls: 'foo-cls my-cls bar-cls'
     *      });
     *
     * You can use the '~=' operator instead, it will return Components with
     * the property that **exactly** matches one of the whitespace-separated
     * values. This is also true for properties that only have *one* value:
     *
     *     Ext.ComponentQuery.query('panel[cls~=my-cls]');
     *
     * Will match both Components:
     *
     *     Ext.create('Ext.panel.Panel', {
     *         cls: 'foo-cls my-cls bar-cls'
     *     });
     *
     *     Ext.create('Ext.window.Window', {
     *         cls: 'my-cls'
     *     });
     *
     * Generally, '=' operator is more suited for object properties other than
     * CSS classes, while '~=' operator will work best with properties that
     * hold lists of whitespace-separated CSS classes.
     *
     * The '^=' operator will return Components with specified attribute that
     * start with the passed value:
     *
     *     Ext.ComponentQuery.query('panel[title^=Sales]');
     *
     * Will match the following Component:
     *
     *     Ext.create('Ext.panel.Panel', {
     *         title: 'Sales estimate for Q4'
     *     });
     *
     * The '$=' operator will return Components with specified properties that
     * end with the passed value:
     *
     *     Ext.ComponentQuery.query('field[fieldLabel$=name]');
     *
     * Will match the following Component:
     *
     *     Ext.create('Ext.form.field.Text', {
     *         fieldLabel: 'Enter your name'
     *     });
     *
     * The '/=' operator will return Components with specified properties that
     * match the passed regular expression:
     *
     *     Ext.ComponentQuery.query('button[action/="edit|save"]');
     *
     * Will match the following Components with a custom 'action' property:
     *
     *     Ext.create('Ext.button.Button', {
     *          action: 'edit'
     *     });
     *
     *     Ext.create('Ext.button.Button', {
     *          action: 'save'
     *     });
     *
     * When you need to use meta characters like [], (), etc. in your query, make sure
     * to escape them with back slashes:
     *
     *     Ext.ComponentQuery.query('panel[title="^Sales for Q\\[1-4\\]"]');
     *
     * The following test will find panels with their 'ownProperty' collapsed being equal to
     * 'false'. It will **not** match a collapsed property from the prototype chain.
     *
     *     Ext.ComponentQuery.query('panel[@collapsed=false]');
     *
     * Member expressions from candidate Components may be tested. If the expression returns
     * a *truthy* value, the candidate Component will be included in the query:
     *
     *     var disabledFields = myFormPanel.query("{isDisabled()}");
     *
     * Such expressions are executed in Component's context, and the above expression is
     * similar to running this snippet for every Component in your application:
     *
     *      if (component.isDisabled()) {
     *          matches.push(component);
     *      }
     *
     * It is important to use only methods that are available in **every** Component instance
     * to avoid run time exceptions. If you need to match your Components with a custom
     * condition formula, you can augment 'Ext.Component' to provide custom matcher that
     * will return 'false' by default, and override it in your custom classes:
     *
     *      Ext.define('My.Component', {
     *          override: 'Ext.Component',
     *          myMatcher: function() { return false; }
     *      });
     *
     *      Ext.define('My.Panel', {
     *          extend: 'Ext.panel.Panel',
     *          requires: ['My.Component'],     // Ensure that Component override is applied
     *          myMatcher: function(selector) {
     *              return selector === 'myPanel';
     *          }
     *      });
     *
     * After that you can use a selector with your custom matcher to find all instances
     * of 'My.Panel':
     *
     *      Ext.ComponentQuery.query("{myMatcher('myPanel')}");
     *
     * However if you really need to use a custom matcher, you may find it easier to implement
     * a custom Pseudo class instead (see below).
     *
     * ## Conditional matching
     *
     * Attribute matchers can be combined to select only Components that match **all**
     * conditions (logical AND operator):
     *
     *     Ext.ComponentQuery.query('panel[cls~=my-cls][floating=true][title$="sales data"]');
     *
     * E.g., the query above will match only a Panel-descended Component that has 'my-cls'
     * CSS class *and* is floating *and* with a title that ends with "sales data".
     *
     * Expressions separated with commas will match any Component that satisfies
     * *either* expression (logical OR operator):
     *
     *     Ext.ComponentQuery.query('field[fieldLabel^=User], field[fieldLabel*=password]');
     *
     * E.g., the query above will match any field with field label starting with "User",
     * *or* any field that has "password" in its label.
     *
     * If you need to include a comma in an attribute matching expression, escape it with a
     * backslash:
     *
     *     Ext.ComponentQuery.query('field[fieldLabel^="User\\, foo"], field[fieldLabel*=password]');
     *
     * ## Pseudo classes
     *
     * Pseudo classes may be used to filter results in the same way as in
     * {@link Ext.dom.Query}. There are five default pseudo classes:
     *
     * * 'not' Negates a selector.
     * * 'first' Filters out all except the first matching item for a selector.
     * * 'last' Filters out all except the last matching item for a selector.
     * * 'focusable' Filters out all except Components which by definition and configuration are
     *      potentially able to recieve focus, regardless of their current state
     * * 'canfocus' Filters out all except Components which are curently able to recieve focus.
     *      That is, they are defined and configured focusable, and they are also visible and enabled.
     * * 'nth-child' Filters Components by ordinal position in the selection.
     * * 'scrollable' Filters out all except Components which are scrollable.
     * * 'visible' Filters out hidden Components. May test deep visibility using '':visible(true)''
     *
     * These pseudo classes can be used with other matchers or without them:
     *
     *      // Select first direct child button in any panel
     *      Ext.ComponentQuery.query('panel > button:first');
     *
     *      // Select last field in Profile form
     *      Ext.ComponentQuery.query('form[title=Profile] field:last');
     *
     *      // Find first focusable Component in a panel and focus it
     *      panel.down(':canfocus').focus();
     *
     *      // Select any field that is not hidden in a form
     *      form.query('field:not(hiddenfield)');
     *
     *      // Find last scrollable Component and reset its scroll positions.
     *      tabpanel.down(':scrollable[hideMode=display]:last').getScrollable().scrollTo(0, 0);
     *
     * Pseudo class 'nth-child' can be used to find any child Component by its
     * position relative to its siblings. This class' handler takes one argument
     * that specifies the selection formula as 'Xn' or 'Xn+Y':
     *
     *      // Find every odd field in a form
     *      form.query('field:nth-child(2n+1)'); // or use shortcut: :nth-child(odd)
     *
     *      // Find every even field in a form
     *      form.query('field:nth-child(2n)');   // or use shortcut: :nth-child(even)
     *
     *      // Find every 3rd field in a form
     *      form.query('field:nth-child(3n)');
     *
     * Pseudo classes can be combined to further filter the results, e.g., in the
     * form example above we can modify the query to exclude hidden fields:
     *
     *      // Find every 3rd non-hidden field in a form
     *      form.query('field:not(hiddenfield):nth-child(3n)');
     *
     * Note that when combining pseudo classes, whitespace is significant, i.e.
     * there should be no spaces between pseudo classes. This is a common mistake;
     * if you accidentally type a space between 'field' and ':not', the query
     * will not return any result because it will mean "find *field's children
     * Components* that are not hidden fields...".
     *
     * ## Custom pseudo classes
     *
     * It is possible to define your own custom pseudo classes. In fact, a
     * pseudo class is just a property in 'Ext.ComponentQuery.pseudos' object
     * that defines pseudo class name (property name) and pseudo class handler
     * (property value):
     *
     *     // Function receives array and returns a filtered array.
     *     Ext.ComponentQuery.pseudos.invalid = function(items) {
     *         var i = 0, l = items.length, c, result = [];
     *         for (; i < l; i++) {
     *             if (!(c = items[i]).isValid()) {
     *                 result.push(c);
     *             }
     *         }
     *         return result;
     *     };
     *
     *     var invalidFields = myFormPanel.query('field:invalid');
     *     if (invalidFields.length) {
     *         invalidFields[0].getEl().scrollIntoView(myFormPanel.body);
     *         for (var i = 0, l = invalidFields.length; i < l; i++) {
     *             invalidFields[i].getEl().frame("red");
     *         }
     *     }
     *
     * Pseudo class handlers can be even more flexible, with a selector
     * argument used to define the logic:
     *
     *      // Handler receives array of itmes and selector in parentheses
     *      Ext.ComponentQuery.pseudos.titleRegex = function(components, selector) {
     *          var i = 0, l = components.length, c, result = [], regex = new RegExp(selector);
     *          for (; i < l; i++) {
     *              c = components[i];
     *              if (c.title && regex.test(c.title)) {
     *                  result.push(c);
     *              }
     *          }
     *          return result;
     *      }
     *
     *      var salesTabs = tabPanel.query('panel:titleRegex("sales\\s+for\\s+201[123]")');
     *
     * Be careful when using custom pseudo classes with MVC Controllers: when
     * you use a pseudo class in Controller's 'control' or 'listen' component
     * selectors, the pseudo class' handler function will be called very often
     * and may slow down your application significantly. A good rule of thumb
     * is to always specify Component xtype with the pseudo class so that the
     * handlers are only called on Components that you need, and try to make
     * the condition checks as cheap in terms of execution time as possible.
     * Note how in the example above, handler function checks that Component
     * *has* a title first, before running regex test on it.
     *
     * ## Query examples
     *
     * Queries return an array of Components. Here are some example queries:
     *
     *     // retrieve all Ext.Panels in the document by xtype
     *     var panelsArray = Ext.ComponentQuery.query('panel');
     *
     *     // retrieve all Ext.Panels within the container with an id myCt
     *     var panelsWithinmyCt = Ext.ComponentQuery.query('#myCt panel');
     *
     *     // retrieve all direct children which are Ext.Panels within myCt
     *     var directChildPanel = Ext.ComponentQuery.query('#myCt > panel');
     *
     *     // retrieve all grids or trees
     *     var gridsAndTrees = Ext.ComponentQuery.query('gridpanel, treepanel');
     *
     *     // Focus first Component
     *     myFormPanel.child(':canfocus').focus();
     *
     *     // Retrieve every odd text field in a form
     *     myFormPanel.query('textfield:nth-child(odd)');
     *
     *     // Retrieve every even field in a form, excluding hidden fields
     *     myFormPanel.query('field:not(hiddenfield):nth-child(even)');
     *
     *     // Retrieve every scrollable in a tabpanel
     *     tabpanel.query(':scrollable');
     *
     * For easy access to queries based from a particular Container see the
     * {@link Ext.container.Container#query}, {@link Ext.container.Container#down} and
     * {@link Ext.container.Container#child} methods. Also see
     * {@link Ext.Component#up}.
     */
    export class ComponentQuery {
        /**
         * Tests whether the passed Component matches the selector string.
         * An empty selector will always match.
         *
         * @param {Ext.Component} component The Component to test
         * @param {String} selector The selector string to test against.
         * @param {Ext.Component} [root=null] The root component.
         * @return {Boolean} True if the Component matches the selector.
         */
        static is(component: Ext.Component, selector: string, root?: Ext.Component): boolean;

        /**
         * Returns an array of matched Components from within the passed root object.
         *
         * This method filters returned Components in a similar way to how CSS selector based DOM
         * queries work using a textual selector string.
         *
         * See class summary for details.
         *
         * @param {String} selector The selector string to filter returned Components.
         * @param {Ext.container.Container} [root] The Container within which to perform the query.
         * If omitted, all Components within the document are included in the search.
         *
         * This parameter may also be an array of Components to filter according to the selector.
         * @return {Ext.Component[]} The matched Components.
         */
        static query(selector: string, root?: Ext.Container): Ext.Component;

        /**
         * Traverses the tree rooted at the passed root in post-order mode, calling the passed function on the nodes at each level.
         * That is the function is called upon each node **after** being called on its children).
         *
         * For an object to be queryable, it must implement the 'getRefItems' method which returns all
         * immediate child items.
         *
         * This method is used at each level down the cascade. Currently {@link Ext.Component Component}s
         * and {@link Ext.data.TreeModel TreeModel}s are queryable.
         *
         * If you have tree-structured data, you can make your nodes queryable, and use ComponentQuery on them.
         *
         * @param {Object} selector A ComponentQuery selector used to filter candidate nodes before calling the function.
         * An empty string matches any node.
         * @param {String} root The root queryable object to start from.
         * @param {Function} fn The function to call. Return 'false' to abort the traverse.
         * @param {Object} fn.node The node being visited.
         * @param {Object} [scope] The context ('this' reference) in which the function is executed.
         * @param {Array} [extraArgs] A set of arguments to be appended to the function's argument list to pass down extra data known to the caller
         * **after** the node being visited.
         */
        static visitPostOrder(selector: any, root: string, fn: Function, fn_node: any, scope?: any, extraArgs?: any[]);

        /**
         * Traverses the tree rooted at the passed root in pre-order mode, calling the passed function on the nodes at each level.
         * That is the function is called upon each node **before** being called on its children).
         *
         * For an object to be queryable, it must implement the 'getRefItems' method which returns all
         * immediate child items.
         *
         * This method is used at each level down the cascade. Currently {@link Ext.Component Component}s
         * and {@link Ext.data.TreeModel TreeModel}s are queryable.
         *
         * If you have tree-structured data, you can make your nodes queryable, and use ComponentQuery on them.
         *
         * @param {Object} selector A ComponentQuery selector used to filter candidate nodes before calling the function.
         * An empty string matches any node.
         * @param {String} root The root queryable object to start from.
         * @param {Function} fn The function to call. Return 'false' to abort the traverse.
         * @param {Object} fn.node The node being visited.
         * @param {Object} [scope] The context ('this' reference) in which the function is executed.
         * @param {Array} [extraArgs] A set of arguments to be appended to the function's argument list to pass down extra data known to the caller
         * **after** the node being visited.
         */
        static visitPreOrder(selector: any, root: string, fn: Function, fn_node: any, scope?: any, extraArgs?: any[]);
    }

    interface ConfigConfig {
        /**
         * This function if supplied will be called as classes or instances provide values
         * that need to be combined with inherited values. The function should return the
         * value that will be the config value. Further calls may receive such returned
         * values as 'oldValue'.
         *
         * The new value to merge with the old.
         *
         * The current value prior to 'newValue' being merged.
         *
         * The class or instance to which the merged config value
         * will be applied.
         *
         * The mixin providing the 'newValue' or 'null' if
         * the 'newValue' is not being provided by a mixin.
         *
         * Optional
         */
        merge?: Function;
    }

    /**
     * This class manages a config property. Instances of this type are created and cached as
     * classes declare their config properties. One instance of this class is created per
     * config property name.
     *
     *      Ext.define('MyClass', {
     *          config: {
     *              foo: 42
     *          }
     *      });
     *
     * This uses the cached 'Ext.Config' instance for the "foo" property.
     *
     * When config properties apply options to config properties a prototype chained object is
     * created from the cached instance. For example:
     *
     *      Ext.define('MyClass', {
     *          config: {
     *              foo: {
     *                  $value: 42,
     *                  lazy: true
     *              }
     *          }
     *      });
     *
     * This creates a prototype chain to the cached "foo" instance of 'Ext.Config' and applies
     * the 'lazy' option to that new instance. This chained instance is then kept by the
     * 'Ext.Configurator' for that class.
     */
    export class Config implements Ext.ConfigConfig {
        /**
         * This function if supplied will be called as classes or instances provide values
         * that need to be combined with inherited values. The function should return the
         * value that will be the config value. Further calls may receive such returned
         * values as 'oldValue'.
         *
         * The new value to merge with the old.
         *
         * The current value prior to 'newValue' being merged.
         *
         * The class or instance to which the merged config value
         * will be applied.
         *
         * The mixin providing the 'newValue' or 'null' if
         * the 'newValue' is not being provided by a mixin.
         *
         * Optional
         */
        merge: Function;

        /**
         * Returns the name of the property that stores this config on the given instance or
         * class prototype.
         * @return {String}
         */
        getInternalName(target: any): string;
    }

    /**
     * This class manages the config properties for a class.
     */
    export class Configurator {
    }

    interface ContainerConfig extends Ext.ComponentConfig {
        /**
         * The item from the {@link #cfg-items} collection that will be active first. This is
         * usually only meaningful in a {@link Ext.layout.Card card layout}, where only one item can be active at a
         * time. If passes a string, it will be assumed to be a {@link Ext.ComponentQuery} selector.
         */
        activeItem?: any|string|number;

        /**
         * If 'true', child items will be destroyed as soon as they are {@link #method-remove removed}
         * from this container.
         */
        autoDestroy?: boolean;

        /**
         * Animation to be used during transitions of cards.
         * @removed 2.0.0 Please use {@link Ext.layout.Card#animation} instead
         */
        cardSwitchAnimation?: string|any|boolean;

        /**
         * Enables you to easily control Components inside this Container by listening to their
         * events and taking some action. For example, if we had a container with a nested Disable button, and we
         * wanted to hide the Container when the Disable button is tapped, we could do this:
         *
         *     Ext.create('Ext.Container', {
         *         control: {
         *            'button[text=Disable]': {
         *                tap: 'hideMe'
         *            }
         *         },
         *
         *         hideMe: function () {
         *             this.hide();
         *         }
         *     });
         *
         * We used a {@link Ext.ComponentQuery} selector to listen to the {@link Ext.Button#tap tap} event on any
         * {@link Ext.Button button} anywhere inside the Container that has the {@link Ext.Button#text text} 'Disable'.
         * Whenever a Component matching that selector fires the 'tap' event our 'hideMe' function is called. 'hideMe' is
         * called with scope: 'this' (e.g. 'this' is the Container instance).
         */
        control?: any;

        /** @cfg {String} defaultType
         * The default {@link Ext.Component xtype} of child Components to create in this Container when a child item
         * is specified as a raw configuration object, rather than as an instantiated Component.
         */
        defaultType?: any;

        /**
         * A set of default configurations to apply to all child Components in this Container.
         * It's often useful to specify defaults when creating more than one items with similar configurations. For
         * example here we can specify that each child is a panel and avoid repeating the xtype declaration for each
         * one:
         *
         *     Ext.create('Ext.Container', {
         *         defaults: {
         *             xtype: 'panel'
         *         },
         *         items: [
         *             {
         *                 html: 'Panel 1'
         *             },
         *             {
         *                 html: 'Panel 2'
         *             }
         *         ]
         *     });
         */
        defaults?: any;

        /**
         * When using a {@link #modal} Component, setting this to 'true' will hide the modal
         * mask and the Container when the mask is tapped on.
         */
        hideOnMaskTap?: boolean;

        /**
         * The child items to add to this Container. This is usually an array of Component
         * configurations or instances, for example:
         *
         *     Ext.create('Ext.Container', {
         *         items: [
         *             {
         *                 xtype: 'panel',
         *                 html: 'This is an item'
         *             }
         *         ]
         *     });
         */
        items?: any[]|any;

        /**
         * Configuration for this Container's layout. Example:
         *
         *     Ext.create('Ext.Container', {
         *         layout: {
         *             type: 'hbox',
         *             align: 'middle'
         *         },
         *         items: [
         *             {
         *                 xtype: 'panel',
         *                 flex: 1,
         *                 style: 'background-color: red;'
         *             },
         *             {
         *                 xtype: 'panel',
         *                 flex: 2,
         *                 style: 'background-color: green'
         *             }
         *         ]
         *     });
         */
        layout?: any|string;

        /**
         * A configuration to allow you to mask this container.
         * You can optionally pass an object block with and xtype of 'loadmask', and an optional 'message' value to
         * display a loading mask. Please refer to the {@link Ext.LoadMask} component to see other configurations.
         *
         *     masked: {
         *         xtype: 'loadmask',
         *         message: 'My message'
         *     }
         *
         * Alternatively, you can just call the setter at any time with 'true'/'false' to show/hide the mask:
         *
         *     setMasked(true); //show the mask
         *     setMasked(false); //hides the mask
         *
         * There are also two convenient methods, {@link #method-mask} and {@link #unmask}, to allow you to mask and unmask
         * this container at any time.
         *
         * Remember, the {@link Ext.Viewport} is always a container, so if you want to mask your whole application at anytime,
         * can call:
         *
         *     Ext.Viewport.setMasked({
         *         xtype: 'loadmask',
         *         message: 'Hello'
         *     });
         */
        masked?: boolean|any|Ext.Mask|Ext.LoadMask;

        /**
         * 'true' to make this Container modal. This will create a mask underneath the Container
         * that covers its parent and does not allow the user to interact with any other Components until this
         * Container is dismissed.
         */
        modal?: boolean;
    }

    /**
     * A Container has all of the abilities of {@link Ext.Component Component}, but lets you nest other Components inside
     * it. Applications are made up of lots of components, usually nested inside one another. Containers allow you to
     * render and arrange child Components inside them. Most apps have a single top-level Container called a Viewport,
     * which takes up the entire screen. Inside of this are child components, for example in a mail app the Viewport
     * Container's two children might be a message List and an email preview pane.
     *
     * Containers give the following extra functionality:
     *
     * - Adding child Components at instantiation and run time
     * - Removing child Components
     * - Specifying a Layout
     *
     * Layouts determine how the child Components should be laid out on the screen. In our mail app example we'd use an
     * HBox layout so that we can pin the email list to the left hand edge of the screen and allow the preview pane to
     * occupy the rest. There are several layouts, each of which help you achieve your desired
     * application structure.
     *
     * ## Adding Components to Containers
     *
     * As we mentioned above, Containers are special Components that can have child Components arranged by a Layout. One of
     * the code samples above showed how to create a Panel with 2 child Panels already defined inside it but it's easy to
     * do this at run time too:
     *
     *     @example miniphone
     *     //this is the Panel we'll be adding below
     *     var aboutPanel = Ext.create('Ext.Panel', {
     *         html: 'About this app'
     *     });
     *
     *     //this is the Panel we'll be adding to
     *     var mainPanel = Ext.create('Ext.Panel', {
     *         fullscreen: true,
     *
     *         layout: 'hbox',
     *         defaults: {
     *             flex: 1
     *         },
     *
     *         items: {
     *             html: 'First Panel',
     *             style: 'background-color: #5E99CC;'
     *         }
     *     });
     *
     *     //now we add the first panel inside the second
     *     mainPanel.add(aboutPanel);
     *
     * Here we created three Panels in total. First we made the aboutPanel, which we might use to tell the user a little
     * about the app. Then we create one called mainPanel, which already contains a third Panel in its
     * {@link Ext.Container#cfg-items items} configuration, with some dummy text ("First Panel"). Finally, we add the first
     * panel to the second by calling the {@link Ext.Container#method-add add} method on 'mainPanel'.
     *
     * In this case we gave our mainPanel another hbox layout, but we also introduced some
     * {@link Ext.Container#defaults defaults}. These are applied to every item in the Panel, so in this case every child
     * inside 'mainPanel' will be given a 'flex: 1' configuration. The effect of this is that when we first render the screen
     * only a single child is present inside 'mainPanel', so that child takes up the full width available to it. Once the
     * 'mainPanel.add' line is called though, the 'aboutPanel' is rendered inside of it and also given a 'flex' of 1, which will
     * cause it and the first panel to both receive half the full width of the 'mainPanel'.
     *
     * Likewise, it's easy to remove items from a Container:
     *
     *     mainPanel.remove(aboutPanel);
     *
     * After this line is run everything is back to how it was, with the first child panel once again taking up the full
     * width inside 'mainPanel'.
     */
    export class Container extends Ext.Component implements Ext.ContainerConfig {
        /**
         * The item from the {@link #cfg-items} collection that will be active first. This is
         * usually only meaningful in a {@link Ext.layout.Card card layout}, where only one item can be active at a
         * time. If passes a string, it will be assumed to be a {@link Ext.ComponentQuery} selector.
         */
        activeItem: any|string|number;

        /**
         * If 'true', child items will be destroyed as soon as they are {@link #method-remove removed}
         * from this container.
         */
        autoDestroy: boolean;

        /**
         * Animation to be used during transitions of cards.
         * @removed 2.0.0 Please use {@link Ext.layout.Card#animation} instead
         */
        cardSwitchAnimation: string|any|boolean;

        /**
         * Enables you to easily control Components inside this Container by listening to their
         * events and taking some action. For example, if we had a container with a nested Disable button, and we
         * wanted to hide the Container when the Disable button is tapped, we could do this:
         *
         *     Ext.create('Ext.Container', {
         *         control: {
         *            'button[text=Disable]': {
         *                tap: 'hideMe'
         *            }
         *         },
         *
         *         hideMe: function () {
         *             this.hide();
         *         }
         *     });
         *
         * We used a {@link Ext.ComponentQuery} selector to listen to the {@link Ext.Button#tap tap} event on any
         * {@link Ext.Button button} anywhere inside the Container that has the {@link Ext.Button#text text} 'Disable'.
         * Whenever a Component matching that selector fires the 'tap' event our 'hideMe' function is called. 'hideMe' is
         * called with scope: 'this' (e.g. 'this' is the Container instance).
         */
        control: any;

        /**
         * A set of default configurations to apply to all child Components in this Container.
         * It's often useful to specify defaults when creating more than one items with similar configurations. For
         * example here we can specify that each child is a panel and avoid repeating the xtype declaration for each
         * one:
         *
         *     Ext.create('Ext.Container', {
         *         defaults: {
         *             xtype: 'panel'
         *         },
         *         items: [
         *             {
         *                 html: 'Panel 1'
         *             },
         *             {
         *                 html: 'Panel 2'
         *             }
         *         ]
         *     });
         */
        defaults: any;

        /** @cfg {String} defaultType
         * The default {@link Ext.Component xtype} of child Components to create in this Container when a child item
         * is specified as a raw configuration object, rather than as an instantiated Component.
         */
        defaultType: any;

        /**
         * When using a {@link #modal} Component, setting this to 'true' will hide the modal
         * mask and the Container when the mask is tapped on.
         */
        hideOnMaskTap: boolean;

        /**
         * The child items to add to this Container. This is usually an array of Component
         * configurations or instances, for example:
         *
         *     Ext.create('Ext.Container', {
         *         items: [
         *             {
         *                 xtype: 'panel',
         *                 html: 'This is an item'
         *             }
         *         ]
         *     });
         */
        items: any[]|any;

        /**
         * Configuration for this Container's layout. Example:
         *
         *     Ext.create('Ext.Container', {
         *         layout: {
         *             type: 'hbox',
         *             align: 'middle'
         *         },
         *         items: [
         *             {
         *                 xtype: 'panel',
         *                 flex: 1,
         *                 style: 'background-color: red;'
         *             },
         *             {
         *                 xtype: 'panel',
         *                 flex: 2,
         *                 style: 'background-color: green'
         *             }
         *         ]
         *     });
         */
        layout: any|string;

        /**
         * 'true' to enable border management of docked items.  When enabled, borders of docked
         * items will collapse where they meet to avoid duplicated borders.
         */
        protected manageBorders: any;

        /**
         * A configuration to allow you to mask this container.
         * You can optionally pass an object block with and xtype of 'loadmask', and an optional 'message' value to
         * display a loading mask. Please refer to the {@link Ext.LoadMask} component to see other configurations.
         *
         *     masked: {
         *         xtype: 'loadmask',
         *         message: 'My message'
         *     }
         *
         * Alternatively, you can just call the setter at any time with 'true'/'false' to show/hide the mask:
         *
         *     setMasked(true); //show the mask
         *     setMasked(false); //hides the mask
         *
         * There are also two convenient methods, {@link #method-mask} and {@link #unmask}, to allow you to mask and unmask
         * this container at any time.
         *
         * Remember, the {@link Ext.Viewport} is always a container, so if you want to mask your whole application at anytime,
         * can call:
         *
         *     Ext.Viewport.setMasked({
         *         xtype: 'loadmask',
         *         message: 'Hello'
         *     });
         */
        masked: boolean|any|Ext.Mask|Ext.LoadMask;

        /**
         * 'true' to make this Container modal. This will create a mask underneath the Container
         * that covers its parent and does not allow the user to interact with any other Components until this
         * Container is dismissed.
         */
        modal: boolean;

        /**
         * Adds one or more Components to this Container. Example:
         *
         *     var myPanel = Ext.create('Ext.Panel', {
         *         html: 'This will be added to a Container'
         *     });
         *
         *     var items = myContainer.add([myPanel]); // Array returned
         *     var item = myContainer.add(myPanel); // One item is returned
         *
         * @param {Object/Object[]/Ext.Component/Ext.Component[]} newItems The new item(s) to add
         * to the Container. Note that if an array of items to add was passed in, an array of added
         * items will be returned as well even if there was only one item.
         *
         * @return {Ext.Component/Ext.Component[]} The Component(s) that were added.
         */
        add(newItems: any|Ext.Component): Ext.Component;

        /**
         * Animates to the supplied 'activeItem' with a specified animation. Currently this only works
         * with a Card layout.  This passed animation will override any default animations on the
         * container, for a single card switch. The animation will be destroyed when complete.
         * @param {Object/Number} activeItem The item or item index to make active.
         * @param {Object/Ext.fx.layout.Card} animation Card animation configuration or instance.
         */
        animateActiveItem(activeItem: any|number, animation: any|Ext.fx.layout.Card);

        /**
         * Changes the {@link #masked} configuration when its setter is called, which will convert the value
         * into a proper object/instance of {@link Ext.Mask}/{@link Ext.LoadMask}. If a mask already exists,
         * it will use that instead.
         * @return {Object}
         */
        applyMasked(masked: boolean|any|Ext.Mask|Ext.LoadMask): any;

        constructor(config: Ext.ActionSheetConfig);

        destroy();

        /**
         * Called when an item is added to this container either during initialization of the {@link #cfg-items} config,
         * or when new items are {@link #method-add added), or {@link #method-insert inserted}.
         *
         * If the passed object is *not* an instanced component, it converts the passed object into an instanced
         * child component.
         *
         * It applies {@link #cfg-defaults} applied for contained child items - that is items
         * which are not {@link Ext.Component#cfg-floating floating} or {@link Ext.Component#cfg-docked docked}.
         *
         * Derived classes can override this method to process context appropriate short-hands
         * such as {@link Ext.Toolbar} and "->" to insert a spacer.
         *
         * @param {Mixed} item The item being added. May be a raw config object or an instanced
         * Component or some other short-hand understood by the container.
         * @return {Ext.Component} The component to be added.
         */
        protected factoryItem(item: any): Ext.Component;

        getActiveItem();

        /**
         * Returns the Component for a given index in the Container's {@link #property-items}.
         * @param {Number} index The index of the Component to return.
         * @return {Ext.Component} The item at the specified 'index', if found.
         */
        getAt(index: number): Ext.Component;

        getAutoDestroy();

        /**
         * Examines this container's '{@link #property-items}' property
         * and gets a direct child component of this container.
         * @param {String/Number} component This parameter may be any of the following:
         *
         * - {String} : representing the 'itemId'
         * or '{@link Ext.Component#getId id}' of the child component.
         * - {Number} : representing the position of the child component
         * within the '{@link #property-items}' property.
         *
         * For additional information see {@link Ext.util.MixedCollection#get}.
         * @return {Ext.Component} The component (if found).
         */
        getComponent(component: string|number): Ext.Component;

        getControl();

        getDefaults();

        getDefaultType();

        /**
         * Finds a docked item of this container using a reference, 'id 'or an 'index' of its location
         * in {@link #getDockedItems}.
         * @param {String/Number} component The 'id' or 'index' of the component to find.
         * @return {Ext.Component/Boolean} The docked component, if found.
         */
        getDockedComponent(component: string|number): Ext.Component|boolean;

        /**
         * Returns all the {@link Ext.Component#docked} items in this container.
         * @return {Array} The docked items of this container.
         */
        getDockedItems(): any[];

        getHideOnMaskTap();

        /**
         * Returns all inner {@link #property-items} of this container. 'inner' means that the item is not 'docked' or
         * 'floating'.
         * @return {Array} The inner items of this container.
         */
        getInnerItems(): any[];

        getItems();

        getMasked();

        getModal();

        protected initialize();

        protected initInheritedState(inheritedState: any, inheritedStateInner: any);

        /**
         * Adds a child Component at the given index. For example, here's how we can add a new item, making it the first
         * child Component of this Container:
         *
         *     myContainer.insert(0, {xtype: 'panel', html: 'new item'});
         *
         * @param {Number} index The index to insert the Component at.
         * @param {Object} item The Component to insert.
         */
        insert(index: number, item: any);

        /**
         * Convenience method which calls {@link #setMasked} with a value of 'true' (to show the mask). For additional
         * functionality, call the {@link #setMasked} function direction (See the {@link #masked} configuration documentation
         * for more information).
         */
        mask();

        /**
         * Removes an item from this Container, optionally destroying it.
         * @param {Ext.Component/String/Number} component The component instance or id or index to remove.
         * @param {Boolean} [destroy] 'true' to automatically call Component's
         * {@link Ext.Component#method-destroy destroy} method.
         *
         * @return {Ext.Component} The Component that was removed.
         */
        remove(component: Ext.Component|string|number, destroy?: boolean): Ext.Component;

        /**
         * Removes all items currently in the Container, optionally destroying them all.
         *
         * @param {Boolean} destroy If 'true', {@link Ext.Component#method-destroy destroys}
         * each removed Component.
         * @param {Boolean} everything If 'true', completely remove all items including
         * docked / centered and floating items.
         *
         * @return {Ext.Component[]} Array of the removed Components
         */
        removeAll(destroy: boolean, everything: boolean): Ext.Component;

        /**
         * Removes the Component at the specified index:
         *
         *     myContainer.removeAt(0); // removes the first item
         *
         * @param {Number} index The index of the Component to remove.
         *
         * @return {Ext.Component} The removed Component
         */
        removeAt(index: number): Ext.Component;

        /**
         * Removes an inner Component at the specified index:
         *
         *     myContainer.removeInnerAt(0); // removes the first item of the innerItems property
         *
         * @param {Number} index The index of the Component to remove.
         * @return {Ext.Component} The removed Component
         */
        removeInnerAt(index: number): Ext.Component;

        setActiveItem();

        setAutoDestroy();

        setControl();

        setDefaults();

        setDefaultType();

        setHideOnMaskTap();

        setItems();

        setLayout();

        setMasked();

        setModal();

        /**
         * Convenience method which calls {@link #setMasked} with a value of false (to hide the mask). For additional
         * functionality, call the {@link #setMasked} function direction (See the {@link #masked} configuration documentation
         * for more information).
         */
        unmask();

        /**
         * Fires whenever item within the Container is activated.
         * @param {Object} newActiveItem The new active item within the container.
         * @param {Ext.Container} this The Container instance.
         * @param {Object} oldActiveItem The old active item within the container.
         */
        activate(newActiveItem: any, that: Ext.Container, oldActiveItem: any);

        activeitemchange();

        /**
         * Fires whenever item within the Container is deactivated.
         * @param {Object} oldActiveItem The old active item within the container.
         * @param {Ext.Container} this The Container instance.
         * @param {Object} newActiveItem The new active item within the container.
         */
        deactivate(oldActiveItem: any, that: Ext.Container, newActiveItem: any);

        /**
         * Fires whenever item moved within the Container.
         * @param {Ext.Container} this The Container instance.
         * @param {Object} item The item moved within the Container.
         * @param {Number} toIndex The new index of the item.
         * @param {Number} fromIndex The old index of the item.
         */
        move(that: Ext.Container, item: any, toIndex: number, fromIndex: number);
    }

    /**
     * This class defines some basic methods for handling dates.
     *
     * The date parsing and formatting syntax contains a subset of
     * [PHP's 'date()' function](http://www.php.net/date), and the formats that are
     * supported will provide results equivalent to their PHP versions.
     *
     * The following is a list of all currently supported formats:
     *
     *      Format      Description                                                               Example returned values
     *      ------      -----------------------------------------------------------------------   -----------------------
     *        d         Day of the month, 2 digits with leading zeros                             01 to 31
     *        D         A short textual representation of the day of the week                     Mon to Sun
     *        j         Day of the month without leading zeros                                    1 to 31
     *        l         A full textual representation of the day of the week                      Sunday to Saturday
     *        N         ISO-8601 numeric representation of the day of the week                    1 (for Monday) through 7 (for Sunday)
     *        S         English ordinal suffix for the day of the month, 2 characters             st, nd, rd or th. Works well with j
     *        w         Numeric representation of the day of the week                             0 (for Sunday) to 6 (for Saturday)
     *        z         The day of the year (starting from 0)                                     0 to 364 (365 in leap years)
     *        W         ISO-8601 week number of year, weeks starting on Monday                    01 to 53
     *        F         A full textual representation of a month, such as January or March        January to December
     *        m         Numeric representation of a month, with leading zeros                     01 to 12
     *        M         A short textual representation of a month                                 Jan to Dec
     *        n         Numeric representation of a month, without leading zeros                  1 to 12
     *        t         Number of days in the given month                                         28 to 31
     *        L         Whether it&#39;s a leap year                                                  1 if it is a leap year, 0 otherwise.
     *        o         ISO-8601 year number (identical to (Y), but if the ISO week number (W)    Examples: 1998 or 2004
     *                  belongs to the previous or next year, that year is used instead)
     *        Y         A full numeric representation of a year, 4 digits                         Examples: 1999 or 2003
     *        y         A two digit representation of a year                                      Examples: 99 or 03
     *        a         Lowercase Ante meridiem and Post meridiem                                 am or pm
     *        A         Uppercase Ante meridiem and Post meridiem                                 AM or PM
     *        g         12-hour format of an hour without leading zeros                           1 to 12
     *        G         24-hour format of an hour without leading zeros                           0 to 23
     *        h         12-hour format of an hour with leading zeros                              01 to 12
     *        H         24-hour format of an hour with leading zeros                              00 to 23
     *        i         Minutes, with leading zeros                                               00 to 59
     *        s         Seconds, with leading zeros                                               00 to 59
     *        u         Decimal fraction of a second                                              Examples:
     *                  (minimum 1 digit, arbitrary number of digits allowed)                     001 (i.e. 0.001s) or
     *                                                                                            100 (i.e. 0.100s) or
     *                                                                                            999 (i.e. 0.999s) or
     *                                                                                            999876543210 (i.e. 0.999876543210s)
     *        O         Difference to Greenwich time (GMT) in hours and minutes                   Example: +1030
     *        P         Difference to Greenwich time (GMT) with colon between hours and minutes   Example: -08:00
     *        T         Timezone abbreviation of the machine running the code                     Examples: EST, MDT, PDT ...
     *        Z         Timezone offset in seconds (negative if west of UTC, positive if east)    -43200 to 50400
     *        c         ISO 8601 date represented as the local time with an offset to UTC appended.
     *                  Notes:                                                                    Examples:
     *                  1) If unspecified, the month / day defaults to the current month / day,   1991 or
     *                     the time defaults to midnight, while the timezone defaults to the      1992-10 or
     *                     browser's timezone. If a time is specified, it must include both hours 1993-09-20 or
     *                     and minutes. The "T" delimiter, seconds, milliseconds and timezone     1994-08-19T16:20+01:00 or
     *                     are optional.                                                          1995-07-18T17:21:28-02:00 or
     *                  2) The decimal fraction of a second, if specified, must contain at        1996-06-17T18:22:29.98765+03:00 or
     *                     least 1 digit (there is no limit to the maximum number                 1997-05-16T19:23:30,12345-0400 or
     *                     of digits allowed), and may be delimited by either a '.' or a ','      1998-04-15T20:24:31.2468Z or
     *                  Refer to the examples on the right for the various levels of              1999-03-14T20:24:32Z or
     *                  date-time granularity which are supported, or see                         2000-02-13T21:25:33
     *                  http://www.w3.org/TR/NOTE-datetime for more info.                         2001-01-12 22:26:34
     *        C         An ISO date string as implemented by the native Date object's             1962-06-17T09:21:34.125Z
     *                  [Date.toISOString](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)
     *                  method. This outputs the numeric part with *UTC* hour and minute
     *                  values, and indicates this by appending the ''Z'' timezone
     *                  identifier.
     *        U         Seconds since the Unix Epoch (January 1 1970 00:00:00 GMT)                1193432466 or -2138434463
     *        MS        Microsoft AJAX serialized dates                                           \/Date(1238606590509)\/ (i.e. UTC milliseconds since epoch) or
     *                                                                                            \/Date(1238606590509+0800)\/
     *        time      A javascript millisecond timestamp                                        1350024476440
     *        timestamp A UNIX timestamp (same as U)                                              1350024866
     *
     * Example usage (note that you must escape format specifiers with '\\' to render them as character literals):
     *
     *     // Sample date:
     *     // 'Wed Jan 10 2007 15:05:01 GMT-0600 (Central Standard Time)'
     *
     *     var dt = new Date('1/10/2007 03:05:01 PM GMT-0600');
     *     console.log(Ext.Date.format(dt, 'Y-m-d'));                          // 2007-01-10
     *     console.log(Ext.Date.format(dt, 'F j, Y, g:i a'));                  // January 10, 2007, 3:05 pm
     *     console.log(Ext.Date.format(dt, 'l, \\t\\he jS \\of F Y h:i:s A')); // Wednesday, the 10th of January 2007 03:05:01 PM
     *
     * Here are some standard date/time patterns that you might find helpful.  They
     * are not part of the source of Ext.Date, but to use them you can simply copy this
     * block of code into any script that is included after Ext.Date and they will also become
     * globally available on the Date object.  Feel free to add or remove patterns as needed in your code.
     *
     *     Ext.Date.patterns = {
     *         ISO8601Long:"Y-m-d H:i:s",
     *         ISO8601Short:"Y-m-d",
     *         ShortDate: "n/j/Y",
     *         LongDate: "l, F d, Y",
     *         FullDateTime: "l, F d, Y g:i:s A",
     *         MonthDay: "F d",
     *         ShortTime: "g:i A",
     *         LongTime: "g:i:s A",
     *         SortableDateTime: "Y-m-d\\TH:i:s",
     *         UniversalSortableDateTime: "Y-m-d H:i:sO",
     *         YearMonth: "F, Y"
     *     };
     *
     * Example usage:
     *
     *     var dt = new Date();
     *     console.log(Ext.Date.format(dt, Ext.Date.patterns.ShortDate));
     *
     * Developer-written, custom formats may be used by supplying both a formatting and a parsing function
     * which perform to specialized requirements. The functions are stored in {@link #parseFunctions} and {@link #formatFunctions}.
     */
    export class Date {
        /**
         * Date interval constant.
         */
        static DAY: string;

        /**
         * An array of textual day names.
         * Override these values for international dates.
         *
         * Example:
         *
         *     Ext.Date.dayNames = [
         *         'SundayInYourLang',
         *         'MondayInYourLang'
         *         // ...
         *     ];
         */
        static dayNames: string;

        /**
         * The date format string that the {@link Ext.util.Format#dateRenderer}
         * and {@link Ext.util.Format#date} functions use.  See {@link Ext.Date} for details.
         *
         * This may be overridden in a locale file.
         */
        static defaultFormat: string;

        /**
         * An object hash containing default date values used during date parsing.
         *
         * The following properties are available:
         *
         * - 'y': {@link Number} - The default year value. Defaults to 'undefined'.
         * - 'm': {@link Number} - The default 1-based month value. Defaults to 'undefined'.
         * - 'd': {@link Number} - The default day value. Defaults to 'undefined'.
         * - 'h': {@link Number} - The default hour value. Defaults to 'undefined'.
         * - 'i': {@link Number} - The default minute value. Defaults to 'undefined'.
         * - 's': {@link Number} - The default second value. Defaults to 'undefined'.
         * - 'ms': {@link Number} - The default millisecond value. Defaults to 'undefined'.
         *
         * Override these properties to customize the default date values used by the {@link #parse} method.
         *
         * __Note:__ In countries which experience Daylight Saving Time (i.e. DST), the 'h', 'i', 's'
         * and 'ms' properties may coincide with the exact time in which DST takes effect.
         * It is the responsibility of the developer to account for this.
         *
         * Example Usage:
         *
         *     // set default day value to the first day of the month
         *     Ext.Date.defaults.d = 1;
         *
         *     // parse a February date string containing only year and month values.
         *     // setting the default day value to 1 prevents weird date rollover issues
         *     // when attempting to parse the following date string on, for example, March 31st 2009.
         *     Ext.Date.parse('2009-02', 'Y-m'); // returns a Date object representing February 1st 2009.
         */
        static defaults: any;

        /**
         * The base format-code to formatting-function hashmap used by the {@link #format} method.
         * Formatting functions are strings (or functions which return strings) which
         * will return the appropriate value when evaluated in the context of the Date object
         * from which the {@link #format} method is called.
         * Add to / override these mappings for custom date formatting.
         *
         * __Note:__ 'Ext.Date.format()' treats characters as literals if an appropriate mapping cannot be found.
         *
         * Example:
         *
         *     Ext.Date.formatCodes.x = "Ext.util.Format.leftPad(this.getDate(), 2, '0')";
         *     console.log(Ext.Date.format(new Date(), 'X'); // returns the current day of the month
         */
        static formatCodes: any;

        /**
         * An object hash in which each property is a date formatting function. The property name is the
         * format string which corresponds to the produced formatted date string.
         *
         * This object is automatically populated with date formatting functions as
         * date formats are requested for Ext standard formatting strings.
         *
         * Custom formatting functions may be inserted into this object, keyed by a name which from then on
         * may be used as a format string to {@link #format}.
         *
         * Example:
         *
         *     Ext.Date.formatFunctions['x-date-format'] = myDateFormatter;
         *
         * A formatting function should return a string representation of the Date object which
         * is the scope (this) of the function.
         *
         * To enable date strings to also be _parsed_ according to that format, a corresponding
         * parsing function must be placed into the {@link #parseFunctions} property.
         */
        static formatFunctions: any;

        static HOUR: string;

        /**
         * Date interval constant.
         */
        static MILLI: string;

        /**
         * Date interval constant.
         */
        static MINUTE: string;

        /**
         * Date interval constant.
         */
        static MONTH: string;

        /**
         * An array of textual month names.
         * Override these values for international dates.
         *
         * Example:
         *
         *     Ext.Date.monthNames = [
         *         'JanInYourLang',
         *         'FebInYourLang'
         *         // ...
         *     ];
         */
        static monthNames: string;

        /**
         * An object hash of zero-based JavaScript month numbers (with short month names as keys).
         *
         * __Note:__ keys are case-sensitive.
         *
         * Override these values for international dates.
         *
         * Example:
         *
         *     Ext.Date.monthNumbers = {
         *         'LongJanNameInYourLang': 0,
         *         'ShortJanNameInYourLang':0,
         *         'LongFebNameInYourLang':1,
         *         'ShortFebNameInYourLang':1
         *         // ...
         *     };
         */
        static monthNumbers: any;

        /**
         * An object hash in which each property is a date parsing function. The property name is the
         * format string which that function parses.
         *
         * This object is automatically populated with date parsing functions as
         * date formats are requested for Ext standard formatting strings.
         *
         * Custom parsing functions may be inserted into this object, keyed by a name which from then on
         * may be used as a format string to {@link #parse}.
         *
         * Example:
         *
         *     Ext.Date.parseFunctions['x-date-format'] = myDateParser;
         *
         *  A parsing function should return a Date object, and is passed the following parameters:
         *
         * - 'date': {@link String} - The date string to parse.
         * - 'strict': {@link Boolean} - 'true' to validate date strings while parsing
         * (i.e. prevent JavaScript Date "rollover"). __The default must be 'false'.__
         * Invalid date strings should return 'null' when parsed.
         *
         * To enable Dates to also be _formatted_ according to that format, a corresponding
         * formatting function must be placed into the {@link #formatFunctions} property.
         */
        static parseFunctions: any;

        /**
         * Date interval constant.
         */
        static SECOND: string;

        /**
         * Global flag which determines if strict date parsing should be used.
         * Strict date parsing will not roll-over invalid dates, which is the
         * default behavior of JavaScript Date objects.
         * (see {@link #parse} for more information)
         */
        static useStrict: boolean;

        /**
         * Date interval constant.
         */
        static YEAR: string;

        /**
         * Provides a convenient method for performing basic date arithmetic. This method
         * does not modify the Date instance being called - it creates and returns
         * a new Date instance containing the resulting date value.
         *
         * Examples:
         *
         *     // Basic usage:
         *     var dt = Ext.Date.add(new Date('10/29/2006'), Ext.Date.DAY, 5);
         *     console.log(dt); // returns 'Fri Nov 03 2006 00:00:00'
         *
         *     // Negative values will be subtracted:
         *     var dt2 = Ext.Date.add(new Date('10/1/2006'), Ext.Date.DAY, -5);
         *     console.log(dt2); // returns 'Tue Sep 26 2006 00:00:00'
         *
         *      // Decimal values can be used:
         *     var dt3 = Ext.Date.add(new Date('10/1/2006'), Ext.Date.DAY, 1.25);
         *     console.log(dt3); // returns 'Mon Oct 02 2006 06:00:00'
         *
         * @param {Date} date The date to modify
         * @param {String} interval A valid date interval enum value.
         * @param {Number} value The amount to add to the current date.
         * @return {Date} The new Date instance.
         */
        static add(date: Date, interval: string, value: number): Date;

        /**
         * Align the date to 'unit'.
         * @param {Date} date The date to be aligned.
         * @param {String} unit The unit. This unit is compatible with the date interval constants.
         * @return {Date} The aligned date.
         */
        static align(date: Date, unit: string, step: number): Date;

        /**
         * Checks if a date falls on or between the given start and end dates.
         * @param {Date} date The date to check
         * @param {Date} start Start date
         * @param {Date} end End date
         * @return {Boolean} 'true' if this date falls on or between the given start and end dates.
         */
        static between(date: Date, start: Date, end: Date): boolean;

        /**
         * Attempts to clear all time information from this Date by setting the time to midnight of the same day,
         * automatically adjusting for Daylight Saving Time (DST) where applicable.
         *
         * __Note:__ DST timezone information for the browser's host operating system is assumed to be up-to-date.
         * @param {Date} date The date
         * @param {Boolean} [clone=false] 'true' to create a clone of this date, clear the time and return it.
         * @return {Date} this or the clone.
         */
        static clearTime(date: Date, clone?: boolean): Date;

        /**
         * Creates and returns a new Date instance with the exact same date value as the called instance.
         * Dates are copied and passed by reference, so if a copied date variable is modified later, the original
         * variable will also be changed.  When the intention is to create a new variable that will not
         * modify the original instance, you should create a clone.
         *
         * Example of correctly cloning a date:
         *
         *     //wrong way:
         *     var orig = new Date('10/1/2006');
         *     var copy = orig;
         *     copy.setDate(5);
         *     console.log(orig);  // returns 'Thu Oct 05 2006'!
         *
         *     //correct way:
         *     var orig = new Date('10/1/2006'),
         *         copy = Ext.Date.clone(orig);
         *     copy.setDate(5);
         *     console.log(orig);  // returns 'Thu Oct 01 2006'
         *
         * @param {Date} date The date.
         * @return {Date} The new Date instance.
         */
        static clone(date: Date): Date;

        /**
         * Calculate how many units are there between two time.
         * @param {Date} min The first time.
         * @param {Date} max The second time.
         * @param {String} unit The unit. This unit is compatible with the date interval constants.
         * @return {Number} The maximum number n of units that min + n * unit <= max.
         */
        static diff(min: Date, max: Date, unit: string): number;

        /**
         * Formats a date given the supplied format string.
         * @param {Date} date The date to format
         * @param {String} format The format string
         * @return {String} The formatted date or an empty string if date parameter is not a JavaScript Date object
         */
        static format(date: Date, format: string): string;

        /**
         * Checks if the specified format contains information about
         * anything other than the time.
         * @param {String} format The format to check
         * @return {Boolean} True if the format contains information about
         * date/day information.
         */
        static formatContainsDateInfo(format: string): boolean;

        /**
         * Checks if the specified format contains hour information
         * @param {String} format The format to check
         * @return {Boolean} True if the format contains hour information
         */
        static formatContainsHourInfo(format: string): boolean;

        /**
         * Get the numeric day number of the year, adjusted for leap year.
         *
         *     @example
         *     var dt = new Date('9/17/2011');
         *     console.log(Ext.Date.getDayOfYear(dt)); // 259
         *
         * @param {Date} date The date
         * @return {Number} 0 to 364 (365 in leap years).
         */
        static getDayOfYear(date: Date): number;

        /**
         * Get the number of days in the current month, adjusted for leap year.
         * @param {Date} date The date
         * @return {Number} The number of days in the month.
         */
        static getDaysInMonth(date: Date): number;

        /**
         * Returns the number of milliseconds between two dates.
         * @param {Date} dateA The first date.
         * @param {Date} [dateB=new Date()] (optional) The second date.
         * @return {Number} The difference in milliseconds
         */
        static getElapsed(dateA: Date, dateB?: Date): number;

        /**
         * Get the date of the first day of the month in which this date resides.
         * @param {Date} date The date
         * @return {Date}
         */
        static getFirstDateOfMonth(date: Date): Date;

        /**
         * Get the first day of the current month, adjusted for leap year.  The returned value
         * is the numeric day index within the week (0-6) which can be used in conjunction with
         * the {@link #monthNames} array to retrieve the textual day name.
         *
         *      @example
         *      var dt = new Date('1/10/2007'),
         *          firstDay = Ext.Date.getFirstDayOfMonth(dt);
         *      console.log(Ext.Date.dayNames[firstDay]); // output: 'Monday'
         *
         * @param {Date} date The date
         * @return {Number} The day number (0-6).
         */
        static getFirstDayOfMonth(date: Date): number;

        /**
         * Get the offset from GMT of the current date (equivalent to the format specifier 'O').
         *
         *     @example
         *     var dt = new Date('9/17/2011');
         *     console.log(Ext.Date.getGMTOffset(dt));
         *
         * @param {Date} date The date
         * @param {Boolean} [colon=false] 'true' to separate the hours and minutes with a colon.
         * @return {String} The 4-character offset string prefixed with + or - (e.g. '-0600').
         */
        static getGMTOffset(date: Date, colon?: boolean): string;

        /**
         * Get the date of the last day of the month in which this date resides.
         * @param {Date} date The date
         * @return {Date}
         */
        static getLastDateOfMonth(date: Date): Date;

        /**
         * Get the last day of the current month, adjusted for leap year.  The returned value
         * is the numeric day index within the week (0-6) which can be used in conjunction with
         * the {@link #monthNames} array to retrieve the textual day name.
         *
         *      @example
         *      var dt = new Date('1/10/2007'),
         *          lastDay = Ext.Date.getLastDayOfMonth(dt);
         *
         *      console.log(Ext.Date.dayNames[lastDay]); // output: 'Wednesday'
         *
         * @param {Date} date The date
         * @return {Number} The day number (0-6).
         */
        static getLastDayOfMonth(date: Date): number;

        /**
         * Get the zero-based JavaScript month number for the given short/full month name.
         * Override this function for international dates.
         * @param {String} name The short/full month name.
         * @return {Number} The zero-based JavaScript month number.
         */
        static getMonthNumber(name: string): number;

        /**
         * Get the short day name for the given day number.
         * Override this function for international dates.
         * @param {Number} day A zero-based JavaScript day number.
         * @return {String} The short day name.
         */
        static getShortDayName(day: number): string;

        /**
         * Get the short month name for the given month number.
         * Override this function for international dates.
         * @param {Number} month A zero-based JavaScript month number.
         * @return {String} The short month name.
         */
        static getShortMonthName(month: number): string;

        /**
         * Get the English ordinal suffix of the current day (equivalent to the format specifier 'S').
         * @param {Date} date The date
         * @return {String} 'st, 'nd', 'rd' or 'th'.
         */
        static getSuffix(date: Date): string;

        /**
         * Get the timezone abbreviation of the current date (equivalent to the format specifier 'T').
         *
         * __Note:__ The date string returned by the JavaScript Date object's 'toString()' method varies
         * between browsers (e.g. FF vs IE) and system region settings (e.g. IE in Asia vs IE in America).
         * For a given date string e.g. "Thu Oct 25 2007 22:55:35 GMT+0800 (Malay Peninsula Standard Time)",
         * 'getTimezone()' first tries to get the timezone abbreviation from between a pair of parentheses
         * (which may or may not be present), failing which it proceeds to get the timezone abbreviation
         * from the GMT offset portion of the date string.
         *
         *     @example
         *     var dt = new Date('9/17/2011');
         *     console.log(Ext.Date.getTimezone(dt));
         *
         * @param {Date} date The date
         * @return {String} The abbreviated timezone name (e.g. 'CST', 'PDT', 'EDT', 'MPST' ...).
         */
        static getTimezone(date: Date): string;

        /**
         * Get the numeric ISO-8601 week number of the year.
         * (equivalent to the format specifier 'W', but without a leading zero).
         *
         *     @example
         *     var dt = new Date('9/17/2011');
         *     console.log(Ext.Date.getWeekOfYear(dt)); // 37
         *
         * @param {Date} date The date.
         * @return {Number} 1 to 53.
         */
        static getWeekOfYear(date: Date): number;

        /**
         * Checks if the current date is affected by Daylight Saving Time (DST).
         * @param {Date} date The date
         * @return {Boolean} 'true' if the current date is affected by DST.
         */
        static isDST(date: Date): boolean;

        /**
         * Compares if two dates are equal by comparing their values.
         * @return {Boolean} 'true' if the date values are equal
         */
        static isEqual(date1: Date, date2: Date): boolean;

        /**
         * Checks if the current date falls within a leap year.
         *
         *     @example
         *     var dt = new Date('1/10/2011');
         *     console.log(Ext.Date.isLeapYear(dt)); // false
         *
         * @param {Date} date The date
         * @return {Boolean} 'true' if the current date falls within a leap year, 'false' otherwise.
         */
        static isLeapYear(date: Date): boolean;

        /**
         * Checks if the passed Date parameters will cause a JavaScript Date "rollover".
         * @param {Number} year 4-digit year.
         * @param {Number} month 1-based month-of-year.
         * @param {Number} day Day of month.
         * @param {Number} hour (optional) Hour.
         * @param {Number} minute (optional) Minute.
         * @param {Number} second (optional) Second.
         * @param {Number} millisecond (optional) Millisecond.
         * @return {Boolean} 'true' if the passed parameters do not cause a Date "rollover", 'false' otherwise.
         */
        static isValid(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number): boolean;

        /**
         * Parses the passed string using the specified date format.
         * Note that this function expects normal calendar dates, meaning that months are 1-based (i.e. 1 = January).
         * The {@link #defaults} hash will be used for any date value (i.e. year, month, day, hour, minute, second or millisecond)
         * which cannot be found in the passed string. If a corresponding default date value has not been specified in the {@link #defaults} hash,
         * the current date's year, month, day or DST-adjusted zero-hour time value will be used instead.
         * Keep in mind that the input date string must precisely match the specified format string
         * in order for the parse operation to be successful (failed parse operations return a
         * 'null' value).
         *
         * Example:
         *
         *     //dt = Fri May 25 2007 (current date)
         *     var dt = new Date();
         *
         *     //dt = Thu May 25 2006 (today&#39;s month/day in 2006)
         *     dt = Ext.Date.parse("2006", "Y");
         *
         *     //dt = Sun Jan 15 2006 (all date parts specified)
         *     dt = Ext.Date.parse("2006-01-15", "Y-m-d");
         *
         *     //dt = Sun Jan 15 2006 15:20:01
         *     dt = Ext.Date.parse("2006-01-15 3:20:01 PM", "Y-m-d g:i:s A");
         *
         *     // attempt to parse Sun Feb 29 2006 03:20:01 in strict mode
         *     dt = Ext.Date.parse("2006-02-29 03:20:01", "Y-m-d H:i:s", true); // returns null
         *
         * @param {String} input The raw date string.
         * @param {String} format The expected date string format.
         * @param {Boolean} [strict=false] (optional) 'true' to validate date strings while parsing (i.e. prevents JavaScript Date "rollover").
         * Invalid date strings will return 'null' when parsed.
         * @return {Date/null} The parsed Date, or 'null' if an invalid date string.
         */
        static parse(input: string, format: string, strict?: boolean): Date;

        /**
         * Provides a convenient method for performing basic date arithmetic. This method
         * does not modify the Date instance being called - it creates and returns
         * a new Date instance containing the resulting date value.
         *
         * Examples:
         *
         *     // Basic usage:
         *     var dt = Ext.Date.subtract(new Date('10/29/2006'), Ext.Date.DAY, 5);
         *     console.log(dt); // returns 'Tue Oct 24 2006 00:00:00'
         *
         *     // Negative values will be added:
         *     var dt2 = Ext.Date.subtract(new Date('10/1/2006'), Ext.Date.DAY, -5);
         *     console.log(dt2); // returns 'Fri Oct 6 2006 00:00:00'
         *
         *      // Decimal values can be used:
         *     var dt3 = Ext.Date.subtract(new Date('10/1/2006'), Ext.Date.DAY, 1.25);
         *     console.log(dt3); // returns 'Fri Sep 29 2006 06:00:00'
         *
         * @param {Date} date The date to modify
         * @param {String} interval A valid date interval enum value.
         * @param {Number} value The amount to subtract from the current date.
         * @return {Date} The new Date instance.
         */
        static subtract(date: Date, interval: string, value: number): Date;

        /**
         * Removes all escaping for a date format string. In date formats,
         * using a '\' can be used to escape special characters.
         * @param {String} format The format to unescape
         * @return {String} The unescaped format
         */
        static unescapeFormat(format: string): string;
    }

    interface DecoratorConfig extends Ext.ComponentConfig {
        /**
         * The config object to factory the Component that this Decorator wraps around
         */
        component?: any;
    }

    /**
     * @extends Ext.Component
     *
     * In a few words, a Decorator is a Component that wraps around another Component. A typical example of a Decorator is a
     * {@link Ext.field.Field Field}. A form field is nothing more than a decorator around another component, and gives the
     * component a label, as well as extra styling to make it look good in a form.
     *
     * A Decorator can be thought of as a lightweight Container that has only one child item, and no layout overhead.
     * The look and feel of decorators can be styled purely in CSS.
     *
     * Another powerful feature that Decorator provides is config proxying. For example: all config items of a
     * {@link Ext.slider.Slider Slider} also exist in a {@link Ext.field.Slider Slider Field} for API convenience.
     * The {@link Ext.field.Slider Slider Field} simply proxies all corresponding getters and setters
     * to the actual {@link Ext.slider.Slider Slider} instance. Writing out all the setters and getters to do that is a tedious task
     * and a waste of code space. Instead, when you sub-class Ext.Decorator, all you need to do is to specify those config items
     * that you want to proxy to the Component using a special 'proxyConfig' class property. Here's how it may look like
     * in a Slider Field class:
     *
     *     Ext.define('My.field.Slider', {
     *         extend: 'Ext.Decorator',
     *
     *         config: {
     *             component: {
     *                 xtype: 'slider'
     *             }
     *         },
     *
     *         proxyConfig: {
     *             minValue: 0,
     *             maxValue: 100,
     *             increment: 1
     *         }
     *
     *         // ...
     *     });
     *
     * Once 'My.field.Slider' class is created, it will have all setters and getters methods for all items listed in 'proxyConfig'
     * automatically generated. These methods all proxy to the same method names that exist within the Component instance.
     */
    export class Decorator extends Ext.Component implements Ext.DecoratorConfig {
        /**
         * The config object to factory the Component that this Decorator wraps around
         */
        component: any;

        /**
         * Creates new Component.
         * @param {Object} config The standard configuration object.
         */
        constructor(config: Ext.ButtonConfig);

        destroy();

        getComponent();

        setComponent();
    }

    /**
     * Deferreds are the mechanism used to create new Promises. A Deferred has a single
     * associated Promise that can be safely returned to external consumers to ensure they do
     * not interfere with the resolution or rejection of the deferred operation.
     *
     * This implementation of Promises is an extension of the ECMAScript 6 Promises API as
     * detailed [here][1]. For a compatible, though less full featured, API see '{@link Ext.Promise}'.
     *
     * A Deferred is typically used within the body of a function that performs an asynchronous
     * operation. When that operation succeeds, the Deferred should be resolved; if that
     * operation fails, the Deferred should be rejected.
     *
     * Each Deferred has an associated Promise. A Promise delegates 'then' calls to its
     * Deferred's 'then' method. In this way, access to Deferred operations are divided between
     * producer (Deferred) and consumer (Promise) roles.
     *
     * ## Basic Usage
     *
     * In it's most common form, a method will create and return a Promise like this:
     *
     *      // A method in a service class which uses a Store and returns a Promise
     *      //
     *      loadCompanies: function () {
     *          var deferred = new Ext.Deferred(); // create the Ext.Deferred object
     *
     *          this.companyStore.load({
     *              callback: function (records, operation, success) {
     *                  if (success) {
     *                      // Use "deferred" to drive the promise:
     *                      deferred.resolve(records);
     *                  }
     *                  else {
     *                      // Use "deferred" to drive the promise:
     *                      deferred.reject("Error loading Companies.");
     *                  }
     *              }
     *          });
     *
     *          return deferred.promise;  // return the Promise to the caller
     *      }
     *
     * You can see this method first creates a '{@link Ext.Deferred Deferred}' object. It then
     * returns its 'Promise' object for use by the caller. Finally, in the asynchronous
     * callback, it resolves the 'deferred' object if the call was successful, and rejects the
     * 'deferred' if the call failed.
     *
     * When a Deferred's 'resolve' method is called, it fulfills with the optionally specified
     * value. If 'resolve' is called with a then-able (i.e.a Function or Object with a 'then'
     * function, such as another Promise) it assimilates the then-able's result; the Deferred
     * provides its own 'resolve' and 'reject' methods as the onFulfilled or onRejected
     * arguments in a call to that then-able's 'then' function. If an error is thrown while
     * calling the then-able's 'then' function (prior to any call back to the specified
     * 'resolve' or 'reject' methods), the Deferred rejects with that error. If a Deferred's
     * 'resolve' method is called with its own Promise, it rejects with a TypeError.
     *
     * When a Deferred's 'reject' method is called, it rejects with the optionally specified
     * reason.
     *
     * Each time a Deferred's 'then' method is called, it captures a pair of optional
     * onFulfilled and onRejected callbacks and returns a Promise of the Deferred's future
     * value as transformed by those callbacks.
     *
     * See '{@link Ext.promise.Promise}' for an example of using the returned Promise.
     *
     * @since 6.0.0
     */
    export class Deferred extends Ext.Base {
        /**
         * Returns a new Promise that will only resolve once all the specified
         * 'promisesOrValues' have resolved.
         *
         * The resolution value will be an Array containing the resolution value of each
         * of the 'promisesOrValues'.
         *
         * @param {Mixed[]/Ext.promise.Promise[]/Ext.promise.Promise} promisesOrValues An
         * Array of values or Promises, or a Promise of an Array of values or Promises.
         * @return {Ext.promise.Promise} A Promise of an Array of the resolved values.
         */
        static all(promisesOrValues: any|Ext.promise.Promise): Ext.promise.Promise;

        /**
         * Initiates a competitive race, returning a new Promise that will resolve when
         * any one of the specified 'promisesOrValues' have resolved, or will reject when
         * all 'promisesOrValues' have rejected or cancelled.
         *
         * The resolution value will the first value of 'promisesOrValues' to resolve.
         *
         * @param {Mixed[]/Ext.promise.Promise[]/Ext.promise.Promise} promisesOrValues An
         * Array of values or Promises, or a Promise of an Array of values or Promises.
         * @return {Ext.promise.Promise} A Promise of the first resolved value.
         */
        static any(promisesOrValues: any|Ext.promise.Promise): Ext.promise.Promise;

        /**
         * Returns a new Promise that will automatically resolve with the specified
         * Promise or value after the specified delay (in milliseconds).
         *
         * @param {Mixed} promiseOrValue A Promise or value.
         * @param {Number} milliseconds A delay duration (in milliseconds).
         * @return {Ext.promise.Promise} A Promise of the specified Promise or value that
         * will resolve after the specified delay.
         */
        static delay(promiseOrValue: any, milliseconds: number): Ext.promise.Promise;

        /**
         * Traditional map function, similar to 'Array.prototype.map()', that allows
         * input to contain promises and/or values.
         *
         * The specified map function may return either a value or a promise.
         *
         * @param {Mixed[]/Ext.promise.Promise[]/Ext.promise.Promise} promisesOrValues An
         * Array of values or Promises, or a Promise of an Array of values or Promises.
         * @param {Function} mapFn A Function to call to transform each resolved value in
         * the Array.
         * @return {Ext.promise.Promise} A Promise of an Array of the mapped resolved
         * values.
         */
        static map(promisesOrValues: any|Ext.promise.Promise, mapFn: Function): Ext.promise.Promise;

        /**
         * Returns a new function that wraps the specified function and caches the
         * results for previously processed inputs.
         *
         * Similar to {@link Ext.Function#memoize Ext.Function.memoize()}, except it
         * allows for parameters that are Promises and/or values.
         *
         * @param {Function} fn A Function to wrap.
         * @param {Object} scope An optional scope in which to execute the wrapped function.
         * @param {Function} hashFn An optional function used to compute a hash key for
         * storing the result, based on the arguments to the original function.
         * @return {Function} The new wrapper function.
         */
        static memoize(fn: Function, scope: any, hashFn: Function): Function;

        /**
         * Execute an Array (or {@link Ext.promise.Promise Promise} of an Array) of
         * functions in parallel.
         *
         * The specified functions may optionally return their results as
         * {@link Ext.promise.Promise Promises}.
         *
         * @param {Function[]/Ext.promise.Promise} fns The Array (or Promise of an Array)
         * of functions to execute.
         * @param {Object} scope Optional scope in which to execute the specified functions.
         * @return {Ext.promise.Promise} Promise of an Array of results for each function
         * call (in the same order).
         */
        static parallel(fns: Function|Ext.promise.Promise, scope: any): Ext.promise.Promise;

        /**
         * Execute an Array (or {@link Ext.promise.Promise Promise} of an Array) of
         * functions as a pipeline, where each function's result is passed to the
         * subsequent function as input.
         *
         * The specified functions may optionally return their results as
         * {@link Ext.promise.Promise Promises}.
         *
         * @param {Function[]/Ext.promise.Promise} fns The Array (or Promise of an Array)
         * of functions to execute.
         * @param {Object} initialValue Initial value to be passed to the first function
         * in the pipeline.
         * @param {Object} scope Optional scope in which to execute the specified functions.
         * @return {Ext.promise.Promise} Promise of the result value for the final
         * function in the pipeline.
         */
        static pipeline(fns: Function|Ext.promise.Promise, initialValue: any, scope: any): Ext.promise.Promise;

        /**
         * Traditional reduce function, similar to 'Array.reduce()', that allows input to
         * contain promises and/or values.
         *
         * @param {Mixed[]/Ext.promise.Promise[]/Ext.promise.Promise} values An
         * Array of values or Promises, or a Promise of an Array of values or Promises.
         * @param {Function} reduceFn A Function to call to transform each successive
         * item in the Array into the final reduced value.
         * @param {Mixed} initialValue An initial Promise or value.
         * @return {Ext.promise.Promise} A Promise of the reduced value.
         */
        static reduce(values: any|Ext.promise.Promise, reduceFn: Function, initialValue: any): Ext.promise.Promise;

        /**
         * Convenience method that returns a new Promise rejected with the specified
         * reason.
         *
         * @param {Error} reason Rejection reason.
         * @return {Ext.promise.Promise} The rejected Promise.
         */
        static rejected(reason: Error): Ext.promise.Promise;

        /**
         * Returns a new Promise that either
         *
         *  * Resolves immediately for the specified value, or
         *  * Resolves or rejects when the specified promise (or third-party Promise or
         *    then()-able) is resolved or rejected.
         *
         * @param {Mixed} promiseOrValue A Promise (or third-party Promise or then()-able)
         * or value.
         * @return {Ext.promise.Promise} A Promise of the specified Promise or value.
         */
        static resolved(promiseOrValue: any): Ext.promise.Promise;

        /**
         * Execute an Array (or {@link Ext.promise.Promise Promise} of an Array) of
         * functions sequentially.
         *
         * The specified functions may optionally return their results as {@link
         * Ext.promise.Promise Promises}.
         *
         * @param {Function[]/Ext.promise.Promise} fns The Array (or Promise of an Array)
         * of functions to execute.
         * @param {Object} scope Optional scope in which to execute the specified functions.
         * @return {Ext.promise.Promise} Promise of an Array of results for each function
         * call (in the same order).
         */
        static sequence(fns: Function|Ext.promise.Promise, scope: any): Ext.promise.Promise;

        /**
         * Initiates a competitive race, returning a new Promise that will resolve when
         * 'howMany' of the specified 'promisesOrValues' have resolved, or will reject
         * when it becomes impossible for 'howMany' to resolve.
         *
         * The resolution value will be an Array of the first 'howMany' values of
         * 'promisesOrValues' to resolve.
         *
         * @param {Mixed[]/Ext.promise.Promise[]/Ext.promise.Promise} promisesOrValues An
         * Array of values or Promises, or a Promise of an Array of values or Promises.
         * @param {Number} howMany The expected number of resolved values.
         * @return {Ext.promise.Promise} A Promise of the expected number of resolved
         * values.
         */
        static some(promisesOrValues: any|Ext.promise.Promise, howMany: number): Ext.promise.Promise;

        /**
         * Returns a new Promise that will automatically reject after the specified
         * timeout (in milliseconds) if the specified promise has not resolved or
         * rejected.
         *
         * @param {Mixed} promiseOrValue A Promise or value.
         * @param {Number} milliseconds A timeout duration (in milliseconds).
         * @return {Ext.promise.Promise} A Promise of the specified Promise or value that
         * enforces the specified timeout.
         */
        static timeout(promiseOrValue: any, milliseconds: number): Ext.promise.Promise;
    }

    /**
     * A helper class for the native JavaScript Error object that adds a few useful capabilities for handling
     * errors in an application. When you use Ext.Error to {@link #raise} an error from within any class that
     * uses the Class System, the Error class can automatically add the source class and method from which
     * the error was raised. It also includes logic to automatically log the error to the console, if available,
     * with additional metadata about the error. In all cases, the error will always be thrown at the end so that
     * execution will halt.
     *
     * Ext.Error also offers a global error {@link #handle handling} method that can be overridden in order to
     * handle application-wide errors in a single spot. You can optionally {@link #ignore} errors altogether,
     * although in a real application it's usually a better idea to override the handling function and perform
     * logging or some other method of reporting the errors in a way that is meaningful to the application.
     *
     * At its simplest you can simply raise an error as a simple string from within any code:
     *
     * Example usage:
     *
     *     Ext.raise('Something bad happened!');
     *
     * If raised from plain JavaScript code, the error will be logged to the console (if available) and the message
     * displayed. In most cases however you'll be raising errors from within a class, and it may often be useful to add
     * additional metadata about the error being raised.  The {@link #raise} method can also take a config object.
     * In this form the 'msg' attribute becomes the error description, and any other data added to the config gets
     * added to the error object and, if the console is available, logged to the console for inspection.
     *
     * Example usage:
     *
     *     Ext.define('Ext.Foo', {
     *         doSomething: function(option){
     *             if (someCondition === false) {
     *                 Ext.raise({
     *                     msg: 'You cannot do that!',
     *                     option: option,   // whatever was passed into the method
     *                     'error code': 100 // other arbitrary info
     *                 });
     *             }
     *         }
     *     });
     *
     * If a console is available (that supports the 'console.dir' function) you'll see console output like:
     *
     *     An error was raised with the following data:
     *     option:         Object { foo: "bar"}
     *         foo:        "bar"
     *     error code:     100
     *     msg:            "You cannot do that!"
     *     sourceClass:   "Ext.Foo"
     *     sourceMethod:  "doSomething"
     *
     *     uncaught exception: You cannot do that!
     *
     * As you can see, the error will report exactly where it was raised and will include as much information as the
     * raising code can usefully provide.
     *
     * If you want to handle all application errors globally you can simply override the static {@link #handle} method
     * and provide whatever handling logic you need. If the method returns true then the error is considered handled
     * and will not be thrown to the browser. If anything but true is returned then the error will be thrown normally.
     *
     * Example usage:
     *
     *     Ext.Error.handle = function(err) {
     *         if (err.someProperty == 'NotReallyAnError') {
     *             // maybe log something to the application here if applicable
     *             return true;
     *         }
     *         // any non-true return value (including none) will cause the error to be thrown
     *     }
     */
    export class Error {
        /**
         * Static flag that can be used to globally disable error reporting to the browser if set to true
         * (defaults to false). Note that if you ignore Ext errors it's likely that some other code may fail
         * and throw a native JavaScript error thereafter, so use with caution. In most cases it will probably
         * be preferable to supply a custom error {@link #handle handling} function instead.
         *
         * Example usage:
         *
         *     Ext.Error.ignore = true;
         */
        static ignore: boolean;

        /**
         * Globally handle any Ext errors that may be raised, optionally providing custom logic to
         * handle different errors individually. Return true from the function to bypass throwing the
         * error to the browser, otherwise the error will be thrown and execution will halt.
         *
         * Example usage:
         *
         *     Ext.Error.handle = function(err) {
         *         if (err.someProperty == 'NotReallyAnError') {
         *             // maybe log something to the application here if applicable
         *             return true;
         *         }
         *         // any non-true return value (including none) will cause the error to be thrown
         *     }
         *
         * @param {Object} err The error being raised. It will contain any attributes that were originally
         * raised with it, plus properties about the method and class from which the error originated
         * (if raised from a class that uses the Class System).
         */
        static handle(err: any);

        /**
         * This method is called internally by {@link Ext#raise}. Application code should
         * call {@link Ext#raise} instead of calling this method directly.
         *
         * @deprecated 6.0.0 Use {@link Ext#raise} instead.
         */
        static raise();
    }

    export class Evented extends Ext.Base {
        constructor(config: Ext.util.GeolocationConfig);
    }

    interface FactoryConfig {
        /**
         * The prefix to apply to 'type' values to form a complete alias. This defaults to the
         * proper value in most all cases and should not need to be specified.
         *
         * @since 5.0.0
         *
         * Optional
         */
        aliasPrefix?: string;

        /**
         * The config property to set when the factory is given a config that is a string.
         *
         * @since 5.0.0
         *
         * Optional, Defaults to: "type"
         */
        defaultProperty?: string;

        /**
         * An optional type to use if none is given to the factory at invocation. This is a
         * suffix added to the 'aliasPrefix'. For example, if 'aliasPrefix="layout."' and
         * 'defaultType="hbox"' the default alias is '"layout.hbox"'. This is an alternative
         * to 'xclass' so only one should be provided.
         *
         * @since 5.0.0
         *
         * Optional, Defaults to: null
         */
        defaultType?: string;

        /**
         * The property that identifies an object as instance vs a config.
         *
         * @since 5.0.0
         *
         * Optional, Defaults to: "isInstance"
         */
        instanceProp?: string;

        /**
         * The full classname of the type of instance to create when none is provided to the
         * factory. This is an alternative to 'defaultType' so only one should be specified.
         *
         * @since 5.0.0
         *
         * Optional, Defaults to: null
         */
        xclass?: string;
    }

    /**
     * Manages factories for families of classes (classes with a common 'alias' prefix). The
     * factory for a class family is a function stored as a 'static' on 'Ext.Factory'. These
     * are created either by directly calling 'Ext.Factory.define' or by using the
     * 'Ext.mixin.Factoryable' interface.
     *
     * To illustrate, consider the layout system's use of aliases. The 'hbox' layout maps to
     * the '"layout.hbox"' alias that one typically provides via the 'layout' config on a
     * Container.
     *
     * Under the covers this maps to a call like this:
     *
     *      Ext.Factory.layout('hbox');
     *
     * Or possibly:
     *
     *      Ext.Factory.layout({
     *          type: 'hbox'
     *      });
     *
     * The value of the 'layout' config is passed to the 'Ext.Factory.layout' function. The
     * exact signature of a factory method matches '{@link Ext.Factory#create}'.
     *
     * To define this factory directly, one could call 'Ext.Factory.define' like so:
     *
     *      Ext.Factory.define('layout', 'auto');  // "layout.auto" is the default type
     *
     * @since 5.0.0
     */
    export class Factory implements Ext.FactoryConfig {
        /**
         * The prefix to apply to 'type' values to form a complete alias. This defaults to the
         * proper value in most all cases and should not need to be specified.
         *
         * @since 5.0.0
         *
         * Optional
         */
        aliasPrefix: string;

        /**
         * The config property to set when the factory is given a config that is a string.
         *
         * @since 5.0.0
         *
         * Optional, Defaults to: "type"
         */
        defaultProperty: string;

        /**
         * An optional type to use if none is given to the factory at invocation. This is a
         * suffix added to the 'aliasPrefix'. For example, if 'aliasPrefix="layout."' and
         * 'defaultType="hbox"' the default alias is '"layout.hbox"'. This is an alternative
         * to 'xclass' so only one should be provided.
         *
         * @since 5.0.0
         *
         * Optional, Defaults to: null
         */
        defaultType: string;

        /**
         * The property that identifies an object as instance vs a config.
         *
         * @since 5.0.0
         *
         * Optional, Defaults to: "isInstance"
         */
        instanceProp: string;

        /**
         * The full classname of the type of instance to create when none is provided to the
         * factory. This is an alternative to 'defaultType' so only one should be specified.
         *
         * @since 5.0.0
         *
         * Optional, Defaults to: null
         */
        xclass: string;

        /**
         * Creates an instance of this class family given configuration options.
         *
         * @param {Object/String} [config] The configuration or instance (if an Object) or
         * just the type (if a String) describing the instance to create.
         * @param {String} [config.xclass] The full class name of the class to create.
         * @param {String} [config.type] The type string to add to the alias prefix for this
         * factory.
         * @param {String} [defaultType] The type to create if no type is contained in the
         * 'config'.
         * @return {Object} The newly created instance.
         *
         * @since 5.0.0
         */
        create(config?: string|Ext.FactoryConfig, config_xclass?: string, config_type?: string, defaultType?: string): any;

        /**
         * Returns an instance of an ID generator based on the ID you pass in.
         * @return {Object} Ext.data.identifier.* The data identifier
         */
        dataIdentifier(id: string): any;

        /**
         * For example, the layout alias family could be defined like this:
         *
         *      Ext.Factory.define('layout', {
         *          defaultType: 'auto'
         *      });
         *
         * To define multiple families at once:
         *
         *      Ext.Factory.define({
         *          layout: {
         *              defaultType: 'auto'
         *          }
         *      });
         *
         * @param {String} type The alias prefix for type (e.g., "layout.").
         * @param {Object/String} [config] An object specifying the config for the 'Ext.Factory'
         * to be created. If a string is passed it is treated as the 'defaultType'.
         * @return {Function}
         * @since 5.0.0
         */
        static define(type: string, config?: string|Ext.FactoryConfig): Function;
    }

    /**
     * A simple class to verify if a browser feature exists or not on the current device.
     *
     *     if (Ext.feature.has.Canvas) {
     *         // do some cool things with canvas here
     *     }
     *
     * See the {@link #has} property/method for details of the features that can be detected.
     */
    export class feature {
        /**
         * Verifies if a browser feature exists or not on the current device.
         *
         * A "hybrid" property, can be either accessed as a method call, i.e:
         *
         *     if (Ext.feature.has('Canvas')) {
         *         // ...
         *     }
         *
         * or as an object with boolean properties, i.e:
         *
         *     if (Ext.feature.has.Canvas) {
         *         // ...
         *     }
         *
         * For possible properties/parameter values see 'Ext.supports'.
         *
         * @param {String} name The feature name to check.
         * @return {Boolean}
         */
        static has(name: string): boolean;
    }

    /**
     * A collection of useful static methods to deal with function callbacks.
     */
    export class Function {
        /**
         * Create an alias to the provided method property with name 'methodName' of 'object'.
         * Note that the execution scope will still be bound to the provided 'object' itself.
         *
         * @return {Function} aliasFn
         */
        static alias(object: any|Function, methodName: string): Function;

        /**
         * Create a new function from the provided 'fn', change 'this' to the provided scope,
         * optionally overrides arguments for the call. Defaults to the arguments passed by
         * the caller.
         *
         * {@link Ext#bind Ext.bind} is alias for {@link Ext.Function#bind Ext.Function.bind}
         *
         * **NOTE:** This method is deprecated. Use the standard 'bind' method of JavaScript
         * 'Function' instead:
         *
         *      function foo () {
         *          ...
         *      }
         *
         *      var fn = foo.bind(this);
         *
         * This method is unavailable natively on IE8 and IE/Quirks but Ext JS provides a
         * "polyfill" to emulate the important features of the standard 'bind' method. In
         * particular, the polyfill only provides binding of "this" and optional arguments.
         *
         * @param {Function} fn The function to delegate.
         * @param {Object} scope (optional) The scope ('this' reference) in which the function is executed.
         * **If omitted, defaults to the default global environment object (usually the browser window).**
         * @param {Array} args (optional) Overrides arguments for the call. (Defaults to the arguments passed by the caller)
         * @param {Boolean/Number} appendArgs (optional) if True args are appended to call args instead of overriding,
         * if a number the args are inserted at the specified position.
         * @return {Function} The new function.
         */
        static bind(fn: Function, scope: any, args: any[], appendArgs: boolean|number): Function;

        /**
         * Captures the given parameters for a later call to 'Ext.callback'. This binding is
         * most useful for resolving scopes for example to an 'Ext.app.ViewController'.
         *
         * The arguments match that of 'Ext.callback' except for the 'args' which, if provided
         * to this method, are prepended to any arguments supplied by the eventual caller of
         * the returned function.
         *
         * @return {Function} A function that, when called, uses 'Ext.callback' to call the
         * captured 'callback'.
         * @since 5.0.0
         */
        static bindCallback(): Function;

        /**
         * Create a "clone" of the provided method. The returned method will call the given
         * method passing along all arguments and the "this" pointer and return its result.
         *
         * @return {Function} cloneFn
         */
        static clone(method: Function): Function;

        /**
         * Wraps the passed function in a barrier function which will call the passed function after the passed number of invocations.
         * @param {Number} count The number of invocations which will result in the calling of the passed function.
         * @param {Function} fn The function to call after the required number of invocations.
         * @param {Object} scope The scope ('this' reference) in which the function will be called.
         */
        static createBarrier(count: number, fn: Function, scope: any);

        /**
         * Creates a delegate function, optionally with a bound scope which, when called, buffers
         * the execution of the passed function for the configured number of milliseconds.
         * If called again within that period, the impending invocation will be canceled, and the
         * timeout period will begin again.
         *
         * @param {Function} fn The function to invoke on a buffered timer.
         * @param {Number} buffer The number of milliseconds by which to buffer the invocation of the
         * function.
         * @param {Object} [scope] The scope ('this' reference) in which.
         * the passed function is executed. If omitted, defaults to the scope specified by the caller.
         * @param {Array} [args] Override arguments for the call. Defaults to the arguments
         * passed by the caller.
         * @return {Function} A function which invokes the passed function after buffering for the specified time.
         */
        static createBuffered(fn: Function, buffer: number, scope?: any, args?: any[]): Function;

        /**
         * Creates a delegate (callback) which, when called, executes after a specific delay.
         *
         * @param {Function} fn The function which will be called on a delay when the returned function is called.
         * Optionally, a replacement (or additional) argument list may be specified.
         * @param {Number} delay The number of milliseconds to defer execution by whenever called.
         * @param {Object} scope (optional) The scope ('this' reference) used by the function at execution time.
         * @param {Array} args (optional) Override arguments for the call. (Defaults to the arguments passed by the caller)
         * @param {Boolean/Number} appendArgs (optional) if True args are appended to call args instead of overriding,
         * if a number the args are inserted at the specified position.
         * @return {Function} A function which, when called, executes the original function after the specified delay.
         */
        static createDelayed(fn: Function, delay: number, scope: any, args: any[], appendArgs: boolean|number): Function;

        /**
         * Creates an interceptor function. The passed function is called before the original one. If it returns false,
         * the original one is not called. The resulting function returns the results of the original function.
         * The passed function is called with the parameters of the original function. Example usage:
         *
         *     var sayHi = function(name){
         *         alert('Hi, ' + name);
         *     };
         *
         *     sayHi('Fred'); // alerts "Hi, Fred"
         *
         *     // create a new function that validates input without
         *     // directly modifying the original function:
         *     var sayHiToFriend = Ext.Function.createInterceptor(sayHi, function(name){
         *         return name === 'Brian';
         *     });
         *
         *     sayHiToFriend('Fred');  // no alert
         *     sayHiToFriend('Brian'); // alerts "Hi, Brian"
         *
         * @param {Function} origFn The original function.
         * @param {Function} newFn The function to call before the original.
         * @param {Object} [scope] The scope ('this' reference) in which the passed function is executed.
         * **If omitted, defaults to the scope in which the original function is called or the browser window.**
         * @param {Object} [returnValue=null] The value to return if the passed function return 'false'.
         * @return {Function} The new function.
         */
        static createInterceptor(origFn: Function, newFn: Function, scope?: any, returnValue?: any): Function;

        /**
         * Create a combined function call sequence of the original function + the passed function.
         * The resulting function returns the results of the original function.
         * The passed function is called with the parameters of the original function. Example usage:
         *
         *     var sayHi = function(name){
         *         alert('Hi, ' + name);
         *     };
         *
         *     sayHi('Fred'); // alerts "Hi, Fred"
         *
         *     var sayGoodbye = Ext.Function.createSequence(sayHi, function(name){
         *         alert('Bye, ' + name);
         *     });
         *
         *     sayGoodbye('Fred'); // both alerts show
         *
         * @param {Function} originalFn The original function.
         * @param {Function} newFn The function to sequence.
         * @param {Object} [scope] The scope ('this' reference) in which the passed function is executed.
         * If omitted, defaults to the scope in which the original function is called or the
         * default global environment object (usually the browser window).
         * @return {Function} The new function.
         */
        static createSequence(originalFn: Function, newFn: Function, scope?: any): Function;

        /**
         * Creates a throttled version of the passed function which, when called repeatedly and
         * rapidly, invokes the passed function only after a certain interval has elapsed since the
         * previous invocation.
         *
         * This is useful for wrapping functions which may be called repeatedly, such as
         * a handler of a mouse move event when the processing is expensive.
         *
         * @param {Function} fn The function to execute at a regular time interval.
         * @param {Number} interval The interval in milliseconds on which the passed function is executed.
         * @param {Object} [scope] The scope ('this' reference) in which
         * the passed function is executed. If omitted, defaults to the scope specified by the caller.
         * @return {Function} A function which invokes the passed function at the specified interval.
         */
        static createThrottled(fn: Function, interval: number, scope?: any): Function;

        /**
         * Calls this function after the number of milliseconds specified, optionally in a specific scope. Example usage:
         *
         *     var sayHi = function(name){
         *         alert('Hi, ' + name);
         *     }
         *
         *     // executes immediately:
         *     sayHi('Fred');
         *
         *     // executes after 2 seconds:
         *     Ext.Function.defer(sayHi, 2000, this, ['Fred']);
         *
         *     // this syntax is sometimes useful for deferring
         *     // execution of an anonymous function:
         *     Ext.Function.defer(function(){
         *         alert('Anonymous');
         *     }, 100);
         *
         * {@link Ext#defer Ext.defer} is alias for {@link Ext.Function#defer Ext.Function.defer}
         *
         * @param {Function} fn The function to defer.
         * @param {Number} millis The number of milliseconds for the 'setTimeout' call
         * (if less than or equal to 0 the function is executed immediately).
         * @param {Object} scope (optional) The scope ('this' reference) in which the function is executed.
         * **If omitted, defaults to the browser window.**
         * @param {Array} [args] Overrides arguments for the call. Defaults to the arguments passed by the caller.
         * @param {Boolean/Number} [appendArgs=false] If 'true' args are appended to call args instead of overriding,
         * or, if a number, then the args are inserted at the specified position.
         * @return {Number} The timeout id that can be used with 'clearTimeout'.
         */
        static defer(fn: Function, millis: number, scope: any, args?: any[], appendArgs?: boolean|number): number;

        /**
         * A very commonly used method throughout the framework. It acts as a wrapper around another method
         * which originally accepts 2 arguments for 'name' and 'value'.
         * The wrapped function then allows "flexible" value setting of either:
         *
         * - 'name' and 'value' as 2 arguments
         * - one single object argument with multiple key - value pairs
         *
         * For example:
         *
         *     var setValue = Ext.Function.flexSetter(function(name, value) {
         *         this[name] = value;
         *     });
         *
         *     // Afterwards
         *     // Setting a single name - value
         *     setValue('name1', 'value1');
         *
         *     // Settings multiple name - value pairs
         *     setValue({
         *         name1: 'value1',
         *         name2: 'value2',
         *         name3: 'value3'
         *     });
         *
         * @param {Function} setter The single value setter method.
         * @param {String} setter.name The name of the value being set.
         * @param {Object} setter.value The value being set.
         * @return {Function}
         */
        static flexSetter(setter: Function, setter_name: string, setter_value: any): Function;

        /**
         * Adds behavior to an existing method that is executed after the
         * original behavior of the function.  For example:
         *
         *     var soup = {
         *         contents: [],
         *         add: function(ingredient) {
         *             this.contents.push(ingredient);
         *         }
         *     };
         *     Ext.Function.interceptAfter(soup, "add", function(ingredient){
         *         // Always add a bit of extra salt
         *         this.contents.push("salt");
         *     });
         *     soup.add("water");
         *     soup.add("onions");
         *     soup.contents; // will contain: water, salt, onions, salt
         *
         * @param {Object} object The target object
         * @param {String} methodName Name of the method to override
         * @param {Function} fn Function with the new behavior.  It will
         * be called with the same arguments as the original method.  The
         * return value of this function will be the return value of the
         * new method.
         * @param {Object} [scope] The scope to execute the interceptor function. Defaults to the object.
         * @return {Function} The new function just created.
         */
        static interceptAfter(object: any, methodName: string, fn: Function, scope?: any): Function;

        /**
         * Adds behavior to an existing method that is executed before the
         * original behavior of the function.  For example:
         *
         *     var soup = {
         *         contents: [],
         *         add: function(ingredient) {
         *             this.contents.push(ingredient);
         *         }
         *     };
         *     Ext.Function.interceptBefore(soup, "add", function(ingredient){
         *         if (!this.contents.length && ingredient !== "water") {
         *             // Always add water to start with
         *             this.contents.push("water");
         *         }
         *     });
         *     soup.add("onions");
         *     soup.add("salt");
         *     soup.contents; // will contain: water, onions, salt
         *
         * @param {Object} object The target object
         * @param {String} methodName Name of the method to override
         * @param {Function} fn Function with the new behavior.  It will
         * be called with the same arguments as the original method.  The
         * return value of this function will be the return value of the
         * new method.
         * @param {Object} [scope] The scope to execute the interceptor function. Defaults to the object.
         * @return {Function} The new function just created.
         */
        static interceptBefore(object: any, methodName: string, fn: Function, scope?: any): Function;

        /**
         * Calls this function repeatedly at a given interval, optionally in a specific scope.
         *
         * {@link Ext#defer Ext.defer} is alias for {@link Ext.Function#defer Ext.Function.defer}
         *
         * @param {Function} fn The function to defer.
         * @param {Number} millis The number of milliseconds for the 'setInterval' call
         * @param {Object} scope (optional) The scope ('this' reference) in which the function is executed.
         * **If omitted, defaults to the browser window.**
         * @param {Array} [args] Overrides arguments for the call. Defaults to the arguments passed by the caller.
         * @param {Boolean/Number} [appendArgs=false] If 'true' args are appended to call args instead of overriding,
         * or, if a number, then the args are inserted at the specified position.
         * @return {Number} The interval id that can be used with 'clearInterval'.
         */
        static interval(fn: Function, millis: number, scope: any, args?: any[], appendArgs?: boolean|number): number;

        /**
         * Returns a wrapper function that caches the return value for previously
         * processed function argument(s).
         *
         * For example:
         *
         *      function factorial (value) {
         *          var ret = value;
         *
         *          while (--value > 1) {
         *              ret *= value;
         *          }
         *
         *          return ret;
         *      }
         *
         * Each call to 'factorial' will loop and multiply to produce the answer. Using
         * this function we can wrap the above and cache its answers:
         *
         *      factorial = Ext.Function.memoize(factorial);
         *
         * The returned function operates in the same manner as before, but results are
         * stored in a cache to avoid calling the wrapped function when given the same
         * arguments.
         *
         *      var x = factorial(20);  // first time; call real factorial()
         *      var y = factorial(20);  // second time; return value from first call
         *
         * To support multi-argument methods, you will need to provide a 'hashFn'.
         *
         *      function permutation (n, k) {
         *          return factorial(n) / factorial(n - k);
         *      }
         *
         *      permutation = Ext.Function.memoize(permutation, null, function (n, k) {
         *          n + '-' + k;
         *      });
         *
         * In this case, the 'memoize' of 'factorial' is sufficient optimization, but the
         * example is simply to illustrate how to generate a unique key for an expensive,
         * multi-argument method.
         *
         * **IMPORTANT**: This cache is unbounded so be cautious of memory leaks if the
         * 'memoize'd function is kept indefinitely or is given an unbounded set of
         * possible arguments.
         *
         * @param {Function} fn Function to wrap.
         * @param {Object} scope Optional scope in which to execute the wrapped function.
         * @param {Function} hashFn Optional function used to compute a hash key for
         * storing the result, based on the arguments to the original function.
         * @return {Function} The caching wrapper function.
         * @since 6.0.0
         */
        static memoize(fn: Function, scope: any, hashFn: Function): Function;

        /**
         * Create a new function from the provided 'fn', the arguments of which are pre-set to 'args'.
         * New arguments passed to the newly created callback when it's invoked are appended after the pre-set ones.
         * This is especially useful when creating callbacks.
         *
         * For example:
         *
         *     var originalFunction = function(){
         *         alert(Ext.Array.from(arguments).join(' '));
         *     };
         *
         *     var callback = Ext.Function.pass(originalFunction, ['Hello', 'World']);
         *
         *     callback(); // alerts 'Hello World'
         *     callback('by Me'); // alerts 'Hello World by Me'
         *
         * {@link Ext#pass Ext.pass} is alias for {@link Ext.Function#pass Ext.Function.pass}
         *
         * @param {Function} fn The original function.
         * @param {Array} args The arguments to pass to new callback.
         * @param {Object} scope (optional) The scope ('this' reference) in which the function is executed.
         * @return {Function} The new callback function.
         */
        static pass(fn: Function, args: any[], scope: any): Function;
    }

    /**
     * An '{@link Ext.mixin.Observable Observable}' through which Ext fires global events.
     *
     * Ext.on() and Ext.un() are shorthand for {@link #addListener} and {@link #removeListener}
     * on this Observable.  For example, to listen for the idle event:
     *
     *     Ext.on('idle', function() {
     *         // do something
     *     });
     */
    export class GlobalEvents {
        /**
         * Fires when a Component is added to a Container.
         */
        static added(component: Ext.Component);

        /**
         * Fires before {@link Ext.mixin.Responsive} perform any updates in response to
         * dynamic changes. This is prior to refreshing 'responsiveFormulas'.
         * @param {Object} context The context object used by 'responsiveConfig' expressions.
         * @since 5.0.1
         */
        static beforeresponsiveupdate(context: any);

        /**
         * Fires when {@link Ext.mixin.Responsive} is about to perform updates in response to
         * dynamic changes. At this point all 'responsiveFormulas' have been refreshed.
         * @param {Object} context The context object used by 'responsiveConfig' expressions.
         * @since 5.0.1
         */
        static beginresponsiveupdate(context: any);

        /**
         * Fires when a Component is collapsed (e.g., a panel).
         */
        static collapse(component: Ext.Component);

        /**
         * Fires when a Component is expanded (e.g., a panel).
         */
        static expand(component: Ext.Component);

        /**
         * Fires when a Component is hidden.
         */
        static hide(component: Ext.Component);

        /**
         * Fires when an event handler finishes its run, just before returning to
         * browser control.
         *
         * This includes DOM event handlers, Ajax (including JSONP) event handlers,
         * and {@link Ext.util.TaskRunner TaskRunners}
         *
         * When called at the tail of a DOM event, the event object is passed as the
         * sole parameter.
         *
         * This can be useful for performing cleanup, or update tasks which need to
         * happen only after all code in an event handler has been run, but which
         * should not be executed in a timer due to the intervening browser
         * reflow/repaint which would take place.
         */
        static idle();

        /**
         * A mousedown listener on the document that is immune to stopPropagation()
         * used in cases where we need to know if a mousedown event occurred on the
         * document regardless of whether some other handler tried to stop it.  An
         * example where this is useful is a menu that needs to be hidden whenever
         * there is a mousedown event on the document.
         * @param {Ext.event.Event} e The event object
         */
        static mousedown(e: Ext.event.Event);

        /**
         * Fires when a Component is removed from a Container.
         */
        static removed(component: Ext.Component);

        /**
         * Fires when the browser window is resized.  To avoid running resize handlers
         * too often resulting in sluggish window resizing, resize events use a buffer
         * of 100 milliseconds.
         * @param {Number} width The new width
         * @param {Number} height The new height
         */
        static resize(width: number, height: number);

        /**
         * Fires after {@link Ext.mixin.Responsive} has performed updates in response to
         * dynamic changes.
         * @param {Object} context The context object used by 'responsiveConfig' expressions.
         * @since 5.0.1
         */
        static responsiveupdate(context: any);

        /**
         * Fires when a Component is shown.
         */
        static show(component: Ext.Component);
    }

    interface ImgConfig extends Ext.ComponentConfig {
        /**
         * The CSS class to be used when {@link #mode} is set to 'background'
         */
        backgroundCls?: string;

        baseCls?: any;

        /**
         * The CSS class to be used when {@link #mode} is not set to 'background'
         */
        imageCls?: string;

        /**
         * If set to 'background', uses a background-image CSS property instead of an
         * '<img>' tag to display the image.
         */
        mode?: string;

        /**
         * The source of this image. See {@link Ext#resolveResource} for
         * details on locating application resources.
         */
        src?: string;
    }

    /**
     * This is a simple way to add an image of any size to your application and have it participate in the layout system
     * like any other component. This component typically takes between 1 and 3 configurations - a {@link #src}, and
     * optionally a {@link #height} and a {@link #width}:
     *
     *     @example miniphone
     *     var img = Ext.create('Ext.Img', {
     *         src: 'http://www.sencha.com/assets/images/sencha-avatar-64x64.png',
     *         height: 64,
     *         width: 64
     *     });
     *     Ext.Viewport.add(img);
     *
     * It's also easy to add an image into a panel or other container using its xtype:
     *
     *     @example miniphone
     *     Ext.create('Ext.Panel', {
     *         fullscreen: true,
     *         layout: 'hbox',
     *         items: [
     *             {
     *                 xtype: 'image',
     *                 src: 'http://www.sencha.com/assets/images/sencha-avatar-64x64.png',
     *                 flex: 1
     *             },
     *             {
     *                 xtype: 'panel',
     *                 flex: 2,
     *                 html: 'Sencha Inc.<br/>1700 Seaport Boulevard Suite 120, Redwood City, CA'
     *             }
     *         ]
     *     });
     *
     * Here we created a panel which contains an image (a profile picture in this case) and a text area to allow the user
     * to enter profile information about themselves. In this case we used an {@link Ext.layout.HBox hbox layout} and
     * flexed the image to take up one third of the width and the text area to take two thirds of the width. See the
     * {@link Ext.layout.HBox hbox docs} for more information on flexing items.
     */
    export class Img extends Ext.Component implements Ext.ImgConfig {
        /**
         * The CSS class to be used when {@link #mode} is set to 'background'
         */
        backgroundCls: string;

        /**
         * The base CSS class to apply to this component's element. This will also be prepended to
         * other elements within this component. To add specific styling for sub-classes, use the {@link #cls} config.
         */
        baseCls: string;

        /**
         * The CSS class to be used when {@link #mode} is not set to 'background'
         */
        imageCls: string;

        /**
         * If set to 'background', uses a background-image CSS property instead of an
         * '<img>' tag to display the image.
         */
        mode: string;

        /**
         * The source of this image. See {@link Ext#resolveResource} for
         * details on locating application resources.
         */
        src: string;

        /**
         * Creates new Component.
         * @param {Object} config The standard configuration object.
         */
        constructor(config: Ext.ButtonConfig);

        destroy();

        getBackgroundCls();

        getBaseCls();

        getImageCls();

        getMode();

        getSrc();

        protected initialize();

        setBackgroundCls();

        setBaseCls();

        setImageCls();

        setMode();

        setSrc();

        /**
         * Fires if an error occured when trying to load the image
         * @param {Ext.Img} this The Image instance
         * @param {Ext.event.Event} e The event object
         */
        error(that: Ext.Img, e: Ext.event.Event);

        /**
         * Fires when the image is loaded
         * @param {Ext.Img} this The Image instance
         * @param {Ext.event.Event} e The event object
         */
        load(that: Ext.Img, e: Ext.event.Event);

        /**
         * Fires whenever the component is tapped
         * @param {Ext.Img} this The Image instance
         * @param {Ext.event.Event} e The event object
         */
        tap(that: Ext.Img, e: Ext.event.Event);
    }

    export class Inventory {
        /**
         * Get the aliases of a class by the class name
         *
         * @return {Array} aliases
         */
        getAliasesByName(name: string): any[];

        /**
         * Get the name of a class by its alias.
         *
         * @return {String} className
         */
        getNameByAlias(alias: string): string;

        /**
         * Get the name of a class by its alternate name.
         *
         * @return {String} className
         */
        getNameByAlternate(alternate: string): string;

        /**
         * Converts a string expression to an array of matching class names. An expression can
         * either refers to class aliases or class names. Expressions support wildcards:
         *
         *      // returns ['Ext.window.Window']
         *     var window = Ext.ClassManager.getNamesByExpression('widget.window');
         *
         *     // returns ['widget.panel', 'widget.window', ...]
         *     var allWidgets = Ext.ClassManager.getNamesByExpression('widget.*');
         *
         *     // returns ['Ext.data.Store', 'Ext.data.ArrayProxy', ...]
         *     var allData = Ext.ClassManager.getNamesByExpression('Ext.data.*');
         *
         * @param {Object} [exclude=null] An object keyed by class name containing classes to
         * exclude from the returned classes. This must be provided if 'accumulate' is set to
         * 'true'.
         * @param {Boolean} [accumulate=false] Pass 'true' to add matching classes to the
         * specified 'exclude' object.
         * @return {String[]} An array of class names.
         */
        getNamesByExpression(expression: string, exclude?: any, accumulate?: boolean): string;

        /**
         * This method returns a selector object that produces a selection of classes and
         * delivers them to the desired 'receiver'.
         *
         * The returned selector object has the same methods as the given 'receiver' object
         * but these methods on the selector accept a first argument that expects a pattern
         * or array of patterns. The actual method on the 'receiver' will be called with an
         * array of classes that match these patterns but with any patterns passed to an
         * 'exclude' call removed.
         *
         * For example:
         *
         *      var sel = inventory.select({
         *              require: function (classes) {
         *                  console.log('Classes: ' + classes.join(','));
         *              }
         *          });
         *
         *      sel.exclude('Ext.chart.*').exclude('Ext.draw.*').require('*');
         *
         *      // Logs all classes except those in the Ext.chart and Ext.draw namespaces.
         *
         * @param {Object} [scope] Optional scope to use when calling 'receiver' methods.
         * @return {Object} An object with the same methods as 'receiver' plus 'exclude'.
         */
        select(receiver: any, scope?: any): any;

        /**
         * Sets the path of a namespace.
         * For Example:
         *
         *      inventory.setPath('Ext', '.');
         *      inventory.setPath({
         *          Ext: '.'
         *      });
         *
         * @param {String/Object} name The name of a single mapping or an object of mappings.
         * @param {String} [path] If 'name' is a String, then this is the path for that name.
         * Otherwise this parameter is ignored.
         * @return {Ext.Inventory} this
         */
        setPath(name: string|any, path?: string): Ext.Inventory;
    }

    /**
     * Modified version of [Douglas Crockford's JSON.js][dc] that doesn't
     * mess with the Object prototype.
     *
     * [dc]: http://www.json.org/js.html
     */
    export class JSON {
        /**
         * Decodes (parses) a JSON string to an object. If the JSON is invalid, this function throws
         * a SyntaxError unless the safe option is set.
         *
         * @param {String} json The JSON string.
         * @param {Boolean} [safe=false] 'true' to return null, otherwise throw an exception
         * if the JSON is invalid.
         * @return {Object} The resulting object.
         */
        static decode(json: string, safe?: boolean): any;

        /**
         * Encodes an Object, Array or other value.
         *
         * If the environment's native JSON encoding is not being used ({@link Ext#USE_NATIVE_JSON} is not set,
         * or the environment does not support it), then ExtJS's encoding will be used. This allows the developer
         * to add a 'toJSON' method to their classes which need serializing to return a valid JSON representation
         * of the object.
         *
         * @param {Object} o The variable to encode.
         * @return {String} The JSON string.
         */
        static encode(o: any): string;

        /**
         * Encodes a Date. This returns the actual string which is inserted into the JSON string as the literal
         * expression. **The returned value includes enclosing double quotation marks.**
         *
         * The default return format is '"yyyy-mm-ddThh:mm:ss"'.
         *
         * To override this:
         *
         *     Ext.JSON.encodeDate = function(d) {
         *         return Ext.Date.format(d, '"Y-m-d"');
         *     };
         *
         * @param {Date} d The Date to encode
         * @return {String} The string literal to use in a JSON string.
         */
        static encodeDate(d: Date): string;

        /**
         * Encodes a String. This returns the actual string which is inserted into the JSON string as the literal
         * expression. **The returned value includes enclosing double quotation marks.**
         *
         * To override this:
         *
         *     Ext.JSON.encodeString = function(s) {
         *         return 'Foo' + s;
         *     };
         *
         * @param {String} s The String to encode
         * @return {String} The string literal to use in a JSON string.
         */
        static encodeString(s: string): string;

        /**
         * The function which {@link #encode} uses to encode all javascript values to their JSON representations
         * when {@link Ext#USE_NATIVE_JSON} is 'false'.
         *
         * This is made public so that it can be replaced with a custom implementation.
         *
         * @param {Object} o Any javascript value to be converted to its JSON representation
         * @return {String} The JSON representation of the passed value.
         */
        static encodeValue(o: any): string;
    }

    interface LabelConfig extends Ext.ComponentConfig {
        baseCls?: any;
    }

    /**
     * A simple label component which allows you to insert content using {@link #html} configuration.
     *
     *     @example miniphone
     *     Ext.Viewport.add({
     *         xtype: 'label',
     *         html: 'My label!'
     *     });
     */
    export class Label extends Ext.Component implements Ext.LabelConfig {
        baseCls: string;

        /**
         * Creates new Component.
         * @param {Object} config The standard configuration object.
         */
        constructor(config: Ext.ButtonConfig);

        getBaseCls();

        setBaseCls();
    }

    /**
     * This class provides dynamic loading support for JavaScript classes. Application code
     * does not typically need to call 'Ext.Loader' except perhaps to configure path mappings
     * when not using [Sencha Cmd](http://www.sencha.com/products/sencha-cmd/).
     *
     *      Ext.Loader.setPath('MyApp', 'app');
     *
     * When using Sencha Cmd, this is handled by the "bootstrap" provided by the application
     * build script and such configuration is not necessary.
     *
     * # Typical Usage
     *
     * The 'Ext.Loader' is most often used behind the scenes to satisfy class references in
     * class declarations. Like so:
     *
     *      Ext.define('MyApp.view.Main', {
     *          extend: 'Ext.panel.Panel',
     *
     *          mixins: [
     *              'MyApp.util.Mixin'
     *          ],
     *
     *          requires: [
     *              'Ext.grid.Panel'
     *          ],
     *
     *          uses: [
     *              'MyApp.util.Stuff'
     *          ]
     *      });
     *
     * In all of these cases, 'Ext.Loader' is used internally to resolve these class names
     * and ensure that the necessary class files are loaded.
     *
     * During development, these files are loaded individually for optimal debugging. For a
     * production use, [Sencha Cmd](http://www.sencha.com/products/sencha-cmd/) will replace
     * all of these strings with the actual resolved class references because it ensures that
     * the classes are all contained in the build in the correct order. In development, these
     * files will not be loaded until the 'MyApp.view.Main' class indicates they are needed
     * as shown above.
     *
     * # Loading Classes
     *
     * You can also use 'Ext.Loader' directly to load classes or files. The simplest form of
     * use is '{@link Ext#require}'.
     *
     * For example:
     *
     *      Ext.require('MyApp.view.Main', function () {
     *          // On callback, the MyApp.view.Main class is now loaded
     *
     *          var view = new MyApp.view.Main();
     *      });
     *
     * You can alternatively require classes by alias or wildcard.
     *
     *     Ext.require('widget.window');
     *
     *     Ext.require(['widget.window', 'layout.border', 'Ext.data.Connection']);
     *
     *     Ext.require(['widget.*', 'layout.*', 'Ext.data.*']);
     *
     * The callback function is optional.
     *
     * **Note** Using 'Ext.require' at global scope will cause '{@link Ext#onReady}' and
     * '{@link Ext.app.Application#launch}' methods to be deferred until the required classes
     * are loaded. It is these cases where the callback function is most often unnecessary.
     *
     * ## Using Excludes
     *
     * Alternatively, you can exclude what you don't need:
     *
     *     // Include everything except Ext.tree.*
     *     Ext.exclude('Ext.tree.*').require('*');
     *
     *     // Include all widgets except widget.checkbox* (this will exclude
     *     // widget.checkbox, widget.checkboxfield, widget.checkboxgroup, etc.)
     *     Ext.exclude('widget.checkbox*').require('widget.*');
     *
     * # Dynamic Instantiation
     *
     * Another feature enabled by 'Ext.Loader' is instantiation using class names or aliases.
     *
     * For example:
     *
     *      var win = Ext.create({
     *          xtype: 'window',
     *
     *          // or
     *          // xclass: 'Ext.window.Window'
     *
     *          title: 'Hello'
     *      });
     *
     * This form of creation can be useful if the type to create ('window' in the above) is
     * not known statically. Internally, '{@link Ext#create}' may need to *synchronously*
     * load the desired class and its requirements. Doing this will generate a warning in
     * the console:
     *
     *      [Ext.Loader] Synchronously loading 'Ext.window.Window'...
     *
     * If you see these in your debug console, you should add the indicated class(es) to the
     * appropriate 'requires' array (as above) or make an '{@link Ext#require}' call.
     *
     *
     * **Note** Using '{@link Ext#create}' has some performance overhead and is best reserved
     * for cases where the target class is not known until run-time.
     */
    export class Loader {
        /**
         * An array of class names to keep track of the dependency loading order.
         * This is not guaranteed to be the same everytime due to the asynchronous
         * nature of the Loader.
         */
        static history: any[];

        /**
         * Appends current timestamp to script files to prevent caching.
         *
         * Optional, Defaults to: true
         */
        static disableCaching: boolean;

        /**
         * The get parameter name for the cache buster's timestamp.
         *
         * Optional, Defaults to: "_dc"
         */
        static disableCachingParam: string;

        /**
         * Whether or not to enable the dynamic dependency loading feature.
         *
         * Optional, Defaults to: true
         */
        static enabled: boolean;

        /**
         * The mapping from namespaces to file paths
         *
         *     {
         *         'Ext': '.', // This is set by default, Ext.layout.container.Container will be
         *                     // loaded from ./layout/Container.js
         *
         *         'My': './src/my_own_folder' // My.layout.Container will be loaded from
         *                                     // ./src/my_own_folder/layout/Container.js
         *     }
         *
         * Note that all relative paths are relative to the current HTML document.
         * If not being specified, for example, 'Other.awesome.Class' will simply be
         * loaded from '"./Other/awesome/Class.js"'.
         */
        static paths: any;

        /**
         * 'false' to remove asynchronously loaded scripts, 'true' to retain script
         * element for browser debugger compatibility and improved load performance.
         */
        static preserveScripts: boolean;

        /**
         * millisecond delay between asynchronous script injection (prevents stack
         * overflow on some user agents) 'false' disables delay but potentially
         * increases stack load.
         *
         * Optional, Defaults to: false
         */
        static scriptChainDelay: boolean;

        /**
         * Optional charset to specify encoding of dynamic script content.
         */
        static scriptCharset: string;

        /**
         * fixes up loader path configs by prepending Ext.Boot#baseUrl to the beginning
         * of the path, then delegates to Ext.Loader#addClassPathMappings
         */
        static addBaseUrlClassPathMappings();

        /**
         * Sets a batch of path entries
         *
         * @param {Object} paths a set of className: path mappings
         * @return {Ext.Loader} this
         */
        static addClassPathMappings(paths: any): Ext.Loader;

        /**
         * Get the config value corresponding to the specified name. If no name is given, will return the config object
         * @param {String} name The config property name
         * @return {Object}
         */
        static getConfig(name: string): any;

        /**
         * Translates a className to a file path by adding the
         * the proper prefix and converting the .'s to /'s. For example:
         *
         *     Ext.Loader.setPath('My', '/path/to/My');
         *
         *     alert(Ext.Loader.getPath('My.awesome.Class')); // alerts '/path/to/My/awesome/Class.js'
         *
         * Note that the deeper namespace levels, if explicitly set, are always resolved first. For example:
         *
         *     Ext.Loader.setPath({
         *         'My': '/path/to/lib',
         *         'My.awesome': '/other/path/for/awesome/stuff',
         *         'My.awesome.more': '/more/awesome/path'
         *     });
         *
         *     alert(Ext.Loader.getPath('My.awesome.Class')); // alerts '/other/path/for/awesome/stuff/Class.js'
         *
         *     alert(Ext.Loader.getPath('My.awesome.more.Class')); // alerts '/more/awesome/path/Class.js'
         *
         *     alert(Ext.Loader.getPath('My.cool.Class')); // alerts '/path/to/lib/cool/Class.js'
         *
         *     alert(Ext.Loader.getPath('Unknown.strange.Stuff')); // alerts 'Unknown/strange/Stuff.js'
         *
         * @return {String} path
         */
        static getPath(className: string): string;

        /**
         * Loads the specified script URL and calls the supplied callbacks. If this method
         * is called before {@link Ext#isReady}, the script's load will delay the transition
         * to ready. This can be used to load arbitrary scripts that may contain further
         * {@link Ext#require Ext.require} calls.
         *
         * @param {Object/String/String[]} options The options object or simply the URL(s) to load.
         * @param {String} options.url The URL from which to load the script.
         * @param {Function} [options.onLoad] The callback to call on successful load.
         * @param {Function} [options.onError] The callback to call on failure to load.
         * @param {Object} [options.scope] The scope ('this') for the supplied callbacks.
         */
        static loadScript(options: any|string, options_url: string, options_onLoad?: Function, options_onError?: Function, options_scope?: any);

        /**
         * Add a new listener to be executed when all required scripts are fully loaded
         *
         * @param {Function} fn The function callback to be executed
         * @param {Object} scope The execution scope ('this') of the callback function.
         * @param {Boolean} [withDomReady=true] Pass 'false' to not also wait for document
         * dom ready.
         * @param {Object} [options] Additional callback options.
         * @param {Number} [options.delay=0] A number of milliseconds to delay.
         * @param {Number} [options.priority=0] Relative priority of this callback. Negative
         * numbers are reserved.
         */
        static onReady(fn: Function, scope: any, withDomReady?: boolean, options?: any, options_delay?: number, options_priority?: number);

        /**
         * Set the configuration for the loader. This should be called right after ext-(debug).js
         * is included in the page, and before Ext.onReady. i.e:
         *
         *     <script type="text/javascript" src="ext-core-debug.js"></script>
         *     <script type="text/javascript">
         *         Ext.Loader.setConfig({
         *           enabled: true,
         *           paths: {
         *               'My': 'my_own_path'
         *           }
         *         });
         *     </script>
         *     <script type="text/javascript">
         *         Ext.require(...);
         *
         *         Ext.onReady(function() {
         *           // application code here
         *         });
         *     </script>
         *
         * Refer to config options of {@link Ext.Loader} for the list of possible properties
         *
         * @param {Object} config The config object to override the default values
         * @return {Ext.Loader} this
         */
        static setConfig(config: any): Ext.Loader;

        /**
         * Sets the path of a namespace.
         * For Example:
         *
         *     Ext.Loader.setPath('Ext', '.');
         *
         * @param {String/Object} name See {@link Ext.Function#flexSetter flexSetter}
         * @param {String} [path] See {@link Ext.Function#flexSetter flexSetter}
         * @return {Ext.Loader} this
         */
        static setPath(name: string|any, path?: string): Ext.Loader;
    }

    interface LoadMaskConfig extends Ext.MaskConfig {
        /**
         * The CSS Class for this component
         */
        cls?: string;

        /**
         * True to show the loading indicator on this {@link Ext.LoadMask}.
         */
        indicator?: boolean;

        /**
         * The text to display in a centered loading message box.
         */
        message?: string;

        /**
         * The CSS class to apply to the loading message element.
         */
        messageCls?: string;
    }

    /**
     * A simple class used to mask any {@link Ext.Container}.
     *
     * This should rarely be used directly, instead look at the {@link Ext.Container#masked} configuration.
     *
     * ## Example
     *
     *     @example miniphone
     *     Ext.Viewport.add({
     *         masked: {
     *            xtype: 'loadmask'
     *         }
     *     });
     *
     * You can customize the loading {@link #message} and whether or not you want to show the {@link #indicator}:
     *
     *     @example miniphone
     *     Ext.Viewport.add({
     *         masked: {
     *            xtype: 'loadmask',
     *            message: 'A message..',
     *            indicator: false
     *         }
     *     });
     */
    export class LoadMask extends Ext.Mask implements Ext.LoadMaskConfig {
        /**
         * The CSS Class for this component
         */
        cls: string;

        /**
         * True to show the loading indicator on this {@link Ext.LoadMask}.
         */
        indicator: boolean;

        /**
         * The text to display in a centered loading message box.
         */
        message: string;

        /**
         * The CSS class to apply to the loading message element.
         */
        messageCls: string;

        /**
         * Creates new Component.
         * @param {Object} config The standard configuration object.
         */
        constructor(config: Ext.ButtonConfig);

        getCls();

        getIndicator();

        getMessage();

        getMessageCls();

        setCls();

        setIndicator();

        setMessage();

        setMessageCls();
    }

    interface MapConfig extends Ext.ContainerConfig {
        /**
         * The base CSS class to apply to the Map's element
         */
        baseCls?: string;

        /**
         * Geolocation provider for the map.
         */
        geo?: Ext.util.Geolocation;

        /**
         * The wrapped map.
         */
        map?: any;

        /**
         * Listeners for any Google Maps events specified by the Google Documentation:
         * [http://code.google.com/apis/maps/documentation/v3/reference.html](http://code.google.com/apis/maps/documentation/v3/reference.html)
         */
        mapListeners?: any;

        /**
         * MapOptions as specified by the Google Documentation:
         * [http://code.google.com/apis/maps/documentation/v3/reference.html](http://code.google.com/apis/maps/documentation/v3/reference.html)
         */
        mapOptions?: any;

        /**
         * Pass in true to center the map based on the geolocation coordinates or pass a
         * {@link Ext.util.Geolocation GeoLocation} config to have more control over your GeoLocation options
         */
        useCurrentLocation?: boolean|Ext.util.Geolocation;
    }

    /**
     * Wraps a Google Map in an Ext.Component using the [Google Maps API](http://code.google.com/apis/maps/documentation/v3/introduction.html).
     *
     * To use this component you must include an additional JavaScript file from Google:
     *
     *     <script type="text/javascript" src="http://maps.google.com/maps/api/js?sensor=true"></script>
     *
     * ## Example
     *
     *     Ext.Viewport.add({
     *         xtype: 'map',
     *         useCurrentLocation: true
     *     });
     */
    export class Map extends Ext.Container implements Ext.MapConfig {
        /**
         * The base CSS class to apply to the Map's element
         */
        baseCls: string;

        /**
         * Geolocation provider for the map.
         */
        geo: Ext.util.Geolocation;

        /**
         * The wrapped map.
         */
        map: any;

        /**
         * Listeners for any Google Maps events specified by the Google Documentation:
         * [http://code.google.com/apis/maps/documentation/v3/reference.html](http://code.google.com/apis/maps/documentation/v3/reference.html)
         */
        mapListeners: any;

        /**
         * MapOptions as specified by the Google Documentation:
         * [http://code.google.com/apis/maps/documentation/v3/reference.html](http://code.google.com/apis/maps/documentation/v3/reference.html)
         */
        mapOptions: any;

        /**
         * Pass in true to center the map based on the geolocation coordinates or pass a
         * {@link Ext.util.Geolocation GeoLocation} config to have more control over your GeoLocation options
         */
        useCurrentLocation: boolean|Ext.util.Geolocation;

        constructor();

        getBaseCls();

        getGeo();

        getMap();

        getMapListeners();

        getUseCurrentLocation();

        protected initialize();

        setBaseCls();

        setGeo();

        setMap();

        /**
         * Moves the map center to the designated coordinates hash of the form:
         *
         *     { latitude: 37.381592, longitude: -122.135672 }
         *
         * or a google.maps.LatLng object representing to the target location.
         *
         * @param {Object/google.maps.LatLng} coordinates Object representing the desired Latitude and
         * longitude upon which to center the map.
         */
        setMapCenter(coordinates: any);

        setMapListeners();

        setMapOptions();

        setUseCurrentLocation();

        /**
         * Fired when map is panned around.
         * @param {google.maps.Map} map The rendered google.map.Map instance
         * @param {google.maps.LatLng} center The current LatLng center of the map
         */
        centerchange(that: Ext.Map, map: any, center: any);

        /**
         * Fired when Map initially rendered.
         * @param {google.maps.Map} map The rendered google.map.Map instance
         */
        maprender(that: Ext.Map, map: any);

        /**
         * Fired when display type of the map changes.
         * @param {google.maps.Map} map The rendered google.map.Map instance
         * @param {Number} mapType The current display type of the map
         */
        typechange(that: Ext.Map, map: any, mapType: number);

        /**
         * Fired when map is zoomed.
         * @param {google.maps.Map} map The rendered google.map.Map instance
         * @param {Number} zoomLevel The current zoom level of the map
         */
        zoomchange(that: Ext.Map, map: any, zoomLevel: number);
    }

    interface MaskConfig extends Ext.ComponentConfig {
        baseCls?: any;

        /**
         * True to make this mask transparent.
         */
        transparent?: boolean;
    }

    /**
     * A simple class used to mask any {@link Ext.Container}.
     *
     * This should rarely be used directly, instead look at the {@link Ext.Container#masked} configuration.
     *
     * ## Example
     *
     *     @example miniphone
     *     // Create our container
     *     var container = Ext.create('Ext.Container', {
     *         html: 'My container!'
     *     });
     *
     *     // Add the container to the Viewport
     *     Ext.Viewport.add(container);
     *
     *     // Mask the container
     *     container.setMasked(true);
     */
    export class Mask extends Ext.Component implements Ext.MaskConfig {
        /**
         * The base CSS class to apply to this component's element. This will also be prepended to
         * other elements within this component. To add specific styling for sub-classes, use the {@link #cls} config.
         */
        baseCls: string;

        /**
         * True to make this mask transparent.
         */
        transparent: boolean;

        /**
         * Creates new Component.
         * @param {Object} config The standard configuration object.
         */
        constructor(config: Ext.ButtonConfig);

        getBaseCls();

        getTransparent();

        setBaseCls();

        setTransparent();

        /**
         * A tap event fired when a user taps on this mask
         * @param {Ext.Mask} this The mask instance
         * @param {Ext.EventObject} e The event object
         */
        tap(that: Ext.Mask, e: any);
    }

    interface MediaConfig extends Ext.ComponentConfig {
        /**
         * Will automatically pause the media when the container is deactivated.
         */
        autoPause?: boolean;

        /**
         * Will automatically start playing the media when the container is activated.
         */
        autoResume?: boolean;

        /**
         * Set this to 'false' to turn off the native media controls.
         * Defaults to 'false' when you are on Android, as it doesn't support controls.
         */
        enableControls?: boolean;

        /**
         * Will loop the media forever.
         */
        loop?: boolean;

        /**
         * A reference to the underlying audio/video element.
         */
        media?: Ext.dom.Element;

        /**
         * Whether or not the media is muted. This will also set the volume to zero.
         */
        muted?: boolean;

        /**
         * Will begin preloading the media immediately.
         */
        preload?: boolean;

        /**
         * Location of the media to play.
         */
        url?: string;

        /**
         * The volume of the media from 0.0 to 1.0.
         */
        volume?: number;
    }

    /**
     * Provides a base class for audio/visual controls. Should not be used directly.
     *
     * Please see the {@link Ext.Audio} and {@link Ext.Video} classes for more information.
     */
    export class Media extends Ext.Component implements Ext.MediaConfig {
        /**
         * Will automatically pause the media when the container is deactivated.
         */
        autoPause: boolean;

        /**
         * Will automatically start playing the media when the container is activated.
         */
        autoResume: boolean;

        /**
         * Set this to 'false' to turn off the native media controls.
         * Defaults to 'false' when you are on Android, as it doesn't support controls.
         */
        enableControls: boolean;

        /**
         * Will loop the media forever.
         */
        loop: boolean;

        /**
         * A reference to the underlying audio/video element.
         */
        media: Ext.dom.Element;

        /**
         * Whether or not the media is muted. This will also set the volume to zero.
         */
        muted: boolean;

        /**
         * Will begin preloading the media immediately.
         */
        preload: boolean;

        /**
         * Location of the media to play.
         */
        url: string;

        /**
         * The volume of the media from 0.0 to 1.0.
         */
        volume: number;

        constructor();

        destroy();

        getAutoPause();

        getAutoResume();

        /**
         * Returns the current time of the media, in seconds.
         * @return {Number}
         */
        getCurrentTime(): number;

        /**
         * Returns the duration of the media, in seconds.
         * @return {Number}
         */
        getDuration(): number;

        getEnableControls();

        getLoop();

        getMedia();

        getMuted();

        getPreload();

        getUrl();

        getVolume();

        protected initialize();

        /**
         * Returns if the media is currently playing.
         * @return {Boolean} playing 'true' if the media is playing.
         */
        isPlaying(): boolean;

        /**
         * Pauses media playback.
         */
        pause();

        /**
         * Starts or resumes media playback.
         */
        play();

        setAutoPause();

        setAutoResume();

        /**
         * Set the current time of the media.
         * @param {Number} time The time, in seconds.
         * @return {Number}
         */
        setCurrentTime(time: number): number;

        setEnableControls();

        setLoop();

        setMedia();

        setMuted();

        setPreload();

        setUrl();

        setVolume();

        /**
         * Stops media playback and returns to the beginning.
         */
        stop();

        /**
         * Toggles the media playback state.
         */
        toggle();

        /**
         * Updates the controls of the video element.
         */
        updateEnableControls();

        /**
         * Updates the loop setting of the media element.
         */
        updateLoop();

        /**
         * Sets the URL of the media element. If the media element already exists, it is update the src attribute of the
         * element. If it is currently playing, it will start the new video.
         */
        updateUrl();

        /**
         * Fires whenever the media playback has ended.
         * @param {Number} time The time at which the media ended at in seconds.
         */
        ended(that: Ext.Media, time: number);

        /**
         * Fires whenever the muted status is changed.
         * The volumechange event will also fire after the 'mutedchange' event fires.
         * @param {Boolean} muted The muted status.
         */
        mutedchange(that: Ext.Media, muted: boolean);

        /**
         * Fires when the media is playing every 15 to 250ms.
         * @param {Number} time The current time in seconds.
         */
        timeupdate(that: Ext.Media, time: number);

        /**
         * Fires whenever the volume is changed.
         * @param {Number} volume The volume level from 0 to 1.
         */
        volumechange(that: Ext.Media, volume: number);
    }

    interface MenuConfig extends Ext.SheetConfig {
        baseCls?: any;

        bottom?: any;

        defaultType?: any;

        height?: any;

        left?: any;

        right?: any;

        width?: any;
    }

    /**
     * {@link Ext.Menu}'s are used with {@link Ext.Viewport#setMenu}. A menu can be linked with any side of the screen (top, left, bottom or right)
     *  and will simply describe the contents of your menu. To use this menu you will call various menu related functions on the {@link Ext.Viewport}
     * such as {@link Ext.Viewport#showMenu}, {@link Ext.Viewport#hideMenu}, {@link Ext.Viewport#toggleMenu}, {@link Ext.Viewport#hideOtherMenus},
     * or {@link Ext.Viewport#hideAllMenus}.
     *
     *      @example preview
     *      var menu = Ext.create('Ext.Menu', {
     *          items: [{
     *              text: 'Settings',
     *              iconCls: 'settings'
     *          }, {
     *              text: 'New Item',
     *              iconCls: 'compose'
     *          }, {
     *              text: 'Star',
     *              iconCls: 'star'
     *          }]
     *      });
     *
     *      Ext.Viewport.add({
     *          xtype: 'panel',
     *          html: 'Main View Content'
     *      });
     *
     *      Ext.Viewport.setMenu(menu, {
     *          side: 'left',
     *          // omitting the reveal config defaults the animation to 'cover'
     *          reveal: true
     *      });
     *
     *      Ext.Viewport.showMenu('left');
     *
     * The {@link #defaultType} of a Menu item is a {@link Ext.Button button}.
     */
    export class Menu extends Ext.Sheet implements Ext.MenuConfig {
        baseCls: string;

        /**
         * The absolute bottom position of this Component; must be a valid CSS length value, e.g: '300', '100px', '30%', etc.
         * Explicitly setting this value will make this Component become 'floating', which means its layout will no
         * longer be affected by the Container that it resides in.
         */
        bottom: number|string;

        /** @cfg {String} defaultType
         * The default {@link Ext.Component xtype} of child Components to create in this Container when a child item
         * is specified as a raw configuration object, rather than as an instantiated Component.
         */
        defaultType: any;

        /**
         * The height of this Component; must be a valid CSS length value, e.g: '300', '100px', '30%', etc.
         * By default, if this is not explicitly set, this Component's element will simply have its own natural size.
         * If set to 'auto', it will set the width to 'null' meaning it will have its own natural size.
         */
        height: number|string;

        /**
         * The absolute left position of this Component; must be a valid CSS length value, e.g: '300', '100px', '30%', etc.
         * Explicitly setting this value will make this Component become 'floating', which means its layout will no
         * longer be affected by the Container that it resides in.
         */
        left: number|string;

        /**
         * The absolute right position of this Component; must be a valid CSS length value, e.g: '300', '100px', '30%', etc.
         * Explicitly setting this value will make this Component become 'floating', which means its layout will no
         * longer be affected by the Container that it resides in.
         */
        right: number|string;

        /**
         * The width of this Component; must be a valid CSS length value, e.g: '300', '100px', '30%', etc.
         * By default, if this is not explicitly set, this Component's element will simply have its own natural size.
         * If set to 'auto', it will set the width to 'null' meaning it will have its own natural size.
         */
        width: number|string;

        constructor();

        getBaseCls();

        getBottom();

        getDefaultType();

        getHeight();

        getLeft();

        getRight();

        getWidth();

        setBaseCls();

        setBottom();

        setDefaultType();

        setHeight();

        setLeft();

        setRight();

        setWidth();

        /**
         * Only fire the hide event if it is initialized
         */
        updateHidden();
    }

    interface MessageBoxConfig extends Ext.SheetConfig {
        baseCls?: any;

        /**
         * An array of buttons, or an object of a button to be displayed in the toolbar of this {@link Ext.MessageBox}.
         */
        buttons?: any[]|any;

        /**
         * The default height in pixels of the message box's multiline textarea if displayed.
         */
        defaultTextHeight?: number;

        hideAnimation?: any;

        iconCls?: string;

        layout?: any;

        /**
         * The message to be displayed in the {@link Ext.MessageBox}.
         */
        message?: string;

        /**
         * The message to be displayed in the {@link Ext.MessageBox}.
         * @removed 2.0.0 Please use {@link #message} instead.
         */
        msg?: string;

        showAnimation?: any;

        /**
         * Override the default 'zIndex' so it is normally always above floating components.
         */
        zIndex?: any;
    }

    /**
     * Utility class for generating different styles of message boxes. The framework provides a global singleton
     * {@link Ext.Msg} for common usage which you should use in most cases.
     *
     * If you want to use {@link Ext.MessageBox} directly, just think of it as a modal {@link Ext.Container}.
     *
     * Note that the MessageBox is asynchronous. Unlike a regular JavaScript 'alert' (which will halt browser execution),
     * showing a MessageBox will not cause the code to stop. For this reason, if you have code that should only run _after_
     * some user feedback from the MessageBox, you must use a callback function (see the 'fn' configuration option parameter
     * for the {@link #method-show show} method for more details).
     *
     *     @example preview
     *     Ext.Msg.alert('Title', 'The quick brown fox jumped over the lazy dog.', Ext.emptyFn);
     *
     * Checkout {@link Ext.Msg} for more examples.
     */
    export class MessageBox extends Ext.Sheet implements Ext.MessageBoxConfig {
        baseCls: string;

        /**
         * An array of buttons, or an object of a button to be displayed in the toolbar of this {@link Ext.MessageBox}.
         */
        buttons: any[]|any;

        /**
         * The default height in pixels of the message box's multiline textarea if displayed.
         */
        defaultTextHeight: number;

        /**
         * Animation effect to apply when the Component is being hidden.  Typically you want to use an
         * outbound animation type such as 'fadeOut' or 'slideOut'. For more animations, check the {@link Ext.fx.Animation#type} config.
         */
        hideAnimation: string|any;

        iconCls: string;

        /**
         * Configuration for this Container's layout. Example:
         *
         *     Ext.create('Ext.Container', {
         *         layout: {
         *             type: 'hbox',
         *             align: 'middle'
         *         },
         *         items: [
         *             {
         *                 xtype: 'panel',
         *                 flex: 1,
         *                 style: 'background-color: red;'
         *             },
         *             {
         *                 xtype: 'panel',
         *                 flex: 2,
         *                 style: 'background-color: green'
         *             }
         *         ]
         *     });
         */
        layout: any|string;

        /**
         * The message to be displayed in the {@link Ext.MessageBox}.
         */
        message: string;

        /**
         * The message to be displayed in the {@link Ext.MessageBox}.
         * @removed 2.0.0 Please use {@link #message} instead.
         */
        msg: string;

        /**
         * Animation effect to apply when the Component is being shown.  Typically you want to use an
         * inbound animation type such as 'fadeIn' or 'slideIn'. For more animations, check the {@link Ext.fx.Animation#type} config.
         */
        showAnimation: string|any;

        /**
         * Override the default 'zIndex' so it is normally always above floating components.
         */
        zIndex: number;

        /**
         * Displays a standard read-only message box with an OK button (comparable to the basic JavaScript alert prompt). If
         * a callback function is passed it will be called after the user clicks the button, and the 'itemId' of the button
         * that was clicked will be passed as the only parameter to the callback.
         *
         * @param {String} title The title bar text.
         * @param {String} message The message box body text.
         * @param {Function} [fn] A callback function which is called when the dialog is dismissed by clicking on the configured buttons.
         * @param {String} fn.buttonId The 'itemId' of the button pressed, one of: 'ok', 'yes', 'no', 'cancel'.
         * @param {String} fn.value Value of the input field if either 'prompt' or 'multiLine' option is 'true'.
         * @param {Object} fn.opt The config object passed to show.
         * @param {Object} [scope] The scope ('this' reference) in which the callback is executed.
         * Defaults to: the browser window
         *
         * @return {Ext.MessageBox} this
         */
        alert(title: string, message: string, fn?: Function, fn_buttonId?: string, fn_value?: string, fn_opt?: any, scope?: any): Ext.MessageBox;

        /**
         * Displays a confirmation message box with Yes and No buttons (comparable to JavaScript's confirm). If a callback
         * function is passed it will be called after the user clicks either button, and the id of the button that was
         * clicked will be passed as the only parameter to the callback (could also be the top-right close button).
         *
         * @param {String} title The title bar text.
         * @param {String} message The message box body text.
         * @param {Function} fn A callback function which is called when the dialog is dismissed by clicking on the configured buttons.
         * @param {String} fn.buttonId The 'itemId' of the button pressed, one of: 'ok', 'yes', 'no', 'cancel'.
         * @param {String} fn.value Value of the input field if either 'prompt' or 'multiLine' option is 'true'.
         * @param {Object} fn.opt The config object passed to show.
         * @param {Object} [scope] The scope ('this' reference) in which the callback is executed.
         *
         * Defaults to: the browser window
         *
         * @return {Ext.MessageBox} this
         */
        confirm(title: string, message: string, fn: Function, fn_buttonId: string, fn_value: string, fn_opt: any, scope?: any): Ext.MessageBox;

        constructor(config: Ext.ActionSheetConfig);

        getBaseCls();

        getButtons();

        getDefaultTextHeight();

        getHideAnimation();

        getIconCls();

        getLayout();

        getPrompt();

        getShowAnimation();

        getTitle();

        getZIndex();

        /**
         * Displays a message box with OK and Cancel buttons prompting the user to enter some text (comparable to
         * JavaScript's prompt). The prompt can be a single-line or multi-line textbox. If a callback function is passed it
         * will be called after the user clicks either button, and the id of the button that was clicked (could also be the
         * top-right close button) and the text that was entered will be passed as the two parameters to the callback.
         *
         * Example usage:
         *
         *     @example
         *     Ext.Msg.prompt(
         *         'Welcome!',
         *         'What\'s your name going to be today?',
         *         function (buttonId, value) {
         *             console.log(value);
         *         },
         *         null,
         *         false,
         *         null,
         *         {
         *             autoCapitalize: true,
         *             placeHolder: 'First-name please...'
         *         }
         *     );
         *
         * @param {String} title The title bar text.
         * @param {String} message The message box body text.
         * @param {Function} fn A callback function which is called when the dialog is dismissed by clicking on the configured buttons.
         * @param {String} fn.buttonId The 'itemId' of the button pressed, one of: 'ok', 'yes', 'no', 'cancel'.
         * @param {String} fn.value Value of the input field if either 'prompt' or 'multiLine' option is 'true'.
         * @param {Object} fn.opt The config object passed to show.
         * @param {Object} scope The scope ('this' reference) in which the callback is executed.
         *
         * Defaults to: the browser window.
         *
         * @param {Boolean/Number} [multiLine=false] 'true' to create a multiline textbox using the 'defaultTextHeight' property,
         * or the height in pixels to create the textbox.
         *
         * @param {String} [value] Default value of the text input element.
         *
         * @param {Object} [prompt=true]
         * The configuration for the prompt. See the {@link Ext.MessageBox#cfg-prompt prompt} documentation in {@link Ext.MessageBox}
         * for more information.
         *
         * @return {Ext.MessageBox} this
         */
        prompt(title: string, message: string, fn: Function, fn_buttonId: string, fn_value: string, fn_opt: any, scope: any, multiLine?: boolean|number, value?: string, prompt?: any): Ext.MessageBox;

        setBaseCls();

        setButtons();

        setDefaultTextHeight();

        setHideAnimation();

        setIconCls();

        setLayout();

        setMessage();

        setPrompt();

        setShowAnimation();

        setTitle();

        setZIndex();
    }

    /**
     * This class is a base class for mixins. These are classes that extend this class and are
     * designed to be used as a 'mixin' by user code.
     *
     * It provides mixins with the ability to "hook" class methods of the classes in to which
     * they are mixed. For example, consider the 'destroy' method pattern. If a mixin class
     * had cleanup requirements, it would need to be called as part of 'destroy'.
     *
     * Starting with a basic class we might have:
     *
     *      Ext.define('Foo.bar.Base', {
     *          destroy: function () {
     *              console.log('B');
     *              // cleanup
     *          }
     *      });
     *
     * A derived class would look like this:
     *
     *      Ext.define('Foo.bar.Derived', {
     *          extend: 'Foo.bar.Base',
     *
     *          destroy: function () {
     *              console.log('D');
     *              // more cleanup
     *
     *              this.callParent(); // let Foo.bar.Base cleanup as well
     *          }
     *      });
     *
     * To see how using this class help, start with a "normal" mixin class that also needs to
     * cleanup its resources. These mixins must be called explicitly by the classes that use
     * them. For example:
     *
     *      Ext.define('Foo.bar.Util', {
     *          destroy: function () {
     *              console.log('U');
     *          }
     *      });
     *
     *      Ext.define('Foo.bar.Derived', {
     *          extend: 'Foo.bar.Base',
     *
     *          mixins: {
     *              util: 'Foo.bar.Util'
     *          },
     *
     *          destroy: function () {
     *              console.log('D');
     *              // more cleanup
     *
     *              this.mixins.util.destroy.call(this);
     *
     *              this.callParent(); // let Foo.bar.Base cleanup as well
     *          }
     *      });
     *
     *      var obj = new Foo.bar.Derived();
     *
     *      obj.destroy();
     *      // logs D then U then B
     *
     * This class is designed to solve the above in simpler and more reliable way.
     *
     * ## mixinConfig
     *
     * Using 'mixinConfig' the mixin class can provide "before" or "after" hooks that do not
     * involve the derived class implementation. This also means the derived class cannot
     * adjust parameters to the hook methods.
     *
     *      Ext.define('Foo.bar.Util', {
     *          extend: 'Ext.Mixin',
     *
     *          mixinConfig: {
     *              after: {
     *                  destroy: 'destroyUtil'
     *              }
     *          },
     *
     *          destroyUtil: function () {
     *              console.log('U');
     *          }
     *      });
     *
     *      Ext.define('Foo.bar.Class', {
     *          mixins: {
     *              util: 'Foo.bar.Util'
     *          },
     *
     *          destroy: function () {
     *              console.log('D');
     *          }
     *      });
     *
     *      var obj = new Foo.bar.Derived();
     *
     *      obj.destroy();
     *      // logs D then U
     *
     *  If the destruction should occur in the other order, you can use 'before':
     *
     *      Ext.define('Foo.bar.Util', {
     *          extend: 'Ext.Mixin',
     *
     *          mixinConfig: {
     *              before: {
     *                  destroy: 'destroyUtil'
     *              }
     *          },
     *
     *          destroyUtil: function () {
     *              console.log('U');
     *          }
     *      });
     *
     *      Ext.define('Foo.bar.Class', {
     *          mixins: {
     *              util: 'Foo.bar.Util'
     *          },
     *
     *          destroy: function () {
     *              console.log('D');
     *          }
     *      });
     *
     *      var obj = new Foo.bar.Derived();
     *
     *      obj.destroy();
     *      // logs U then D
     *
     * ### Chaining
     *
     * One way for a mixin to provide methods that act more like normal inherited methods is
     * to use an 'on' declaration. These methods will be injected into the 'callParent' chain
     * between the derived and superclass. For example:
     *
     *      Ext.define('Foo.bar.Util', {
     *          extend: 'Ext.Mixin',
     *
     *          mixinConfig: {
     *              on: {
     *                  destroy: function () {
     *                      console.log('M');
     *                  }
     *              }
     *          }
     *      });
     *
     *      Ext.define('Foo.bar.Base', {
     *          destroy: function () {
     *              console.log('B');
     *          }
     *      });
     *
     *      Ext.define('Foo.bar.Derived', {
     *          extend: 'Foo.bar.Base',
     *
     *          mixins: {
     *              util: 'Foo.bar.Util'
     *          },
     *
     *          destroy: function () {
     *              this.callParent();
     *              console.log('D');
     *          }
     *      });
     *
     *      var obj = new Foo.bar.Derived();
     *
     *      obj.destroy();
     *      // logs M then B then D
     *
     * As with 'before' and 'after', the value of 'on' can be a method name.
     *
     *      Ext.define('Foo.bar.Util', {
     *          extend: 'Ext.Mixin',
     *
     *          mixinConfig: {
     *              on: {
     *                  destroy: 'onDestroy'
     *              }
     *          }
     *
     *          onDestroy: function () {
     *              console.log('M');
     *          }
     *      });
     *
     * Because this technique leverages 'callParent', the derived class controls the time and
     * parameters for the call to all of its bases (be they 'extend' or 'mixin' flavor).
     *
     * ### Derivations
     *
     * Some mixins need to process class extensions of their target class. To do this you can
     * define an 'extended' method like so:
     *
     *      Ext.define('Foo.bar.Util', {
     *          extend: 'Ext.Mixin',
     *
     *          mixinConfig: {
     *              extended: function (baseClass, derivedClass, classBody) {
     *                  // This function is called whenever a new "derivedClass" is created
     *                  // that extends a "baseClass" in to which this mixin was mixed.
     *              }
     *          }
     *      });
     */
    export class Mixin extends Ext.Base {
    }

    /**
     * @extends Ext.MessageBox
     *
     * A global shared singleton instance of the {@link Ext.MessageBox} class.
     *
     * Allows for simple creation of various different alerts and notifications.
     *
     * To change any configurations on this singleton instance, you must change the
     * 'defaultAllowedConfig' object.  For example to remove all animations on 'Msg':
     *
     *     Ext.Msg.defaultAllowedConfig.showAnimation = false;
     *     Ext.Msg.defaultAllowedConfig.hideAnimation = false;
     *
     * ## Examples
     *
     * ### Alert
     * Use the {@link #alert} method to show a basic alert:
     *
     *     @example preview
     *     Ext.Msg.alert('Title', 'The quick brown fox jumped over the lazy dog.', Ext.emptyFn);
     *
     * ### Prompt
     * Use the {@link #method-prompt} method to show an alert which has a textfield:
     *
     *     @example preview
     *     Ext.Msg.prompt('Name', 'Please enter your name:', function(text) {
     *         // process text value and close...
     *     });
     *
     * ### Confirm
     * Use the {@link #confirm} method to show a confirmation alert (shows yes and no buttons).
     *
     *     @example preview
     *     Ext.Msg.confirm("Confirmation", "Are you sure you want to do that?", Ext.emptyFn);
     */
    export class Msg {
        constructor(config: Ext.ActionSheetConfig);
    }

    /**
     * A collection of useful static methods to deal with numbers
     */
    export class Number {
        /**
         * Coerces a given index into a valid index given a 'length'.
         *
         * Negative indexes are interpreted starting at the end of the collection. That is,
         * a value of -1 indicates the last item, or equivalent to 'length - 1'.
         *
         * When handling methods that take "begin" and "end" arguments like most array or
         * string methods, this method can be used like so:
         *
         *      function foo (array, begin, end) {
         *          var range = Ext.Number.clipIndices(array.length, [begin, end]);
         *
         *          begin = range[0];
         *          end   = range[1];
         *
         *          // 0 <= begin <= end <= array.length
         *
         *          var length = end - begin;
         *      }
         *
         * For example:
         *
         *      +---+---+---+---+---+---+---+---+
         *      |   |   |   |   |   |   |   |   |  length = 8
         *      +---+---+---+---+---+---+---+---+
         *        0   1   2   3   4   5   6   7
         *       -8  -7  -6  -5  -4  -3  -2  -1
         *
         *      console.log(Ext.Number.clipIndices(8, [3, 10]); // logs "[3, 8]"
         *      console.log(Ext.Number.clipIndices(8, [-5]);    // logs "[3, 8]"
         *      console.log(Ext.Number.clipIndices(8, []);
         *      console.log(Ext.Number.clipIndices(8, []);
         *
         * @param {Object} [options] An object with different option flags.
         * @param {Boolean} [options.count=false] The second number in 'indices' is the
         * count not and an index.
         * @param {Boolean} [options.inclusive=false] The second number in 'indices' is
         * "inclusive" meaning that the item should be considered in the range. Normally,
         * the second number is considered the first item outside the range or as an
         * "exclusive" bound.
         * @param {Boolean} [options.wrap=true] Wraps negative numbers backwards from the
         * end of the array. Passing 'false' simply clips negative index values at 0.
         * @return {Number[]} The normalized '[begin, end]' array where 'end' is now
         * exclusive such that 'length = end - begin'. Both values are between 0 and the
         * given 'length' and 'end' will not be less-than 'begin'.
         */
        static clipIndices(length: number, indices: number, options?: any, options_count?: boolean, options_inclusive?: boolean, options_wrap?: boolean): number;

        /**
         * Checks whether or not the passed number is within a desired range.  If the number is already within the
         * range it is returned, otherwise the min or max value is returned depending on which side of the range is
         * exceeded. Note that this method returns the constrained value but does not change the current number.
         * @param {Number} number The number to check
         * @param {Number} min The minimum number in the range
         * @param {Number} max The maximum number in the range
         * @return {Number} The constrained value if outside the range, otherwise the current value
         */
        static constrain(number: number, min: number, max: number): number;

        /**
         * Corrects floating point numbers that overflow to a non-precise
         * value because of their floating nature, for example '0.1 + 0.2'
         * @param {Number} n The number
         * @return {Number} The correctly rounded number
         */
        static correctFloat(n: number): number;

        /**
         * Validate that a value is numeric and convert it to a number if necessary. Returns the specified default value if
         * it is not.
         Ext.Number.from('1.23', 1); // returns 1.23
         Ext.Number.from('abc', 1); // returns 1
         * @param {Number} defaultValue The value to return if the original value is non-numeric
         * @return {Number} value, if numeric, defaultValue otherwise
         */
        static from(value: any, defaultValue: number): number;

        /**
         * Determines if two numbers 'n1' and 'n2' are equal within a given
         * margin of precision 'epsilon'.
         * @param {Number} n1 First number.
         * @param {Number} n2 Second number.
         * @param {Number} epsilon Margin of precision.
         * @returns {Boolean} 'true', if numbers are equal. 'false' otherwise.
         */
        static isEqual(n1: number, n2: number, epsilon: number);

        /**
         * Returns the base 10 logarithm of a number.
         * This will use Math.log10, if available (ES6).
         * @param {Number} x The number.
         * @return {Number} Base 10 logarithm of the number 'x'.
         */
        static log10(x: number): number;

        /**
         * Returns a random integer between the specified range (inclusive)
         * @param {Number} from Lowest value to return.
         * @param {Number} to Highest value to return.
         * @return {Number} A random integer within the specified range.
         */
        static randomInt(from: number, to: number): number;

        /**
         * Returns the sign of the given number. See also MDN for Math.sign documentation
         * for the standard method this method emulates.
         * @param {Number} x The number.
         * @return {Number} The sign of the number 'x', indicating whether the number is
         * positive (1), negative (-1) or zero (0).
         */
        static sign(x: number): number;

        /**
         * Snaps the passed number between stopping points based upon a passed increment value.
         *
         * The difference between this and {@link #snapInRange} is that {@link #snapInRange} uses the minValue
         * when calculating snap points:
         *
         *     r = Ext.Number.snap(56, 2, 55, 65);        // Returns 56 - snap points are zero based
         *
         *     r = Ext.Number.snapInRange(56, 2, 55, 65); // Returns 57 - snap points are based from minValue
         *
         * @param {Number} value The unsnapped value.
         * @param {Number} increment The increment by which the value must move.
         * @param {Number} minValue The minimum value to which the returned value must be constrained. Overrides the increment.
         * @param {Number} maxValue The maximum value to which the returned value must be constrained. Overrides the increment.
         * @return {Number} The value of the nearest snap target.
         */
        static snap(value: number, increment: number, minValue: number, maxValue: number): number;

        /**
         * Snaps the passed number between stopping points based upon a passed increment value.
         *
         * The difference between this and {@link #snap} is that {@link #snap} does not use the minValue
         * when calculating snap points:
         *
         *     r = Ext.Number.snap(56, 2, 55, 65);        // Returns 56 - snap points are zero based
         *
         *     r = Ext.Number.snapInRange(56, 2, 55, 65); // Returns 57 - snap points are based from minValue
         *
         * @param {Number} value The unsnapped value.
         * @param {Number} increment The increment by which the value must move.
         * @param {Number} [minValue=0] The minimum value to which the returned value must be constrained.
         * @param {Number} [maxValue=Infinity] The maximum value to which the returned value must be constrained.
         * @return {Number} The value of the nearest snap target.
         */
        static snapInRange(value: number, increment: number, minValue?: number, maxValue?: number): number;

        /**
         * Formats a number using fixed-point notation
         * @param {Number} value The number to format
         * @param {Number} precision The number of digits to show after the decimal point
         */
        static toFixed(value: number, precision: number);
    }

    /**
     * A collection of useful static methods to deal with objects.
     */
    export class Object {
        /**
         * Returns a new object with the given object as the prototype chain. This method is
         * designed to mimic the ECMA standard 'Object.create' method and is assigned to that
         * function when it is available.
         *
         * **NOTE** This method does not support the property definitions capability of the
         * 'Object.create' method. Only the first argument is supported.
         *
         * @param {Object} object The prototype chain for the new object.
         */
        static chain(object: any);

        /**
         * This method removes all keys from the given object.
         * @param {Object} object The object from which to remove all keys.
         * @return {Object} The given object.
         */
        static clear(object: any): any;

        /**
         * Iterates through an object and invokes the given callback function for each iteration.
         * The iteration can be stopped by returning 'false' in the callback function. For example:
         *
         *     var person = {
         *         name: 'Jacky'
         *         hairColor: 'black'
         *         loves: ['food', 'sleeping', 'wife']
         *     };
         *
         *     Ext.Object.each(person, function(key, value, myself) {
         *         console.log(key + ":" + value);
         *
         *         if (key === 'hairColor') {
         *             return false; // stop the iteration
         *         }
         *     });
         *
         * @param {Object} object The object to iterate
         * @param {Function} fn The callback function.
         * @param {Object} fn.object The object itself
         * @param {Object} [scope] The execution scope ('this') of the callback function
         */
        static each(object: any, fn: Function, fn_key: string, fn_value: any, fn_object: any, scope?: any);

        /**
         * Iterates through an object and invokes the given callback function for each iteration.
         * The iteration can be stopped by returning 'false' in the callback function. For example:
         *
         *     var items = {
         *         1: 'Hello',
         *         2: 'World'
         *     };
         *
         *     Ext.Object.eachValue(items, function (value) {
         *         console.log("Value: " + value);
         *     });
         *
         * This will log 'Hello' and 'World' in no particular order. This method is useful
         * in cases where the keys are not important to the processing, just the values.
         *
         * @param {Object} object The object to iterate
         * @param {Function} fn The callback function.
         * @param {Object} fn.value The value of
         * @param {Object} [scope] The execution scope ('this') of the callback function
         */
        static eachValue(object: any, fn: Function, fn_value: any, scope?: any);

        /**
         * Shallow compares the contents of 2 objects using strict equality. Objects are
         * considered equal if they both have the same set of properties and the
         * value for those properties equals the other in the corresponding object.
         *
         *     // Returns true
         *     Ext.Object.equals({
         *         foo: 1,
         *         bar: 2
         *     }, {
         *         foo: 1,
         *         bar: 2
         *     });
         *
         * @return {Boolean} 'true' if the objects are equal.
         */
        static equals(object1: any, object2: any): boolean;

        /**
         * Freezes the given object making it immutable. This operation is by default shallow
         * and does not effect objects referenced by the given object.
         *
         * @param {Object} obj The object to freeze.
         * @param {Boolean} [deep=false] Pass 'true' to freeze sub-objects recursively.
         * @return {Object} The given object 'obj'.
         */
        static freeze(obj: any, deep?: boolean): any;

        /**
         * Converts a query string back into an object.
         *
         * Non-recursive:
         *
         *     Ext.Object.fromQueryString("foo=1&bar=2"); // returns {foo: '1', bar: '2'}
         *     Ext.Object.fromQueryString("foo=&bar=2"); // returns {foo: '', bar: '2'}
         *     Ext.Object.fromQueryString("some%20price=%24300"); // returns {'some price': '$300'}
         *     Ext.Object.fromQueryString("colors=red&colors=green&colors=blue"); // returns {colors: ['red', 'green', 'blue']}
         *
         * Recursive:
         *
         *     Ext.Object.fromQueryString(
         *         "username=Jacky&"+
         *         "dateOfBirth[day]=1&dateOfBirth[month]=2&dateOfBirth[year]=1911&"+
         *         "hobbies[0]=coding&hobbies[1]=eating&hobbies[2]=sleeping&"+
         *         "hobbies[3][0]=nested&hobbies[3][1]=stuff", true);
         *
         *     // returns
         *     {
         *         username: 'Jacky',
         *         dateOfBirth: {
         *             day: '1',
         *             month: '2',
         *             year: '1911'
         *         },
         *         hobbies: ['coding', 'eating', 'sleeping', ['nested', 'stuff']]
         *     }
         *
         * @param {String} queryString The query string to decode
         * @param {Boolean} [recursive=false] Whether or not to recursively decode the string. This format is supported by
         * PHP / Ruby on Rails servers and similar.
         * @return {Object}
         */
        static fromQueryString(queryString: string, recursive?: boolean): any;

        /**
         * Returns all keys of the given object as an array.
         *
         * @return {String[]} An array of keys from the object or any of its prototypes.
         */
        static getAllKeys(object: any): string;

        /**
         * Returns the first matching key corresponding to the given value.
         * If no matching value is found, null is returned.
         *
         *     var person = {
         *         name: 'Jacky',
         *         loves: 'food'
         *     };
         *
         *     alert(Ext.Object.getKey(person, 'food')); // alerts 'loves'
         *
         * @param {Object} value The value to find
         */
        static getKey(object: any, value: any);

        /**
         * Returns the 'hasOwnProperty' keys of the given object as an array.
         *
         *     var values = Ext.Object.getKeys({
         *         name: 'Jacky',
         *         loves: 'food'
         *     }); // ['name', 'loves']
         *
         * @return {String[]} An array of keys from the object
         */
        static getKeys(object: any): string;

        /**
         * Gets the total number of this object's own properties
         *
         *     var size = Ext.Object.getSize({
         *         name: 'Jacky',
         *         loves: 'food'
         *     }); // size equals 2
         *
         * @return {Number} size
         */
        static getSize(object: any): number;

        /**
         * Gets all values of the given object as an array.
         *
         *     var values = Ext.Object.getValues({
         *         name: 'Jacky',
         *         loves: 'food'
         *     }); // ['Jacky', 'food']
         *
         * @return {Array} An array of values from the object
         */
        static getValues(object: any): any[];

        /**
         * Checks if there are any properties on this object.
         * @return {Boolean} 'true' if there no properties on the object.
         */
        static isEmpty(object: any): boolean;

        /**
         * Merges any number of objects recursively without referencing them or their children.
         *
         *     var extjs = {
         *         companyName: 'Ext JS',
         *         products: ['Ext JS', 'Ext GWT', 'Ext Designer'],
         *         isSuperCool: true,
         *         office: {
         *             size: 2000,
         *             location: 'Palo Alto',
         *             isFun: true
         *         }
         *     };
         *
         *     var newStuff = {
         *         companyName: 'Sencha Inc.',
         *         products: ['Ext JS', 'Ext GWT', 'Ext Designer', 'Sencha Touch', 'Sencha Animator'],
         *         office: {
         *             size: 40000,
         *             location: 'Redwood City'
         *         }
         *     };
         *
         *     var sencha = Ext.Object.merge(extjs, newStuff);
         *
         *     // extjs and sencha then equals to
         *     {
         *         companyName: 'Sencha Inc.',
         *         products: ['Ext JS', 'Ext GWT', 'Ext Designer', 'Sencha Touch', 'Sencha Animator'],
         *         isSuperCool: true,
         *         office: {
         *             size: 40000,
         *             location: 'Redwood City',
         *             isFun: true
         *         }
         *     }
         *
         * @param {Object} destination The object into which all subsequent objects are merged.
         * @param {Object...} object Any number of objects to merge into the destination.
         * @return {Object} merged The destination object with all passed objects merged in.
         */
        static merge(destination: any, object: any): any;

        /**
         * Converts a 'name' - 'value' pair to an array of objects with support for nested structures. Useful to construct
         * query strings. For example:
         *
         *     var objects = Ext.Object.toQueryObjects('hobbies', ['reading', 'cooking', 'swimming']);
         *
         *     // objects then equals:
         *     [
         *         { name: 'hobbies', value: 'reading' },
         *         { name: 'hobbies', value: 'cooking' },
         *         { name: 'hobbies', value: 'swimming' },
         *     ];
         *
         *     var objects = Ext.Object.toQueryObjects('dateOfBirth', {
         *         day: 3,
         *         month: 8,
         *         year: 1987,
         *         extra: {
         *             hour: 4
         *             minute: 30
         *         }
         *     }, true); // Recursive
         *
         *     // objects then equals:
         *     [
         *         { name: 'dateOfBirth[day]', value: 3 },
         *         { name: 'dateOfBirth[month]', value: 8 },
         *         { name: 'dateOfBirth[year]', value: 1987 },
         *         { name: 'dateOfBirth[extra][hour]', value: 4 },
         *         { name: 'dateOfBirth[extra][minute]', value: 30 },
         *     ];
         *
         * @param {Boolean} [recursive=false] True to traverse object recursively
         * @return {Object[]}
         */
        static toQueryObjects(name: string, value: any|any[], recursive?: boolean): any;

        /**
         * Takes an object and converts it to an encoded query string.
         *
         * Non-recursive:
         *
         *     Ext.Object.toQueryString({foo: 1, bar: 2}); // returns "foo=1&bar=2"
         *     Ext.Object.toQueryString({foo: null, bar: 2}); // returns "foo=&bar=2"
         *     Ext.Object.toQueryString({'some price': '$300'}); // returns "some%20price=%24300"
         *     Ext.Object.toQueryString({date: new Date(2011, 0, 1)}); // returns "date=%222011-01-01T00%3A00%3A00%22"
         *     Ext.Object.toQueryString({colors: ['red', 'green', 'blue']}); // returns "colors=red&colors=green&colors=blue"
         *
         * Recursive:
         *
         *     Ext.Object.toQueryString({
         *         username: 'Jacky',
         *         dateOfBirth: {
         *             day: 1,
         *             month: 2,
         *             year: 1911
         *         },
         *         hobbies: ['coding', 'eating', 'sleeping', ['nested', 'stuff']]
         *     }, true); // returns the following string (broken down and url-decoded for ease of reading purpose):
         *     // username=Jacky
         *     //    &dateOfBirth[day]=1&dateOfBirth[month]=2&dateOfBirth[year]=1911
         *     //    &hobbies[0]=coding&hobbies[1]=eating&hobbies[2]=sleeping&hobbies[3][0]=nested&hobbies[3][1]=stuff
         *
         * @param {Object} object The object to encode
         * @param {Boolean} [recursive=false] Whether or not to interpret the object in recursive format.
         * (PHP / Ruby on Rails servers and similar).
         * @return {String} queryString
         */
        static toQueryString(object: any, recursive?: boolean): string;
    }

    /**
     * @extends Ext.env.OS
     * Provides useful information about the current operating system environment.
     *
     * Example:
     *
     *     if (Ext.os.is.Windows) {
     *         // Windows specific code here
     *     }
     *
     *     if (Ext.os.is.iOS) {
     *         // iPad, iPod, iPhone, etc.
     *     }
     *
     *     console.log("Version " + Ext.os.version);
     *
     * For a full list of supported values, refer to the {@link #is} property/method.
     */
    export class os {
        /**
         * The generic type of the current device.
         *
         * Possible values:
         *
         * - Phone
         * - Tablet
         * - Desktop
         *
         * For testing purposes the deviceType can be overridden by adding
         * a deviceType parameter to the URL of the page, like so:
         *
         *     http://localhost/mypage.html?deviceType=Tablet
         */
        static deviceType: string;

        /**
         * @readonly
         * The full name of the current operating system. Possible values are:
         *
         * - iOS
         * - Android
         * - WebOS
         * - BlackBerry,
         * - MacOS
         * - Windows
         * - Linux
         * - Other
         *
         * Optional, Defaults to: null
         */
        static name: string;

        /**
         * Refer to {@link Ext.Version}
         * @readonly
         *
         * Optional, Defaults to: null
         */
        static version: Ext.Version;

        /**
         * A "hybrid" property, can be either accessed as a method call, i.e:
         *
         *     if (Ext.os.is('Android')) {
         *         // ...
         *     }
         *
         * or as an object with boolean properties, i.e:
         *
         *     if (Ext.os.is.Android) {
         *         // ...
         *     }
         *
         * Versions can be conveniently checked as well. For example:
         *
         *     if (Ext.os.is.Android2) {
         *         // Equivalent to (Ext.os.is.Android && Ext.os.version.equals(2))
         *     }
         *
         *     if (Ext.os.is.iOS32) {
         *         // Equivalent to (Ext.os.is.iOS && Ext.os.version.equals(3.2))
         *     }
         *
         * Note that only {@link Ext.Version#getMajor major component} and {@link Ext.Version#getShortVersion simplified}
         * value of the version are available via direct property checking. Supported values are:
         *
         * - iOS
         * - iPad
         * - iPhone
         * - iPhone5 (also true for 4in iPods).
         * - iPod
         * - Android
         * - WebOS
         * - BlackBerry
         * - Bada
         * - MacOS
         * - Windows
         * - Linux
         * - Other
         * @param {String} name The OS name to check.
         * @return {Boolean}
         */
        static is(name: string): boolean;
    }

    interface PanelConfig extends Ext.ContainerConfig {
        baseCls?: any;

        /**
         * - 'true' to enable the border around the panel body (as defined by the theme)
         * Note that even when enabled, the bodyBorder is only visible when there are docked
         * items around the edges of the panel.  Where the bodyBorder touches the panel's outer
         * border it is automatically collapsed into a single border.
         *
         * - 'false' to disable the body border
         *
         * - 'null' - use the value of {@link #border} as the value for bodyBorder
         */
        bodyBorder?: boolean;

        /**
         * A shortcut for setting a padding style on the body element. The value can either be
         * a number to be applied to all sides, or a normal CSS string describing padding.
         */
        bodyPadding?: number|boolean|string;

        border?: any;

        /**
         * Pass as 'false' to prevent a header from being created.
         *
         * You may also assign a header with a config object (optionally containing an 'xtype')
         * to custom-configure your panel's header.
         *
         * See {@link Ext.panel.Header} for all the options that may be specified here.
         */
        header?: boolean|any;

        icon?: string;

        iconCls?: string;

        title?: string|any;

        /**
         * An array of {@link Ext.panel.Tool} configs/instances to be added to the header tool area. The tools are stored as
         * child components of the header container.
         */
        tools?: any|Ext.panel.Tool;
    }

    /**
     * Panels are most useful as Overlays - containers that float over your application. They contain extra styling such
     * that when you {@link #showBy} another component, the container will appear in a rounded black box with a 'tip'
     * pointing to a reference component.
     *
     * If you don't need this extra functionality, you should use {@link Ext.Container} instead.
     *
     *      @example miniphone preview
     *
     *      var button = Ext.create('Ext.Button', {
     *           text: 'Button',
     *           id: 'rightButton'
     *      });
     *
     *      Ext.create('Ext.Container', {
     *          fullscreen: true,
     *          items: [
     *              {
     *                   docked: 'top',
     *                   xtype: 'titlebar',
     *                   items: [
     *                       button
     *                   ]
     *               }
     *          ]
     *      });
     *
     *      Ext.create('Ext.Panel', {
     *          html: 'Floating Panel',
     *          left: 0,
     *          padding: 10
     *      }).showBy(button);
     */
    export class Panel extends Ext.Container implements Ext.PanelConfig {
        defaultBindProperty: any;

        baseCls: string;

        /**
         * - 'true' to enable the border around the panel body (as defined by the theme)
         * Note that even when enabled, the bodyBorder is only visible when there are docked
         * items around the edges of the panel.  Where the bodyBorder touches the panel's outer
         * border it is automatically collapsed into a single border.
         *
         * - 'false' to disable the body border
         *
         * - 'null' - use the value of {@link #border} as the value for bodyBorder
         */
        bodyBorder: boolean;

        /**
         * A shortcut for setting a padding style on the body element. The value can either be
         * a number to be applied to all sides, or a normal CSS string describing padding.
         */
        bodyPadding: number|boolean|string;

        /**
         * Enables or disables bordering on this component.
         * The following values are accepted:
         *
         * - 'null' or 'true (default): Do nothing and allow the border to be specified by the theme.
         * - 'false': suppress the default border provided by the theme.
         *
         * Please note that enabling bordering via this config will not add a 'border-color'
         * or 'border-style' CSS property to the component; you provide the 'border-color'
         * and 'border-style' via CSS rule or {@link #style} configuration
         * (if not already provide by the theme).
         *
         * ## Using {@link #style}:
         *
         *     Ext.Viewport.add({
         *         centered: true,
         *         width: 100,
         *         height: 100,
         *
         *         style: 'border: 1px solid blue;'
         *         // ...
         *     });
         *
         * ## Using CSS:
         *
         *     Ext.Viewport.add({
         *         centered: true,
         *         width: 100,
         *         height: 100,
         *
         *         cls: 'my-component'
         *         // ...
         *     });
         *
         * And your CSS file:
         *
         *     .my-component {
         *         border: 1px solid red;
         *     }
         */
        border: boolean;

        /**
         * Pass as 'false' to prevent a header from being created.
         *
         * You may also assign a header with a config object (optionally containing an 'xtype')
         * to custom-configure your panel's header.
         *
         * See {@link Ext.panel.Header} for all the options that may be specified here.
         */
        header: boolean|any;

        icon: string;

        iconCls: string;

        protected manageBorders: any;

        title: string|any;

        /**
         * An array of {@link Ext.panel.Tool} configs/instances to be added to the header tool area. The tools are stored as
         * child components of the header container.
         */
        tools: any|Ext.panel.Tool;

        /**
         * Adds a CSS class to the body element. If not rendered, the class will
         * be added when the panel is rendered.
         * @param {String} cls The class to add
         * @return {Ext.panel.Panel} this
         */
        addBodyCls(cls: string): Ext.Panel;

        constructor(config: Ext.ActionSheetConfig);

        getBaseCls();

        getBodyBorder();

        getBodyPadding();

        getBorder();

        getHeader();

        getIcon();

        getIconCls();

        getTitle();

        getTools();

        /**
         * Removes a CSS class from the body element.
         * @param {String} cls The class to remove
         * @return {Ext.panel.Panel} this
         */
        removeBodyCls(cls: string): Ext.Panel;

        setBaseCls();

        setBodyBorder();

        setBodyPadding();

        setBorder();

        setHeader();

        setIcon();

        setIconCls();

        setTitle();

        setTools();
    }

    interface ProgressBaseConfig {
        /**
         * A template used to create this ProgressBar's background text given two values:
         *
         *    'value  ' - The raw progress value between 0 and 1
         *    'percent' - The value as a percentage between 0 and 100
         *
         * Optional
         */
        textTpl?: string|Ext.XTemplate;

        /**
         * A floating point value between 0 and 1 (e.g., .5)
         *
         * Optional, Defaults to: 0
         */
        value?: number;
    }

    export class ProgressBase extends Ext.Base implements Ext.ProgressBaseConfig {
        /**
         * A template used to create this ProgressBar's background text given two values:
         *
         *    'value  ' - The raw progress value between 0 and 1
         *    'percent' - The value as a percentage between 0 and 100
         *
         * Optional
         */
        textTpl: string|Ext.XTemplate;

        /**
         * A floating point value between 0 and 1 (e.g., .5)
         *
         * Optional, Defaults to: 0
         */
        value: number;

        getTextTpl();

        getValue();

        setTextTpl();

        setValue();
    }

    interface ProgressConfig extends Ext.WidgetConfig {
        /**
         * Specify as 'true' to have this progress bar animate to new extent when updated.
         *
         * Optional, Defaults to: false
         */
        animate?: boolean;

        /**
         * The base CSS class to apply to the progress bar's wrapper element.
         *
         * Optional, Defaults to: 'x-progress'
         */
        baseCls?: string;

        /**
         * The background text
         *
         * Optional
         */
        text?: string;
    }

    /**
     * A simple progress bar widget.
     *
     * You are responsible for showing, updating (via {@link #setValue}) and clearing the
     * progress bar as needed from your own code. This method is most appropriate when you
     * want to show progress throughout an operation that has predictable points of interest
     * at which you can update the control.
     *
     *     @example
     *     var store = Ext.create('Ext.data.Store', {
     *         fields: ['name', 'progress'],
     *         data: [
     *             { name: 'Lisa', progress: .159 },
     *             { name: 'Bart', progress: .216 },
     *             { name: 'Homer', progress: .55 },
     *             { name: 'Maggie', progress: .167 },
     *             { name: 'Marge', progress: .145 }
     *         ]
     *     });
     *
     *     Ext.create('Ext.grid.Panel', {
     *         title: 'Simpsons',
     *         store: store,
     *         columns: [
     *             { text: 'Name',  dataIndex: 'name' },
     *             {
     *                 text: 'Progress',
     *                 xtype: 'widgetcolumn',
     *                 width: 120,
     *                 dataIndex: 'progress',
     *                 widget: {
     *                     xtype: 'progress'
     *                 }
     *             }
     *         ],
     *         height: 200,
     *         width: 400,
     *         renderTo: Ext.getBody()
     *     });
     */
    export class Progress extends Ext.Widget implements Ext.ProgressConfig {
        protected defaultBindProperty: any;

        protected template: any[];

        /**
         * Specify as 'true' to have this progress bar animate to new extent when updated.
         *
         * Optional, Defaults to: false
         */
        animate: boolean;

        /**
         * The base CSS class to apply to the progress bar's wrapper element.
         *
         * Optional, Defaults to: 'x-progress'
         */
        baseCls: string;

        /**
         * The background text
         *
         * Optional
         */
        text: string;

        constructor(config: Ext.ProgressConfig);

        getAnimate();

        getBaseCls();

        getCls();

        getText();

        getTextCls();

        getUi();

        setAnimate();

        setBaseCls();

        setCls();

        setText();

        setTextCls();

        setUi();
    }

    interface ProgressIndicatorConfig extends Ext.ContainerConfig {
        baseCls?: any;

        centered?: any;

        /**
         * This String is used when progress is not dynamic (only start and end events will be received).
         *
         * If a String is given that text will be used for all states of loading. One can optionally pass in an object
         * with the properties 'upload' and/or 'download' with custom state strings.
         */
        fallbackText?: string|any;

        hidden?: any;

        hideAnimation?: any;

        /**
         * This template is used when progress is dynamic (many updates will be received). Template will be passed
         * and object with properties percent and state.
         *
         * If a String or XTemplate is given that text will be used for all states of loading. One can optionally pass in an object
         * with the properties 'upload' and/or 'download' with custom state templates.
         */
        loadingText?: string|Ext.XTemplate|any;

        modal?: any;

        /**
         * Object with the properties of 'upload' and 'download'. To disable progress monitoring of any state simply set
         * it to false. For example:
         *
         *  monitoredStates: {
         *      upload:false
         *  }
         *
         *  @accessor
         */
        monitoredStates?: any;

        showAnimation?: any;
    }

    /**
     * {@link Ext.ProgressIndicator} provides a progress indicator for file uploads.
     */
    export class ProgressIndicator extends Ext.Container implements Ext.ProgressIndicatorConfig {
        baseCls: string;

        centered: boolean;

        /**
         * This String is used when progress is not dynamic (only start and end events will be received).
         *
         * If a String is given that text will be used for all states of loading. One can optionally pass in an object
         * with the properties 'upload' and/or 'download' with custom state strings.
         */
        fallbackText: string|any;

        hidden: boolean;

        hideAnimation: string|any;

        /**
         * This template is used when progress is dynamic (many updates will be received). Template will be passed
         * and object with properties percent and state.
         *
         * If a String or XTemplate is given that text will be used for all states of loading. One can optionally pass in an object
         * with the properties 'upload' and/or 'download' with custom state templates.
         */
        loadingText: string|Ext.XTemplate|any;

        modal: boolean;

        /**
         * Object with the properties of 'upload' and 'download'. To disable progress monitoring of any state simply set
         * it to false. For example:
         *
         *  monitoredStates: {
         *      upload:false
         *  }
         *
         *  @accessor
         */
        monitoredStates: any;

        showAnimation: string|any;

        constructor();

        getBaseCls();

        getCentered();

        getHidden();

        getHideAnimation();

        getModal();

        getMonitoredStates();

        getShowAnimation();

        setBaseCls();

        setCentered();

        setFallbackText();

        setHidden();

        setHideAnimation();

        setLoadingText();

        setModal();

        setMonitoredStates();

        setShowAnimation();
    }

    /**
     * This class provides an API compatible implementation of the ECMAScript 6 Promises API
     * (providing an implementation as necessary for browsers that do not natively support the
     * 'Promise' class).
     *
     * This class will use the native 'Promise' implementation if one is available. The
     * native implementation, while standard, does not provide all of the features of the
     * Ext JS Promises implementation.
     *
     * To use the Ext JS enhanced Promises implementation, see '{@link Ext.Deferred}' for
     * creating enhanced promises and additional static utility methods.
     *
     * Typical usage:
     *
     *      function getAjax (url) {
     *          // The function passed to Ext.Promise() is called immediately to start
     *          // the asynchronous action.
     *          //
     *          return new Ext.Promise(function (resolve, reject) {
     *              Ext.Ajax.request({
     *                  url: url,
     *
     *                  success: function (response) {
     *                      // Use the provided "resolve" method to deliver the result.
     *                      //
     *                      resolve(response.responseText);
     *                  },
     *
     *                  failure: function (response) {
     *                      // Use the provided "reject" method to deliver error message.
     *                      //
     *                      reject(response.status);
     *                  }
     *              });
     *          });
     *      }
     *
     *      getAjax('http://stuff').then(function (content) {
     *          // content is responseText of ajax response
     *      });
     *
     * To adapt the Ext JS '{@link Ext.data.Store store}' to use a Promise, you might do
     * something like this:
     *
     *      loadCompanies: function() {
     *          var companyStore = this.companyStore;
     *
     *          return new Ext.Promise(function (resolve, reject) {
     *              companyStore.load({
     *                  callback: function(records, operation, success) {
     *                      if (success) {
     *                          // Use the provided "resolve" method  to drive the promise:
     *                          resolve(records);
     *                      }
     *                      else {
     *                          // Use the provided "reject" method  to drive the promise:
     *                          reject("Error loading Companies.");
     *                      }
     *                  }
     *              });
     *          });
     *      }
     *
     * @since 6.0.0
     */
    export class Promise extends Ext.Base {
        /**
         * Returns a new Promise that will only resolve once all the specified
         * 'promisesOrValues' have resolved.
         *
         * The resolution value will be an Array containing the resolution value of each
         * of the 'promisesOrValues'.
         *
         * @param {Mixed[]/Ext.Promise[]/Ext.Promise} promisesOrValues An Array of values
         * or Promises, or a Promise of an Array of values or Promises.
         *
         * @return {Ext.Promise} A Promise of an Array of the resolved values.
         */
        static all(promisesOrValues: any|Ext.Promise): Ext.Promise;

        /**
         * Convenience method that returns a new Promise rejected with the specified
         * reason.
         *
         * @param {Error} reason Rejection reason.
         * @return {Ext.Promise} The rejected Promise.
         */
        static reject(reason: Error): Ext.Promise;

        /**
         * Returns a new Promise that either
         *
         *  * Resolves immediately for the specified value, or
         *  * Resolves or rejects when the specified promise (or third-party Promise or
         *    then()-able) is resolved or rejected.
         *
         * @param {Mixed} promiseOrValue A Promise (or third-party Promise or then()-able)
         * or value.
         * @return {Ext.Promise} A Promise of the specified Promise or value.
         */
        static resolve(promiseOrValue: any): Ext.Promise;
    }

    interface SegmentedButtonConfig extends Ext.ContainerConfig {
        /**
         * Allow toggling the pressed state of each button.
         * Defaults to 'true' when {@link #allowMultiple} is 'true'.
         */
        allowDepress?: boolean;

        /**
         * Allow multiple pressed buttons.
         */
        allowMultiple?: boolean;

        /**
         * Allow child buttons to be pressed when tapped on. Set to 'false' to allow tapping but not toggling of the buttons.
         */
        allowToggle?: boolean;

        baseCls?: any;

        defaultType?: any;

        /**
         * Default {@link Ext.Component#ui ui} to use for buttons in this segmented button.
         * Buttons can override this default by specifying their own UI
         */
        defaultUI?: any;

        /**
         * If {@link #allowMultiple} is 'true', this config may be set to 'true' to indicate that at least
         * one button in the set must remain pressed at all times.
         *
         * If no {@link #value} is configured, and no child buttons are configured 'pressed', the first child
         * button is set 'pressed: true'
         *
         * @since 6.0.2
         */
        forceSelection?: boolean;

        layout?: any;

        /**
         * The pressed buttons for this segmented button.
         *
         * You can remove all pressed buttons by calling {@link #setPressedButtons} with an empty array.
         */
        pressedButtons?: any[];

        /**
         * The value of this button.  When {@link #allowMultiple} is 'false', value is a
         * String or Number.  When {@link #allowMultiple is 'true', value is an array
         * of values.  A value corresponds to a child button's {@link Ext.Button#value
         * value}, or its index if no child button values match the given value.
         *
         * Using the 'value' config of the child buttons with single toggle:
         *
         *     @example
         *     var button = Ext.create('Ext.SegmentedButton', {
         *         renderTo: Ext.getBody(),
         *         value: 'optTwo', // begin with "Option Two" selected
         *         items: [{
         *             text: 'Option One',
         *             value: 'optOne'
         *         }, {
         *             text: 'Option Two',
         *             value: 'optTwo'
         *         }, {
         *             text: 'Option Three',
         *             value:  'optThree'
         *         }]
         *     });
         *
         *     console.log(button.getValue()); // 'optTwo'
         *
         *     // Sets the value to optOne, and sets the pressed state of the "Option One" button
         *     button.setValue('optOne');
         *
         *     console.log(button.getValue()); // 'optOne'
         *
         * Using multiple toggle, and index-based values:
         *
         *     @example
         *     var button = Ext.create('Ext.SegmentedButton', {
         *         renderTo: Ext.getBody(),
         *         allowMultiple: true
         *         value: [1, 2], // begin with "Option Two" and "Option Three" selected
         *         items: [{
         *             text: 'Option One'
         *         }, {
         *             text: 'Option Two'
         *         }, {
         *             text: 'Option Three'
         *         }]
         *     });
         *
         *     // Sets value to [0, 2], and sets pressed state of "Option One" and "Option Three"
         *     button.setValue([0, 2]);
         *
         *     console.log(button.getValue()); // [0, 2]
         *
         *     // Remove all pressed buttons, and set value to null
         *     button.setValue(null);
         *
         * Note that value based setting and index based setting cannot be mixed.
         */
        value?: any;
    }

    /**
     * SegmentedButton is a container for a group of {@link Ext.Button}s. Generally a SegmentedButton would be
     * a child of a {@link Ext.Toolbar} and would be used to switch between different views.
     *
     * ## Example usage:
     *
     *     @example
     *     var segmentedButton = Ext.create('Ext.SegmentedButton', {
     *         allowMultiple: true,
     *         items: [
     *             {
     *                 text: 'Option 1'
     *             },
     *             {
     *                 text: 'Option 2',
     *                 pressed: true
     *             },
     *             {
     *                 text: 'Option 3'
     *             }
     *         ],
     *         listeners: {
     *             toggle: function(container, button, pressed){
     *                 alert("User toggled the '" + button.getText() + "' button: " + (pressed ? 'on' : 'off'));
     *             }
     *         }
     *     });
     *     Ext.Viewport.add({ xtype: 'container', padding: 10, items: [segmentedButton] });
     */
    export class SegmentedButton extends Ext.Container implements Ext.SegmentedButtonConfig {
        /**
         * Allow toggling the pressed state of each button.
         * Defaults to 'true' when {@link #allowMultiple} is 'true'.
         */
        allowDepress: boolean;

        /**
         * Allow multiple pressed buttons.
         */
        allowMultiple: boolean;

        /**
         * Allow child buttons to be pressed when tapped on. Set to 'false' to allow tapping but not toggling of the buttons.
         */
        allowToggle: boolean;

        /**
         * The base CSS class to apply to this component's element. This will also be prepended to
         * other elements within this component. To add specific styling for sub-classes, use the {@link #cls} config.
         */
        baseCls: string;

        /** @cfg {String} defaultType
         * The default {@link Ext.Component xtype} of child Components to create in this Container when a child item
         * is specified as a raw configuration object, rather than as an instantiated Component.
         */
        defaultType: any;

        /**
         * Default {@link Ext.Component#ui ui} to use for buttons in this segmented button.
         * Buttons can override this default by specifying their own UI
         */
        defaultUI: any;

        /**
         * If {@link #allowMultiple} is 'true', this config may be set to 'true' to indicate that at least
         * one button in the set must remain pressed at all times.
         *
         * If no {@link #value} is configured, and no child buttons are configured 'pressed', the first child
         * button is set 'pressed: true'
         *
         * @since 6.0.2
         */
        forceSelection: boolean;

        /**
         * Configuration for this Container's layout. Example:
         *
         *     Ext.create('Ext.Container', {
         *         layout: {
         *             type: 'hbox',
         *             align: 'middle'
         *         },
         *         items: [
         *             {
         *                 xtype: 'panel',
         *                 flex: 1,
         *                 style: 'background-color: red;'
         *             },
         *             {
         *                 xtype: 'panel',
         *                 flex: 2,
         *                 style: 'background-color: green'
         *             }
         *         ]
         *     });
         */
        layout: any|string;

        /**
         * The pressed buttons for this segmented button.
         *
         * You can remove all pressed buttons by calling {@link #setPressedButtons} with an empty array.
         */
        pressedButtons: any[];

        /**
         * The value of this button.  When {@link #allowMultiple} is 'false', value is a
         * String or Number.  When {@link #allowMultiple is 'true', value is an array
         * of values.  A value corresponds to a child button's {@link Ext.Button#value
         * value}, or its index if no child button values match the given value.
         *
         * Using the 'value' config of the child buttons with single toggle:
         *
         *     @example
         *     var button = Ext.create('Ext.SegmentedButton', {
         *         renderTo: Ext.getBody(),
         *         value: 'optTwo', // begin with "Option Two" selected
         *         items: [{
         *             text: 'Option One',
         *             value: 'optOne'
         *         }, {
         *             text: 'Option Two',
         *             value: 'optTwo'
         *         }, {
         *             text: 'Option Three',
         *             value:  'optThree'
         *         }]
         *     });
         *
         *     console.log(button.getValue()); // 'optTwo'
         *
         *     // Sets the value to optOne, and sets the pressed state of the "Option One" button
         *     button.setValue('optOne');
         *
         *     console.log(button.getValue()); // 'optOne'
         *
         * Using multiple toggle, and index-based values:
         *
         *     @example
         *     var button = Ext.create('Ext.SegmentedButton', {
         *         renderTo: Ext.getBody(),
         *         allowMultiple: true
         *         value: [1, 2], // begin with "Option Two" and "Option Three" selected
         *         items: [{
         *             text: 'Option One'
         *         }, {
         *             text: 'Option Two'
         *         }, {
         *             text: 'Option Three'
         *         }]
         *     });
         *
         *     // Sets value to [0, 2], and sets pressed state of "Option One" and "Option Three"
         *     button.setValue([0, 2]);
         *
         *     console.log(button.getValue()); // [0, 2]
         *
         *     // Remove all pressed buttons, and set value to null
         *     button.setValue(null);
         *
         * Note that value based setting and index based setting cannot be mixed.
         */
        value: any;

        constructor(config: Ext.ActionSheetConfig);

        destroy();

        getAllowDepress();

        getAllowMultiple();

        getAllowToggle();

        getBaseCls();

        getDefaultType();

        getDefaultUI();

        getForceSelection();

        getLayout();

        getValue();

        protected initialize();

        /**
         * Returns 'true' if a specified {@link Ext.Button} is pressed.
         * @param {Ext.Button} button The button to check if pressed.
         * @return {Boolean} pressed
         */
        isPressed(button: Ext.Button): boolean;

        setAllowDepress();

        setAllowMultiple();

        setAllowToggle();

        setBaseCls();

        setDefaultType();

        setDefaultUI();

        setForceSelection();

        setLayout();

        setPressedButtons();

        setValue();

        /**
         * Fires when the value changes.
         * @param {Object/Object[]} value The new value. Will be an array with {@link #allowMultiple},
         * a single value if not.
         * @param {Object/Object[]} oldValue The old value. Will be an array with {@link #allowMultiple},
         * a single value if not.
         */
        change(that: Ext.SegmentedButton, value: any, oldValue: any);

        /**
         * Fires when any child button's pressed state has changed.
         * @param {Ext.Button} button The toggled button.
         * @param {Boolean} isPressed Boolean to indicate if the button was pressed or not.
         */
        toggle(that: Ext.SegmentedButton, button: Ext.Button, isPressed: boolean);
    }

    interface SheetConfig extends Ext.PanelConfig {
        baseCls?: any;

        border?: any;

        /**
         * Whether or not this component is absolutely centered inside its container.
         */
        centered?: boolean;

        /**
         * The viewport side used as the enter point when shown. Valid values are 'top', 'bottom', 'left', and 'right'.
         * Applies to sliding animation effects only.
         */
        enter?: string;

        /**
         * The viewport side used as the exit point when hidden. Valid values are 'top', 'bottom', 'left', and 'right'.
         * Applies to sliding animation effects only.
         */
        exit?: string;

        hideAnimation?: any;

        modal?: any;

        showAnimation?: any;

        /**
         * 'true' to stretch this sheet horizontally.
         */
        stretchX?: boolean;

        /**
         * 'true' to stretch this sheet vertically.
         */
        stretchY?: boolean;
    }

    /**
     * A general sheet class. This renderable container provides base support for orientation-aware transitions for popup or
     * side-anchored sliding Panels.
     *
     * In most cases, you should use {@link Ext.ActionSheet}, {@link Ext.MessageBox}, {@link Ext.picker.Picker}, or {@link Ext.picker.Date}.
     */
    export class Sheet extends Ext.Panel implements Ext.SheetConfig {
        baseCls: string;

        /**
         * Enables or disables bordering on this component.
         * The following values are accepted:
         *
         * - 'null' or 'true (default): Do nothing and allow the border to be specified by the theme.
         * - 'false': suppress the default border provided by the theme.
         *
         * Please note that enabling bordering via this config will not add a 'border-color'
         * or 'border-style' CSS property to the component; you provide the 'border-color'
         * and 'border-style' via CSS rule or {@link #style} configuration
         * (if not already provide by the theme).
         *
         * ## Using {@link #style}:
         *
         *     Ext.Viewport.add({
         *         centered: true,
         *         width: 100,
         *         height: 100,
         *
         *         style: 'border: 1px solid blue;'
         *         // ...
         *     });
         *
         * ## Using CSS:
         *
         *     Ext.Viewport.add({
         *         centered: true,
         *         width: 100,
         *         height: 100,
         *
         *         cls: 'my-component'
         *         // ...
         *     });
         *
         * And your CSS file:
         *
         *     .my-component {
         *         border: 1px solid red;
         *     }
         */
        border: boolean;

        /**
         * Whether or not this component is absolutely centered inside its container.
         */
        centered: boolean;

        /**
         * The viewport side used as the enter point when shown. Valid values are 'top', 'bottom', 'left', and 'right'.
         * Applies to sliding animation effects only.
         */
        enter: string;

        /**
         * The viewport side used as the exit point when hidden. Valid values are 'top', 'bottom', 'left', and 'right'.
         * Applies to sliding animation effects only.
         */
        exit: string;

        /**
         * Animation effect to apply when the Component is being hidden.  Typically you want to use an
         * outbound animation type such as 'fadeOut' or 'slideOut'. For more animations, check the {@link Ext.fx.Animation#type} config.
         */
        hideAnimation: string|any;

        protected manageBorders: any;

        /**
         * 'true' to make this Container modal. This will create a mask underneath the Container
         * that covers its parent and does not allow the user to interact with any other Components until this
         * Container is dismissed.
         */
        modal: boolean;

        /**
         * Animation effect to apply when the Component is being shown.  Typically you want to use an
         * inbound animation type such as 'fadeIn' or 'slideIn'. For more animations, check the {@link Ext.fx.Animation#type} config.
         */
        showAnimation: string|any;

        /**
         * 'true' to stretch this sheet horizontally.
         */
        stretchX: boolean;

        /**
         * 'true' to stretch this sheet vertically.
         */
        stretchY: boolean;

        constructor(config: Ext.ActionSheetConfig);

        getBaseCls();

        getBorder();

        getCentered();

        getEnter();

        getExit();

        getHideAnimation();

        getModal();

        getShowAnimation();

        getStretchX();

        getStretchY();

        setBaseCls();

        setBorder();

        setCentered();

        setEnter();

        setExit();

        setHideAnimation();

        setModal();

        setShowAnimation();

        setStretchX();

        setStretchY();

        centeredchange();
    }

    interface SpacerConfig extends Ext.ComponentConfig {
        /**
         * The flex value of this spacer. This defaults to 1, if no width has been set.
         */
        flex?: number;
    }

    /**
     The {@link Ext.Spacer} component is generally used to put space between items in {@link Ext.Toolbar} components.
     ## Examples
     By default the {@link #flex} configuration is set to 1:
     @example miniphone preview
     Ext.create('Ext.Container', {
     fullscreen: true,
     items: [
     {
     xtype : 'toolbar',
     docked: 'top',
     items: [
     {
     xtype: 'button',
     text : 'Button One'
     },
     {
     xtype: 'spacer'
     },
     {
     xtype: 'button',
     text : 'Button Two'
     }
     ]
     }
     ]
     });
     Alternatively you can just set the {@link #width} configuration which will get the {@link Ext.Spacer} a fixed width:
     @example preview
     Ext.create('Ext.Container', {
     fullscreen: true,
     layout: {
     type: 'vbox',
     pack: 'center',
     align: 'stretch'
     },
     items: [
     {
     xtype : 'toolbar',
     docked: 'top',
     items: [
     {
     xtype: 'button',
     text : 'Button One'
     },
     {
     xtype: 'spacer',
     width: 50
     },
     {
     xtype: 'button',
     text : 'Button Two'
     }
     ]
     },
     {
     xtype: 'container',
     items: [
     {
     xtype: 'button',
     text : 'Change Ext.Spacer width',
     handler: function() {
     //get the spacer using ComponentQuery
     var spacer = Ext.ComponentQuery.query('spacer')[0],
     from = 10,
     to = 250;
     //set the width to a random number
     spacer.setWidth(Math.floor(Math.random() * (to - from + 1) + from));
     }
     }
     ]
     }
     ]
     });
     You can also insert multiple {@link Ext.Spacer}'s:
     @example preview
     Ext.create('Ext.Container', {
     fullscreen: true,
     items: [
     {
     xtype : 'toolbar',
     docked: 'top',
     items: [
     {
     xtype: 'button',
     text : 'Button One'
     },
     {
     xtype: 'spacer'
     },
     {
     xtype: 'button',
     text : 'Button Two'
     },
     {
     xtype: 'spacer',
     width: 20
     },
     {
     xtype: 'button',
     text : 'Button Three'
     }
     ]
     }
     ]
     });
     */
    export class Spacer extends Ext.Component implements Ext.SpacerConfig {
        /**
         * The flex value of this spacer. This defaults to 1, if no width has been set.
         */
        flex: number;

        /**
         * Creates new Component.
         * @param {Object} config The standard configuration object.
         */
        constructor(config: Ext.ButtonConfig);

        getFlex();

        getWidth();

        setFlex();

        setWidth();
    }

    /**
     * A collection of useful static methods to deal with strings.
     */
    export class String {
        /**
         * Adds a set of character entity definitions to the set used by
         * {@link Ext.String#htmlEncode} and {@link Ext.String#htmlDecode}.
         *
         * This object should be keyed by the entity name sequence,
         * with the value being the textual representation of the entity.
         *
         *      Ext.String.addCharacterEntities({
         *          '&amp;Uuml;':'Ãœ',
         *          '&amp;ccedil;':'Ã§',
         *          '&amp;ntilde;':'Ã±',
         *          '&amp;egrave;':'Ã¨'
         *      });
         *      var s = Ext.String.htmlEncode("A string with entities: Ã¨ÃœÃ§Ã±");
         *
         * __Note:__ the values of the character entities defined on this object are expected
         * to be single character values.  As such, the actual values represented by the
         * characters are sensitive to the character encoding of the JavaScript source
         * file when defined in string literal form. Script tags referencing server
         * resources with character entities must ensure that the 'charset' attribute
         * of the script node is consistent with the actual character encoding of the
         * server resource.
         *
         * The set of character entities may be reset back to the default state by using
         * the {@link Ext.String#resetCharacterEntities} method
         *
         * @param {Object} newEntities The set of character entities to add to the current
         * definitions.
         */
        static addCharacterEntities(newEntities: any);

        /**
         * Capitalize the first letter of the given string.
         * @return {String}
         */
        static capitalize(string: string): string;

        /**
         * Creates a 'RegExp' given a string 'value' and optional flags. For example, the
         * following two regular expressions are equivalent.
         *
         *      var regex1 = Ext.String.createRegex('hello');
         *
         *      var regex2 = /^hello$/i;
         *
         * The following two regular expressions are also equivalent:
         *
         *      var regex1 = Ext.String.createRegex('world', false, false, false);
         *
         *      var regex2 = /world/;
         *
         * @param {String/RegExp} value The String to convert to a 'RegExp'.
         * @param {Boolean} [startsWith=true] Pass 'false' to allow a match to start
         * anywhere in the string. By default the 'value' will match only at the start
         * of the string.
         * @param {Boolean} [endsWith=true] Pass 'false' to allow the match to end before
         * the end of the string. By default the 'value' will match only at the end of the
         * string.
         * @param {Boolean} [ignoreCase=true] Pass 'false' to make the 'RegExp' case
         * sensitive (removes the 'i' flag).
         * @since 5.0.0
         * @return {RegExp}
         */
        static createRegex(value: string|RegExp, startsWith?: boolean, endsWith?: boolean, ignoreCase?: boolean): RegExp;

        /**
         * Converts a string of characters into a legal, parse-able JavaScript 'var' name as long as the passed
         * string contains at least one alphabetic character. Non alphanumeric characters, and *leading* non alphabetic
         * characters will be removed.
         * @param {String} s A string to be converted into a 'var' name.
         * @return {String} A legal JavaScript 'var' name.
         */
        static createVarName(s: string): string;

        /**
         * Truncate a string and add an ellipsis ('...') to the end if it exceeds the specified length.
         * @param {String} value The string to truncate.
         * @param {Number} length The maximum length to allow before truncating.
         * @param {Boolean} [word=false] 'true' to try to find a common word break.
         * @return {String} The converted text.
         */
        static ellipsis(value: string, length: number, word?: boolean): string;

        /**
         * Checks if a string ends with a substring
         * @param {String} s The original string
         * @param {String} end The substring to check
         * @param {Boolean} [ignoreCase=false] True to ignore the case in the comparison
         */
        static endsWith(s: string, end: string, ignoreCase?: boolean);

        /**
         * Escapes the passed string for ' and \.
         * @param {String} string The string to escape.
         * @return {String} The escaped string.
         */
        static escape(string: string): string;

        /**
         * Escapes the passed string for use in a regular expression.
         * @param {String} string The string to escape.
         * @return {String} The escaped string.
         */
        static escapeRegex(string: string): string;

        /**
         * Allows you to define a tokenized string and pass an arbitrary number of arguments to replace the tokens.  Each
         * token must be unique, and must increment in the format {0}, {1}, etc.  Example usage:
         *
         *     var cls = 'my-class',
         *         text = 'Some text';
         *     var s = Ext.String.format('<div class="{0}">{1}</div>', cls, text);
         *     // s now contains the string: '<div class="my-class">Some text</div>'
         *
         * @param {String} string The tokenized string to be formatted.
         * @param {Mixed...} values The values to replace tokens '{0}', '{1}', etc in order.
         * @return {String} The formatted string.
         */
        static format(string: string, values: any): string;

        /**
         * Convert certain characters (&, <, >, ', and ") from their HTML character equivalents.
         * @param {String} value The string to decode.
         * @return {String} The decoded text.
         */
        static htmlDecode(value: string): string;

        /**
         * Convert certain characters (&, <, >, ', and ") to their HTML character equivalents for literal display in web pages.
         * @param {String} value The string to encode.
         * @return {String} The encoded text.
         */
        static htmlEncode(value: string): string;

        /**
         * Inserts a substring into a string.
         * @param {String} s The original string.
         * @param {String} value The substring to insert.
         * @param {Number} index The index to insert the substring. Negative indexes will insert from the end of
         * the string. Example:
         *
         *     Ext.String.insert("abcdefg", "h", -1); // abcdefhg
         *
         * @return {String} The value with the inserted substring
         */
        static insert(s: string, value: string, index: number): string;

        /**
         * Pads the left side of a string with a specified character.  This is especially useful
         * for normalizing number and date strings.  Example usage:
         *
         *     var s = Ext.String.leftPad('123', 5, '0');
         *     // s now contains the string: '00123'
         *
         * @param {String} string The original string.
         * @param {Number} size The total length of the output string.
         * @param {String} [character=' '] (optional) The character with which to pad the original string.
         * @return {String} The padded string.
         */
        static leftPad(string: string, size: number, character?: string): string;

        /**
         * Returns a string with a specified number of repetitions a given string pattern.
         * The pattern be separated by a different string.
         *
         *      var s = Ext.String.repeat('---', 4); // = '------------'
         *      var t = Ext.String.repeat('--', 3, '/'); // = '--/--/--'
         *
         * @param {String} pattern The pattern to repeat.
         * @param {Number} count The number of times to repeat the pattern (may be 0).
         * @param {String} sep An option string to separate each pattern.
         */
        static repeat(pattern: string, count: number, sep: string);

        /**
         * Resets the set of character entity definitions used by
         * {@link Ext.String#htmlEncode} and {@link Ext.String#htmlDecode} back to the
         * default state.
         */
        static resetCharacterEntities();

        /**
         * Splits a string of space separated words into an array, trimming as needed. If the
         * words are already an array, it is returned.
         */
        static splitWords(words: string|any[]);

        /**
         * Checks if a string starts with a substring
         * @param {String} s The original string
         * @param {String} start The substring to check
         * @param {Boolean} [ignoreCase=false] True to ignore the case in the comparison
         */
        static startsWith(s: string, start: string, ignoreCase?: boolean);

        /**
         * Utility function that allows you to easily switch a string between two alternating values.  The passed value
         * is compared to the current string, and if they are equal, the other value that was passed in is returned.  If
         * they are already different, the first value passed in is returned.  Note that this method returns the new value
         * but does not change the current string.
         *
         *     // alternate sort directions
         *     sort = Ext.String.toggle(sort, 'ASC', 'DESC');
         *
         *     // instead of conditional logic:
         *     sort = (sort === 'ASC' ? 'DESC' : 'ASC');
         *
         * @param {String} string The current string.
         * @param {String} value The value to compare to the current string.
         * @param {String} other The new value to use if the string already equals the first value passed in.
         * @return {String} The new value.
         */
        static toggle(string: string, value: string, other: string): string;

        /**
         * Trims whitespace from either end of a string, leaving spaces within the string intact.  Example:
         *
         *     var s = '  foo bar  ';
         *     alert('-' + s + '-');                   //alerts "- foo bar -"
         *     alert('-' + Ext.String.trim(s) + '-');  //alerts "-foo bar-"
         *
         * @param {String} string The string to trim.
         * @return {String} The trimmed string.
         */
        static trim(string: string): string;

        /**
         * Uncapitalize the first letter of a given string.
         * @return {String}
         */
        static uncapitalize(string: string): string;

        /**
         * Appends content to the query string of a URL, handling logic for whether to place
         * a question mark or ampersand.
         * @param {String} url The URL to append to.
         * @param {String} string The content to append to the URL.
         * @return {String} The resulting URL
         */
        static urlAppend(url: string, string: string): string;
    }

    /**
     * Contains information about features supported in the current environment as well
     * as bugs detected.
     */
    export class supports {
        /**
         * 'true' if the browser fires focus events (focus, blur, focusin, focusout)
         * asynchronously, i.e. in a separate event loop invocation. This is only true
         * for all versions Internet Explorer; Microsoft Edge and other browsers fire
         * focus events synchronously.
         */
        static AsyncFocusEvents: boolean;

        /**
         * if the device supports the HTML5 'audio' tag.
         *
         * This property is available at application boot time, before document ready.
         */
        static Audio: boolean;

        /**
         * if the device supports the HTML5 'audio' tag.
         * @deprecated Use 'Audio' instead.
         */
        static AudioTag: boolean;

        /**
         * if the browser supports the getBoundingClientRect method on elements
         *
         * This property is available at application boot time, before document ready.
         */
        static BoundingClientRect: boolean;

        /**
         * if the device supports Canvas.
         *
         * This property is available at application boot time, before document ready.
         */
        static Canvas: boolean;

        /**
         * if created child elements
         * lose their innerHTML when modifying the innerHTML of the parent element.
         *
         * This property is *NOT* available at application boot time. Only after the document ready event.
         */
        static ChildContentClearedWhenSettingInnerHTML: boolean;

        /**
         * if document environment supports the HTML5
         * classList API.
         *
         * This property is available at application boot time, before document ready.
         */
        static ClassList: boolean;

        /**
         * if the native DOM cloneNode method copies
         * expando properties to the newly cloned node.
         *
         * This property is available at application boot time, before document ready.
         */
        static CloneNodeCopiesExpando: boolean;

        /**
         * if the browser supports document.defaultView.getComputedStyle().
         *
         * This property is *NOT* available at application boot time. Only after the document ready event.
         */
        static ComputedStyle: boolean;

        /**
         * if browser support CreateContextualFragment
         * range native methods.
         * See https://developer.mozilla.org/en/DOM/range.createContextualFragment
         *
         * This property is available at application boot time, before document ready.
         */
        static CreateContextualFragment: boolean;

        /**
         * if the device supports CSS3 border radius.
         *
         * This property is *NOT* available at application boot time. Only after the document ready event.
         */
        static CSS3BorderRadius: boolean;

        /**
         * if document environment supports the CSS3
         * box-shadow style.
         *
         * This property is available at application boot time, before document ready.
         */
        static CSS3BoxShadow: boolean;

        /**
         * if the device supports CSS3DTransform.
         *
         * This property is available at application boot time, before document ready.
         */
        static Css3DTransforms: boolean;

        /**
         * if the device supports CSS3 linear gradients.
         *
         * This property is available at application boot time, before document ready.
         */
        static CSS3LinearGradient: boolean;

        /**
         * if document environment supports the CSS3
         * pointer-events style.
         *
         * This property is available at application boot time, before document ready.
         */
        static CSSPointerEvents: boolean;

        /**
         * if the device supports device motion (acceleration
         * and rotation rate).
         *
         * This property is available at application boot time, before document ready.
         */
        static DeviceMotion: boolean;

        /**
         * if when asking for an element's dimension via offsetWidth or offsetHeight,
         * getBoundingClientRect, etc. the browser returns the subpixel width rounded to the nearest pixel.
         *
         * This property is available at application boot time, before document ready.
         */
        static Direct2DBug: boolean;

        /**
         * if INPUT elements lose their
         * selection when their display style is changed. Essentially, if a text input
         * has focus and its display style is changed, the I-beam disappears.
         *
         * This bug is encountered due to the work around in place for the {@link #RightMargin}
         * bug. This has been observed in Safari 4.0.4 and older, and appears to be fixed
         * in Safari 5. It's not clear if Safari 4.1 has the bug, but it has the same WebKit
         * version number as Safari 5 (according to http://unixpapa.com/js/gecko.html).
         *
         * This property is available at application boot time, before document ready.
         */
        static DisplayChangeInputSelectionBug: any;

        /**
         * if TEXTAREA elements lose their
         * selection when their display style is changed. Essentially, if a text area has
         * focus and its display style is changed, the I-beam disappears.
         *
         * This bug is encountered due to the work around in place for the {@link #RightMargin}
         * bug. This has been observed in Chrome 10 and Safari 5 and older, and appears to
         * be fixed in Chrome 11.
         *
         * This property is available at application boot time, before document ready.
         */
        static DisplayChangeTextAreaSelectionBug: any;

        /**
         * True if the browser emulates a mouseover event on tap (mobile safari)
         *
         * This property is available at application boot time, before document ready.
         */
        static EmulatedMouseOver: boolean;

        /**
         * if the device supports CSS float.
         *
         * This property is available at application boot time, before document ready.
         */
        static Float: boolean;

        /**
         * if the device supports GeoLocation.
         *
         * This property is available at application boot time, before document ready.
         */
        static Geolocation: boolean;

        /**
         * if the device supports Geo-location.
         * @deprecated Use 'Geolocation' instead (notice the lower-casing of 'L').
         */
        static GeoLocation: boolean;

        /**
         * if the browser will return the left/top/right/bottom
         * position as a percentage when explicitly set as a percentage value.
         *
         * This property is *NOT* available at application boot time. Only after the document ready event.
         */
        static GetPositionPercentage: boolean;

        /**
         * if the user agent supports the hashchange event
         *
         * This property is available at application boot time, before document ready.
         */
        static Hashchange: boolean;

        /**
         * 'true' if the browser is currently
         * running in Windows High Contrast accessibility mode.
         *
         * Accessibility features.
         *
         * 'true' if the browser is configured
         * to display images.
         *
         * 'true' if the browser
         * is configured to display background images.
         *
         * 'true' if the browser
         * is configured to honor CSS styling for border colors.
         *
         * 'true' if the browser
         * is currently using reverse colors in light-on-dark accessibility mode.
         */
        static HighContrastMode: boolean;

        /**
         * if the device supports HTML5 history. See
         * https://developer.mozilla.org/en/DOM/Manipulating_the_browser_history
         *
         * This property is available at application boot time, before document ready.
         */
        static History: boolean;

        /**
         * if localStorage is supported.
         *
         * This property is available at application boot time, before document ready.
         */
        static LocalStorage: boolean;

        /**
         * The method name which matches an element against a selector if implemented in this environment.
         *
         * This property is available at application boot time, before document ready.
         */
        static matchesSelector: string;

        /**
         * if the browser supports mouseenter and mouseleave events
         *
         * This property is available at application boot time, before document ready.
         */
        static MouseEnterLeave: boolean;

        /**
         * if the browser supports the mousewheel event
         *
         * This property is available at application boot time, before document ready.
         */
        static MouseWheel: boolean;

        /**
         * if the browser supports placeholders
         * on numeric input fields
         *
         * This property is available at application boot time, before document ready.
         */
        static NumericInputPlaceHolder: boolean;

        /**
         * if the browser supports normal css opacity
         *
         * This property is available at application boot time, before document ready.
         */
        static Opacity: boolean;

        /**
         * if the device supports different orientations.
         *
         * This property is available at application boot time, before document ready.
         */
        static Orientation: boolean;

        /**
         * if the device supports the 'orientationchange'
         * event.
         *
         * This property is available at application boot time, before document ready.
         */
        static OrientationChange: boolean;

        /**
         * if the browser supports the HTML5 placeholder attribute on inputs
         *
         * This property is available at application boot time, before document ready.
         */
        static Placeholder: boolean;

        /**
         * if browser support document.createRange native method.
         * See https://developer.mozilla.org/en/DOM/range.
         *
         * This property is available at application boot time, before document ready.
         */
        static Range: boolean;

        /**
         * if the device supports right margin.
         * See https://bugs.webkit.org/show_bug.cgi?id=13343 for why this is needed.
         *
         * This property is *NOT* available at application boot time. Only after the document ready event.
         */
        static RightMargin: boolean;

        /**
         * if the BoundingClientRect is
         * rotated when the element is rotated using a CSS transform.
         *
         * This property is *NOT* available at application boot time. Only after the document ready event.
         */
        static RotatedBoundingClientRect: boolean;

        /**
         * In some browsers the right padding of an overflowing element is not accounted
         * for in its scrollWidth.  The result can vary depending on whether or not
         * The element contains block-level children.  This method tests the effect
         * of padding on scrollWidth when there are no block-level children inside the
         * overflowing element.
         *
         * This method returns true if the browser is affected by this bug.
         *
         * This property is *NOT* available at application boot time. Only after the document ready event.
         */
        static ScrollWidthInlinePaddingBug: boolean;

        /**
         * True if the browser fires the keydown event on specialkey autorepeat
         *
         * note 1: IE fires ONLY the keydown event on specialkey autorepeat
         * note 2: Safari < 3.1, Gecko (Mac/Linux) & Opera fire only the keypress event on
         * specialkey autorepeat (research done by Jan Wolter at
         * http://unixpapa.com/js/key.html)
         * note 3: Opera 12 behaves like other modern browsers so this workaround does not
         * work anymore
         *
         * This property is available at application boot time, before document ready.
         */
        static SpecialKeyDownRepeat: boolean;

        /**
         * if the device supports SVG.
         *
         * This property is available at application boot time, before document ready.
         */
        static Svg: boolean;

        /**
         * if the browser supports maxlength on textareas.
         *
         * This property is available at application boot time, before document ready.
         */
        static TextAreaMaxLength: boolean;

        /**
         * if the browser supports touch input.
         *
         * This property is available at application boot time, before document ready.
         */
        static Touch: boolean;

        /**
         * if the device supports touch events ('touchstart',
         * 'touchmove', 'touchend').
         *
         * This property is available at application boot time, before document ready.
         */
        static TouchEvents: boolean;

        /**
         * if the device supports CSS3 Transitions.
         *
         * This property is available at application boot time, before document ready.
         */
        static Transitions: boolean;

        /**
         * if the device supports transparent color.
         *
         * This property is *NOT* available at application boot time. Only after the document ready event.
         */
        static TransparentColor: boolean;

        /**
         * if the device supports the HTML5 'video' tag.
         *
         * This property is available at application boot time, before document ready.
         */
        static Video: boolean;

        /**
         * if the device supports VML.
         *
         * This property is available at application boot time, before document ready.
         */
        static Vml: boolean;

        /**
         * if the browser supports XMLHttpRequest
         *
         * This property is available at application boot time, before document ready.
         */
        static XHR2: boolean;

        /**
         * if the browser supports XMLHttpRequest
         * upload progress info
         *
         * This property is available at application boot time, before document ready.
         */
        static XHRUploadProgress: boolean;
    }

    /**
     * Handle batch read / write of DOMs, currently used in SizeMonitor + PaintMonitor
     */
    export class TaskQueue {
    }

    interface TemplateConfig {
        /**
         * True to immediately compile the template. Defaults to false.
         */
        compiled?: boolean;

        /**
         * True to disable format functions in the template. If the template doesn't contain
         * format functions, setting disableFormats to true will reduce apply time. Defaults to false.
         */
        disableFormats?: boolean;
    }

    /**
     * Represents an HTML fragment template. Templates may be {@link #compile precompiled} for greater performance.
     *
     * An instance of this class may be created by passing to the constructor either a single argument, or multiple
     * arguments:
     *
     * # Single argument: String/Array
     *
     * The single argument may be either a String or an Array:
     *
     * - String:
     *
     *       var t = new Ext.Template("<div>Hello {0}.</div>");
     *       t.append('some-element', ['foo']);
     *
     * - Array:
     *
     *   An Array will be combined with 'join('')'.
     *
     *       var t = new Ext.Template([
     *           '<div name="{id}">',
     *               '<span class="{cls}">{name:trim} {value:ellipsis(10)}</span>',
     *           '</div>',
     *       ]);
     *       t.compile();
     *       t.append('some-element', {id: 'myid', cls: 'myclass', name: 'foo', value: 'bar'});
     *
     * # Multiple arguments: String, Object, Array, ...
     *
     * Multiple arguments will be combined with 'join('')'.
     *
     *     var t = new Ext.Template(
     *         '<div name="{id}">',
     *             '<span class="{cls}">{name} {value}</span>',
     *         '</div>',
     *         // a configuration object:
     *         {
     *             compiled: true,      // {@link #compile} immediately
     *         }
     *     );
     *
     * # Notes
     *
     * - For a list of available format functions, see {@link Ext.util.Format}.
     * - 'disableFormats' reduces '{@link #apply}' time when no formatting is required.
     */
    export class Template extends Ext.Base implements Ext.TemplateConfig {
        /**
         * 'true' in this class to identify an object as an instantiated Template, or subclass thereof.
         */
        isTemplate: boolean;

        /**
         * True to immediately compile the template. Defaults to false.
         */
        compiled: boolean;

        /**
         * True to disable format functions in the template. If the template doesn't contain
         * format functions, setting disableFormats to true will reduce apply time. Defaults to false.
         */
        disableFormats: boolean;

        /**
         * Applies the supplied 'values' to the template and appends the new node(s) to the specified 'el'.
         *
         * For example usage see {@link Ext.Template Ext.Template class docs}.
         *
         * @param {String/HTMLElement/Ext.dom.Element} el The context element
         * @param {Object/Array} values The template values. See {@link #applyTemplate} for details.
         * @param {Boolean} returnElement (optional) true to return an Ext.Element.
         * @return {HTMLElement/Ext.dom.Element} The new node or Element
         */
        append(el: string|HTMLElement|Ext.dom.Element, values: any|any[], returnElement: boolean): HTMLElement|Ext.dom.Element;

        /**
         * Returns an HTML fragment of this template with the specified values applied.
         *
         * @param {Object/Array} values The template values. Can be an array if your params are numeric:
         *
         *     var tpl = new Ext.Template('Name: {0}, Age: {1}');
         *     tpl.apply(['John', 25]);
         *
         * or an object:
         *
         *     var tpl = new Ext.Template('Name: {name}, Age: {age}');
         *     tpl.apply({name: 'John', age: 25});
         *
         * @return {String} The HTML fragment
         */
        apply(values: any|any[]): string;

        /**
         * Appends the result of this template to the provided output array.
         * @param {Object/Array} values The template values. See {@link #apply}.
         * @param {Array} out The array to which output is pushed.
         * @return {Array} The given out array.
         */
        applyOut(values: any|any[], out: any[]): any[];

        /**
         * Alias for {@link #apply}.
         */
        applyTemplate();

        /**
         * Compiles the template into an internal function, eliminating the RegEx overhead.
         * @return {Ext.Template} this
         */
        compile(): Ext.Template;

        /**
         * Creates new template.
         *
         * @param {String...} html List of strings to be concatenated into template.
         * Alternatively an array of strings can be given, but then no config object may be passed.
         * @param {Object} config (optional) Config object
         */
        constructor(html: string, config: Ext.TemplateConfig);

        /**
         * Applies the supplied values to the template and inserts the new node(s) after el.
         *
         * @param {String/HTMLElement/Ext.dom.Element} el The context element
         * @param {Object/Array} values The template values. See {@link #applyTemplate} for details.
         * @param {Boolean} returnElement (optional) true to return a Ext.Element.
         * @return {HTMLElement/Ext.dom.Element} The new node or Element
         */
        insertAfter(el: string|HTMLElement|Ext.dom.Element, values: any|any[], returnElement: boolean): HTMLElement|Ext.dom.Element;

        /**
         * Applies the supplied values to the template and inserts the new node(s) before el.
         *
         * @param {String/HTMLElement/Ext.dom.Element} el The context element
         * @param {Object/Array} values The template values. See {@link #applyTemplate} for details.
         * @param {Boolean} returnElement (optional) true to return a Ext.Element.
         * @return {HTMLElement/Ext.dom.Element} The new node or Element
         */
        insertBefore(el: string|HTMLElement|Ext.dom.Element, values: any|any[], returnElement: boolean): HTMLElement|Ext.dom.Element;

        /**
         * Applies the supplied values to the template and inserts the new node(s) as the first child of el.
         *
         * @param {String/HTMLElement/Ext.dom.Element} el The context element
         * @param {Object/Array} values The template values. See {@link #applyTemplate} for details.
         * @param {Boolean} returnElement (optional) true to return a Ext.Element.
         * @return {HTMLElement/Ext.dom.Element} The new node or Element
         */
        insertFirst(el: string|HTMLElement|Ext.dom.Element, values: any|any[], returnElement: boolean): HTMLElement|Ext.dom.Element;

        /**
         * Applies the supplied values to the template and overwrites the content of el with the new node(s).
         *
         * @param {String/HTMLElement/Ext.dom.Element} el The context element
         * @param {Object/Array} values The template values. See {@link #applyTemplate} for details.
         * @param {Boolean} returnElement (optional) true to return a Ext.Element.
         * @return {HTMLElement/Ext.dom.Element} The new node or Element
         */
        overwrite(el: string|HTMLElement|Ext.dom.Element, values: any|any[], returnElement: boolean): HTMLElement|Ext.dom.Element;

        /**
         * Sets the HTML used as the template and optionally compiles it.
         * @param {Boolean} compile (optional) True to compile the template.
         * @return {Ext.Template} this
         */
        set(html: string, compile: boolean): Ext.Template;

        /**
         * Creates a template from the passed element's value (_display:none_ textarea, preferred) or innerHTML.
         * @param {String/HTMLElement} el A DOM element or its id
         * @param {Object} config (optional) Config object
         * @return {Ext.Template} The created template
         * @inheritable
         */
        static from(el: string|HTMLElement, config: Ext.TemplateConfig): Ext.Template;
    }

    interface TitleBarConfig extends Ext.ContainerConfig {
        baseCls?: any;

        cls?: any;

        /**
         * The child items to add to this TitleBar. The {@link #defaultType} of
         * a TitleBar is {@link Ext.Button}, so you do not need to specify an 'xtype' if you are adding
         * buttons.
         *
         * You can also give items a 'align' configuration which will align the item to the 'left' or 'right' of
         * the TitleBar.
         */
        items?: any[]|any;

        /**
         * The maximum width of the button by percentage
         */
        maxButtonWidth?: string;

        /**
         * The title of the toolbar.
         */
        title?: string;

        /**
         * The alignment for the title of the toolbar.
         */
        titleAlign?: string;

        /**
         * Style options for Toolbar. Either 'light' or 'dark'.
         */
        ui?: string;
    }

    /**
     * {@link Ext.TitleBar}'s are most commonly used as a docked item within an {@link Ext.Container}.
     *
     * The main difference between a {@link Ext.TitleBar} and an {@link Ext.Toolbar} is that
     * the {@link #title} configuration is **always** centered horizontally in a {@link Ext.TitleBar} between
     * any items aligned left or right.
     *
     * You can also give items of a {@link Ext.TitleBar} an 'align' configuration of 'left' or 'right'
     * which will dock them to the 'left' or 'right' of the bar.
     *
     * ## Examples
     *
     *     @example preview
     *     Ext.Viewport.add({
     *         xtype: 'titlebar',
     *         docked: 'top',
     *         title: 'Navigation',
     *         items: [
     *             {
     *                 iconCls: 'add',
     *                 align: 'left'
     *             },
     *             {
     *                 iconCls: 'home',
     *                 align: 'right'
     *             }
     *         ]
     *     });
     *
     *     Ext.Viewport.setStyleHtmlContent(true);
     *     Ext.Viewport.setHtml('This shows the title being centered and buttons using align <i>left</i> and <i>right</i>.');
     *
     * <br />
     *
     *     @example preview
     *     Ext.Viewport.add({
     *         xtype: 'titlebar',
     *         docked: 'top',
     *         title: 'Navigation',
     *         items: [
     *             {
     *                 align: 'left',
     *                 text: 'This button has a super long title'
     *             },
     *             {
     *                 iconCls: 'home',
     *                 align: 'right'
     *             }
     *         ]
     *     });
     *
     *     Ext.Viewport.setStyleHtmlContent(true);
     *     Ext.Viewport.setHtml('This shows how the title is automatically moved to the right when one of the aligned buttons is very wide.');
     *
     * <br />
     *
     *     @example preview
     *     Ext.Viewport.add({
     *         xtype: 'titlebar',
     *         docked: 'top',
     *         title: 'A very long title',
     *         items: [
     *             {
     *                 align: 'left',
     *                 text: 'This button has a super long title'
     *             },
     *             {
     *                 align: 'right',
     *                 text: 'Another button'
     *             }
     *         ]
     *     });
     *
     *     Ext.Viewport.setStyleHtmlContent(true);
     *     Ext.Viewport.setHtml('This shows how the title and buttons will automatically adjust their size when the width of the items are too wide..');
     *
     * The {@link #defaultType} of Toolbar's is {@link Ext.Button button}.
     */
    export class TitleBar extends Ext.Container implements Ext.TitleBarConfig {
        defaultBindProperty: any;

        /**
         * The base CSS class to apply to this component's element. This will also be prepended to
         * other elements within this component. To add specific styling for sub-classes, use the {@link #cls} config.
         */
        baseCls: string;

        /**
         * The CSS class to add to this component's element, in
         * addition to the {@link #baseCls}. In many cases, this property will be specified
         * by the derived component class. See {@link #userCls} for adding additional CSS
         * classes to component instances (such as items in a {@link Ext.Container}).
         */
        cls: string;

        /**
         * The child items to add to this TitleBar. The {@link #defaultType} of
         * a TitleBar is {@link Ext.Button}, so you do not need to specify an 'xtype' if you are adding
         * buttons.
         *
         * You can also give items a 'align' configuration which will align the item to the 'left' or 'right' of
         * the TitleBar.
         */
        items: any[]|any;

        /**
         * The maximum width of the button by percentage
         */
        maxButtonWidth: string;

        /**
         * The title of the toolbar.
         */
        title: string;

        /**
         * The alignment for the title of the toolbar.
         */
        titleAlign: string;

        /**
         * Style options for Toolbar. Either 'light' or 'dark'.
         */
        ui: string;

        constructor(config: Ext.ActionSheetConfig);

        getBaseCls();

        getCls();

        getDefaultType();

        getItems();

        getMaxButtonWidth();

        getMinHeight();

        getTitle();

        getTitleAlign();

        getUi();

        protected initialize();

        setBaseCls();

        setCls();

        setDefaultType();

        setItems();

        setMaxButtonWidth();

        setMinHeight();

        setTitle();

        setTitleAlign();

        setUi();
    }

    interface TitleConfig extends Ext.ComponentConfig {
        baseCls?: any;

        /**
         * The title text
         */
        title?: string;
    }

    /**
     * {@link Ext.Title} is used for the {@link Ext.Toolbar#title} configuration in the {@link Ext.Toolbar} component.
     */
    export class Title extends Ext.Component implements Ext.TitleConfig {
        /**
         * The base CSS class to apply to this component's element. This will also be prepended to
         * other elements within this component. To add specific styling for sub-classes, use the {@link #cls} config.
         */
        baseCls: string;

        /**
         * The title text
         */
        title: string;

        /**
         * Creates new Component.
         * @param {Object} config The standard configuration object.
         */
        constructor(config: Ext.ButtonConfig);

        getBaseCls();

        getTitle();

        setBaseCls();

        setTitle();
    }

    interface ToastConfig extends Ext.SheetConfig {
        /**
         * @cfg{Boolean/Object} animation
         * The animation that should be used between toast messages when they are queued up
         */
        animation?: any;

        baseCls?: any;

        hideAnimation?: any;

        hideOnMaskTap?: any;

        layout?: any;

        /**
         * The message to be displayed in the {@link Ext.Toast}.
         */
        message?: string;

        showAnimation?: any;

        /**
         * The amount of time in milliseconds to wait before destroying the toast automatically
         */
        timeout?: number;

        ui?: any;

        /**
         * Override the default 'zIndex' so it is normally always above floating components.
         */
        zIndex?: any;
    }

    /**
     * A 'Toast' is a simple modal message that is displayed on the screen and then automatically closed by a timeout or by a user tapping
     * outside of the toast itself. Think about it like a text only alert box that will self destruct. **A Toast should not be instantiated manually**
     * but creating by calling 'Ext.toast(message, timeout)'. This will create one reusable toast container and content will be swapped out as
     * toast messages are queued or displayed.
     *
     * # Simple Toast
     *
     *      @example miniphone
     *      Ext.toast('Hello Sencha!'); // Toast will close in 1000 milliseconds (default)
     *
     * # Toast with Timeout
     *
     *      @example miniphone
     *      Ext.toast('Hello Sencha!', 5000); // Toast will close in 5000 milliseconds
     *
     * # Toast with config
     *
     *      @example miniphone
     *      Ext.toast({message: 'Hello Sencha!', timeout: 2000}); // Toast will close in 2000 milliseconds
     *
     * # Multiple Toasts queued
     *
     *      @example miniphone
     *      Ext.toast('Hello Sencha!');
     *      Ext.toast('Hello Sencha Again!');
     *      Ext.toast('Hello Sencha One More Time!');
     */
    export class Toast extends Ext.Sheet implements Ext.ToastConfig {
        /**
         * @cfg{Boolean/Object} animation
         * The animation that should be used between toast messages when they are queued up
         */
        animation: any;

        baseCls: string;

        /**
         * Animation effect to apply when the Component is being hidden.  Typically you want to use an
         * outbound animation type such as 'fadeOut' or 'slideOut'. For more animations, check the {@link Ext.fx.Animation#type} config.
         */
        hideAnimation: string|any;

        /**
         * When using a {@link #modal} Component, setting this to 'true' will hide the modal
         * mask and the Container when the mask is tapped on.
         */
        hideOnMaskTap: boolean;

        /**
         * Configuration for this Container's layout. Example:
         *
         *     Ext.create('Ext.Container', {
         *         layout: {
         *             type: 'hbox',
         *             align: 'middle'
         *         },
         *         items: [
         *             {
         *                 xtype: 'panel',
         *                 flex: 1,
         *                 style: 'background-color: red;'
         *             },
         *             {
         *                 xtype: 'panel',
         *                 flex: 2,
         *                 style: 'background-color: green'
         *             }
         *         ]
         *     });
         */
        layout: any|string;

        /**
         * The message to be displayed in the {@link Ext.Toast}.
         */
        message: string;

        /**
         * Animation effect to apply when the Component is being shown.  Typically you want to use an
         * inbound animation type such as 'fadeIn' or 'slideIn'. For more animations, check the {@link Ext.fx.Animation#type} config.
         */
        showAnimation: string|any;

        /**
         * The amount of time in milliseconds to wait before destroying the toast automatically
         */
        timeout: number;

        /**
         * The ui to be used on this Component
         */
        ui: string;

        /**
         * Override the default 'zIndex' so it is normally always above floating components.
         */
        zIndex: number;

        constructor(config: Ext.ActionSheetConfig);

        getBaseCls();

        getHideAnimation();

        getHideOnMaskTap();

        getLayout();

        getMessage();

        getShowAnimation();

        getTimeout();

        getUi();

        getZIndex();

        setBaseCls();

        setHideAnimation();

        setHideOnMaskTap();

        setLayout();

        setMessage();

        setShowAnimation();

        setTimeout();

        setUi();

        setZIndex();
    }

    interface ToolbarConfig extends Ext.ContainerConfig {
        baseCls?: any;

        /**
         * A default {@link Ext.Component#ui ui} to use for {@link Ext.Button Button} items.
         */
        defaultButtonUI?: any;

        /**
         * The docked position for this {@link Ext.Toolbar}.
         * If you specify 'left' or 'right', the {@link #layout} configuration will automatically change to a 'vbox'. It's also
         * recommended to adjust the {@link #width} of the toolbar if you do this.
         */
        docked?: string;

        /**
         * Configuration for this Container's layout. Example:
         *
         *     Ext.create('Ext.Container', {
         *         layout: {
         *             type: 'hbox',
         *             align: 'middle'
         *         },
         *         items: [
         *             {
         *                 xtype: 'panel',
         *                 flex: 1,
         *                 style: 'background-color: red;'
         *             },
         *             {
         *                 xtype: 'panel',
         *                 flex: 2,
         *                 style: 'background-color: green'
         *             }
         *         ]
         *     });
         *
         * __Note:__ If you set the {@link #docked} configuration to 'left' or 'right', the default layout will change from the
         * 'hbox' to a 'vbox'.
         */
        layout?: any|string;

        /**
         * The title of the toolbar.
         */
        title?: string|Ext.Title;
    }

    /**
     * {@link Ext.Toolbar}s are most commonly used as docked items as within a {@link Ext.Container}. They can be docked either 'top' or 'bottom' using the {@link #docked} configuration.
     *
     * They allow you to insert items (normally {@link Ext.Button buttons}) and also add a {@link #title}.
     *
     * The {@link #defaultType} of {@link Ext.Toolbar} is {@link Ext.Button}.
     *
     * You can alternatively use {@link Ext.TitleBar} if you want the title to automatically adjust the size of its items.
     *
     * ## Examples
     *
     *     @example miniphone preview
     *     Ext.create('Ext.Container', {
     *         fullscreen: true,
     *         layout: {
     *             type: 'vbox',
     *             pack: 'center'
     *         },
     *         items: [
     *             {
     *                 xtype : 'toolbar',
     *                 docked: 'top',
     *                 title: 'My Toolbar'
     *             },
     *             {
     *                 xtype: 'container',
     *                 defaults: {
     *                     xtype: 'button',
     *                     margin: '10 10 0 10'
     *                 },
     *                 items: [
     *                     {
     *                         text: 'Toggle docked',
     *                         handler: function() {
     *                             var toolbar = Ext.ComponentQuery.query('toolbar')[0],
     *                                 newDocked = (toolbar.getDocked() === 'top') ? 'bottom' : 'top';
     *
     *                             toolbar.setDocked(newDocked);
     *                         }
     *                     },
     *                     {
     *                         text: 'Toggle UI',
     *                         handler: function() {
     *                             var toolbar = Ext.ComponentQuery.query('toolbar')[0],
     *                                 newUi = (toolbar.getUi() === 'light') ? 'dark' : 'light';
     *
     *                             toolbar.setUi(newUi);
     *                         }
     *                     },
     *                     {
     *                         text: 'Change title',
     *                         handler: function() {
     *                             var toolbar = Ext.ComponentQuery.query('toolbar')[0],
     *                                 titles = ['My Toolbar', 'Ext.Toolbar', 'Configurations are awesome!', 'Beautiful.'],
     //internally, the title configuration gets converted into a {@link Ext.Title} component,
     //so you must get the title configuration of that component
     *                                 title = toolbar.getTitle().getTitle(),
     *                                 newTitle = titles[titles.indexOf(title) + 1] || titles[0];
     *
     *                             toolbar.setTitle(newTitle);
     *                         }
     *                     }
     *                 ]
     *             }
     *         ]
     *     });
     *
     * ## Notes
     *
     * You must use a HTML5 doctype for {@link #docked} 'bottom' to work. To do this, simply add the following code to the HTML file:
     *
     *     <!doctype html>
     *
     * So your index.html file should look a little like this:
     *
     *     <!doctype html>
     *     <html>
     *         <head>
     *             <title>MY application title</title>
     *             ...
     */
    export class Toolbar extends Ext.Container implements Ext.ToolbarConfig {
        /**
         * The base CSS class to apply to this component's element. This will also be prepended to
         * other elements within this component. To add specific styling for sub-classes, use the {@link #cls} config.
         */
        baseCls: string;

        /**
         * A default {@link Ext.Component#ui ui} to use for {@link Ext.Button Button} items.
         */
        defaultButtonUI: any;

        /**
         * The docked position for this {@link Ext.Toolbar}.
         * If you specify 'left' or 'right', the {@link #layout} configuration will automatically change to a 'vbox'. It's also
         * recommended to adjust the {@link #width} of the toolbar if you do this.
         */
        docked: string;

        /**
         * Configuration for this Container's layout. Example:
         *
         *     Ext.create('Ext.Container', {
         *         layout: {
         *             type: 'hbox',
         *             align: 'middle'
         *         },
         *         items: [
         *             {
         *                 xtype: 'panel',
         *                 flex: 1,
         *                 style: 'background-color: red;'
         *             },
         *             {
         *                 xtype: 'panel',
         *                 flex: 2,
         *                 style: 'background-color: green'
         *             }
         *         ]
         *     });
         *
         * __Note:__ If you set the {@link #docked} configuration to 'left' or 'right', the default layout will change from the
         * 'hbox' to a 'vbox'.
         */
        layout: any|string;

        /**
         * The title of the toolbar.
         */
        title: string|Ext.Title;

        constructor(config: Ext.ToolbarConfig);

        getBaseCls();

        getDefaultButtonUI();

        getDefaultType();

        getDocked();

        getLayout();

        getMinHeight();

        /**
         * Returns an {@link Ext.Title} component.
         * @return {Ext.Title}
         */
        getTitle(): Ext.Title;

        /**
         * Hides the title, if it exists.
         */
        hideTitle();

        setBaseCls();

        setDefaultButtonUI();

        setDefaultType();

        setDocked();

        setLayout();

        setMinHeight();

        /**
         * Use this to update the {@link #title} configuration.
         * @param {String/Ext.Title} title You can either pass a String, or a config/instance of {@link Ext.Title}.
         */
        setTitle(title: string|Ext.Title);

        /**
         * Shows the title, if it exists.
         */
        showTitle();
    }

    /**
     * A utility class that wraps around a version number string and provides convenient methods
     * to perform comparisons. A version number is expressed in the following general format:
     *
     *     major[.minor[.patch[.build[release]]]]
     *
     * The 'Version' instance holds various readonly properties that contain the digested form
     * of the version string. The numeric componnets of 'major', 'minor', 'patch' and 'build'
     * as well as the textual suffix called 'release'.
     *
     * Not depicted in the above syntax are three possible prefixes used to control partial
     * matching. These are '^' (the default), '>' and '~'. These are discussed below.
     *
     * Examples:
     *
     *     var version = new Ext.Version('1.0.2beta'); // or maybe "1.0" or "1.2.3.4RC"
     *     console.log("Version is " + version); // Version is 1.0.2beta
     *
     *     console.log(version.getMajor()); // 1
     *     console.log(version.getMinor()); // 0
     *     console.log(version.getPatch()); // 2
     *     console.log(version.getBuild()); // 0
     *     console.log(version.getRelease()); // beta
     *
     * The understood values of 'release' are assigned numberic equivalents for the sake of
     * comparsion. The order of these from smallest to largest is as follows:
     *
     *  * '"dev"'
     *  * '"alpha"' or '"a"'
     *  * '"beta"' or '"b"'
     *  * '"RC"' or '"rc"'
     *  * '"#"'
     *  * '"pl"' or '"p"'
     *
     * Any other (unrecognized) suffix is consider greater than any of these.
     *
     * ## Comparisons
     * There are two forms of comparison that are commonly needed: full and partial. Full
     * comparison is simpler and is also the default.
     *
     * Example:
     *
     *     var version = new Ext.Version('1.0.2beta');
     *
     *     console.log(version.isGreaterThan('1.0.1')); // True
     *     console.log(version.isGreaterThan('1.0.2alpha')); // True
     *     console.log(version.isGreaterThan('1.0.2RC')); // False
     *     console.log(version.isGreaterThan('1.0.2')); // False
     *     console.log(version.isLessThan('1.0.2')); // True
     *
     *     console.log(version.match(1.0)); // True (using a Number)
     *     console.log(version.match('1.0.2')); // True (using a String)
     *
     * These comparisons are ultimately implemented by {@link Ext.Version#compareTo compareTo}
     * which returns -1, 0 or 1 depending on whether the 'Version' instance is less than, equal
     * to, or greater than the given "other" version.
     *
     * For example:
     *
     *      var n = version.compareTo('1.0.1');  // == 1  (because 1.0.2beta > 1.0.1)
     *
     *      n = version.compareTo('1.1');  // == -1
     *      n = version.compareTo(version); // == 0
     *
     * ### Partial Comparisons
     * By default, unspecified version number fields are filled with 0. In other words, the
     * version number fields are 0-padded on the right or a "lower bound". This produces the
     * most commonly used forms of comparsion:
     *
     *      var ver = new Version('4.2');
     *
     *      n = ver.compareTo('4.2.1'); // == -1  (4.2 promotes to 4.2.0 and is less than 4.2.1)
     *
     * There are two other ways to interpret comparisons of versions of different length. The
     * first of these is to change the padding on the right to be a large number (scuh as
     * Infinity) instead of 0. This has the effect of making the version an upper bound. For
     * example:
     *
     *      var ver = new Version('^4.2'); // NOTE: the '^' prefix used
     *
     *      n = ver.compareTo('4.3'); // == -1  (less than 4.3)
     *
     *      n = ver.compareTo('4.2'); // == 1   (greater than all 4.2's)
     *      n = ver.compareTo('4.2.1'); // == 1
     *      n = ver.compareTo('4.2.9'); // == 1
     *
     * The second way to interpret this comparison is to ignore the extra digits, making the
     * match a prefix match. For example:
     *
     *      var ver = new Version('~4.2'); // NOTE: the '~' prefix used
     *
     *      n = ver.compareTo('4.3'); // == -1
     *
     *      n = ver.compareTo('4.2'); // == 0
     *      n = ver.compareTo('4.2.1'); // == 0
     *
     * This final form can be useful when version numbers contain more components than are
     * important for certain comparisons. For example, the full version of Ext JS 4.2.1 is
     * "4.2.1.883" where 883 is the 'build' number.
     *
     * This is how to create a "partial" 'Version' and compare versions to it:
     *
     *      var version421ish = new Version('~4.2.1');
     *
     *      n = version421ish.compareTo('4.2.1.883'); // == 0
     *      n = version421ish.compareTo('4.2.1.2'); // == 0
     *      n = version421ish.compareTo('4.2.1'); // == 0
     *
     *      n = version421ish.compareTo('4.2'); // == 1
     *
     * In the above example, '4.2.1.2' compares as equal to '4.2.1' because digits beyond the
     * given "4.2.1" are ignored. However, '4.2' is less than the '4.2.1' prefix; its missing
     * digit is filled with 0.
     */
    export class Version {
        /**
         * The fourth numeric part of the version number string.
         * @readonly
         *
         * Optional
         */
        build: number;

        /**
         * The first numeric part of the version number string.
         * @readonly
         */
        major: number;

        /**
         * The second numeric part of the version number string.
         * @readonly
         *
         * Optional
         */
        minor: number;

        /**
         * The third numeric part of the version number string.
         * @readonly
         *
         * Optional
         */
        patch: number;

        /**
         * The release level. The following values are understood:
         *
         *  * '"dev"'
         *  * '"alpha"' or '"a"'
         *  * '"beta"' or '"b"'
         *  * '"RC"' or '"rc"'
         *  * '"#"'
         *  * '"pl"' or '"p"'
         * @readonly
         *
         * Optional, Defaults to: ""
         */
        release: string;

        /**
         * Compares this version instance to the specified 'other' version.
         *
         * @param {String/Number/Ext.Version} other The other version to which to compare.
         * @return {Number} -1 if this version is less than the target version, 1 if this
         * version is greater, and 0 if they are equal.
         */
        compareTo(other: string|number|Ext.Version): number;

        /**
         * Returns whether this version equals to the supplied argument
         * @param {String/Number} target The version to compare with
         * @return {Boolean} 'true' if this version equals to the target, 'false' otherwise
         */
        equals(target: string|number): boolean;

        /**
         * Returns the build component value.
         * @return {Number}
         */
        getBuild(): number;

        /**
         * Returns the major component value.
         * @return {Number}
         */
        getMajor(): number;

        /**
         * Returns the minor component value.
         * @return {Number}
         */
        getMinor(): number;

        /**
         * Returns the patch component value.
         * @return {Number}
         */
        getPatch(): number;

        /**
         * Returns the release component text (e.g., "beta").
         * @return {String}
         */
        getRelease(): string;

        /**
         * Returns the release component value for comparison purposes.
         * @return {Number/String}
         */
        getReleaseValue(): number|string;

        /**
         * Returns shortVersion version without dots and release
         * @return {String}
         */
        getShortVersion(): string;

        /**
         * Convenient alias to {@link Ext.Version#isGreaterThan isGreaterThan}
         * @return {Boolean}
         */
        gt(target: string|number|Ext.Version): boolean;

        /**
         * Convenient alias to {@link Ext.Version#isGreaterThanOrEqual isGreaterThanOrEqual}
         * @return {Boolean}
         */
        gtEq(target: string|number|Ext.Version): boolean;

        /**
         * Returns whether this version if greater than the supplied argument
         * @param {String/Number} target The version to compare with
         * @return {Boolean} 'true' if this version if greater than the target, 'false' otherwise
         */
        isGreaterThan(target: string|number): boolean;

        /**
         * Returns whether this version if greater than or equal to the supplied argument
         * @param {String/Number} target The version to compare with
         * @return {Boolean} 'true' if this version if greater than or equal to the target, 'false' otherwise
         */
        isGreaterThanOrEqual(target: string|number): boolean;

        /**
         * Returns whether this version if smaller than the supplied argument
         * @param {String/Number} target The version to compare with
         * @return {Boolean} 'true' if this version if smaller than the target, 'false' otherwise
         */
        isLessThan(target: string|number): boolean;

        /**
         * Returns whether this version if less than or equal to the supplied argument
         * @param {String/Number} target The version to compare with
         * @return {Boolean} 'true' if this version if less than or equal to the target, 'false' otherwise
         */
        isLessThanOrEqual(target: string|number): boolean;

        /**
         * Convenient alias to {@link Ext.Version#isLessThan isLessThan}
         * @return {Boolean}
         */
        lt(target: string|number|Ext.Version): boolean;

        /**
         * Convenient alias to {@link Ext.Version#isLessThanOrEqual isLessThanOrEqual}
         * @return {Boolean}
         */
        ltEq(target: string|number|Ext.Version): boolean;

        /**
         * Returns whether this version matches the supplied argument. Example:
         *
         *     var version = new Ext.Version('1.0.2beta');
         *     console.log(version.match(1)); // true
         *     console.log(version.match(1.0)); // true
         *     console.log(version.match('1.0.2')); // true
         *     console.log(version.match('1.0.2RC')); // false
         *
         * @param {String/Number} target The version to compare with
         * @return {Boolean} 'true' if this version matches the target, 'false' otherwise
         */
        match(target: string|number): boolean;

        /**
         * Returns this format: [major, minor, patch, build, release]. Useful for comparison.
         * @return {Number[]}
         */
        toArray(): number;

        /**
         * Compare 2 specified versions by ensuring the first parameter is a 'Version'
         * instance and then calling the 'compareTo' method.
         *
         * @param {String} current The current version to compare to
         * @param {String} target The target version to compare to
         * @return {Number} Returns -1 if the current version is smaller than the target version, 1 if greater, and 0 if they're equivalent
         */
        static compare(current: string, target: string): number;

        /**
         * Converts a version component to a comparable value
         *
         * @param {Object} value The value to convert
         * @return {Object}
         */
        static getComponentValue(value: any): any;
    }

    interface VideoConfig extends Ext.MediaConfig {
        baseCls?: any;

        /**
         * Determines if native controls should be shown for this video player.
         */
        controls?: boolean;

        /**
         * Location of a poster image to be shown before showing the video.
         */
        posterUrl?: string;
    }

    /**
     * Provides a simple Container for HTML5 Video.
     *
     * ## Notes
     *
     * - There are quite a few issues with the '<video>' tag on Android devices. On Android 2+, the video will
     * appear and play on first attempt, but any attempt afterwards will not work.
     *
     * ## Useful Properties
     *
     * - {@link #url}
     * - {@link #autoPause}
     * - {@link #autoResume}
     *
     * ## Useful Methods
     *
     * - {@link #method-pause}
     * - {@link #method-play}
     * - {@link #toggle}
     *
     * ## Example
     *
     *     var panel = Ext.create('Ext.Panel', {
     *         fullscreen: true,
     *         items: [
     *             {
     *                 xtype    : 'video',
     *                 x        : 600,
     *                 y        : 300,
     *                 width    : 175,
     *                 height   : 98,
     *                 url      : "porsche911.mov",
     *                 posterUrl: 'porsche.png'
     *             }
     *         ]
     *     });
     */
    export class Video extends Ext.Media implements Ext.VideoConfig {
        protected template: any[];

        /**
         * The base CSS class to apply to this component's element. This will also be prepended to
         * other elements within this component. To add specific styling for sub-classes, use the {@link #cls} config.
         */
        baseCls: string;

        /**
         * Determines if native controls should be shown for this video player.
         */
        controls: boolean;

        /**
         * Location of a poster image to be shown before showing the video.
         */
        posterUrl: string;

        constructor();

        getBaseCls();

        getControls();

        getPosterUrl();

        getUrl();

        protected initialize();

        setBaseCls();

        setControls();

        setPosterUrl();

        setUrl();

        /**
         * Updates the URL to the poster, even if it is rendered.
         */
        updatePosterUrl(newUrl: any);
    }

    /**
     * @extends Ext.viewport.Default
     *
     * Ext.Viewport is an instance created when you use {@link Ext#setup}. Because {@link Ext.Viewport} extends from
     * {@link Ext.Container}, it has a {@link #layout} that defaults to {@link Ext.layout.Card}. This means you
     * can add items to it at any time, from anywhere in your code. The {@link Ext.Viewport} {@link #cfg-fullscreen}
     * configuration is 'true' by default, so it will take up your whole screen.
     *
     *     @example raw
     *     Ext.setup({
     *         onReady: function() {
     *             Ext.Viewport.add({
     *                 xtype: 'container',
     *                 html: 'My new container!'
     *             });
     *         }
     *     });
     *
     * If you want to customize anything about this {@link Ext.Viewport} instance, you can do so by adding a property
     * called 'viewport' into your {@link Ext#setup} object:
     *
     *     @example raw
     *     Ext.setup({
     *         viewport: {
     *             layout: 'vbox'
     *         },
     *         onReady: function() {
     *             //do something
     *         }
     *     });
     *
     * **Note** if you use {@link Ext#onReady}, this instance of {@link Ext.Viewport} will **not** be created. Though, in most cases,
     * you should **not** use {@link Ext#onReady}.
     */
    export class Viewport {
        constructor(config: Ext.viewport.DefaultConfig);
    }

    interface WidgetConfig {
        /**
         * The flex of this item *if* this item item is inside a {@link Ext.layout.HBox} or {@link Ext.layout.VBox}
         * layout.
         *
         * You can also update the flex of a component dynamically using the {@link Ext.layout.FlexBox#setItemFlex}
         * method.
         */
        flex?: number;

        /**
         * The height of this Component; must be a valid CSS length value, e.g: '300', '100px', '30%', etc.
         * By default, if this is not explicitly set, this Component's element will simply have its own natural size.
         * If set to 'auto', it will set the width to 'null' meaning it will have its own natural size.
         */
        height?: number|string;

        /**
         * The **unique id of this component instance.**
         *
         * It should not be necessary to use this configuration except for singleton objects in your application. Components
         * created with an id may be accessed globally using {@link Ext#getCmp Ext.getCmp}.
         *
         * Instead of using assigned ids, use the {@link #itemId} config, and {@link Ext.ComponentQuery ComponentQuery}
         * which provides selector-based searching for Sencha Components analogous to DOM querying. The
         * {@link Ext.Container} class contains {@link Ext.Container#down shortcut methods} to query
         * its descendant Components by selector.
         *
         * Note that this id will also be used as the element id for the containing HTML element that is rendered to the
         * page for this component. This allows you to write id-based CSS rules to style the specific instance of this
         * component uniquely, and also to select sub-elements using this component's id as the parent.
         *
         * **Note**: to avoid complications imposed by a unique id also see '{@link #itemId}'.
         *
         * Defaults to an auto-assigned id.
         */
        id?: string;

        /**
         * An itemId can be used as an alternative way to get a reference to a component when no object reference is
         * available. Instead of using an '{@link #id}' with {@link Ext#getCmp}, use 'itemId' with
         * {@link Ext.Container#getComponent} which will retrieve 'itemId''s or {@link #id}'s. Since 'itemId''s are an
         * index to the container's internal MixedCollection, the 'itemId' is scoped locally to the container - avoiding
         * potential conflicts with {@link Ext.ComponentManager} which requires a **unique** '{@link #id}'.
         *
         * Also see {@link #id}, {@link Ext.Container#query}, {@link Ext.Container#down} and {@link Ext.Container#child}.
         */
        itemId?: string;

        /**
         * Additional CSS styles that will be rendered into an inline style attribute when
         * the widget is rendered.
         *
         * You can pass either a string syntax:
         *
         *     style: 'background:red'
         *
         * Or by using an object:
         *
         *     style: {
         *         background: 'red'
         *     }
         *
         * When using the object syntax, you can define CSS Properties by using a string:
         *
         *     style: {
         *         'border-left': '1px solid red'
         *     }
         *
         * Although the object syntax is much easier to read, we suggest you to use the
         * string syntax for better performance.
         */
        style?: string|any;

        /**
         * One or more CSS classes to add to the component's primary element. This config
         * is intended solely for use by the component instantiator (the "user"), not by
         * derived classes.
         *
         * For example:
         *
         *      items: [{
         *          xtype: 'button',
         *          userCls: 'my-button'
         *      ...
         *      }]
         */
        userCls?: string;

        /**
         * The width of this Component; must be a valid CSS length value, e.g: '300', '100px', '30%', etc.
         * By default, if this is not explicitly set, this Component's element will simply have its own natural size.
         * If set to 'auto', it will set the width to 'null' meaning it will have its own natural size.
         */
        width?: number|string;
    }

    /**
     * Ext.Widget is a light-weight Component that consists of nothing more than a template
     * Element that can be cloned to quickly and efficiently replicate many instances.
     * Ext.Widget is typically not instantiated directly, because the default template is
     * just a single element with no listeners. Instead Ext.Widget should be extended to
     * create Widgets that have a useful markup structure and event listeners.
     *
     * For example:
     *
     *      Ext.define('MyWidget', {
     *          extend: 'Ext.Widget',
     *
     *          // The element template passed to Ext.Element.create()
     *          element: {
     *              reference: 'element',
     *              listeners: {
     *                  click: 'onClick'
     *              },
     *              children: [{
     *                  reference: 'innerElement',
     *                  listeners: {
     *                      click: 'onInnerClick'
     *                  }
     *              }]
     *          },
     *
     *          constructor: function(config) {
     *              // It is important to remember to call the Widget superclass constructor
     *              // when overriding the constructor in a derived class. This ensures that
     *              // the element is initialized from the template, and that initConfig() is
     *              // is called.
     *              this.callParent([config]);
     *
     *              // After calling the superclass constructor, the Element is available and
     *              // can safely be manipulated. Reference Elements are instances of
     *              // Ext.Element, and are cached on each Widget instance by reference name.
     *              Ext.getBody().appendChild(this.element);
     *          },
     *
     *          onClick: function() {
     *              // listeners use this Widget instance as their scope
     *              console.log('element clicked', this);
     *          },
     *
     *          onInnerClick: function() {
     *              // access the innerElement reference by name
     *              console.log('inner element clicked', this.innerElement);
     *          }
     *      });
     *
     * @since 5.0.0
     */
    export class Widget extends Ext.Evented implements Ext.WidgetConfig {
        /**
         * A configuration object for Ext.Element.create() that is used to create the Element
         * template.  Supports all the standard options of a Ext.Element.create() config and
         * adds 2 additional options:
         *
         * 1. 'reference' - this option specifies a name for Element references.  These
         * references names become properties of the Widget instance and refer to Ext.Element
         * instances that were created using the template:
         *
         *     element: {
         *         reference: 'element',
         *         children: [{
         *             reference: 'innerElement'
         *         }]
         *     }
         *
         * After construction of a widget the reference elements are accessible as follows:
         *
         *     var foo = new FooWidget(),
         *         innerEl = foo.innerEl; // an Ext.Element that wraps the innerElement
         *
         * The reference attribute is optional, but all Widgets must have a ''element''
         * reference on some element within the template (usually the outermost one).
         *
         * 2. 'listeners' - a standard listeners object as specified by {@link
         * Ext.mixin.Observable}.
         *
         *     element: {
         *         reference: 'element',
         *         listeners: {
         *             click: 'onClick'
         *         },
         *         children: [{
         *             reference: 'innerElement',
         *             listeners: {
         *                 click: 'onInnerClick'
         *             }
         *         }]
         *     }
         *
         * Since listeners cannot be attached without an Ext.Element reference the 'reference'
         * property MUST be specified in order to use 'listeners'.
         *
         * The Widget instance is used as the scope for all listeners specified in this way,
         * so it is invalid to use the 'scope' option in the 'listeners' config since it will
         * always be overwritten using 'this'.
         */
        protected element: any;

        /**
         * An array of child elements to use as the children of the main element in the {@link
         * #element} template.  Only used if "children" are not specified explicitly in the
         * {@link #element} template.
         */
        protected template: any[];

        /**
         * The flex of this item *if* this item item is inside a {@link Ext.layout.HBox} or {@link Ext.layout.VBox}
         * layout.
         *
         * You can also update the flex of a component dynamically using the {@link Ext.layout.FlexBox#setItemFlex}
         * method.
         */
        flex: number;

        /**
         * The height of this Component; must be a valid CSS length value, e.g: '300', '100px', '30%', etc.
         * By default, if this is not explicitly set, this Component's element will simply have its own natural size.
         * If set to 'auto', it will set the width to 'null' meaning it will have its own natural size.
         */
        height: number|string;

        /**
         * The **unique id of this component instance.**
         *
         * It should not be necessary to use this configuration except for singleton objects in your application. Components
         * created with an id may be accessed globally using {@link Ext#getCmp Ext.getCmp}.
         *
         * Instead of using assigned ids, use the {@link #itemId} config, and {@link Ext.ComponentQuery ComponentQuery}
         * which provides selector-based searching for Sencha Components analogous to DOM querying. The
         * {@link Ext.Container} class contains {@link Ext.Container#down shortcut methods} to query
         * its descendant Components by selector.
         *
         * Note that this id will also be used as the element id for the containing HTML element that is rendered to the
         * page for this component. This allows you to write id-based CSS rules to style the specific instance of this
         * component uniquely, and also to select sub-elements using this component's id as the parent.
         *
         * **Note**: to avoid complications imposed by a unique id also see '{@link #itemId}'.
         *
         * Defaults to an auto-assigned id.
         */
        id: string;

        /**
         * An itemId can be used as an alternative way to get a reference to a component when no object reference is
         * available. Instead of using an '{@link #id}' with {@link Ext#getCmp}, use 'itemId' with
         * {@link Ext.Container#getComponent} which will retrieve 'itemId''s or {@link #id}'s. Since 'itemId''s are an
         * index to the container's internal MixedCollection, the 'itemId' is scoped locally to the container - avoiding
         * potential conflicts with {@link Ext.ComponentManager} which requires a **unique** '{@link #id}'.
         *
         * Also see {@link #id}, {@link Ext.Container#query}, {@link Ext.Container#down} and {@link Ext.Container#child}.
         */
        itemId: string;

        /**
         * Additional CSS styles that will be rendered into an inline style attribute when
         * the widget is rendered.
         *
         * You can pass either a string syntax:
         *
         *     style: 'background:red'
         *
         * Or by using an object:
         *
         *     style: {
         *         background: 'red'
         *     }
         *
         * When using the object syntax, you can define CSS Properties by using a string:
         *
         *     style: {
         *         'border-left': '1px solid red'
         *     }
         *
         * Although the object syntax is much easier to read, we suggest you to use the
         * string syntax for better performance.
         */
        style: string|any;

        /**
         * One or more CSS classes to add to the component's primary element. This config
         * is intended solely for use by the component instantiator (the "user"), not by
         * derived classes.
         *
         * For example:
         *
         *      items: [{
         *          xtype: 'button',
         *          userCls: 'my-button'
         *      ...
         *      }]
         */
        userCls: string;

        /**
         * The width of this Component; must be a valid CSS length value, e.g: '300', '100px', '30%', etc.
         * By default, if this is not explicitly set, this Component's element will simply have its own natural size.
         * If set to 'auto', it will set the width to 'null' meaning it will have its own natural size.
         */
        width: number|string;

        protected applyStyle();

        clearListeners();

        constructor(config: Ext.ProgressConfig);

        destroy();

        /**
         * A template method for modifying the {@link #element} config before it is processed.
         * By default adds the result of 'this.getTemplate()' as the 'children' array of
         * {@link #element} if 'children' were not specified in the original
         * {@link #element} config.  Typically this method should not need to be implemented
         * in subclasses.  Instead the {@link #element} property should be use to configure
         * the element template for a given Widget subclass.
         *
         * This method is called once when the first instance of each Widget subclass is
         * created.  The element config object that is returned is cached and used as the template
         * for all successive instances.  The scope object for this method is the class prototype,
         * not the instance.
         *
         * @return {Object} the element config object
         */
        protected getElementConfig(): any;

        getFlex();

        getHeight();

        getItemId();

        /**
         * Returns the height and width of the Component.
         * @return {Object} The current 'height' and 'width' of the Component.
         * @return {Number} return.width
         * @return {Number} return.height
         */
        getSize(): any;

        getStyle();

        getUserCls();

        getWidth();

        /**
         * Initializes the Element for this Widget instance.  If this is the first time a
         * Widget of this type has been instantiated the {@link #element} config will be
         * processed to create an Element.  This Element is then cached on the prototype (see
         * afterCachedConfig) so that future instances can obtain their element by simply
         * cloning the Element that was cached by the first instance.
         */
        protected initElement();

        /**
         * Tests whether this Widget matches a {@link Ext.ComponentQuery ComponentQuery}
         * selector string.
         * @param {String} selector The selector string to test against.
         * @return {Boolean} 'true' if this Widget matches the selector.
         */
        is(selector: string): boolean;

        /**
         * Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
         * from the xtype (default) or whether it is directly of the xtype specified ('shallow = true').
         * **If using your own subclasses, be aware that a Component must register its own xtype
         * to participate in determination of inherited xtypes.__
         *
         * For a list of all available xtypes, see the {@link Ext.Component} header.
         *
         * Example usage:
         *
         *     var t = new Ext.field.Text();
         *     var isText = t.isXType('textfield'); // true
         *     var isBoxSubclass = t.isXType('field'); // true, descended from Ext.field.Field
         *     var isBoxInstance = t.isXType('field', true); // false, not a direct Ext.field.Field instance
         *
         * @param {String} xtype The xtype to check for this Component.
         * @param {Boolean} shallow (optional) 'false' to check whether this Component is descended from the xtype (this is
         * the default), or 'true' to check whether this Component is directly of the specified xtype.
         * @return {Boolean} 'true' if this component descends from the specified xtype, 'false' otherwise.
         */
        isXType(xtype: string, shallow: boolean): boolean;

        protected resolveListenerScope(defaultScope: any, skipThis: any);

        setFlex();

        setHeight();

        setItemId();

        /**
         * Sets the size of the Component.
         * @param {Number} width The new width for the Component.
         * @param {Number} height The new height for the Component.
         */
        setSize(width: number, height: number);

        setStyle();

        setUserCls();

        setWidth();

        /**
         * Toggles the specified CSS class on this element (removes it if it already exists,
         * otherwise adds it).
         * @param {String} className The CSS class to toggle.
         * @param {Boolean} [state] If specified as 'true', causes the class to be added. If
         * specified as 'false', causes the class to be removed.
         */
        toggleCls(className: string, state?: boolean);

        protected updateHeight();

        protected updateStyle();

        protected updateWidth();

        heightchange();

        widthchange();
    }

    interface XTemplateConfig extends Ext.TemplateConfig {
        /**
         * Optional. A statement, or array of statements which set up 'var's which may then
         * be accessed within the scope of the generated function.
         *
         *     var data = {
         *         name: 'Don Griffin',
         *         isWizard: true,
         *         title: 'Senior Technomage',
         *         company: 'Sencha Inc.'
         *     };
         *
         *     var tpl = new Ext.XTemplate('{[values.isWizard ? wizard : notSoWizard]}' +
         *         ' {name}', {
         *         definitions: 'var wizard = "Wizard", notSoWizard = "Townsperson";'
         *     });
         *
         *     console.log(tpl.apply(data));
         *     // LOGS: Wizard Don Griffin
         */
        definitions?: string|any[];

        /**
         * Expressions in templates that traverse "dot paths" and fail (due to 'null' at some
         * stage) have always been expanded as empty strings. This is convenient in most cases
         * but doing so can also mask errors in the template. Setting this to 'true' changes
         * this default so that any expression errors will be thrown as exceptions.
         *
         * Optional, Defaults to: false
         */
        strict?: boolean;
    }

    /**
     * A template class that supports advanced functionality like:
     *
     * - Auto-filling arrays using templates and sub-templates
     * - Conditional processing with basic comparison operators
     * - Basic math function support
     * - Execute arbitrary inline code with special built-in template variables
     * - Custom member functions
     * - Many special tags and built-in operators that aren't defined as part of the API, but are supported in the templates that can be created
     *
     * XTemplate provides the templating mechanism built into {@link Ext.view.View}.
     *
     * The {@link Ext.Template} describes the acceptable parameters to pass to the constructor. The following examples
     * demonstrate all of the supported features.
     *
     * # Sample Data
     *
     * This is the data object used for reference in each code example:
     *
     *     var data = {
     *         name: 'Don Griffin',
     *         title: 'Senior Technomage',
     *         company: 'Sencha Inc.',
     *         drinks: ['Coffee', 'Water', 'More Coffee'],
     *         kids: [
     *             { name: 'Aubrey',  age: 17 },
     *             { name: 'Joshua',  age: 13 },
     *             { name: 'Cale',    age: 10 },
     *             { name: 'Nikol',   age: 5 },
     *             { name: 'Solomon', age: 0 }
     *         ]
     *     };
     *
     * # Auto filling of arrays
     *
     * The **tpl** tag and the **for** operator are used to process the provided data object:
     *
     * - If the value specified in for is an array, it will auto-fill, repeating the template block inside the tpl
     *   tag for each item in the array.
     * - If for="." is specified, the data object provided is examined.
     * - If between="..." is specified, the provided value will be inserted between the items.
     *   This is also supported in the "foreach" looping template.
     * - While processing an array, the special variable {#} will provide the current array index + 1 (starts at 1, not 0).
     *
     * Examples:
     *
     *     <tpl for=".">...</tpl>       // loop through array at root node
     *     <tpl for="foo">...</tpl>     // loop through array at foo node
     *     <tpl for="foo.bar">...</tpl> // loop through array at foo.bar node
     *     <tpl for="." between=",">...</tpl> // loop through array at root node and insert ',' between each item
     *
     * Using the sample data above:
     *
     *     var tpl = new Ext.XTemplate(
     *         '<p>Kids: ',
     *         '<tpl for=".">',       // process the data.kids node
     *             '<p>{#}. {name}</p>',  // use current array index to autonumber
     *         '</tpl></p>'
     *     );
     *     tpl.overwrite(panel.body, data.kids); // pass the kids property of the data object
     *
     * An example illustrating how the **for** property can be leveraged to access specified members of the provided data
     * object to populate the template:
     *
     *     var tpl = new Ext.XTemplate(
     *         '<p>Name: {name}</p>',
     *         '<p>Title: {title}</p>',
     *         '<p>Company: {company}</p>',
     *         '<p>Kids: ',
     *         '<tpl for="kids">',     // interrogate the kids property within the data
     *             '<p>{name}</p>',
     *         '</tpl></p>'
     *     );
     *     tpl.overwrite(panel.body, data);  // pass the root node of the data object
     *
     * Flat arrays that contain values (and not objects) can be auto-rendered using the special **'{.}'** variable inside a
     * loop. This variable will represent the value of the array at the current index:
     *
     *     var tpl = new Ext.XTemplate(
     *         '<p>{name}\'s favorite beverages:</p>',
     *         '<tpl for="drinks">',
     *             '<div> - {.}</div>',
     *         '</tpl>'
     *     );
     *     tpl.overwrite(panel.body, data);
     *
     * When processing a sub-template, for example while looping through a child array, you can access the parent object's
     * members via the **parent** object:
     *
     *     var tpl = new Ext.XTemplate(
     *         '<p>Name: {name}</p>',
     *         '<p>Kids: ',
     *         '<tpl for="kids">',
     *             '<tpl if="age &gt; 1">',
     *                 '<p>{name}</p>',
     *                 '<p>Dad: {parent.name}</p>',
     *             '</tpl>',
     *         '</tpl></p>'
     *     );
     *     tpl.overwrite(panel.body, data);
     *
     * The **foreach** operator is used to loop over an object's properties.  The following
     * example demonstrates looping over the main data object's properties:
     *
     *     var tpl = new Ext.XTemplate(
     *         '<dl>',
     *             '<tpl foreach=".">',
     *                 '<dt>{$}</dt>', // the special **'{$}'** variable contains the property name
     *                 '<dd>{.}</dd>', // within the loop, the **'{.}'** variable is set to the property value
     *             '</tpl>',
     *         '</dl>'
     *     );
     *     tpl.overwrite(panel.body, data);
     *
     * # Conditional processing with basic comparison operators
     *
     * The **tpl** tag and the **if** operator are used to provide conditional checks for deciding whether or not to render
     * specific parts of the template.
     *
     * Using the sample data above:
     *
     *     var tpl = new Ext.XTemplate(
     *         '<p>Name: {name}</p>',
     *         '<p>Kids: ',
     *         '<tpl for="kids">',
     *             '<tpl if="age &gt; 1">',
     *                 '<p>{name}</p>',
     *             '</tpl>',
     *         '</tpl></p>'
     *     );
     *     tpl.overwrite(panel.body, data);
     *
     * More advanced conditionals are also supported:
     *
     *     var tpl = new Ext.XTemplate(
     *         '<p>Name: {name}</p>',
     *         '<p>Kids: ',
     *         '<tpl for="kids">',
     *             '<p>{name} is a ',
     *             '<tpl if="age &gt;= 13">',
     *                 '<p>teenager</p>',
     *             '<tpl elseif="age &gt;= 2">',
     *                 '<p>kid</p>',
     *             '<tpl else>',
     *                 '<p>baby</p>',
     *             '</tpl>',
     *         '</tpl></p>'
     *     );
     *
     *     var tpl = new Ext.XTemplate(
     *         '<p>Name: {name}</p>',
     *         '<p>Kids: ',
     *         '<tpl for="kids">',
     *             '<p>{name} is a ',
     *             '<tpl switch="name">',
     *                 '<tpl case="Aubrey" case="Nikol">',
     *                     '<p>girl</p>',
     *                 '<tpl default>',
     *                     '<p>boy</p>',
     *             '</tpl>',
     *         '</tpl></p>'
     *     );
     *
     * A 'break' is implied between each case and default, however, multiple cases can be listed
     * in a single &lt;tpl&gt; tag.
     *
     * # Using double quotes
     *
     * Examples:
     *
     *     var tpl = new Ext.XTemplate(
     *         "<tpl if='age &gt; 1 && age &lt; 10'>Child</tpl>",
     *         "<tpl if='age &gt;= 10 && age &lt; 18'>Teenager</tpl>",
     *         "<tpl if='this.isGirl(name)'>...</tpl>",
     *         '<tpl if="id == \'download\'">...</tpl>',
     *         "<tpl if='needsIcon'><img src='{icon}' class='{iconCls}'/></tpl>",
     *         "<tpl if='name == \"Don\"'>Hello</tpl>"
     *     );
     *
     * # Basic math support
     *
     * The following basic math operators may be applied directly on numeric data values:
     *
     *     + - * /
     *
     * For example:
     *
     *     var tpl = new Ext.XTemplate(
     *         '<p>Name: {name}</p>',
     *         '<p>Kids: ',
     *         '<tpl for="kids">',
     *             '<tpl if="age &gt; 1">',  // <-- Note that the > is encoded
     *                 '<p>{#}: {name}</p>',  // <-- Auto-number each item
     *                 '<p>In 5 Years: {age+5}</p>',  // <-- Basic math
     *                 '<p>Dad: {parent.name}</p>',
     *             '</tpl>',
     *         '</tpl></p>'
     *     );
     *     tpl.overwrite(panel.body, data);
     *
     * # Execute arbitrary inline code with special built-in template variables
     *
     * Anything between '{[ ... ]}' is considered code to be executed in the scope of the template.
     * The expression is evaluated and the result is included in the generated result. There are
     * some special variables available in that code:
     *
     * - **out**: The output array into which the template is being appended (using 'push' to later
     *   'join').
     * - **values**: The values in the current scope. If you are using scope changing sub-templates,
     *   you can change what values is.
     * - **parent**: The scope (values) of the ancestor template.
     * - **xindex**: If you are in a "for" or "foreach" looping template, the index of the loop you are in (1-based).
     * - **xcount**: If you are in a "for" looping template, the total length of the array you are looping.
     * - **xkey**: If you are in a "foreach" looping template, the key of the current property
     * being examined.
     *
     * This example demonstrates basic row striping using an inline code block and the xindex variable:
     *
     *     var tpl = new Ext.XTemplate(
     *         '<p>Name: {name}</p>',
     *         '<p>Company: {[values.company.toUpperCase() + ", " + values.title]}</p>',
     *         '<p>Kids: ',
     *         '<tpl for="kids">',
     *             '<div class="{[xindex % 2 === 0 ? "even" : "odd"]}">',
     *             '{name}',
     *             '</div>',
     *         '</tpl></p>'
     *      );
     *
     * Any code contained in "verbatim" blocks (using "{% ... %}") will be inserted directly in
     * the generated code for the template. These blocks are not included in the output. This
     * can be used for simple things like break/continue in a loop, or control structures or
     * method calls (when they don't produce output). The 'this' references the template instance.
     *
     *     var tpl = new Ext.XTemplate(
     *         '<p>Name: {name}</p>',
     *         '<p>Company: {[values.company.toUpperCase() + ", " + values.title]}</p>',
     *         '<p>Kids: ',
     *         '<tpl for="kids">',
     *             '{% if (xindex % 2 === 0) continue; %}',
     *             '{name}',
     *             '{% if (xindex > 100) break; %}',
     *             '</div>',
     *         '</tpl></p>'
     *      );
     *
     * # Template member functions
     *
     * One or more member functions can be specified in a configuration object passed into the XTemplate constructor for
     * more complex processing:
     *
     *     var tpl = new Ext.XTemplate(
     *         '<p>Name: {name}</p>',
     *         '<p>Kids: ',
     *         '<tpl for="kids">',
     *             '<tpl if="this.isGirl(name)">',
     *                 '<p>Girl: {name} - {age}</p>',
     *             '<tpl else>',
     *                 '<p>Boy: {name} - {age}</p>',
     *             '</tpl>',
     *             '<tpl if="this.isBaby(age)">',
     *                 '<p>{name} is a baby!</p>',
     *             '</tpl>',
     *         '</tpl></p>',
     *         {
     *             // XTemplate configuration:
     *             disableFormats: true,
     *             // member functions:
     *             isGirl: function(name){
     *                return name == 'Aubrey' || name == 'Nikol';
     *             },
     *             isBaby: function(age){
     *                return age < 1;
     *             }
     *         }
     *     );
     *     tpl.overwrite(panel.body, data);
     */
    export class XTemplate extends Ext.Template implements Ext.XTemplateConfig {
        /**
         * Optional. A statement, or array of statements which set up 'var's which may then
         * be accessed within the scope of the generated function.
         *
         *     var data = {
         *         name: 'Don Griffin',
         *         isWizard: true,
         *         title: 'Senior Technomage',
         *         company: 'Sencha Inc.'
         *     };
         *
         *     var tpl = new Ext.XTemplate('{[values.isWizard ? wizard : notSoWizard]}' +
         *         ' {name}', {
         *         definitions: 'var wizard = "Wizard", notSoWizard = "Townsperson";'
         *     });
         *
         *     console.log(tpl.apply(data));
         *     // LOGS: Wizard Don Griffin
         */
        definitions: string|any[];

        /**
         * Expressions in templates that traverse "dot paths" and fail (due to 'null' at some
         * stage) have always been expanded as empty strings. This is convenient in most cases
         * but doing so can also mask errors in the template. Setting this to 'true' changes
         * this default so that any expression errors will be thrown as exceptions.
         *
         * Optional, Defaults to: false
         */
        strict: boolean;

        /**
         * Creates new template.
         *
         * @param {String...} html List of strings to be concatenated into template.
         * Alternatively an array of strings can be given, but then no config object may be passed.
         * @param {Object} config (optional) Config object
         */
        constructor(html: string, config: Ext.TemplateConfig);

        /**
         * Gets an 'XTemplate' from an object (an instance of an {@link Ext#define}'d class).
         * Many times, templates are configured high in the class hierarchy and are to be
         * shared by all classes that derive from that base. To further complicate matters,
         * these templates are seldom actual instances but are rather configurations. For
         * example:
         *
         *      Ext.define('MyApp.Class', {
         *          extraCls: 'extra-class',
         *
         *          someTpl: [
         *              '<div class="{%this.emitClass(out)%}"></div>',
         *          {
         *              // Member fn - outputs the owing class's extra CSS class
         *              emitClass: function(out) {
         *                  out.push(this.owner.extraCls);
         *              }
         *          }]
         *      });
         *
         * The goal being to share that template definition with all instances and even
         * instances of derived classes, until 'someTpl' is overridden. This method will
         * "upgrade" these configurations to be real 'XTemplate' instances *in place* (to
         * avoid creating one instance per object).
         *
         * The resulting XTemplate will have an 'owner' reference injected which refers back
         * to the owning object whether that is an object which has an *own instance*, or a
         * class prototype. Through this link, XTemplate member functions will be able to access
         * prototype properties of its owning class.
         *
         * @param {Object} instance The object from which to get the 'XTemplate' (must be
         * an instance of an {@link Ext#define}'d class).
         * @param {String} name The name of the property by which to get the 'XTemplate'.
         * @return {Ext.XTemplate} The 'XTemplate' instance or null if not found.
         */
        protected static getTpl(instance: any, name: string): Ext.XTemplate;
    }
}

declare module Ext.app {
    interface ApplicationConfig extends Ext.app.ControllerConfig {
        /**
         * The path to the directory which contains all application's classes.
         * This path will be registered via {@link Ext.Loader#setPath} for the namespace specified
         * in the {@link #name name} config.
         *
         * Optional, Defaults to: "app"
         */
        appFolder?: string;

        /**
         * The name of a property to be assigned to the main namespace to gain a reference to
         * this application. Can be set to an empty value to prevent the reference from
         * being created
         *
         *     Ext.application({
         *         name: 'MyApp',
         *         appProperty: 'myProp',
         *
         *         launch: function() {
         *             console.log(MyApp.myProp === this);
         *         }
         *     });
         */
        appProperty?: string;

        /**
         * Names of {@link Ext.app.Controller controllers} that the app uses.  By default,
         * the framework will look for the controllers in the "controller" folder within the
         * {@link #appFolder}.  Controller classes should be named using the syntax of
         * "{appName}.controller.{ClassName}" with additional sub-folders under the
         * "controller" folder specified within the class name following "controller.".
         *
         *     // by default, the following controller class would be located at:
         *     // app/controller/Main.js
         *     controllers: '.Main' // or 'MyApp.controller.Main'
         *
         *     // while the following would be located at:
         *     // app/controller/customer/Main.js
         *     controllers: 'customer.Main' // or 'MyApp.controller.customer.Main'
         *
         * **Note:** If the controller has a different namespace than that of the
         * application you will need to specify the full class name as well as define a path
         * in the {@link Ext.Loader#cfg-paths Loader's paths} config or
         * {@link Ext.Loader#method-setPath setPath} method.
         */
        controllers?: string;

        currentProfile?: any;

        /**
         * The default token to be used at application launch
         * if one is not present. Often this is set to something like ''home''.
         *
         * Optional, Defaults to: null
         */
        defaultToken?: string;

        /**
         * A class name to use with the 'Ext.application' call. The class must also extend {@link Ext.app.Application}.
         *
         *     Ext.define('MyApp.Application', {
         *         extend: 'Ext.app.Application',
         *
         *         launch: function() {
         *             Ext.direct.Manager.addProvider(Ext.REMOTING_API);
         *         }
         *     });
         *
         *     Ext.application({
         *         extend: 'MyApp.Application'
         *     });
         */
        extend?: string;

        /**
         * The glyphFontFamily to use for this application.  Used as the default font-family
         * for all components that support a 'glyph' config.
         */
        glyphFontFamily?: string;

        /**
         * The application class to be used as the main viewport view for the
         * application.  The view will be configured with the
         * {@link Ext.plugin.Viewport viewport plugin} to ensure the view takes up all
         * available space in the browser viewport.  The main view will be created after
         * the application's {@link #init} method is called and before the
         * {@link #launch} method.  The main view should be an application class type and
         * not a class from the framework.
         *
         * The main view value may be:
         *  - string representing the full class name of the main view or the partial class name following "AppName.view." (provided your main view class follows that convention).
         *  - config object for the main view
         *  - main view class instance
         *
         *     Ext.define('MyApp.view.main.Main', {
         *         extend: 'Ext.panel.Panel',
         *         xtype: 'mainview',
         *         title: 'Main Viewport View'
         *     });
         *
         *     Ext.application({
         *         name : 'MyApp',
         *
         *         mainView: 'MyApp.view.main.Main'
         *         // mainView: 'main.Main'
         *         // mainView: new MyApp.view.main.Main()
         *         // mainView: { xtype: 'mainview' }
         *     });
         *
         * **Note:** You may also call {@link #setMainView} at runtime if you require
         * logic within the application's {@link #launch} method to be processed prior to
         * the creation of the main view.
         */
        mainView?: string|any|Ext.Component;

        /**
         * The name of your application. This will also be the namespace for your views, controllers
         * models and stores. Don't use spaces or special characters in the name. **Application name
         * is mandatory**.
         */
        name?: string;

        /**
         * The list of namespace prefixes used in the application to resolve dependencies
         * like Views and Stores:
         *
         *      Ext.application({
         *          name: 'MyApp',
         *
         *          namespaces: ['Common.code'],
         *
         *          controllers: [ 'Common.code.controller.Foo', 'Bar' ]
         *      });
         *
         *      Ext.define('Common.code.controller.Foo', {
         *          extend: 'Ext.app.Controller',
         *
         *          models: ['Foo'],    // Loads Common.code.model.Foo
         *          views:  ['Bar']     // Loads Common.code.view.Bar
         *      });
         *
         *      Ext.define('MyApp.controller.Bar', {
         *          extend: 'Ext.app.Controller',
         *
         *          models: ['Foo'],    // Loads MyApp.model.Foo
         *          views:  ['Bar']     // Loads MyApp.view.Bar
         *      });
         *
         * You don't need to include main namespace (MyApp), it will be added to the list
         * automatically.
         *
         * Optional
         */
        namespaces?: string;

        /**
         * Additional load paths to add to Ext.Loader.
         * See {@link Ext.Loader#paths} config for more details.
         */
        paths?: any;

        /**
         * Names of the profiles that the app uses.
         */
        profiles?: string;

        /**
         * The scope to execute the {@link #launch} function in. Defaults to the Application instance.
         */
        scope?: any;
    }

    /**
     * Represents an Ext JS application, which is typically a single page app using a
     * {@link Ext.container.Viewport Viewport}.
     *
     * An application consists of one or more Views. The behavior of a View is managed by its
     * corresponding {@link Ext.app.ViewController ViewController} and {@link Ext.app.ViewModel
     * ViewModel}.
     *
     * Global activities are coordinated by {@link Ext.app.Controller Controllers} which are
     * ultimately instantiated by an instance of this (or a derived) class.
     *
     *     Ext.application({
     *         name: 'MyApp',
     *
     *         // An instance of this view is created and set as the Viewport:
     *         autoCreateViewport: 'MyApp.view.Main'
     *     });
     *
     * This does several things. First it creates a global variable called 'MyApp' - all of
     * your Application's classes (such as its Models, Views and Controllers) will reside under
     * this single namespace, which drastically lowers the chances of colliding global variables.
     *
     * The MyApp global will also have a getApplication method to get a reference to the current
     * application:
     *
     *     var app = MyApp.getApplication();
     *
     * # Telling Application about the rest of the app
     *
     * Because an Ext.app.Application represents an entire app, we should tell it about the other
     * parts of the app - namely the Models, Views and Controllers that are bundled with the application. Let's say we have a blog management app; we
     * might have Models and Controllers for Posts and Comments, and Views for listing, adding and editing Posts and Comments.
     * Here's how we'd tell our Application about all these things:
     *
     *     Ext.application({
     *         name: 'Blog',
     *
     *         models: ['Post', 'Comment'],
     *
     *         controllers: ['Posts', 'Comments'],
     *
     *         launch: function() {
     *             ...
     *         }
     *     });
     *
     * Note that we didn't actually list the Views directly in the Application itself. This is because Views are managed by
     * Controllers, so it makes sense to keep those dependencies there. The Application will load each of the specified
     * Controllers using the pathing conventions laid out in the [application architecture guide](../application_architecture/application_architecture.html) - in this case
     * expecting the controllers to reside in app/controller/Posts.js and app/controller/Comments.js. In turn, each
     * Controller simply needs to list the Views it uses and they will be automatically loaded. Here's how our Posts
     * controller like be defined:
     *
     *     Ext.define('MyApp.controller.Posts', {
     *         extend: 'Ext.app.Controller',
     *         views: ['posts.List', 'posts.Edit'],
     *
     *         //the rest of the Controller here
     *     });
     *
     * Because we told our Application about our Models and Controllers, and our Controllers about their Views, Ext JS will
     * automatically load all of our app files for us. This means we don't have to manually add script tags into our html
     * files whenever we add a new class, but more importantly it enables us to create a minimized build of our entire
     * application using Sencha Cmd.
     *
     * # Deriving from Ext.app.Application
     *
     * Typically, applications do not derive directly from Ext.app.Application. Rather, the
     * configuration passed to 'Ext.application' mimics what you might do in a derived class.
     * In some cases, however, it can be desirable to share logic by using a derived class
     * from 'Ext.app.Application'.
     *
     * Derivation works as you would expect, but using the derived class should still be the
     * job of the 'Ext.application' method.
     *
     *     Ext.define('MyApp.Application', {
     *         extend: 'Ext.app.Application',
     *         name: 'MyApp',
     *         ...
     *     });
     *
     *     Ext.application('MyApp.Application');
     *
     * For more information about writing Ext JS applications, please see the [application architecture guide](../../../application_architecture/application_architecture.html).
     */
    export class Application extends Ext.app.Controller implements Ext.app.ApplicationConfig {
        /**
         * The path to the directory which contains all application's classes.
         * This path will be registered via {@link Ext.Loader#setPath} for the namespace specified
         * in the {@link #name name} config.
         *
         * Optional, Defaults to: "app"
         */
        appFolder: string;

        /**
         * The name of a property to be assigned to the main namespace to gain a reference to
         * this application. Can be set to an empty value to prevent the reference from
         * being created
         *
         *     Ext.application({
         *         name: 'MyApp',
         *         appProperty: 'myProp',
         *
         *         launch: function() {
         *             console.log(MyApp.myProp === this);
         *         }
         *     });
         */
        appProperty: string;

        /**
         * Names of {@link Ext.app.Controller controllers} that the app uses.  By default,
         * the framework will look for the controllers in the "controller" folder within the
         * {@link #appFolder}.  Controller classes should be named using the syntax of
         * "{appName}.controller.{ClassName}" with additional sub-folders under the
         * "controller" folder specified within the class name following "controller.".
         *
         *     // by default, the following controller class would be located at:
         *     // app/controller/Main.js
         *     controllers: '.Main' // or 'MyApp.controller.Main'
         *
         *     // while the following would be located at:
         *     // app/controller/customer/Main.js
         *     controllers: 'customer.Main' // or 'MyApp.controller.customer.Main'
         *
         * **Note:** If the controller has a different namespace than that of the
         * application you will need to specify the full class name as well as define a path
         * in the {@link Ext.Loader#cfg-paths Loader's paths} config or
         * {@link Ext.Loader#method-setPath setPath} method.
         */
        controllers: string;

        currentProfile: any;

        /**
         * The default token to be used at application launch
         * if one is not present. Often this is set to something like ''home''.
         *
         * Optional, Defaults to: null
         */
        defaultToken: string;

        /**
         * A class name to use with the 'Ext.application' call. The class must also extend {@link Ext.app.Application}.
         *
         *     Ext.define('MyApp.Application', {
         *         extend: 'Ext.app.Application',
         *
         *         launch: function() {
         *             Ext.direct.Manager.addProvider(Ext.REMOTING_API);
         *         }
         *     });
         *
         *     Ext.application({
         *         extend: 'MyApp.Application'
         *     });
         */
        extend: string;

        /**
         * The glyphFontFamily to use for this application.  Used as the default font-family
         * for all components that support a 'glyph' config.
         */
        glyphFontFamily: string;

        /**
         * The application class to be used as the main viewport view for the
         * application.  The view will be configured with the
         * {@link Ext.plugin.Viewport viewport plugin} to ensure the view takes up all
         * available space in the browser viewport.  The main view will be created after
         * the application's {@link #init} method is called and before the
         * {@link #launch} method.  The main view should be an application class type and
         * not a class from the framework.
         *
         * The main view value may be:
         *  - string representing the full class name of the main view or the partial class name following "AppName.view." (provided your main view class follows that convention).
         *  - config object for the main view
         *  - main view class instance
         *
         *     Ext.define('MyApp.view.main.Main', {
         *         extend: 'Ext.panel.Panel',
         *         xtype: 'mainview',
         *         title: 'Main Viewport View'
         *     });
         *
         *     Ext.application({
         *         name : 'MyApp',
         *
         *         mainView: 'MyApp.view.main.Main'
         *         // mainView: 'main.Main'
         *         // mainView: new MyApp.view.main.Main()
         *         // mainView: { xtype: 'mainview' }
         *     });
         *
         * **Note:** You may also call {@link #setMainView} at runtime if you require
         * logic within the application's {@link #launch} method to be processed prior to
         * the creation of the main view.
         */
        mainView: string|any|Ext.Component;

        /**
         * The name of your application. This will also be the namespace for your views, controllers
         * models and stores. Don't use spaces or special characters in the name. **Application name
         * is mandatory**.
         */
        name: string;

        /**
         * The list of namespace prefixes used in the application to resolve dependencies
         * like Views and Stores:
         *
         *      Ext.application({
         *          name: 'MyApp',
         *
         *          namespaces: ['Common.code'],
         *
         *          controllers: [ 'Common.code.controller.Foo', 'Bar' ]
         *      });
         *
         *      Ext.define('Common.code.controller.Foo', {
         *          extend: 'Ext.app.Controller',
         *
         *          models: ['Foo'],    // Loads Common.code.model.Foo
         *          views:  ['Bar']     // Loads Common.code.view.Bar
         *      });
         *
         *      Ext.define('MyApp.controller.Bar', {
         *          extend: 'Ext.app.Controller',
         *
         *          models: ['Foo'],    // Loads MyApp.model.Foo
         *          views:  ['Bar']     // Loads MyApp.view.Bar
         *      });
         *
         * You don't need to include main namespace (MyApp), it will be added to the list
         * automatically.
         *
         * Optional
         */
        namespaces: string;

        /**
         * Additional load paths to add to Ext.Loader.
         * See {@link Ext.Loader#paths} config for more details.
         */
        paths: any;

        /**
         * Names of the profiles that the app uses.
         */
        profiles: string;

        /**
         * The scope to execute the {@link #launch} function in. Defaults to the Application instance.
         */
        scope: any;

        /**
         * Creates new Application.
         * @param {Object} [config] Config object.
         */
        constructor(config?: Ext.app.ApplicationConfig);

        /**
         * Create an instance of a controller by name.
         * @param {String} name The name of the controller. For a controller with the
         * full class name 'MyApp.controller.Foo', the name parameter should be 'Foo'.
         * If the controller already exists, it will be returned.
         *
         * @return {Ext.app.Controller} controller
         */
        createController(name: string): Ext.app.Controller;

        /**
         * Destroys a controller, any listeners are unbound.
         * @param {String/Ext.app.Controller} controller The controller
         */
        destroyController(controller: string|Ext.app.Controller);

        getApplication();

        getAppProperty();

        getCurrentProfile();

        getDefaultToken();

        getGlyphFontFamily();

        getMainView();

        getProfiles();

        /**
         * Called automatically when the page has completely loaded. This is an empty function that should be
         * overridden by each application that needs to take action on page load.
         * @param {String} profile The detected application profile
         * @return {Boolean} By default, the Application will dispatch to the configured startup controller and
         * action immediately after running the launch function. Return false to prevent this behavior.
         */
        launch(profile: string): boolean;

        /**
         * Called automatically when an update to either the Application Cache or the Local Storage Cache is detected.
         * This is mainly used during production builds.
         * @param {Object} [updateInfo] updateInfo Update information object contains properties for checking which cache triggered the update
         */
        onAppUpdate(updateInfo?: any);

        setAppProperty();

        setCurrentProfile();

        setDefaultToken();

        setGlyphFontFamily();

        setMainView();

        setName();

        setProfiles();
    }

    interface BaseControllerConfig {
        /**
         * The id of this controller. You can use this id when dispatching.
         *
         * For an example of dispatching, see the examples under the
         * {@link Ext.app.Controller#cfg-listen listen} config.
         *
         * If an id is not explicitly set, it will default to the controller's full classname.
         */
        id?: string;

        /**
         * An object of routes to handle hash changes. A route can be defined in a simple way:
         *
         *     routes : {
         *         'foo/bar'  : 'handleFoo',
         *         'user/:id' : 'showUser'
         *     }
         *
         * Where the property is the hash (which can accept a parameter defined by a colon) and the value
         * is the method on the controller to execute. The parameters will get sent in the action method.
         *
         * At the application level, you can define a event that will be executed when no matching
         * routes are found.
         *
         *     Ext.application({
         *         name: 'MyApp',
         *         listen: {
         *             controller: {
         *                 '#': {
         *                     unmatchedroute: 'onUnmatchedRoute'
         *                 }
         *             }
         *         },
         *
         *         onUnmatchedRoute: function(hash) {
         *             console.log('Unmatched', hash);
         *             // Do something...
         *         }
         *     });
         *
         * There is also a complex means of defining a route where you can use a before action and even
         * specify your own RegEx for the parameter:
         *
         *     routes : {
         *         'foo/bar'  : {
         *             action  : 'handleFoo',
         *             before  : 'beforeHandleFoo'
         *         },
         *         'user/:id' : {
         *             action     : 'showUser',
         *             before     : 'beforeShowUser',
         *             conditions : {
         *                 ':id' : '([0-9]+)'
         *             }
         *         }
         *     }
         *
         * This will only match if the 'id' parameter is a number.
         *
         * The before action allows you to cancel an action. Every before action will get passed an 'action' argument with
         * a 'resume' and 'stop' methods as the last argument of the method and you *MUST* execute either method:
         *
         *     beforeHandleFoo : function(action) {
         *         //some logic here
         *
         *         //this will allow the handleFoo action to be executed
         *         action.resume();
         *     },
         *     handleFoo : function() {
         *         //will get executed due to true being passed in callback in beforeHandleFoo
         *     },
         *     beforeShowUser : function(id, action) {
         *         //allows for async process like an Ajax
         *         Ext.Ajax.request({
         *             url     : 'foo.php',
         *             success : function() {
         *                 //will not allow the showUser method to be executed but will continue other queued actions.
         *                 action.stop();
         *             },
         *             failure : function() {
         *                 //will not allow the showUser method to be executed and will not allow other queued actions to be executed.
         *                 action.stop(true);
         *             }
         *         });
         *     },
         *     showUser : function(id) {
         *         //will not get executed due to false being passed in callback in beforeShowUser
         *     }
         *
         * You *MUST* execute the 'resume' or 'stop' method on the 'action' argument. Executing 'action.resume();' will continue
         * the action, 'action.stop();' will not allow the action to resume but will allow other queued actions to resume,
         * 'action.stop(true);' will not allow the action and any other queued actions to resume.
         *
         * The default RegEx that will be used is '([%a-zA-Z0-9\\-\\_\\s,]+)' but you can specify any
         * that may suit what you need to accomplish. An example of an advanced condition may be to make
         * a parameter optional and case-insensitive:
         *
         *     routes : {
         *         'user:id' : {
         *             action     : 'showUser',
         *             before     : 'beforeShowUser',
         *             conditions : {
         *                 ':id' : '(?:(?:\/){1}([%a-z0-9_,\s\-]+))?'
         *             }
         *         }
         *     }
         */
        routes?: any;
    }

    /**
     * Base class for Controllers.
     */
    export class BaseController extends Ext.Base implements Ext.app.BaseControllerConfig {
        /**
         * The id of this controller. You can use this id when dispatching.
         *
         * For an example of dispatching, see the examples under the
         * {@link Ext.app.Controller#cfg-listen listen} config.
         *
         * If an id is not explicitly set, it will default to the controller's full classname.
         */
        id: string;

        /**
         * An object of routes to handle hash changes. A route can be defined in a simple way:
         *
         *     routes : {
         *         'foo/bar'  : 'handleFoo',
         *         'user/:id' : 'showUser'
         *     }
         *
         * Where the property is the hash (which can accept a parameter defined by a colon) and the value
         * is the method on the controller to execute. The parameters will get sent in the action method.
         *
         * At the application level, you can define a event that will be executed when no matching
         * routes are found.
         *
         *     Ext.application({
         *         name: 'MyApp',
         *         listen: {
         *             controller: {
         *                 '#': {
         *                     unmatchedroute: 'onUnmatchedRoute'
         *                 }
         *             }
         *         },
         *
         *         onUnmatchedRoute: function(hash) {
         *             console.log('Unmatched', hash);
         *             // Do something...
         *         }
         *     });
         *
         * There is also a complex means of defining a route where you can use a before action and even
         * specify your own RegEx for the parameter:
         *
         *     routes : {
         *         'foo/bar'  : {
         *             action  : 'handleFoo',
         *             before  : 'beforeHandleFoo'
         *         },
         *         'user/:id' : {
         *             action     : 'showUser',
         *             before     : 'beforeShowUser',
         *             conditions : {
         *                 ':id' : '([0-9]+)'
         *             }
         *         }
         *     }
         *
         * This will only match if the 'id' parameter is a number.
         *
         * The before action allows you to cancel an action. Every before action will get passed an 'action' argument with
         * a 'resume' and 'stop' methods as the last argument of the method and you *MUST* execute either method:
         *
         *     beforeHandleFoo : function(action) {
         *         //some logic here
         *
         *         //this will allow the handleFoo action to be executed
         *         action.resume();
         *     },
         *     handleFoo : function() {
         *         //will get executed due to true being passed in callback in beforeHandleFoo
         *     },
         *     beforeShowUser : function(id, action) {
         *         //allows for async process like an Ajax
         *         Ext.Ajax.request({
         *             url     : 'foo.php',
         *             success : function() {
         *                 //will not allow the showUser method to be executed but will continue other queued actions.
         *                 action.stop();
         *             },
         *             failure : function() {
         *                 //will not allow the showUser method to be executed and will not allow other queued actions to be executed.
         *                 action.stop(true);
         *             }
         *         });
         *     },
         *     showUser : function(id) {
         *         //will not get executed due to false being passed in callback in beforeShowUser
         *     }
         *
         * You *MUST* execute the 'resume' or 'stop' method on the 'action' argument. Executing 'action.resume();' will continue
         * the action, 'action.stop();' will not allow the action to resume but will allow other queued actions to resume,
         * 'action.stop(true);' will not allow the action and any other queued actions to resume.
         *
         * The default RegEx that will be used is '([%a-zA-Z0-9\\-\\_\\s,]+)' but you can specify any
         * that may suit what you need to accomplish. An example of an advanced condition may be to make
         * a parameter optional and case-insensitive:
         *
         *     routes : {
         *         'user:id' : {
         *             action     : 'showUser',
         *             before     : 'beforeShowUser',
         *             conditions : {
         *                 ':id' : '(?:(?:\/){1}([%a-z0-9_,\s\-]+))?'
         *             }
         *         }
         *     }
         */
        routes: any;

        /**
         * Creates new Controller.
         *
         * @param {Object} [config] Configuration object.
         */
        constructor(config?: Ext.app.BaseControllerConfig);

        /**
         * Adds listeners to components selected via {@link Ext.ComponentQuery}. Accepts an
         * object containing component paths mapped to a hash of listener functions.
         *
         * In the following example the 'updateUser' function is mapped to to the 'click'
         * event on a button component, which is a child of the 'useredit' component.
         *
         *      Ext.define('AM.controller.Users', {
         *          init: function() {
         *              this.control({
         *                  'useredit button[action=save]': {
         *                      click: this.updateUser
         *                  }
         *              });
         *          },
         *
         *          updateUser: function(button) {
         *              console.log('clicked the Save button');
         *          }
         *      });
         *
         * Or alternatively one call 'control' with two arguments:
         *
         *      this.control('useredit button[action=save]', {
         *          click: this.updateUser
         *      });
         *
         * See {@link Ext.ComponentQuery} for more information on component selectors.
         *
         * @param {String/Object} selectors If a String, the second argument is used as the
         * listeners, otherwise an object of selectors -> listeners is assumed
         * @param {Object} [listeners] Config for listeners.
         */
        control(selectors: string|any, listeners?: any);

        destroy();

        getBefore();

        getControl();

        getId();

        getListen();

        getRoutes();

        /**
         * Adds listeners to different event sources (also called "event domains"). The
         * primary event domain is that of components, but there are also other event domains:
         * {@link Ext.app.domain.Global Global} domain that intercepts events fired from
         * {@link Ext.GlobalEvents} Observable instance, {@link Ext.app.domain.Controller Controller}
         * domain can be used to listen to events fired by other Controllers,
         * {@link Ext.app.domain.Store Store} domain gives access to Store events, and
         * {@link Ext.app.domain.Direct Direct} domain can be used with Ext Direct Providers
         * to listen to their events.
         *
         * To listen to "bar" events fired by a controller with id="foo":
         *
         *      Ext.define('AM.controller.Users', {
         *          init: function() {
         *              this.listen({
         *                  controller: {
         *                      '#foo': {
         *                         bar: this.onFooBar
         *                      }
         *                  }
         *              });
         *          },
         *          ...
         *      });
         *
         * To listen to "bar" events fired by any controller, and "baz" events
         * fired by Store with storeId="baz":
         *
         *      Ext.define('AM.controller.Users', {
         *          init: function() {
         *              this.listen({
         *                  controller: {
         *                      '*': {
         *                         bar: this.onAnyControllerBar
         *                      }
         *                  },
         *                  store: {
         *                      '#baz': {
         *                          baz: this.onStoreBaz
         *                      }
         *                  }
         *              });
         *          },
         *          ...
         *      });
         *
         * To listen to "idle" events fired by {@link Ext.GlobalEvents} when other event
         * processing is complete and Ext JS is about to return control to the browser:
         *
         *      Ext.define('AM.controller.Users', {
         *          init: function() {
         *              this.listen({
         *                  global: {               // Global events are always fired
         *                      idle: this.onIdle   // from the same object, so there
         *                  }                       // are no selectors
         *              });
         *          }
         *      });
         *
         * As this relates to components, the following example:
         *
         *      Ext.define('AM.controller.Users', {
         *          init: function() {
         *              this.listen({
         *                  component: {
         *                      'useredit button[action=save]': {
         *                         click: this.updateUser
         *                      }
         *                  }
         *              });
         *          },
         *          ...
         *      });
         *
         * Is equivalent to:
         *
         *      Ext.define('AM.controller.Users', {
         *          init: function() {
         *              this.control({
         *                  'useredit button[action=save]': {
         *                     click: this.updateUser
         *                  }
         *              });
         *          },
         *          ...
         *      });
         *
         * Of course, these can all be combined in a single call and used instead of
         * 'control', like so:
         *
         *      Ext.define('AM.controller.Users', {
         *          init: function() {
         *              this.listen({
         *                  global: {
         *                      idle: this.onIdle
         *                  },
         *                  controller: {
         *                      '*': {
         *                         foobar: this.onAnyFooBar
         *                      },
         *                      '#foo': {
         *                         bar: this.onFooBar
         *                      }
         *                  },
         *                  component: {
         *                      'useredit button[action=save]': {
         *                         click: this.updateUser
         *                      }
         *                  },
         *                  store: {
         *                      '#qux': {
         *                          load: this.onQuxLoad
         *                      }
         *                  }
         *              });
         *          },
         *          ...
         *      });
         *
         * @param {Object} to Config object containing domains, selectors and listeners.
         * @param {Ext.app.Controller} [controller] The controller to add the listeners to. Defaults to the current controller.
         */
        listen(to: any, controller?: Ext.app.Controller);

        /**
         * Update the hash. By default, it will not execute the routes if the current token and the
         * token passed are the same.
         *
         * @param {String/Ext.data.Model} token The token to redirect to.  Can be either a String
         * or a {@link Ext.data.Model Model} instance - if a Model instance is passed it will
         * internally be converted into a String token by calling the Model's
         * {@link Ext.data.Model#toUrl toUrl} function.
         *
         * @param {Boolean} force Force the update of the hash regardless of the current token.
         *
         * @return {Boolean} Will return 'true' if the token was updated.
         */
        redirectTo(token: string|Ext.data.Model, force: boolean): boolean;

        setBefore();

        setControl();

        setId();

        setListen();

        setRoutes();
    }

    interface ControllerConfig extends Ext.app.BaseControllerConfig {
        /**
         * The {@link Ext.app.Application} for this controller accessible via the getApplication method.
         * @readonly
         */
        application?: Ext.app.Application;

        /**
         * Array of models to require from AppName.model namespace. For example:
         *
         *      Ext.define("MyApp.controller.Foo", {
         *          extend: "Ext.app.Controller",
         *          models: ['User', 'Vehicle']
         *      });
         *
         * This is equivalent to:
         *
         *      Ext.define("MyApp.controller.Foo", {
         *          extend: "Ext.app.Controller",
         *          requires: ['MyApp.model.User', 'MyApp.model.Vehicle'],
         *
         *          getUserModel: function() {
         *              return this.getModel("User");
         *          },
         *
         *          getVehicleModel: function() {
         *              return this.getModel("Vehicle");
         *          }
         *      });
         *
         * **Note:** If the model has a different namespace than that of the
         * application you will need to specify the full class name as well as define a path
         * in the {@link Ext.Loader#cfg-paths Loader's paths} config or
         * {@link Ext.Loader#method-setPath setPath} method.
         */
        models?: string;

        /**
         * The refs config creates a getter method on the controller that internally
         * uses Ext.ComponentQuery to fetch the component instance using the configured
         * selector.  The following example will add the 'getList' method to
         * the controller and will return the first component in the application
         * hierarchy with an xtype of "grid".  By default, *undefined* will be returned
         * when the query does not locate the target component.
         *
         *     Ext.define('MyApp.controller.Foo', {
         *         extend: 'Ext.app.Controller',
         *
         *         refs: [{
         *             ref: 'list',
         *             selector: 'grid'
         *         }]
         *     });
         *
         * The following fields may be used in the ref definition:
         *
         * - 'ref' - name of the reference.
         * - 'selector' - Ext.ComponentQuery selector to access the component.
         * - 'autoCreate' - True to create the component automatically if not found on
         * page.
         * - 'forceCreate' - True to force the creation of the component every time
         * reference is accessed (when 'get<REFNAME>' is called).
         * - 'xtype' - Used to create the component by its xtype with 'autoCreate' or
         * 'forceCreate'. If you don't provide 'xtype', an Ext.Component instance will
         * be created.
         *
         * The following example will create a 'getList' and 'getUser' method on the
         * controller.
         *
         *     Ext.define('MyApp.controller.Foo', {
         *         extend: 'Ext.app.Controller',
         *
         *         refs: [{
         *             list: 'grid',
         *             user: {
         *                 autoCreate: true,
         *                 selector: 'form',
         *                 xtype: 'form'
         *             }
         *         }]
         *     });
         */
        refs?: any;

        /**
         * Array of stores to require from AppName.store namespace and to generate getter methods for.
         * For example:
         *
         *      Ext.define("MyApp.controller.Foo", {
         *          extend: "Ext.app.Controller",
         *          stores: ['Users', 'Vehicles']
         *      });
         *
         * This is equivalent to:
         *
         *      Ext.define("MyApp.controller.Foo", {
         *          extend: "Ext.app.Controller",
         *
         *          requires: [
         *              'MyApp.store.Users',
         *              'MyApp.store.Vehicles'
         *          ]
         *
         *          getUsersStore: function() {
         *              return this.getStore("Users");
         *          },
         *
         *          getVehiclesStore: function() {
         *              return this.getStore("Vehicles");
         *          }
         *      });
         *
         * **Note:** If the store has a different namespace than that of the
         * application you will need to specify the full class name as well as define a path
         * in the {@link Ext.Loader#cfg-paths Loader's paths} config or
         * {@link Ext.Loader#method-setPath setPath} method.
         */
        stores?: string;

        /**
         * Array of views to require from AppName.view namespace and to generate getter methods for.
         * For example:
         *
         *      Ext.define("MyApp.controller.Foo", {
         *          extend: "Ext.app.Controller",
         *          views: ['List', 'Detail']
         *      });
         *
         * This is equivalent to:
         *
         *      Ext.define("MyApp.controller.Foo", {
         *          extend: "Ext.app.Controller",
         *          requires: ['MyApp.view.List', 'MyApp.view.Detail'],
         *
         *          getListView: function() {
         *              return this.getView("List");
         *          },
         *
         *          getDetailView: function() {
         *              return this.getView("Detail");
         *          }
         *      });
         *
         * **Note:** If the view has a different namespace than that of the
         * application you will need to specify the full class name as well as define a path
         * in the {@link Ext.Loader#cfg-paths Loader's paths} config or
         * {@link Ext.Loader#method-setPath setPath} method.
         */
        views?: string;
    }

    /**
     * Controllers are the glue that binds an application together. That said, their main
     * purpose is to listen for events (usually from views) and take some action. Here's how
     * we might create a Controller to manage Users:
     *
     *      Ext.define('MyApp.controller.Users', {
     *          extend: 'Ext.app.Controller',
     *
     *          init: function() {
     *              console.log('Initialized Users! This happens before ' +
     *                          'the Application launch() function is called');
     *          }
     *      });
     *
     * The init function is a special method that is called when your application boots. It is
     * called before the {@link Ext.app.Application Application}'s launch function is executed.
     * This creates an area you can run code prior to Viewport creation.
     *
     * The controller's {@link #method-control} function
     * makes it easy to listen to events on your view classes and take some action with a
     * handler function. Let's update our Users controller to tell us when the panel is
     * rendered:
     *
     *      Ext.define('MyApp.controller.Users', {
     *          extend: 'Ext.app.Controller',
     *
     *          control: {
     *              'viewport > panel': {
     *                  render: 'onPanelRendered'
     *              }
     *          }
     *
     *          onPanelRendered: function() {
     *              console.log('The panel was rendered');
     *          }
     *      });
     *
     * The {@link Ext.app.BaseController#method-control control method} has now set up
     * listeners on views in our application. The control method uses the ComponentQuery
     * engine to quickly and easily get references to components on the page. If you are not
     * familiar with ComponentQuery yet, be sure to check out the
     * {@link Ext.ComponentQuery documentation}. In brief, it allows us to pass a
     * CSS-like selector that will find every matching component on the page.
     *
     * In our init function above, we supplied 'viewport > panel', which translates to "find me
     * every Panel that is a direct child of a Viewport". We then supplied an object that maps
     * event names (just 'render' in this case) to handler functions. In short, whenever
     * a component that matches our selector fires a 'render' event, our
     * onPanelRendered function is called.
     *
     * ## Event domains
     *
     * In Ext JS 4.2, we introduced the concept of event domains. In terms of MVC, an event
     * domain is one or more base classes that fire events to which a Controller wants to
     * listen. Besides Component event domain that encompass {@link Ext.Component}-descended
     * Views, Controllers now can listen to events from data Stores, Ext Direct Providers,
     * other Controllers, and Ext.GlobalEvents. This feature provides a way to communicate
     * between parts of the whole application without the need to bind controllers together
     * tightly, and allows to develop and test application parts in isolation.
     *
     * See usage examples in {@link #method-listen} method documentation.
     *
     * ## Using refs
     *
     * One of the most useful parts of Controllers is the ref system. These use
     * {@link Ext.ComponentQuery} to make it really easy to get references to Views on your
     * page. Let's look at an example of this now:
     *
     *      Ext.define('MyApp.controller.Users', {
     *          extend: 'Ext.app.Controller',
     *
     *          refs: [{
     *              ref: 'list',
     *              selector: 'grid'
     *          }],
     *
     *          control: {
     *              'button': {
     *                  click: 'refreshGrid'
     *              }
     *          },
     *
     *          refreshGrid: function() {
     *              this.getList().store.load();
     *          }
     *      });
     *
     * This example assumes the existence of a {@link Ext.grid.Panel Grid} on the page, which
     * contains a single button to refresh the Grid when clicked. In our refs array, we set up
     * a reference to the grid. There are two parts to this - the 'selector', which is a
     * {@link Ext.ComponentQuery ComponentQuery} selector which finds any grid on the page and
     * assigns it to the reference 'list'.
     *
     * By giving the reference a name, we get a number of things for free. The first is the
     * getList function that we use in the refreshGrid method above. This is generated
     * automatically by the Controller based on the name of our ref, which was capitalized and
     * prepended with get to go from 'list' to 'getList'.
     *
     * The way this works is that the first time getList is called by your code, the
     * ComponentQuery selector is run and the first component that matches the selector
     * ('grid' in this case) will be returned. All future calls to getList will use a cached
     * reference to that grid. Usually it is advised to use a specific ComponentQuery selector
     * that will only match a single View in your application (in the case above our selector
     * will match any grid on the page).
     *
     * Bringing it all together, we configure control
     * to listen to any click on a {@link Ext.button.Button button} and call our refreshGrid
     * function (again, this will match any button on the page so we advise a more specific
     * selector than just 'button', but have left it this way for simplicity). When the button
     * is clicked we use out getList function to refresh the grid.
     *
     * You can create any number of refs and control any number of components this way, simply
     * adding more functions to your Controller as you go. For an example of real-world usage
     * of Controllers see the Feed Viewer example in the examples/app/feed-viewer folder in
     * the SDK download.
     *
     * ## Generated getter methods
     *
     * Refs aren't the only thing that generate convenient getter methods. Controllers often
     * have to deal with Models and Stores so the framework offers a couple of easy ways to
     * get access to those too. Let's look at another example:
     *
     *      Ext.define('MyApp.controller.Users', {
     *          extend: 'Ext.app.Controller',
     *
     *          models: ['User'],
     *          stores: ['AllUsers', 'AdminUsers'],
     *
     *          init: function() {
     *              var User, allUsers, ed;
     *
     *              User = this.getUserModel();
     *              allUsers = this.getAllUsersStore();
     *
     *              ed = new User({ name: 'Ed' });
     *              allUsers.add(ed);
     *          }
     *      });
     *
     * By specifying Models and Stores that the Controller cares about, it again dynamically
     * loads them from the appropriate locations (app/model/User.js, app/store/AllUsers.js and
     * app/store/AdminUsers.js in this case) and creates getter functions for them all. The
     * example above will create a new User model instance and add it to the AllUsers Store.
     * Of course, you could do anything in this function but in this case we just did
     * something simple to demonstrate the functionality.
     *
     * ## Further Reading
     *
     * For more information about writing Ext JS 5 applications, please see the
     * [Application Architecture](../../../application_architecture/application_architecture.html).
     * Also see the {@link Ext.app.Application} documentation.
     */
    export class Controller extends Ext.app.BaseController implements Ext.app.ControllerConfig {
        /**
         * The {@link Ext.app.Application} for this controller accessible via the getApplication method.
         * @readonly
         */
        application: Ext.app.Application;

        /**
         * Array of models to require from AppName.model namespace. For example:
         *
         *      Ext.define("MyApp.controller.Foo", {
         *          extend: "Ext.app.Controller",
         *          models: ['User', 'Vehicle']
         *      });
         *
         * This is equivalent to:
         *
         *      Ext.define("MyApp.controller.Foo", {
         *          extend: "Ext.app.Controller",
         *          requires: ['MyApp.model.User', 'MyApp.model.Vehicle'],
         *
         *          getUserModel: function() {
         *              return this.getModel("User");
         *          },
         *
         *          getVehicleModel: function() {
         *              return this.getModel("Vehicle");
         *          }
         *      });
         *
         * **Note:** If the model has a different namespace than that of the
         * application you will need to specify the full class name as well as define a path
         * in the {@link Ext.Loader#cfg-paths Loader's paths} config or
         * {@link Ext.Loader#method-setPath setPath} method.
         */
        models: string;

        /**
         * The refs config creates a getter method on the controller that internally
         * uses Ext.ComponentQuery to fetch the component instance using the configured
         * selector.  The following example will add the 'getList' method to
         * the controller and will return the first component in the application
         * hierarchy with an xtype of "grid".  By default, *undefined* will be returned
         * when the query does not locate the target component.
         *
         *     Ext.define('MyApp.controller.Foo', {
         *         extend: 'Ext.app.Controller',
         *
         *         refs: [{
         *             ref: 'list',
         *             selector: 'grid'
         *         }]
         *     });
         *
         * The following fields may be used in the ref definition:
         *
         * - 'ref' - name of the reference.
         * - 'selector' - Ext.ComponentQuery selector to access the component.
         * - 'autoCreate' - True to create the component automatically if not found on
         * page.
         * - 'forceCreate' - True to force the creation of the component every time
         * reference is accessed (when 'get<REFNAME>' is called).
         * - 'xtype' - Used to create the component by its xtype with 'autoCreate' or
         * 'forceCreate'. If you don't provide 'xtype', an Ext.Component instance will
         * be created.
         *
         * The following example will create a 'getList' and 'getUser' method on the
         * controller.
         *
         *     Ext.define('MyApp.controller.Foo', {
         *         extend: 'Ext.app.Controller',
         *
         *         refs: [{
         *             list: 'grid',
         *             user: {
         *                 autoCreate: true,
         *                 selector: 'form',
         *                 xtype: 'form'
         *             }
         *         }]
         *     });
         */
        refs: any;

        /**
         * Array of stores to require from AppName.store namespace and to generate getter methods for.
         * For example:
         *
         *      Ext.define("MyApp.controller.Foo", {
         *          extend: "Ext.app.Controller",
         *          stores: ['Users', 'Vehicles']
         *      });
         *
         * This is equivalent to:
         *
         *      Ext.define("MyApp.controller.Foo", {
         *          extend: "Ext.app.Controller",
         *
         *          requires: [
         *              'MyApp.store.Users',
         *              'MyApp.store.Vehicles'
         *          ]
         *
         *          getUsersStore: function() {
         *              return this.getStore("Users");
         *          },
         *
         *          getVehiclesStore: function() {
         *              return this.getStore("Vehicles");
         *          }
         *      });
         *
         * **Note:** If the store has a different namespace than that of the
         * application you will need to specify the full class name as well as define a path
         * in the {@link Ext.Loader#cfg-paths Loader's paths} config or
         * {@link Ext.Loader#method-setPath setPath} method.
         */
        stores: string;

        /**
         * Array of views to require from AppName.view namespace and to generate getter methods for.
         * For example:
         *
         *      Ext.define("MyApp.controller.Foo", {
         *          extend: "Ext.app.Controller",
         *          views: ['List', 'Detail']
         *      });
         *
         * This is equivalent to:
         *
         *      Ext.define("MyApp.controller.Foo", {
         *          extend: "Ext.app.Controller",
         *          requires: ['MyApp.view.List', 'MyApp.view.Detail'],
         *
         *          getListView: function() {
         *              return this.getView("List");
         *          },
         *
         *          getDetailView: function() {
         *              return this.getView("Detail");
         *          }
         *      });
         *
         * **Note:** If the view has a different namespace than that of the
         * application you will need to specify the full class name as well as define a path
         * in the {@link Ext.Loader#cfg-paths Loader's paths} config or
         * {@link Ext.Loader#method-setPath setPath} method.
         */
        views: string;

        /**
         * Allow the controller to resume receiving events from the event bus.
         * Routes will also be able to begin firing on this controller.
         * Also see {@link #deactivate}.
         */
        activate();

        /**
         * Registers one or more {@link #refs references}.
         */
        addRef(refs: any);

        /**
         * Creates new Controller.
         *
         * @param {Object} [config] Configuration object.
         */
        constructor(config?: Ext.app.ControllerConfig);

        /**
         * Prevent this controller from receiving events from the event bus.
         * Routes will also not be triggered on inactive controllers unless
         * the {@link Ext.app.route.Route#allowInactive} flag is set.
         * Also see {@link #activate}.
         */
        deactivate();

        destroy();

        getActive();

        getApplication();

        /**
         * Returns instance of a {@link Ext.app.Controller Controller} with the given id.
         * When controller doesn't exist yet, it's created. Note that this method depends
         * on Application instance and will return undefined when Application is not
         * accessible. The only exception is when this Controller instance's id is requested;
         * in that case we always return the instance even if Application is no available.
         *
         *
         * @return {Ext.app.Controller} controller instance or undefined.
         */
        getController(id: string): Ext.app.Controller;

        /**
         * Returns a {@link Ext.data.Model Model} class with the given name.
         *
         * @return {Ext.Class} A class ultimately derived from 'Ext.data.Model'.
         */
        getModel(name: string): Ext.Class;

        /**
         * Returns instance of a {@link Ext.app.Profile Profile} with the given name.
         *
         *
         * @return {String} a profile instance.
         */
        getProfile(name: string): string;

        getRefs();

        /**
         * Returns instance of a {@link Ext.data.Store Store} with the given name.
         * When store doesn't exist yet, it's created.
         *
         *
         * @return {Ext.data.Store} a store instance.
         */
        getStore(name: string): Ext.data.Store;

        /**
         * Returns a View class with the given name.  To create an instance of the view,
         * you can use it like it's used by Application to create the Viewport:
         *
         *     this.getView('Viewport').create();
         *
         *
         * @return {Ext.Base} a view class.
         */
        getView(view: string): Ext.Base;

        /**
         * Returns 'true' if a {@link #refs reference} is registered.
         *
         * @param {String} ref The name of the ref to check for.
         * @return {Boolean}
         */
        hasRef(ref: string): boolean;

        /**
         * A template method that is called when your application boots. It is called before the
         * {@link Ext.app.Application Application}'s launch function is executed so gives a hook point
         * to run any code before your Viewport is created.
         */
        init(application: Ext.app.Application);

        /**
         * Checks if this controller is active. See {@link #activate} &
         * {@link #deactivate}.
         * @return {Boolean} 'true' if this controller is active.
         */
        isActive(): boolean;

        /**
         * A template method like {@link #init}, but called after the viewport is created.
         * This is called after the {@link Ext.app.Application#launch launch} method of Application
         * is executed.
         */
        onLaunch(application: Ext.app.Application);

        setActive();

        setApplication();

        setRefs();
    }

    /**
     * This class manages event dispatching for Controllers. The details of connecting classes
     * to this dispatching mechanism is delegated to {@link Ext.app.EventDomain} instances.
     */
    export class EventBus {
        /**
         * Adds a set of component event listeners for a controller. To work with event domains
         * other than component, see {@link #listen}.
         *
         * @param {Object} selectors Config object containing selectors and listeners.
         * @param {Ext.app.BaseController} controller The listening controller instance.
         */
        static control(selectors: any, controller: Ext.app.BaseController);

        /**
         * Adds a set of event domain listeners for a controller. For more information on event
         * domains, see {@link Ext.app.EventDomain} and {@link Ext.app.BaseController}.
         *
         * @param {Object} to Config object containing domains, selectors and listeners.
         * @param {Ext.app.BaseController} controller The listening controller instance.
         */
        static listen(to: any, controller: Ext.app.BaseController);

        /**
         * Removes all of a controller's attached listeners.
         *
         * @param {String/Ext.app.BaseController} controllerId The id or the controller instance.
         */
        static unlisten(controllerId: string|Ext.app.BaseController);
    }

    interface EventDomainConfig {
        /**
         * Name of the identifier property for this event domain.
         */
        idProperty?: string;
    }

    /**
     * This class is a base class for an event domain. In the context of MVC, an "event domain"
     * is one or more base classes that fire events to which a Controller wants to listen. A
     * controller listens to events by describing the selectors for events of interest to it.
     *
     * Matching selectors to the firer of an event is one key aspect that defines an event
     * domain. All event domain instances must provide a 'match' method that tests selectors
     * against the event firer.
     *
     * When an event domain instance is created (typically as a 'singleton'), its 'type'
     * property is used to catalog the domain in the
     * {@link Ext.app.EventDomain#instances Ext.app.EventDomain.instances} map.
     *
     * There are five event domains provided by default:
     *
     * -   {@link Ext.app.domain.Component Component domain}. This is the primary event domain that
     * has been available since Ext JS MVC was introduced. This domain is defined as any class that
     * extends {@link Ext.Component}, where the selectors use
     * {@link Ext.ComponentQuery#query Ext.ComponentQuery}.
     * -   {@link Ext.app.domain.Global Global domain}. This domain provides Controllers with access
     * to events fired from {@link Ext.GlobalEvents} Observable instance. These events represent
     * the state of the application as a whole, and are always anonymous. Because of this, Global
     * domain does not provide selectors at all.
     * -   {@link Ext.app.domain.Controller Controller domain}. This domain includes all classes
     * that extend {@link Ext.app.Controller}. Events fired by Controllers will be available
     * within this domain; selectors are either Controller's {@link Ext.app.Controller#id id} or
     * '*' wildcard for any Controller.
     * -   {@link Ext.app.domain.Store Store domain}. This domain is for classes extending
     * {@link Ext.data.AbstractStore}. Selectors are either Store's
     * {@link Ext.data.AbstractStore#storeId storeId} or '*' wildcard for any Store.
     * -   {@link Ext.app.domain.Direct Direct domain}. This domain includes all classes that extend
     * {@link Ext.direct.Provider}. Selectors are either Provider's {@link Ext.direct.Provider#id id}
     * or '*' wildcard for any Provider. This domain is optional and will be loaded only if
     * {@link Ext.direct.Manager} singleton is required in your application.
     */
    export class EventDomain extends Ext.Base implements Ext.app.EventDomainConfig {
        protected isInstance: boolean;

        /**
         * Name of the identifier property for this event domain.
         */
        idProperty: string;

        constructor();

        destroy();

        /**
         * This method matches the firer of the event (the 'target') to the given 'selector'.
         * Default matching is very simple: a match is true when selector equals target's
         * {@link #cfg-idProperty idProperty}, or when selector is '*' wildcard to match any
         * target.
         *
         * @param {Object} target The firer of the event.
         * @param {String} selector The selector to which to match the 'target'.
         *
         * @return {Boolean} 'true' if the 'target' matches the 'selector'.
         */
        protected match(target: any, selector: string): boolean;

        /**
         * This method is called by the derived class to monitor 'fireEvent' calls. Any call
         * to 'fireEvent' on the target Observable will be intercepted and dispatched to any
         * listening Controllers. Assuming the original 'fireEvent' method does not return
         * 'false', the event is passed to the 'dispatch' method of this object.
         *
         * This is typically called in the 'constructor' of derived classes.
         *
         * @param {Ext.Class} observable The Observable to monitor for events.
         */
        protected monitor(observable: Ext.Class);

        /**
         * An object map containing 'Ext.app.EventDomain' instances keyed by the value
         * of their 'type' property.
         */
        static instances: any;
    }

    interface ProfileConfig {
        /**
         * The {@link Ext.app.Application Application} instance to which this Profile is
         * bound. This is set automatically.
         * @readonly
         */
        application?: Ext.app.Application;

        /**
         * Any additional {@link Ext.app.Controller Controllers} to load for this profile.
         * Note that each item here will be prepended with the Profile namespace when loaded.
         *
         * Example usage:
         *
         *     controllers: [
         *         'Users',
         *         'MyApp.controller.Products'
         *     ]
         *
         * This will load *MyApp.controller.tablet.Users* and *MyApp.controller.Products*.
         */
        controllers?: string;

        mainView?: string;

        /**
         * Any additional {@link Ext.app.Application#models Models} to load for this profile.
         * Note that each item here will be prepended with the Profile namespace when loaded.
         *
         * Example usage:
         *
         *     models: [
         *         'Group',
         *         'MyApp.model.User'
         *     ]
         *
         * This will load *MyApp.model.tablet.Group* and *MyApp.model.User*.
         */
        models?: string;

        /**
         * The name of this Profile. Defaults to the last section of the class name (e.g. a profile
         * called MyApp.profile.Phone will default the name to 'Phone').
         *
         * Optional
         */
        name?: string;

        /**
         * The namespace that this Profile's classes can be found in. Defaults to the lowercase
         * Profile {@link #name}, for example a Profile called MyApp.profile.Phone will by default have a 'phone'
         * namespace, which means that this Profile's additional models, stores, views and controllers will be loaded
         * from the MyApp.model.phone.*, MyApp.store.phone.*, MyApp.view.phone.* and MyApp.controller.phone.* namespaces
         * respectively.
         *
         * Optional
         */
        namespace?: string;

        /**
         * Any additional {@link Ext.app.Application#stores Stores} to load for this profile.
         * Note that each item here will be prepended with the Profile namespace when loaded.
         *
         * Example usage:
         *
         *     stores: [
         *         'Users',
         *         'MyApp.store.Products'
         *     ]
         *
         * This will load *MyApp.store.tablet.Users* and *MyApp.store.Products*.
         */
        stores?: string;

        /**
         * This config allows the active profile to define a set of 'xtypes' and map them
         * to desired classes and default configurations. Normally an 'xtype' is statically
         * declared by a {@link Ext.Component component} in its class definition. This
         * mechanism allows the active profile to control a set of these types.
         *
         * Example:
         *
         *      views: {
         *          // The "main" xtype maps to MyApp.view.tablet.Main
         *          //
         *          main: 'MyApp.view.tablet.Main',
         *
         *          // The "inbox" xtype maps to a subclass of MyApp.view.Inbox (created
         *          // by this mechanism) that sets the "mode" config to "compact".
         *          //
         *          inbox: {
         *              xclass: 'MyApp.view.Inbox',
         *              mode: 'compact'
         *          }
         *      }
         *
         * Note that class names used in this form must be full class names, unlike the
         * historical usage of 'views'. Further, these views cannot be accessed using the
         * 'getView' method but rather via their assigned 'xtype'.
         *
         * The historical usage of this config is enabled when an array is passed. In this
         * case, these are simply additional {@link Ext.app.Application#views views} to
         * load for this profile. Note that each item here will be prepended with the
         * Profile namespace when loaded.
         *
         * Example usage:
         *
         *     views: [
         *         'Main',
         *         'MyApp.view.Login'
         *     ]
         *
         * This will load *MyApp.view.tablet.Main* and *MyApp.view.Login*. While supported,
         * this usage is discouraged in favor of 'xtype' mapping.
         */
        views?: any|string;
    }

    /**
     * A Profile represents a range of devices that fall under a common category. For the vast majority of apps that use
     * device profiles, the app defines a Phone profile and a Tablet profile. Doing this enables you to easily customize
     * the experience for the different sized screens offered by those device types.
     *
     * Only one Profile can be active at a time, and each Profile defines a simple {@link #isActive} function that should
     * return either true or false. The first Profile to return true from its isActive function is set as your Application's
     * {@link Ext.app.Application#currentProfile current profile}.
     *
     * A Profile can define any number of {@link #models}, {@link #views}, {@link #controllers} and {@link #stores} which
     * will be loaded if the Profile is activated. It can also define a {@link #launch} function that will be called after
     * all of its dependencies have been loaded, just before the {@link Ext.app.Application#launch application launch}
     * function is called.
     *
     * ## Sample Usage
     *
     * First you need to tell your Application about your Profile(s):
     *
     *     Ext.application({
     *         name: 'MyApp',
     *         profiles: ['Phone', 'Tablet']
     *     });
     *
     * This will load app/profile/Phone.js and app/profile/Tablet.js. Here's how we might define the Phone profile:
     *
     *     Ext.define('MyApp.profile.Phone', {
     *         extend: 'Ext.app.Profile',
     *
     *         views: ['Main'],
     *
     *         isActive: function() {
     *             return Ext.os.is('Phone');
     *         }
     *     });
     *
     * The isActive function returns true if we detect that we are running on a phone device. If that is the case the
     * Application will set this Profile active and load the 'Main' view specified in the Profile's {@link #views} config.
     *
     * ## Class Specializations
     *
     * Because Profiles are specializations of an application, all of the models, views, controllers and stores defined
     * in a Profile are expected to be namespaced under the name of the Profile. Here's an expanded form of the example
     * above:
     *
     *     Ext.define('MyApp.profile.Phone', {
     *         extend: 'Ext.app.Profile',
     *
     *         views: ['Main'],
     *         controllers: ['Signup'],
     *         models: ['MyApp.model.Group'],
     *
     *         isActive: function() {
     *             return Ext.os.is('Phone');
     *         }
     *     });
     *
     * In this case, the Profile is going to load *app/view/phone/Main.js*, *app/controller/phone/Signup.js* and
     * *app/model/Group.js*. Notice that in each of the first two cases the name of the profile ('phone' in this case) was
     * injected into the class names. In the third case we specified the full Model name (for Group) so the Profile name
     * was not injected.
     *
     * For a fuller understanding of the ideas behind Profiles and how best to use them in your app, we suggest you read
     * the [device profiles guide](/touch/2.4/core_concepts/device_profiles.html).
     */
    export class Profile extends Ext.Base implements Ext.app.ProfileConfig {
        /**
         * 'true' to identify an object as an instance of 'Ext.app.Profile'
         */
        isProfile: any;

        /**
         * The {@link Ext.app.Application Application} instance to which this Profile is
         * bound. This is set automatically.
         * @readonly
         */
        application: Ext.app.Application;

        /**
         * Any additional {@link Ext.app.Controller Controllers} to load for this profile.
         * Note that each item here will be prepended with the Profile namespace when loaded.
         *
         * Example usage:
         *
         *     controllers: [
         *         'Users',
         *         'MyApp.controller.Products'
         *     ]
         *
         * This will load *MyApp.controller.tablet.Users* and *MyApp.controller.Products*.
         */
        controllers: string;

        mainView: string;

        /**
         * Any additional {@link Ext.app.Application#models Models} to load for this profile.
         * Note that each item here will be prepended with the Profile namespace when loaded.
         *
         * Example usage:
         *
         *     models: [
         *         'Group',
         *         'MyApp.model.User'
         *     ]
         *
         * This will load *MyApp.model.tablet.Group* and *MyApp.model.User*.
         */
        models: string;

        /**
         * The name of this Profile. Defaults to the last section of the class name (e.g. a profile
         * called MyApp.profile.Phone will default the name to 'Phone').
         *
         * Optional
         */
        name: string;

        /**
         * The namespace that this Profile's classes can be found in. Defaults to the lowercase
         * Profile {@link #name}, for example a Profile called MyApp.profile.Phone will by default have a 'phone'
         * namespace, which means that this Profile's additional models, stores, views and controllers will be loaded
         * from the MyApp.model.phone.*, MyApp.store.phone.*, MyApp.view.phone.* and MyApp.controller.phone.* namespaces
         * respectively.
         *
         * Optional
         */
        namespace: string;

        /**
         * Any additional {@link Ext.app.Application#stores Stores} to load for this profile.
         * Note that each item here will be prepended with the Profile namespace when loaded.
         *
         * Example usage:
         *
         *     stores: [
         *         'Users',
         *         'MyApp.store.Products'
         *     ]
         *
         * This will load *MyApp.store.tablet.Users* and *MyApp.store.Products*.
         */
        stores: string;

        /**
         * This config allows the active profile to define a set of 'xtypes' and map them
         * to desired classes and default configurations. Normally an 'xtype' is statically
         * declared by a {@link Ext.Component component} in its class definition. This
         * mechanism allows the active profile to control a set of these types.
         *
         * Example:
         *
         *      views: {
         *          // The "main" xtype maps to MyApp.view.tablet.Main
         *          //
         *          main: 'MyApp.view.tablet.Main',
         *
         *          // The "inbox" xtype maps to a subclass of MyApp.view.Inbox (created
         *          // by this mechanism) that sets the "mode" config to "compact".
         *          //
         *          inbox: {
         *              xclass: 'MyApp.view.Inbox',
         *              mode: 'compact'
         *          }
         *      }
         *
         * Note that class names used in this form must be full class names, unlike the
         * historical usage of 'views'. Further, these views cannot be accessed using the
         * 'getView' method but rather via their assigned 'xtype'.
         *
         * The historical usage of this config is enabled when an array is passed. In this
         * case, these are simply additional {@link Ext.app.Application#views views} to
         * load for this profile. Note that each item here will be prepended with the
         * Profile namespace when loaded.
         *
         * Example usage:
         *
         *     views: [
         *         'Main',
         *         'MyApp.view.Login'
         *     ]
         *
         * This will load *MyApp.view.tablet.Main* and *MyApp.view.Login*. While supported,
         * this usage is discouraged in favor of 'xtype' mapping.
         */
        views: any|string;

        /**
         * Creates a new Profile instance
         */
        constructor();

        getApplication();

        getControllers();

        getMainView();

        getModels();

        getStores();

        getViews();

        /**
         * This method is called once the profile is determined to be the active profile. This
         * initialization is performed before controllers are initialized and therefore also
         * before launch.
         * @since 6.0.1
         */
        protected init();

        /**
         * Determines whether or not this Profile is active on the device isActive is executed on. Should return true if
         * this profile is meant to be active on this device, false otherwise. Each Profile should implement this function
         * (the default implementation just returns false).
         * @return {Boolean} True if this Profile should be activated on the device it is running on, false otherwise
         */
        isActive(): boolean;

        /**
         * The launch function is called by the {@link Ext.app.Application Application} if this Profile's {@link #isActive}
         * function returned true. This is typically the best place to run any profile-specific app launch code. Example
         * usage:
         *
         *     launch: function() {
         *         Ext.create('MyApp.view.tablet.Main');
         *     }
         */
        launch();

        setApplication();

        setControllers();

        setMainView();

        setModels();

        setName();

        setNamespace();

        setStores();

        setViews();
    }

    export class Util extends Ext.Base {
    }

    /**
     * A view controller is a controller that can be attached to a specific view
     * instance so it can manage the view and its child components. Each instance of the view
     * will have a new view controller, so the instances are isolated.
     *
     * When a controller is specified on a view, the view automatically becomes a {@link Ext.container.Container#referenceHolder},
     * so it will receive inline events declared on the view. Sample usage:
     *
     *     @example
     *     Ext.define('User', {
     *        extend: 'Ext.data.Model',
     *        fields: ['name', 'phone']
     *     });
     *
     *     Ext.define('UserListController', {
     *         extend : 'Ext.app.ViewController',
     *         alias: 'controller.userlist',
     *
     *         init: function(view) {
     *             this.userCount = 0;
     *             var users = [],
     *                 i;
     *
     *             for (i = 0; i < 5; ++i) {
     *                 users.push(this.getUser());
     *             }
     *             view.getStore().add(users);
     *         },
     *
     *         onAddClick: function() {
     *             this.addUser();
     *         },
     *
     *         onDeleteClick: function() {
     *             var view = this.getView(),
     *                 selected = view.getSelectionModel().getSelection()[0],
     *                 store = view.getStore();
     *
     *             store.remove(selected);
     *         },
     *
     *         onSelectionChange: function(selModel, selections) {
     *             this.lookupReference('delete').setDisabled(selections.length === 0);
     *         },
     *
     *         getUser: function() {
     *             ++this.userCount;
     *             return {
     *                 name: 'User ' + this.userCount,
     *                 phone: this.generatePhone()
     *             };
     *         },
     *
     *         addUser: function() {
     *             this.getView().getStore().add(this.getUser());
     *         },
     *
     *         generatePhone: function() {
     *             var num = '',
     *                 i;
     *
     *             for (i = 0; i < 7; ++i) {
     *                 num += Ext.Number.randomInt(0, 9);
     *                 if (num.length === 3) {
     *                     num += '-';
     *                 }
     *             }
     *             return num;
     *         }
     *     });
     *
     *     Ext.define('UserList', {
     *         extend: 'Ext.grid.Panel',
     *         controller: 'userlist',
     *
     *         tbar: [{
     *             text: 'Add',
     *             listeners: {
     *                 click: 'onAddClick'
     *             }
     *         }, {
     *             text: 'Delete',
     *             reference: 'delete',
     *             listeners: {
     *                 click: 'onDeleteClick'
     *             }
     *         }],
     *         store: {
     *             model: 'User'
     *         },
     *         selModel: {
     *             type: 'rowmodel',
     *             listeners: {
     *                 selectionchange: 'onSelectionChange'
     *             }
     *         },
     *         columns: [{
     *             flex: 1,
     *             dataIndex: 'name',
     *             text: 'Name'
     *         }, {
     *             flex: 1,
     *             dataIndex: 'phone',
     *             text: 'Phone'
     *         }]
     *     });
     *
     *     Ext.onReady(function() {
     *         new UserList({
     *             renderTo: Ext.getBody(),
     *             width: 400,
     *             height: 200
     *         });
     *     });
     */
    export class ViewController extends Ext.app.BaseController {
        factoryConfig: any;

        /**
         * Called before the view initializes. This is called before the view's
         * initComponent method has been called.
         * @param {Ext.Component} view The view
         */
        protected beforeInit(view: Ext.Component);

        /**
         * This method closes the associated view. The manner in which this is done (that is,
         * the method called to close the view) is specified by 'closeViewAction'.
         *
         * It is common for views to map one or more events to this method to allow the view
         * to be closed.
         */
        closeView();

        constructor();

        /**
         * Destroy the view controller.
         */
        destroy();

        /**
         * Fires an event on the view. See {@link Ext.Component#fireEvent}.
         * @param {String} eventName The name of the event to fire.
         * @param {Object...} args Variable number of parameters are passed to handlers.
         * @return {Boolean} returns false if any of the handlers return false otherwise it returns true.
         */
        protected fireViewEvent(eventName: string, args: any): boolean;

        getCloseViewAction();

        /**
         * @since 5.0.0
         */
        getReferences();

        /**
         * Get a {@link Ext.data.Session} attached to the view for this controller.
         * See {@link Ext.Component#lookupSession}.
         *
         * @return {Ext.data.Session} The session. 'null' if no session is found.
         *
         * @since 5.0.0
         */
        getSession(): Ext.data.Session;

        /**
         * Get a {@link Ext.data.Store} attached to the {@link #getViewModel ViewModel} attached to
         * this controller. See {@link Ext.app.ViewModel#getStore}.
         * @param {String} name The name of the store.
         * @return {Ext.data.Store} The store. 'null' if no store is found, or there is no
         * {@link Ext.app.ViewModel} attached to the view for this controller.
         *
         * @since 5.0.0
         */
        getStore(name: string): Ext.data.Store;

        /**
         * Get the view for this controller.
         * @return {Ext.Component} The view.
         */
        getView(): Ext.Component;

        /**
         * Get a {@link Ext.app.ViewModel} attached to the view for this controller.
         * See {@link Ext.Component#lookupViewModel}.
         *
         * @return {Ext.app.ViewModel} The ViewModel. 'null' if no ViewModel is found.
         *
         * @since 5.0.0
         */
        getViewModel(): Ext.app.ViewModel;

        /**
         * Called when the view initializes. This is called after the view's initComponent
         * method has been called.
         * @param {Ext.Component} view The view
         */
        protected init(view: Ext.Component);

        /**
         * Called when the view model instance for an attached view is first created.
         * @param {Ext.app.ViewModel} viewModel The ViewModel
         */
        protected initViewModel(viewModel: Ext.app.ViewModel);

        /**
         * Gets a reference to the component with the specified {@link Ext.Component#reference}
         * value.
         *
         * The method is a short-hand for the {@link #lookupReference} method.
         *
         * @param {String} key The name of the reference to lookup.
         * @return {Ext.Component} The component, 'null' if the reference doesn't exist.
         * @since 6.0.1
         */
        lookup(key: string): Ext.Component;

        /**
         * Gets a reference to the component with the specified {@link Ext.Component#reference}
         * value.
         *
         * The {@link #lookup} method is a short-hand version of this method.
         *
         * @param {String} key The name of the reference to lookup.
         * @return {Ext.Component} The component, 'null' if the reference doesn't exist.
         * @since 5.0.0
         */
        lookupReference(key: string): Ext.Component;

        setCloseViewAction();
    }

    interface ViewModelConfig {
        /**
         * This object holds the arbitrary data that populates the 'ViewModel' and is
         * then available for binding.
         * @since 5.0.0
         */
        data?: any;

        /**
         * An object that defines named values whose value is managed by function calls.
         * The names of the properties of this object are assigned as values in the
         * ViewModel.
         *
         * For example:
         *
         *      formulas: {
         *          xy: function (get) { return get('x') * get('y'); }
         *      }
         *
         * For more details about defining a formula, see '{@link Ext.app.bind.Formula}'.
         * @since 5.0.0
         */
        formulas?: any;

        /**
         * Links provide a way to assign a simple name to a more complex bind. The primary
         * use for this is to assign names to records in the data model.
         *
         *      links: {
         *          theUser: {
         *              type: 'User',
         *              id: 12
         *          }
         *      }
         *
         * It is also possible to force a new phantom record to be created by not specifying an
         * id but passing 'create: true' as part of the descriptor. This is often useful when
         * creating a new record for a child session.
         *
         *     links: {
         *         newUser: {
         *             type: 'User',
         *             create: true
         *         }
         *     }
         *
         * 'create' can also be an object containing initial data for the record.
         *
         *     links: {
         *         newUser: {
         *             type: 'User',
         *             create: {
         *                 firstName: 'John',
         *                 lastName: 'Smith'
         *             }
         *         }
         *     }
         *
         * While that is the typical use, the value of each property in 'links' may also be
         * a bind descriptor (see '{@link #method-bind}' for the various forms of bind
         * descriptors).
         * @since 5.0.0
         */
        links?: any;

        /**
         * The parent 'ViewModel' of this 'ViewModel'. Once set, this cannot be changed.
         * @readonly
         * @since 5.0.0
         */
        parent?: Ext.app.ViewModel;

        /**
         * The schema to use for getting information about entities.
         */
        schema?: string|Ext.data.schema.Schema;

        /**
         * The session used to manage the data model (records and stores).
         * @since 5.0.0
         */
        session?: Ext.data.Session;

        /**
         * A declaration of 'Ext.data.Store' configurations that are first processed as
         * binds to produce an effective store configuration.
         *
         * A simple store definition. We can reference this in our bind statements using the
         * '{users}' as we would with other data values.
         *
         *     new Ext.app.ViewModel({
         *         stores: {
         *             users: {
         *                 model: 'User',
         *                 autoLoad: true
         *             }
         *         }
         *     });
         *
         * This store definition contains a dynamic binding. The store will not be created until
         * the initial value for groupId is set. Once that occurs, the store is created with the appropriate
         * filter configuration. Subsequently, once we change the group value, the old filter will be
         * overwritten with the new value.
         *
         *     var viewModel = new Ext.app.ViewModel({
         *         stores: {
         *             users: {
         *                 model: 'User',
         *                 filters: [{
         *                     property: 'groupId',
         *                     value: '{groupId}'
         *                 }]
         *             }
         *         }
         *     });
         *     viewModel.set('groupId', 1); // This will trigger the store creation with the filter.
         *     viewModel.set('groupId', 2); // The filter value will be changed.
         *
         * This store uses {@link Ext.data.ChainedStore store chaining} to create a store backed by the
         * data in another store. By specifying a string as the store, it will bind our creation and backing
         * to the other store. This functionality is especially useful when wanting to display a different "view"
         * of a store, for example a different sort order or different filters.
         *
         *     var viewModel = new Ext.app.ViewModel({
         *         stores: {
         *             allUsers: {
         *                 model: 'User',
         *                 autoLoad: true
         *             },
         *             children: {
         *                 source: '{allUsers}',
         *                 filters: [{
         *                     property: 'age',
         *                     value: 18,
         *                     operator: '<'
         *                 }]
         *             }
         *         }
         *     });
         *
         * @since 5.0.0
         */
        stores?: any;

        /**
         * The Container that owns this 'ViewModel' instance.
         * @since 5.0.0
         */
        view?: Ext.Container;
    }

    /**
     * This class manages arbitrary data and its relationship to data models. Instances of
     * 'ViewModel' are associated with some 'Component' and then used by their child items
     * for the purposes of Data Binding.
     *
     * # Binding
     *
     * The most commonly used aspect of a 'ViewModel' is the 'bind' method. This method takes
     * a "bind descriptor" (see below) and a callback to call when the data indicated by the
     * bind descriptor either becomes available or changes.
     *
     * The 'bind' method, based on the bind descriptor given, will return different types of
     * "binding" objects. These objects maintain the connection between the requested data and
     * the callback. Bindings ultimately derive from '{@link Ext.app.bind.BaseBinding}'
     * which provides several methods to help manage the binding.
     *
     * Perhaps the most important method is 'destroy'. When the binding is no longer needed
     * it is important to remember to 'destroy' it. Leaking bindings can cause performance
     * problems or worse when callbacks are called at unexpected times.
     *
     * The types of bindings produced by 'bind' are:
     *
     *   * '{@link Ext.app.bind.Binding}'
     *   * '{@link Ext.app.bind.Multi}'
     *   * '{@link Ext.app.bind.TemplateBinding}'
     *
     * ## Bind Descriptors
     *
     * A "bind descriptor" is a value (a String, an Object or an array of these) that describe
     * the desired data. Any piece of data in the 'ViewModel' can be described by a bind
     * descriptor.
     *
     * ### Textual Bind Descriptors
     *
     * The simplest and most common form of bind descriptors are strings that look like an
     * 'Ext.Template' containing text and tokens surrounded by "{}" with dot notation inside
     * to traverse objects and their properties.
     *
     * For example:
     *
     *   * ''Hello {user.name}!''
     *   * ''You have selected "{selectedItem.text}".''
     *   * ''{user.groups}''
     *
     * The first two bindings are '{@link Ext.app.bind.TemplateBinding template bindings}'
     * which use the familiar 'Ext.Template' syntax with some slight differences. For more on
     * templates see '{@link Ext.app.bind.Template}'.
     *
     * The third bind descriptor is called a "direct bind descriptor". This special form of
     * bind maps one-to-one to some piece of data in the 'ViewModel' and is managed by the
     * '{@link Ext.app.bind.Binding}' class.
     *
     * #### Two-Way Descriptors
     *
     * A direct bind descriptor may be able to write back a value to the 'ViewModel' as well
     * as retrieve one. When this is the case, they are said to be "two-way". For example:
     *
     *      var binding = viewModel.bind('{s}', function(x) { console.log('s=' + s); });
     *
     *      binding.setValue('abc');
     *
     * Direct use of 'ViewModel' in this way is not commonly needed because 'Ext.Component'
     * automates this process. For example, a 'textfield' component understands when it is
     * given a "two-way" binding and automatically synchronizes its value bidirectionally using
     * the above technique. For example:
     *
     *      Ext.widget({
     *          items: [{
     *              xtype: 'textfield',
     *              bind: '{s}'  // a two-way / direct bind descriptor
     *          }]
     *      });
     *
     * ### Object and Array Descriptors / Multi-Bind
     *
     * With two exceptions (see below) an Object is interpreted as a "shape" to produce by
     * treating each of its properties as individual bind descriptors. An object of the same
     * shape is passed as the value of the bind except that each property is populated with
     * the appropriate value. Of course, this definition is recursive, so these properties
     * may also be objects.
     *
     * For example:
     *
     *      viewModel.bind({
     *              x: '{x}',
     *              foo: {
     *                  bar: 'Hello {foo.bar}'
     *              }
     *          },
     *          function (obj) {
     *              //  obj = {
     *              //      x: 42,
     *              //      foo: {
     *              //          bar: 'Hello foobar'
     *              //      }
     *              //  }
     *          });
     *
     * Arrays are handled in the same way. Each element of the array is considered a bind
     * descriptor (recursively) and the value produced for the binding is an array with each
     * element set to the bound property.
     *
     * ### Bind Options
     *
     * One exception to the "object is a multi-bind" rule is when that object contains a
     * 'bindTo' property. When an object contains a 'bindTo' property the object is understood
     * to contain bind options and the value of 'bindTo' is considered the actual bind
     * descriptor.
     *
     * For example:
     *
     *      viewModel.bind({
     *              bindTo: '{x}',
     *              single: true
     *          },
     *          function (x) {
     *              console.log('x: ' + x); // only called once
     *          });
     *
     * The available bind options depend on the type of binding, but since all bindings
     * derive from '{@link Ext.app.bind.BaseBinding}' its options are always applicable.
     * For a list of the other types of bindings, see above.
     *
     * #### Deep Binding
     *
     * When a direct bind is made and the bound property is an object, by default the binding
     * callback is only called when that reference changes. This is the most efficient way to
     * understand a bind of this type, but sometimes you may need to be notified if any of the
     * properties of that object change.
     *
     * To do this, we create a "deep bind":
     *
     *      viewModel.bind({
     *              bindTo: '{someObject}',
     *              deep: true
     *          },
     *          function (someObject) {
     *              // called when reference changes or *any* property changes
     *          });
     *
     * #### Binding Timings
     *
     * The 'ViewModel' has a {@link #scheduler} attached that is used to coordinate the firing of bindings.
     * It serves 2 main purposes:
     * - To coordinate dependencies between bindings. This means bindings will be fired in an order such that
     * the any dependencies for a binding are fired before the binding itself.
     * - To batch binding firings. The scheduler runs on a short timer, so the following code will only trigger
     * a single binding (the last), the changes in between will never be triggered.
     *
     *     viewModel.bind('{val}', function(v) {
     *         console.log(v);
     *     });
     *     viewModel.set('val', 1);
     *     viewModel.set('val', 2);
     *     viewModel.set('val', 3);
     *     viewModel.set('val', 4);
     *
     * The 'ViewModel' can be forced to process by calling '{@link #notify}', which will force the
     * scheduler to run immediately in the current state.
     *
     *     viewModel.bind('{val}', function(v) {
     *         console.log(v);
     *     });
     *     viewModel.set('val', 1);
     *     viewModel.notify();
     *     viewModel.set('val', 2);
     *     viewModel.notify();
     *     viewModel.set('val', 3);
     *     viewModel.notify();
     *     viewModel.set('val', 4);
     *     viewModel.notify();
     *
     *
     * #### Models, Stores and Associations
     *
     * A {@link Ext.data.Session Session} manages model instances and their associations.
     * The 'ViewModel' may be used with or without a 'Session'. When a 'Session' is attached, the
     * 'ViewModel' will always consult the 'Session' to ask about records and stores. The 'Session'
     * ensures that only a single instance of each model Type/Id combination is created. This is
     * important when tracking changes in models so that we always have the same reference.
     *
     * A 'ViewModel' provides functionality to easily consume the built in data package types
     * {@link Ext.data.Model} and {@link Ext.data.Store}, as well as their associations.
     *
     * ### Model Links
     *
     * A model can be described declaratively using a {@link #links 'link'}. In the example code below,
     * We ask the 'ViewModel' to construct a record of type 'User' with 'id: 17'. The model will be loaded
     * from the server and the bindings will trigger once the load has completed. Similarly, we could also
     * attach a model instance to the 'ViewModel' data directly.
     *
     *     Ext.define('MyApp.model.User', {
     *         extend: 'Ext.data.Model',
     *         fields: ['name']
     *     });
     *
     *     var rec = new MyApp.model.User({
     *         id: 12,
     *         name: 'Foo'
     *     });
     *
     *     var viewModel = new Ext.app.ViewModel({
     *         links: {
     *             theUser: {
     *                 type: 'User',
     *                 id: 17
     *             }
     *         },
     *         data: {
     *             otherUser: rec
     *         }
     *     });
     *     viewModel.bind('{theUser.name}', function(v) {
     *         console.log(v);
     *     });
     *     viewModel.bind('{otherUser.name}', function(v) {
     *         console.log(v);
     *     });
     *
     * ### Model Fields
     *
     * Bindings have the functionality to inspect the parent values and resolve the underlying
     * value dynamically. This behavior allows model fields to be interrogated as part of a binding.
     *
     *     Ext.define('MyApp.model.User', {
     *         extend: 'Ext.data.Model',
     *         fields: ['name', 'age']
     *     });
     *
     *     var viewModel = new Ext.app.ViewModel({
     *         links: {
     *             theUser: {
     *                 type: 'User',
     *                 id: 22
     *             }
     *         }
     *     });
     *
     *     // Server responds with:
     *     {
     *         "id": 22,
     *         "name": "Foo",
     *         "age": 100
     *     }
     *
     *     viewModel.bind('Hello {name}, you are {age} years old', function(v) {
     *         console.log(v);
     *     });
     *
     * ### Associations
     *
     * In the same way as fields, the bindings can also traverse associations in a bind statement.
     * The 'ViewModel' will handle the asynchronous loading of data and only present the value once
     * the full path has been loaded. For more information on associations see {@link Ext.data.schema.OneToOne OneToOne} and
     * {@link Ext.data.schema.ManyToOne ManyToOne} associations.
     *
     *     Ext.define('User', {
     *         extend: 'Ext.data.Model',
     *         fields: ['name']
     *     });
     *
     *     Ext.define('Order', {
     *         extend: 'Ext.data.Model',
     *         fields: ['date', {
     *             name: 'userId',
     *             reference: 'User'
     *         }]
     *     });
     *
     *     Ext.define('OrderItem', {
     *         extend: 'Ext.data.Model',
     *         fields: ['price', 'qty', {
     *             name: 'orderId',
     *             reference: 'Order'
     *         }]
     *     });
     *
     *     var viewModel = new Ext.app.ViewModel({
     *         links: {
     *             orderItem: {
     *                 type: 'OrderItem',
     *                 id: 13
     *             }
     *         }
     *     });
     *     // The viewmodel will handle both ways of loading the data:
     *     // a) If the data is loaded inline in a nested fashion it will
     *     //    not make requests for extra data
     *     // b) Only loading a single model at a time. So the Order will be loaded once
     *     //    the OrderItem returns. The User will be loaded once the Order loads.
     *     viewModel.bind('{orderItem.order.user.name}', function(name) {
     *         console.log(name);
     *     });
     *
     * ### Stores
     *
     * Stores can be created as part of the 'ViewModel' definition. The definitions are processed
     * like bindings which allows for very powerful dynamic functionality.
     *
     * It is important to ensure that you name viewModel's data keys uniquely. If data is not named
     * uniquely, binds and formulas may receive information from an unintended data source.
     * This applies to keys in the viewModel's data block, stores, and links configs.
     *
     *     var viewModel = new Ext.app.ViewModel({
     *         stores: {
     *             users: {
     *                 model: 'User',
     *                 autoLoad: true,
     *                 filters: [{
     *                     property: 'createdDate',
     *                     value: '{createdFilter}',
     *                     operator: '>'
     *                 }]
     *             }
     *         }
     *     });
     *     // Later on in our code, we set the date so that the store is created.
     *     viewModel.set('createdFilter', Ext.Date.subtract(new Date(), Ext.Date.DAY, 7));
     *
     * See {@link #stores} for more detail.
     *
     * #### Formulas
     *
     * Formulas allow for calculated 'ViewModel' data values. The dependencies for these formulas
     * are automatically determined so that the formula will not be processed until the required
     * data is present.
     *
     *     var viewModel = new Ext.app.ViewModel({
     *         formulas: {
     *             fullName: function(get) {
     *                 return get('firstName') + ' ' + get('lastName');
     *             }
     *         },
     *         data: {firstName: 'John', lastName: 'Smith'}
     *     });
     *
     *     viewModel.bind('{fullName}', function(v) {
     *         console.log(v);
     *     });
     *
     * See {@link #formulas} for more detail.
     */
    export class ViewModel extends Ext.Base implements Ext.app.ViewModelConfig {
        factoryConfig: any;

        /**
         * This object holds the arbitrary data that populates the 'ViewModel' and is
         * then available for binding.
         * @since 5.0.0
         */
        data: any;

        /**
         * An object that defines named values whose value is managed by function calls.
         * The names of the properties of this object are assigned as values in the
         * ViewModel.
         *
         * For example:
         *
         *      formulas: {
         *          xy: function (get) { return get('x') * get('y'); }
         *      }
         *
         * For more details about defining a formula, see '{@link Ext.app.bind.Formula}'.
         * @since 5.0.0
         */
        formulas: any;

        /**
         * Links provide a way to assign a simple name to a more complex bind. The primary
         * use for this is to assign names to records in the data model.
         *
         *      links: {
         *          theUser: {
         *              type: 'User',
         *              id: 12
         *          }
         *      }
         *
         * It is also possible to force a new phantom record to be created by not specifying an
         * id but passing 'create: true' as part of the descriptor. This is often useful when
         * creating a new record for a child session.
         *
         *     links: {
         *         newUser: {
         *             type: 'User',
         *             create: true
         *         }
         *     }
         *
         * 'create' can also be an object containing initial data for the record.
         *
         *     links: {
         *         newUser: {
         *             type: 'User',
         *             create: {
         *                 firstName: 'John',
         *                 lastName: 'Smith'
         *             }
         *         }
         *     }
         *
         * While that is the typical use, the value of each property in 'links' may also be
         * a bind descriptor (see '{@link #method-bind}' for the various forms of bind
         * descriptors).
         * @since 5.0.0
         */
        links: any;

        /**
         * The parent 'ViewModel' of this 'ViewModel'. Once set, this cannot be changed.
         * @readonly
         * @since 5.0.0
         */
        parent: Ext.app.ViewModel;

        /**
         * The schema to use for getting information about entities.
         */
        schema: string|Ext.data.schema.Schema;

        /**
         * The session used to manage the data model (records and stores).
         * @since 5.0.0
         */
        session: Ext.data.Session;

        /**
         * A declaration of 'Ext.data.Store' configurations that are first processed as
         * binds to produce an effective store configuration.
         *
         * A simple store definition. We can reference this in our bind statements using the
         * '{users}' as we would with other data values.
         *
         *     new Ext.app.ViewModel({
         *         stores: {
         *             users: {
         *                 model: 'User',
         *                 autoLoad: true
         *             }
         *         }
         *     });
         *
         * This store definition contains a dynamic binding. The store will not be created until
         * the initial value for groupId is set. Once that occurs, the store is created with the appropriate
         * filter configuration. Subsequently, once we change the group value, the old filter will be
         * overwritten with the new value.
         *
         *     var viewModel = new Ext.app.ViewModel({
         *         stores: {
         *             users: {
         *                 model: 'User',
         *                 filters: [{
         *                     property: 'groupId',
         *                     value: '{groupId}'
         *                 }]
         *             }
         *         }
         *     });
         *     viewModel.set('groupId', 1); // This will trigger the store creation with the filter.
         *     viewModel.set('groupId', 2); // The filter value will be changed.
         *
         * This store uses {@link Ext.data.ChainedStore store chaining} to create a store backed by the
         * data in another store. By specifying a string as the store, it will bind our creation and backing
         * to the other store. This functionality is especially useful when wanting to display a different "view"
         * of a store, for example a different sort order or different filters.
         *
         *     var viewModel = new Ext.app.ViewModel({
         *         stores: {
         *             allUsers: {
         *                 model: 'User',
         *                 autoLoad: true
         *             },
         *             children: {
         *                 source: '{allUsers}',
         *                 filters: [{
         *                     property: 'age',
         *                     value: 18,
         *                     operator: '<'
         *                 }]
         *             }
         *         }
         *     });
         *
         * @since 5.0.0
         */
        stores: any;

        /**
         * The Container that owns this 'ViewModel' instance.
         * @since 5.0.0
         */
        view: Ext.Container;

        /**
         * This method requests that data in this 'ViewModel' be delivered to the specified
         * 'callback'. The data desired is given in a "bind descriptor" which is the first
         * argument.
         *
         * A simple call might look like this:
         *
         *     var binding = vm.bind('{foo}', this.onFoo, this);
         *
         *     binding.destroy();  // when done with the binding
         *
         * Options for the binding can be provided in the last argument:
         *
         *     var binding = vm.bind('{foo}', this.onFoo, this, {
         *         deep: true
         *     });
         *
         * Alternatively, bind options can be combined with the bind descriptor using only
         * the first argument:
         *
         *     var binding = vm.bind({
         *         bindTo: '{foo}',  // the presence of bindTo identifies this form
         *         deep: true
         *     }, this.onFoo, this);
         *
         * See the class documentation for more details on Bind Descriptors and options.
         *
         * @param {String/Object/Array} descriptor The bind descriptor. See class description
         * for details.
         * @param {Function} callback The function to call with the value of the bound property.
         * @param {Object} [scope] The scope ('this' pointer) for the 'callback'.
         * @param {Object} [options] Additional options to configure the {@link Ext.app.bind.Binding binding}.
         * If this parameter is provided, the 'bindTo' form of combining options and bind descriptor is not
         * recognized.
         * @return {Ext.app.bind.BaseBinding/Ext.app.bind.Binding} The binding.
         */
        bind(descriptor: string|any|any[], callback: Function, scope?: any, options?: any): Ext.app.bind.BaseBinding|Ext.app.bind.Binding;

        constructor(config: Ext.app.ViewModelConfig);

        destroy();

        /**
         * Get a value from the data for this viewmodel.
         * @param {String} path The path of the data to retrieve.
         *
         *    var value = vm.get('theUser.address.city');
         *
         * @return {Object} The data stored at the passed path.
         */
        get(path: string): any;

        getData();

        getFormulas();

        getLinks();

        getParent();

        getSchema();

        /**
         * Gets the session attached to this (or a parent) ViewModel. See the {@link #session} configuration.
         * @return {Ext.data.Session} The session. 'null' if no session exists.
         */
        getSession(): Ext.data.Session;

        /**
         * Gets a store configured via the {@link #stores} configuration.
         * @param {String} key The name of the store.
         * @return {Ext.data.Store} The store. 'null' if no store exists.
         */
        getStore(key: string): Ext.data.Store;

        getView();

        /**
         * Create a link to a reference. See the {@link #links} configuration.
         * @param {String} key The name for the link.
         * @param {Object} reference The reference descriptor.
         */
        linkTo(key: string, reference: any);

        /**
         * Forces all bindings in this ViewModel hierarchy to evaluate immediately. Use this to do a synchronous flush
         * of all bindings.
         */
        notify();

        /**
         * Set  a value in the data for this viewmodel.
         * @param {Object/String} path The path of the value to set, or an object literal to set
         * at the root of the viewmodel.
         * @param {Object} value The data to set at the value. If the value is an object literal,
         * any required paths will be created.
         *
         *     // Set a single property at the root level
         *     viewModel.set('expiry', Ext.Date.add(new Date(), Ext.Date.DAY, 7));
         *     console.log(viewModel.get('expiry'));
         *     // Sets a single property in user.address, does not overwrite any hierarchy.
         *     viewModel.set('user.address.city', 'London');
         *     console.log(viewModel.get('user.address.city'));
         *     // Sets 2 properties of "user". Overwrites any existing hierarchy.
         *     viewModel.set('user', {firstName: 'Foo', lastName: 'Bar'});
         *     console.log(viewModel.get('user.firstName'));
         *     // Sets a single property at the root level. Overwrites any existing hierarchy.
         *     viewModel.set({rootKey: 1});
         *     console.log(viewModel.get('rootKey'));
         */
        set(path: any|string, value: any);

        setData();

        setFormulas();

        setLinks();

        setParent();

        setSchema();

        setSession();

        setStores();

        setView();
    }
}

declare module Ext.app.bind {
    /**
     * This class manages bindings for a 'Session' or 'ViewModel'.
     */
    export class AbstractStub extends Ext.util.Schedulable {
        /**
         * This property is set at creation of ths stub and should not be changed.
         * @readonly
         */
        owner: Ext.data.Session|Ext.app.ViewModel;

        constructor(owner: any, name: any);

        destroy();
    }

    interface BaseBindingConfig {
        /**
         * This option instructs the binding to call its 'destroy' method immediately after
         * delivering the initial value.
         * @since 5.0.0
         *
         * Optional, Defaults to: false
         */
        single?: boolean;
    }

    /**
     * This class is the base for 'Binding' and 'MultiBinding'.
     */
    export class BaseBinding extends Ext.util.Schedulable implements Ext.app.bind.BaseBindingConfig {
        /**
         * This option instructs the binding to call its 'destroy' method immediately after
         * delivering the initial value.
         * @since 5.0.0
         *
         * Optional, Defaults to: false
         */
        single: boolean;

        constructor();

        destroy();
    }

    interface BindingConfig extends Ext.app.bind.BaseBindingConfig {
        /**
         * Normally a binding is only notified of changes to its bound property, but if that
         * property is an object it is sometimes helpful to be notified of changes to its
         * properties. To receive notifications of changes to all properties of a bound object,
         * set this to 'true'.
         * @since 5.0.0
         *
         * Optional, Defaults to: false
         */
        deep?: boolean;
    }

    /**
     * This class is created to manage a direct bind.  'Ext.app.ViewModel' returns this from
     * its {@link Ext.app.ViewModel#method-bind bind} method.
     */
    export class Binding extends Ext.app.bind.BaseBinding implements Ext.app.bind.BindingConfig {
        /**
         * Normally a binding is only notified of changes to its bound property, but if that
         * property is an object it is sometimes helpful to be notified of changes to its
         * properties. To receive notifications of changes to all properties of a bound object,
         * set this to 'true'.
         * @since 5.0.0
         *
         * Optional, Defaults to: false
         */
        deep: boolean;

        /**
         * Binds to the 'validation' association for the bound property. For example, when a
         * binding is bound to something like this:
         *
         *      var binding = viewModel.bind('{theUser.name}', ...);
         *
         * The validation status for the "name" property can be requested like so:
         *
         *      var validationBinding = binding.bindValidation(fn, scope);
         *
         * Calling this method in the above example would be equivalent to the following bind:
         *
         *      var validationBinding = viewModel.bind('{theUser.validation.name}', fn, scope);
         *
         * The primary reason to use this method is in cases where the original bind expression
         * is not known.
         *
         * For example, this method is used by 'Ext.form.field.Base' when given the
         * '{@link Ext.Component#modelValidation modelValidation}' config is set. As such it
         * not common for users to need to call this method.
         *
         * @param {Function} callback The function to call when the validation changes.
         * @param {Object} [scope] The scope on which to call the 'callback'.
         * @return {Ext.app.bind.Binding} A binding to the validation of the bound property.
         * @since 5.0.0
         */
        bindValidation(callback: Function, scope?: any): Ext.app.bind.Binding;

        constructor();

        /**
         * Destroys this binding. No further calls will be made to the callback method. No
         * methods should be called on this binding after calling this method.
         * @since 5.0.0
         */
        destroy();

        /**
         * Returns the diagnostic name for this binding.
         * @return {String}
         * @since 5.0.0
         */
        getFullName(): string;

        /**
         * Returns the current value of the bound property. If this binding 'isLoading' this
         * value will be 'undefined'.
         * @return {Mixed} The value of the bound property.
         * @since 5.0.0
         */
        getValue(): any;

        /**
         * Returns 'true' if the bound property is loading. In the general case this means
         * that the value is just not available yet. In specific cases, when the bound property
         * is an 'Ext.data.Model' it means that a request to the server is in progress to get
         * the record. For an 'Ext.data.Store' it means that
         * '{@link Ext.data.Store#method-load load}' has been called on the store but it is
         * still in progress.
         * @return {Boolean}
         * @since 5.0.0
         */
        isLoading(): boolean;

        /**
         * This method returns 'true' if this binding can only be read. If this method returns
         * 'false' then the binding can be set using 'setValue' (meaning this binding can be
         * a two-way binding).
         * @return {Boolean}
         * @since 5.0.0
         */
        isReadOnly(): boolean;

        /**
         * Tells the bound property to refresh itself. This has meaning when the bound property
         * is something like an 'Ext.data.Model' and an 'Ext.data.Store' but does nothing in
         * most cases.
         * @since 5.0.0
         */
        refresh();

        /**
         * Sets the value of the bound property. This will throw an error in debug mode if
         * this binding 'isReadOnly'.
         * @param {Mixed} value The new value.
         * @since 5.0.0
         */
        setValue(value: any);
    }

    interface FormulaConfig {
        /**
         * An explicit bind request to produce data to provide the 'get' function. If this is
         * specified, the result of this bind is the first argument to 'get'. If not given,
         * then 'get' receives a getter function that can retrieve bind expressions. For details on what can
         * be specified for this property see '{@link Ext.app.ViewModel#bind}'.
         * @since 5.0.0
         *
         * Optional
         */
        bind?: any;

        /**
         * The function to call to calculate the formula's value. The 'get' method executes
         * with a 'this' pointer of the 'ViewModel' and receives a getter function or the result of a configured 'bind'.
         * @since 5.0.0
         */
        get?: Function;

        /**
         * If provided this method allows a formula to be set. This method is typically called
         * when '{@link Ext.app.bind.Binding#setValue}' is called. The 'set' method executes
         * with a 'this' pointer of the 'ViewModel'. Whatever values need to be updated can
         * be set by calling '{@link Ext.app.ViewModel#set}'.
         * @since 5.0.0
         *
         * Optional
         */
        set?: Function;

        /**
         * This option instructs the binding to call its 'destroy' method immediately after
         * delivering the initial value.
         * @since 5.0.0
         *
         * Optional, Defaults to: false
         */
        single?: boolean;
    }

    /**
     * This class manages a formula defined for an 'Ext.app.ViewModel'.
     *
     * ## Formula Basics
     *
     * Formulas in a 'ViewModel' can be defined as simply as just a function:
     *
     *      formulas: {
     *          xy: function (get) { return get('x') * get('y'); }
     *      }
     *
     * When you need to be more explicit, "xy" can become an object. The following means the
     * same thing as above:
     *
     *      formulas: {
     *          xy: {
     *              get: function (get) { return get('x') * get('y'); }
     *          }
     *      }
     *
     * ### Data Dependencies
     *
     * One of the important aspects of a 'ViewModel' is notification of change. In order to
     * manage this, a 'ViewModel' *must* know the dependencies between data. In the above case
     * this is accomplished by **parsing the text of the function**. While this is convenient
     * and reduces the maintenance/risk that would come from explicitly listing dependencies
     * separately, there are some rules to be aware of:
     *
     *   * All dependencies are resolved by matching the binding statements in the getter function.
     *   * If you need to use these values in other ways, cache them as a 'var' (following
     *     the first rule to capture the value) and use that 'var'.
     *
     * In the above formulas, the "xy" formula depends on "x" and "y" in the 'ViewModel'. As
     * these values change, the formula is called to produce the correct value for "xy". This
     * in turn can be used by other formulas. For example:
     *
     *      formulas: {
     *          xy: function (get) {  // "get" is arbitrary but a good convention
     *              return get('x') * get('y');
     *          },
     *
     *          xyz: function (get) {
     *              return get('xy') * get('z');
     *          }
     *      }
     *
     * In the above, "xyz" depends on "xy" and "z" values in the 'ViewModel'.
     *
     * ### The Getter Method
     *
     * The argument passed to the formula is a function that allows you to retrieve
     * the matched bind statements.
     *
     *      formulas: {
     *          foo: function (get) {
     *              return get('theUser.address.city');
     *          }
     *      }
     *
     * In the above, the dependency is resolved to 'theUser.address.city'. The formula will not
     * be triggered until the value for 'city' is present.
     *
     * ### Capturing Values
     *
     * If values need to be used repeatedly, you can use a 'var' as long as the Rules are not
     * broken.
     *
     *      formulas: {
     *          x2y2: function (get) {
     *              // These are still "visible" as "get('x')" and "get('y')" so this is OK:
     *              var x = get('x'),
     *                  y = get('y');
     *
     *              return x * x * y * y;
     *          }
     *      }
     *
     * ## Explicit Binding
     *
     * While function parsing is convenient, there are times it is not the best solution. In
     * these cases, an explicit 'bind' can be given. To revisit the previous example with an
     * explicit binding:
     *
     *      formulas: {
     *          zip: {
     *              bind: '{foo.bar.zip}',
     *
     *              get: function (zip) {
     *                  // NOTE: the only thing we get is what our bind produces.
     *                  return zip * 2;
     *              }
     *          }
     *      }
     *
     * In this case we have given the formula an explicit 'bind' value so it will no longer
     * parse the 'get' function. Instead, it will call '{@link Ext.app.ViewModel#bind}' with
     * the value of the 'bind' property and pass the produced value to 'get' whenever it
     * changes.
     *
     * ## Settable Formulas
     *
     * When a formula is "reversible" it can be given a 'set' method to allow it to participate
     * in two-way binding. For example:
     *
     *      formulas: {
     *             fullName: {
     *                 get: function (get) {
     *                     var ret = get('firstName') || '';
     *
     *                     if (get('lastName')) {
     *                         ret += ' ' +  get('lastName');
     *                     }
     *
     *                     return ret;
     *                 },
     *
     *                 set: function (value) {
     *                     var space = value.indexOf(' '),
     *                         split = (space < 0) ? value.length : space;
     *
     *                     this.set({
     *                         firstName: value.substring(0, split),
     *                         lastName: value.substring(split + 1)
     *                     });
     *                 }
     *             }
     *         }
     *
     * When the 'set' method is called the 'this' reference is the 'Ext.app.ViewModel' so it
     * just calls its '{@link Ext.app.ViewModel#method-set set method}'.
     *
     * ## Single Run Formulas
     *
     * If a formula only needs to produce an initial value, it can be marked as 'single'.
     *
     *      formulas: {
     *          xy: {
     *              single: true,
     *
     *              get: function (get) {
     *                  return get('x') * get('y');
     *              }
     *          }
     *      }
     *
     * This formulas 'get' method will be called with 'x' and 'y' once and then its binding
     * to these properties will be destroyed. This means the 'get' method (and hence the value
     * of 'xy') will only be executed/calculated once.
     */
    export class Formula extends Ext.util.Schedulable implements Ext.app.bind.FormulaConfig {
        /**
         * An explicit bind request to produce data to provide the 'get' function. If this is
         * specified, the result of this bind is the first argument to 'get'. If not given,
         * then 'get' receives a getter function that can retrieve bind expressions. For details on what can
         * be specified for this property see '{@link Ext.app.ViewModel#bind}'.
         * @since 5.0.0
         *
         * Optional
         */
        bind: any;

        /**
         * The function to call to calculate the formula's value. The 'get' method executes
         * with a 'this' pointer of the 'ViewModel' and receives a getter function or the result of a configured 'bind'.
         * @since 5.0.0
         */
        get: Function;

        /**
         * If provided this method allows a formula to be set. This method is typically called
         * when '{@link Ext.app.bind.Binding#setValue}' is called. The 'set' method executes
         * with a 'this' pointer of the 'ViewModel'. Whatever values need to be updated can
         * be set by calling '{@link Ext.app.ViewModel#set}'.
         * @since 5.0.0
         *
         * Optional
         */
        set: Function;

        /**
         * This option instructs the binding to call its 'destroy' method immediately after
         * delivering the initial value.
         * @since 5.0.0
         *
         * Optional, Defaults to: false
         */
        single: boolean;

        constructor(stub: any, formula: any);

        destroy();
    }

    /**
     * This class manages stubs associated with 'link' requests. These bind to some other
     * descriptor and forward changes from there.
     */
    export class LinkStub extends Ext.app.bind.Stub {
        constructor(owner: any, name: any, parent: any);

        destroy();
    }

    /**
     * This class is created to manage a multi-bind against a 'ViewModel'.
     */
    export class Multi extends Ext.app.bind.BaseBinding {
        constructor();

        destroy();
    }

    /**
     * This class is the root stub for managing a 'ViewModel'.
     */
    export class RootStub extends Ext.app.bind.AbstractStub {
        constructor(owner: any, name: any);

        schedule();

        unschedule();
    }

    /**
     * This class and its derived classes are used to manage access to the properties of an
     * object stored in a 'Session'.
     */
    export class Stub extends Ext.app.bind.AbstractStub {
        constructor(owner: any, name: any, parent: any);

        destroy();
    }

    /**
     * This class holds the parsed text for a bind template. The syntax is that of a normal
     * 'Ext.Template' except that substitution tokens can contain dots to reference property
     * names.
     *
     * The template is parsed and stored in a representation like this:
     *
     *      me.text = 'Hey {foo.bar}! Test {bar} and {foo.bar} with {abc} over {bar:number}'
     *
     *      me.tokens = [ 'foo.bar', 'bar', 'abc' ]
     *
     *      me.buffer = [           me.slots = [
     *          'Hey ',                 undefined,
     *          undefined,              { token: 'foo.bar', pos: 0 },
     *          '! Test ',              undefined,
     *          undefined,              { token: 'bar', pos: 1 },
     *          ' and ',                undefined,
     *          undefined,              { token: 'foo.bar', pos: 0 },
     *          ' with ',               undefined,
     *          undefined,              { token: 'abc', pos: 2 },
     *          ' over ',               undefined,
     *          undefined               { token: 'bar', fmt: 'number', pos: 1 }
     *      ]                       ]
     *
     * @since 5.0.0
     */
    export class Template extends Ext.Base {
        /**
         * Applies this template to the given 'values'. The 'values' must correspond to the
         * 'tokens' returned by 'getTokens'.
         *
         * @param {Array} values The values of the 'tokens'.
         * @param {Object} scope The object instance to use for "this." formatter calls in the
         * template.
         * @return {String}
         * @since 5.0.0
         */
        apply(values: any[], scope: any): string;

        /**
         * @param {String} text The text of the template.
         */
        constructor(text: string);

        /**
         * Returns the distinct set of binding tokens for this template.
         * @return {String[]} The 'tokens' for this template.
         */
        getTokens(): string;
    }

    /**
     * This class is created to manage a template against a 'ViewModel'. A binding of this
     * type uses '{@link Ext.app.bind.Template}' to process the template text so see that
     * class for details on template syntax.
     *
     * The bindings to provide the data needed by the template are managed here.
     */
    export class TemplateBinding extends Ext.app.bind.BaseBinding {
        constructor(template: any, owner: any, callback: any, scope: any, options: any);

        destroy();
    }
}

declare module Ext.app.domain {
    /**
     * This class implements the component event domain. All classes extending from
     * {@link Ext.Component} are included in this domain. The matching criteria uses
     * {@link Ext.ComponentQuery}.
     */
    export class Component {
    }

    /**
     * This class implements the controller event domain. All classes extending from
     * {@link Ext.app.Controller} are included in this domain. The selectors are simply id,
     * alias, or the wildcard "*" to match any controller.
     */
    export class Controller {
    }

    /**
     * This class implements the Ext Direct event domain. All classes extending from
     * {@link Ext.direct.Provider} are included in this domain. The selectors are simply provider
     * id's or the wildcard "*" to match any provider.
     */
    export class Direct {
    }

    /**
     * This class implements the global event domain. This domain represents event fired from
     * {@link Ext.GlobalEvents} Observable instance. No selectors are supported for this domain.
     */
    export class Global {
    }

    /**
     * This class implements the data store event domain. All classes extending from
     * {@link Ext.data.AbstractStore} are included in this domain. The selectors are simply
     * store id, alias or the wildcard "*" to match any store.
     */
    export class Store {
    }

    export class View extends Ext.app.EventDomain {
        protected isInstance: boolean;

        constructor(controller: any);

        destroy();
    }
}

declare module Ext.app.route {
    /**
     * A Queue is a queue of {@link Ext.app.route.Route} instances managed by the
     * {@link Ext.app.route.Router} singleton if queueActions is set to 'true'.
     *
     * A developer shouldn't need to use this class as {@link Ext.app.route.Router} should
     * manage this class. When a {@link Ext.app.route.Route} is executed,it will automatically
     * keep running the queue until the queue is empty.
     */
    export class Queue extends Ext.Base {
        /**
         * The token from the {@link Ext.app.route.Router} that is being enacted on.
         */
        token: any;

        /**
         * Clear all queued actions.
         */
        clearQueue();

        constructor(config: any);

        /**
         * Handle the execution of a queued action and optionally clear all queued actions.
         *
         * @param {Boolean} clearQueue If 'true' was returned, will clear all queued actions.
         */
        onActionExecute(clearQueue: boolean);

        /**
         * Add a {@link Ext.app.route.Route} to the queue.
         *
         * @param {Ext.app.route.Route} route The route to add to the queue.
         * @param {Object} args The arguments recognized by the {Ext.app.route.Route}.
         */
        queueAction(route: Ext.app.route.Route, args: any);

        /**
         * Run the queue one by one.
         */
        runQueue();
    }

    interface RouteConfig {
        /**
         * The name of the action that will be called on the
         * {@link #controller} if this route is matched.
         */
        action?: string;

        /**
         * 'true' to allow this route to be triggered on
         * a controller that is not active.
         */
        allowInactive?: boolean;

        /**
         * An optional function used to intercept {@link #action}
         * to do perform additional tasks and possibly stop the execution. An example is if the route is
         * for editing a user and you need to verify the current user has permission. You could
         * send an {@link Ext.Ajax} request to a server or some arbitrary code.
         *
         * This function MUST be executed by passing in a Boolean
         * value to allow execution of the configured action on {@link Ext.app.route.Route}.
         *
         * Defaults to 'null'
         */
        before?: Function;

        /**
         * 'true' to allow the tokens to be matched with
         * case-insensitive. Defaults to 'false' which will force case matching.
         */
        caseInsensitive?: boolean;

        /**
         * Optional set of conditions for each token in the url
         * string. Each key should be one of the tokens, each value should be a regex that the
         * token should accept. For example, if you have a Route with a url like
         * '"files/:fileName"' and you want it to match urls like "files/someImage.jpg" then
         * you can set these conditions to allow the :fileName token to accept strings
         * containing a period ("."):
         *
         *     conditions: {
         *         ':fileName': "[0-9a-zA-Z\.]+"
         *     }
         */
        conditions?: any;

        /**
         * The name of the Controller whose {@link #action} will be
         * called if this route is matched.
         */
        controller?: string;

        /**
         * (required) The url regex to match against.
         */
        url?: string;
    }

    /**
     * Represents a mapping between a url and a controller/action pair. May also contain
     * additional params.
     *
     * This is a private internal class that should not need to be used by end-developer code.
     * Its API and existence are subject to change so use at your own risk.
     */
    export class Route extends Ext.Base implements Ext.app.route.RouteConfig {
        /**
         * The name of the action that will be called on the
         * {@link #controller} if this route is matched.
         */
        action: string;

        /**
         * 'true' to allow this route to be triggered on
         * a controller that is not active.
         */
        allowInactive: boolean;

        /**
         * An optional function used to intercept {@link #action}
         * to do perform additional tasks and possibly stop the execution. An example is if the route is
         * for editing a user and you need to verify the current user has permission. You could
         * send an {@link Ext.Ajax} request to a server or some arbitrary code.
         *
         * This function MUST be executed by passing in a Boolean
         * value to allow execution of the configured action on {@link Ext.app.route.Route}.
         *
         * Defaults to 'null'
         */
        before: Function;

        /**
         * 'true' to allow the tokens to be matched with
         * case-insensitive. Defaults to 'false' which will force case matching.
         */
        caseInsensitive: boolean;

        /**
         * Optional set of conditions for each token in the url
         * string. Each key should be one of the tokens, each value should be a regex that the
         * token should accept. For example, if you have a Route with a url like
         * '"files/:fileName"' and you want it to match urls like "files/someImage.jpg" then
         * you can set these conditions to allow the :fileName token to accept strings
         * containing a period ("."):
         *
         *     conditions: {
         *         ':fileName': "[0-9a-zA-Z\.]+"
         *     }
         */
        conditions: any;

        /**
         * The name of the Controller whose {@link #action} will be
         * called if this route is matched.
         */
        controller: string;

        /**
         * (required) The url regex to match against.
         */
        url: string;

        constructor(config: Ext.app.route.RouteConfig);

        /**
         * Attempts to recognize a given url string and return controller/action pair for it.
         *
         * @param {String} url The url to recognize.
         * @return {Object/Boolean} The matched data, or 'false' if no match.
         */
        recognize(url: string): any|boolean;
    }

    /**
     * The Router is an ordered set of {@link Ext.app.route.Route} definitions that decode a
     * url into a controller function to execute. Each 'route' defines a type of url to match,
     * along with the controller function to call if it is matched. The Router uses the
     * {@link Ext.util.History} singleton to find out when the browser's url has changed.
     *
     * Routes are almost always defined inside a {@link Ext.app.Controller Controller}, as
     * opposed to on the Router itself. End-developers should not usually need to interact
     * directly with the Router as the Controllers manage everything automatically. See the
     * {@link Ext.app.Controller Controller documentation} for more information on specifying
     * routes.
     */
    export class Router {
        /**
         * The token to split the routes to support multiple routes.
         *
         * Optional, Defaults to: |
         */
        static multipleToken: string;

        /**
         * True to queue routes to be executed one after the
         * other, false to execute routes immediately.
         */
        static queueRoutes: boolean;

        /**
         * The connected {@link Ext.app.route.Route}
         * instances.
         */
        static routes: Ext.app.route.Route;

        /**
         * Clear all the recognized routes.
         */
        static clear();

        /**
         * Create the {@link Ext.app.route.Route} instance and connect to the
         * {@link Ext.app.route.Router} singleton.
         *
         * @param {String} url The url to recognize.
         * @param {String} action The action on the controller to execute when the url is
         * matched.
         * @param {Ext.app.Controller} controller The controller associated with the
         * {@link Ext.app.route.Route}
         */
        static connect(url: string, action: string, controller: Ext.app.Controller);

        /**
         * Disconnects all routes for a controller.
         * @param {Ext.app.Controller} controller The controller to disconnect routes from.
         */
        static disconnectAll(controller: Ext.app.Controller);

        /**
         * Convenience method which just calls the supplied function with the
         * {@link Ext.app.route.Router} singleton. Example usage:
         *
         *     Ext.app.route.Router.draw(function(map) {
         *         map.connect('activate/:token', {controller: 'users', action: 'activate'});
         *         map.connect('home',            {controller: 'index', action: 'home'});
         *     });
         *
         * @param {Function} fn The function to call
         */
        static draw(fn: Function);

        /**
         * Recognizes a url string connected to the Router, return the controller/action pair
         * plus any additional config associated with it.
         *
         * @param {String} url The url to recognize.
         * @return {Object/Boolean} If the url was recognized, the controller and action to
         * call, else 'false'.
         */
        static recognize(url: string): any|boolean;
    }
}

declare module Ext.behavior {
    export class Behavior extends Ext.Base {
        constructor(component: any);
    }

    export class Draggable extends Ext.behavior.Behavior {
        constructor(component: any);
    }

    export class Translatable extends Ext.behavior.Behavior {
        constructor(component: any);
    }
}

declare module Ext.carousel {
    interface CarouselConfig extends Ext.ContainerConfig {
        baseCls?: any;

        /**
         * The direction of the Carousel, either 'horizontal' or 'vertical'.
         */
        direction?: string;

        /**
         * Provides an indicator while toggling between child items to let the user
         * know where they are in the card stack.
         */
        indicator?: boolean;

        /**
         * Style options for Carousel. Default is 'dark'. 'light' is also available.
         */
        ui?: string;
    }

    /**
     * Carousels, like tabs, are a great way to allow the user to swipe through multiple full-screen pages.
     * A Carousel shows only one of its pages at a time but allows you to swipe through with your finger.
     *
     * Carousels can be oriented either horizontally or vertically and are easy to configure - they just work like any other
     * Container. Here's how to set up a simple horizontal Carousel:
     *
     *     @example
     *     Ext.create('Ext.Carousel', {
     *         fullscreen: true,
     *
     *         defaults: {
     *             styleHtmlContent: true
     *         },
     *
     *         items: [
     *             {
     *                 html : 'Item 1',
     *                 style: 'background-color: #5E99CC'
     *             },
     *             {
     *                 html : 'Item 2',
     *                 style: 'background-color: #759E60'
     *             },
     *             {
     *                 html : 'Item 3'
     *             }
     *         ]
     *     });
     *
     * We can also make Carousels orient themselves vertically:
     *
     *     @example preview
     *     Ext.create('Ext.Carousel', {
     *         fullscreen: true,
     *         direction: 'vertical',
     *
     *         defaults: {
     *             styleHtmlContent: true
     *         },
     *
     *         items: [
     *             {
     *                 html : 'Item 1',
     *                 style: 'background-color: #759E60'
     *             },
     *             {
     *                 html : 'Item 2',
     *                 style: 'background-color: #5E99CC'
     *             }
     *         ]
     *     });
     *
     * ### Common Configurations
     * * {@link #ui} defines the style of the carousel
     * * {@link #direction} defines the direction of the carousel
     * * {@link #indicator} defines if the indicator show be shown
     *
     * ### Useful Methods
     * * {@link #next} moves to the next card
     * * {@link #previous} moves to the previous card
     * * {@link #setActiveItem} moves to the passed card
     */
    export class Carousel extends Ext.Container implements Ext.carousel.CarouselConfig {
        /**
         * The base CSS class to apply to this component's element. This will also be prepended to
         * other elements within this component. To add specific styling for sub-classes, use the {@link #cls} config.
         */
        baseCls: string;

        /**
         * The direction of the Carousel, either 'horizontal' or 'vertical'.
         */
        direction: string;

        /**
         * Provides an indicator while toggling between child items to let the user
         * know where they are in the card stack.
         */
        indicator: boolean;

        /**
         * Style options for Carousel. Default is 'dark'. 'light' is also available.
         */
        ui: string;

        constructor(config: Ext.ActionSheetConfig);

        destroy();

        /**
         * Returns the index of the currently active card.
         * @return {Number} The index of the currently active card.
         */
        getActiveIndex(): number;

        getAnimation();

        getBaseCls();

        getBufferSize();

        getDirection();

        getDirectionLock();

        getIndicator();

        getItemConfig();

        getItemLength();

        getUi();

        /**
         * Switches to the next card.
         * @return {Ext.carousel.Carousel} this
         */
        next(): Ext.carousel.Carousel;

        /**
         * Switches to the previous card.
         * @return {Ext.carousel.Carousel} this
         */
        previous(): Ext.carousel.Carousel;

        setAnimation();

        setBaseCls();

        setBufferSize();

        setDirection();

        setDirectionLock();

        setIndicator();

        setItemConfig();

        setItemLength();

        setUi();
    }

    interface IndicatorConfig extends Ext.ComponentConfig {
        baseCls?: any;
    }

    /**
     * A private utility class used by Ext.Carousel to create indicators.
     */
    export class Indicator extends Ext.Component implements Ext.carousel.IndicatorConfig {
        /**
         * The base CSS class to apply to this component's element. This will also be prepended to
         * other elements within this component. To add specific styling for sub-classes, use the {@link #cls} config.
         */
        baseCls: string;

        /**
         * Creates new Component.
         * @param {Object} config The standard configuration object.
         */
        constructor(config: Ext.ButtonConfig);

        destroy();

        getBaseCls();

        getDirection();

        setBaseCls();

        setDirection();

        /**
         * Fires when this indicator is tapped on the right half
         */
        next(that: Ext.carousel.Indicator);

        /**
         * Fires when this indicator is tapped on the left half
         */
        previous(that: Ext.carousel.Indicator);
    }

    interface InfiniteConfig extends Ext.carousel.CarouselConfig {
        indicator?: any;
    }

    /**
     * The true infinite implementation of Carousel, private for now until it's stable to be public
     */
    export class Infinite extends Ext.carousel.Carousel implements Ext.carousel.InfiniteConfig {
        indicator: boolean;

        constructor(config: Ext.ActionSheetConfig);

        getIndicator();

        getInnerItemConfig();

        getMaxItemIndex();

        setIndicator();

        setInnerItemConfig();

        setMaxItemIndex();
    }

    interface ItemConfig extends Ext.DecoratorConfig {
        baseCls?: any;

        component?: any;
    }

    export class Item extends Ext.Decorator implements Ext.carousel.ItemConfig {
        baseCls: string;

        component: any;

        /**
         * Creates new Component.
         * @param {Object} config The standard configuration object.
         */
        constructor(config: Ext.ButtonConfig);

        getBaseCls();

        getComponent();

        getTranslatable();

        setBaseCls();

        setComponent();

        setTranslatable();
    }
}

declare module Ext.chart {
    interface AbstractChartConfig extends Ext.draw.ContainerConfig {
        /**
         * (optional) 'true' for the default animation (easing: 'ease' and duration: 500)
         * or a standard animation config object to be used for default chart animations.
         */
        animation?: boolean|any;

        /**
         * Array of {@link Ext.chart.axis.Axis Axis} instances or config objects. For example:
         *
         *     axes: [{
         *         type: 'numeric',
         *         position: 'left',
         *         title: 'Number of Hits',
         *         minimum: 0
         *     }, {
         *         type: 'category',
         *         position: 'bottom',
         *         title: 'Month of the Year'
         *     }]
         */
        axes?: Ext.chart.axis.Axis|any[]|any;

        /**
         * Set the chart background. This can be a gradient object, image, or color.
         *
         * For example, if 'background' were to be a color we could set the object as
         *
         *     background: '#ccc'
         *
         * You can specify an image by using:
         *
         *     background: {
         *         type: 'image',
         *         src: 'http://path.to.image/'
         *     }
         *
         * Also you can specify a gradient by using the gradient object syntax:
         *
         *     background: {
         *         type: 'linear',
         *         degrees: 0,
         *         stops: [
         *             {
         *                 offset: 0,
         *                 color: 'white'
         *             },
         *             {
         *                 offset: 1,
         *                 color: 'blue'
         *             }
         *         ]
         *     }
         */
        background?: any;

        /**
         * Array of colors/gradients to override the color of items and legends.
         */
        colors?: any[];

        /**
         * The current highlight item in the chart.
         * The object must be the one that you get from item events.
         *
         * Note that series can also own highlight items.
         * This notion is separate from this one and should not be used at the same time.
         */
        highlightItem?: any;

        /**
         * The amount of inset padding in pixels for the chart.
         * Inset padding is the padding from the boundary of the chart to any of its contents.
         */
        insetPadding?: any|number|string;

        /**
         * Interactions are optional modules that can be plugged in to a chart to allow the user to interact
         * with the chart and its data in special ways. The 'interactions' config takes an Array of Object
         * configurations, each one corresponding to a particular interaction class identified by a 'type' property:
         *
         *     new Ext.chart.AbstractChart({
         *         renderTo: Ext.getBody(),
         *         width: 800,
         *         height: 600,
         *         store: store1,
         *         axes: [
         *             // ...some axes options...
         *         ],
         *         series: [
         *             // ...some series options...
         *         ],
         *         interactions: [{
         *             type: 'interactiontype'
         *             // ...additional configs for the interaction...
         *         }]
         *     });
         *
         * When adding an interaction which uses only its default configuration (no extra properties other than 'type'),
         * you can alternately specify only the type as a String rather than the full Object:
         *
         *     interactions: ['reset', 'rotate']
         *
         * The current supported interaction types include:
         *
         * - {@link Ext.chart.interactions.PanZoom panzoom} - allows pan and zoom of axes
         * - {@link Ext.chart.interactions.ItemHighlight itemhighlight} - allows highlighting of series data points
         * - {@link Ext.chart.interactions.ItemInfo iteminfo} - allows displaying details of a data point in a popup panel
         * - {@link Ext.chart.interactions.Rotate rotate} - allows rotation of pie and radar series
         *
         * See the documentation for each of those interaction classes to see how they can be configured.
         *
         * Additional custom interactions can be registered using ''interactions.'' alias prefix.
         */
        interactions?: any[];

        legend?: Ext.chart.Legend|any;

        /**
         * Array of {@link Ext.chart.series.Series Series} instances or config objects. For example:
         *
         *     series: [{
         *         type: 'column',
         *         axis: 'left',
         *         listeners: {
         *             'afterrender': function() {
         *                 console.log('afterrender');
         *             }
         *         },
         *         xField: 'category',
         *         yField: 'data1'
         *     }]
         */
        series?: Ext.chart.series.Series|any[];

        /**
         * The data source to which the chart is bound. Acceptable values for this property are:
         *
         *   - **any {@link Ext.data.Store Store} class / subclass**
         *   - **an {@link Ext.data.Store#storeId ID of a store}**
         *   - **a {@link Ext.data.Store Store} config object**.  When passing a config you can
         *     specify the store type by alias.  Passing a config object with a store type will
         *     dynamically create a new store of that type when the chart is instantiated.
         *
         * For example:
         *
         *     Ext.define('MyApp.store.Customer', {
         *         extend: 'Ext.data.Store',
         *         alias: 'store.customerstore',
         *
         *         fields: ['name', 'value']
         *     });
         *
         *
         *     Ext.create({
         *         xtype: 'cartesian',
         *         renderTo: document.body,
         *         height: 400,
         *         width: 400,
         *         store: {
         *             type: 'customerstore',
         *             data: [{
         *                 name: 'metric one',
         *                 value: 10
         *             }]
         *         },
         *         axes: [{
         *             type: 'numeric',
         *             position: 'left',
         *             title: {
         *                 text: 'Sample Values',
         *                 fontSize: 15
         *             },
         *             fields: 'value'
         *         }, {
         *             type: 'category',
         *             position: 'bottom',
         *             title: {
         *                 text: 'Sample Values',
         *                 fontSize: 15
         *             },
         *             fields: 'name'
         *         }],
         *         series: {
         *             type: 'bar',
         *             xField: 'name',
         *             yField: 'value'
         *         }
         *     });
         */
        store?: Ext.data.Store|string|any;

        /**
         * The style for the chart component.
         */
        style?: any;

        /**
         * The name of the theme to be used. A theme defines the colors and styles
         * used by the series, axes, markers and other chart components.
         * Please see the documentation for the {@link Ext.chart.theme.Base} class for more information.
         * Possible theme values are:
         *   - 'green', 'sky', 'red', 'purple', 'blue', 'yellow'
         *   - 'category1' to 'category6'
         *   - and the above theme names with the '-gradients' suffix, e.g. 'green-gradients'
         *
         * Optional, Defaults to: "default"
         */
        theme?: string;
    }

    /**
     * The Ext.chart package provides the capability to visualize data.
     * Each chart binds directly to a {@link Ext.data.Store store} enabling automatic updates of the chart.
     * A chart configuration object has some overall styling options as well as an array of axes
     * and series. A chart instance example could look like this:
     *
     *     Ext.create('Ext.chart.CartesianChart', {
     *         width: 800,
     *         height: 600,
     *         animation: {
     *             easing: 'backOut',
     *             duration: 500
     *         },
     *         store: store1,
     *         legend: {
     *             position: 'right'
     *         },
     *         axes: [
     *             // ...some axes options...
     *         ],
     *         series: [
     *             // ...some series options...
     *         ]
     *     });
     *
     * In this example we set the 'width' and 'height' of a chart; We decide whether our series are
     * animated or not and we select a store to be bound to the chart; We also set the legend to the right part of the
     * chart.
     *
     * You can register certain interactions such as {@link Ext.chart.interactions.PanZoom} on the chart by specify an
     * array of names or more specific config objects. All the events will be wired automatically.
     *
     * You can also listen to series 'itemXXX' events on both chart and series level.
     *
     * For example:
     *
     *     Ext.create('Ext.chart.CartesianChart', {
     *         plugins: {
     *             ptype: 'chartitemevents',
     *             moveEvents: true
     *         },
     *         store: {
     *             fields: ['pet', 'households', 'total'],
     *             data: [
     *                 {pet: 'Cats', households: 38, total: 93},
     *                 {pet: 'Dogs', households: 45, total: 79},
     *                 {pet: 'Fish', households: 13, total: 171}
     *             ]
     *         },
     *         axes: [{
     *             type: 'numeric',
     *             position: 'left'
     *         }, {
     *             type: 'category',
     *             position: 'bottom'
     *         }],
     *         series: [{
     *             type: 'bar',
     *             xField: 'pet',
     *             yField: 'households',
     *             listeners: {
     *                 itemmousemove: function (series, item, event) {
     *                     console.log('itemmousemove', item.category, item.field);
     *                 }
     *             }
     *         }, {
     *             type: 'line',
     *             xField: 'pet',
     *             yField: 'total',
     *             marker: true
     *         }],
     *         listeners: { // Listen to itemclick events on all series.
     *             itemclick: function (chart, item, event) {
     *                 console.log('itemclick', item.category, item.field);
     *             }
     *         }
     *     });
     *
     * For more information about the axes and series configurations please check the documentation of
     * each series (Line, Bar, Pie, etc).
     */
    export class AbstractChart extends Ext.draw.Container implements Ext.chart.AbstractChartConfig {
        /**
         * (optional) 'true' for the default animation (easing: 'ease' and duration: 500)
         * or a standard animation config object to be used for default chart animations.
         */
        animation: boolean|any;

        /**
         * Array of {@link Ext.chart.axis.Axis Axis} instances or config objects. For example:
         *
         *     axes: [{
         *         type: 'numeric',
         *         position: 'left',
         *         title: 'Number of Hits',
         *         minimum: 0
         *     }, {
         *         type: 'category',
         *         position: 'bottom',
         *         title: 'Month of the Year'
         *     }]
         */
        axes: Ext.chart.axis.Axis|any[]|any;

        /**
         * Set the chart background. This can be a gradient object, image, or color.
         *
         * For example, if 'background' were to be a color we could set the object as
         *
         *     background: '#ccc'
         *
         * You can specify an image by using:
         *
         *     background: {
         *         type: 'image',
         *         src: 'http://path.to.image/'
         *     }
         *
         * Also you can specify a gradient by using the gradient object syntax:
         *
         *     background: {
         *         type: 'linear',
         *         degrees: 0,
         *         stops: [
         *             {
         *                 offset: 0,
         *                 color: 'white'
         *             },
         *             {
         *                 offset: 1,
         *                 color: 'blue'
         *             }
         *         ]
         *     }
         */
        background: any;

        /**
         * Array of colors/gradients to override the color of items and legends.
         */
        colors: any[];

        /**
         * The current highlight item in the chart.
         * The object must be the one that you get from item events.
         *
         * Note that series can also own highlight items.
         * This notion is separate from this one and should not be used at the same time.
         */
        highlightItem: any;

        /**
         * The amount of inset padding in pixels for the chart.
         * Inset padding is the padding from the boundary of the chart to any of its contents.
         */
        insetPadding: any|number|string;

        /**
         * Interactions are optional modules that can be plugged in to a chart to allow the user to interact
         * with the chart and its data in special ways. The 'interactions' config takes an Array of Object
         * configurations, each one corresponding to a particular interaction class identified by a 'type' property:
         *
         *     new Ext.chart.AbstractChart({
         *         renderTo: Ext.getBody(),
         *         width: 800,
         *         height: 600,
         *         store: store1,
         *         axes: [
         *             // ...some axes options...
         *         ],
         *         series: [
         *             // ...some series options...
         *         ],
         *         interactions: [{
         *             type: 'interactiontype'
         *             // ...additional configs for the interaction...
         *         }]
         *     });
         *
         * When adding an interaction which uses only its default configuration (no extra properties other than 'type'),
         * you can alternately specify only the type as a String rather than the full Object:
         *
         *     interactions: ['reset', 'rotate']
         *
         * The current supported interaction types include:
         *
         * - {@link Ext.chart.interactions.PanZoom panzoom} - allows pan and zoom of axes
         * - {@link Ext.chart.interactions.ItemHighlight itemhighlight} - allows highlighting of series data points
         * - {@link Ext.chart.interactions.ItemInfo iteminfo} - allows displaying details of a data point in a popup panel
         * - {@link Ext.chart.interactions.Rotate rotate} - allows rotation of pie and radar series
         *
         * See the documentation for each of those interaction classes to see how they can be configured.
         *
         * Additional custom interactions can be registered using ''interactions.'' alias prefix.
         */
        interactions: any[];

        legend: Ext.chart.Legend|any;

        /**
         * Array of {@link Ext.chart.series.Series Series} instances or config objects. For example:
         *
         *     series: [{
         *         type: 'column',
         *         axis: 'left',
         *         listeners: {
         *             'afterrender': function() {
         *                 console.log('afterrender');
         *             }
         *         },
         *         xField: 'category',
         *         yField: 'data1'
         *     }]
         */
        series: Ext.chart.series.Series|any[];

        /**
         * The data source to which the chart is bound. Acceptable values for this property are:
         *
         *   - **any {@link Ext.data.Store Store} class / subclass**
         *   - **an {@link Ext.data.Store#storeId ID of a store}**
         *   - **a {@link Ext.data.Store Store} config object**.  When passing a config you can
         *     specify the store type by alias.  Passing a config object with a store type will
         *     dynamically create a new store of that type when the chart is instantiated.
         *
         * For example:
         *
         *     Ext.define('MyApp.store.Customer', {
         *         extend: 'Ext.data.Store',
         *         alias: 'store.customerstore',
         *
         *         fields: ['name', 'value']
         *     });
         *
         *
         *     Ext.create({
         *         xtype: 'cartesian',
         *         renderTo: document.body,
         *         height: 400,
         *         width: 400,
         *         store: {
         *             type: 'customerstore',
         *             data: [{
         *                 name: 'metric one',
         *                 value: 10
         *             }]
         *         },
         *         axes: [{
         *             type: 'numeric',
         *             position: 'left',
         *             title: {
         *                 text: 'Sample Values',
         *                 fontSize: 15
         *             },
         *             fields: 'value'
         *         }, {
         *             type: 'category',
         *             position: 'bottom',
         *             title: {
         *                 text: 'Sample Values',
         *                 fontSize: 15
         *             },
         *             fields: 'name'
         *         }],
         *         series: {
         *             type: 'bar',
         *             xField: 'name',
         *             yField: 'value'
         *         }
         *     });
         */
        store: Ext.data.Store|string|any;

        /**
         * The style for the chart component.
         */
        style: any;

        /**
         * The name of the theme to be used. A theme defines the colors and styles
         * used by the series, axes, markers and other chart components.
         * Please see the documentation for the {@link Ext.chart.theme.Base} class for more information.
         * Possible theme values are:
         *   - 'green', 'sky', 'red', 'purple', 'blue', 'yellow'
         *   - 'category1' to 'category6'
         *   - and the above theme names with the '-gradients' suffix, e.g. 'green-gradients'
         *
         * Optional, Defaults to: "default"
         */
        theme: string;

        /**
         * Adds a {@link Ext.chart.series.Series Series} to this chart.
         *
         * The Series (or array) passed will be added to the existing series. If an 'id' is specified
         * in a new Series, any existing Series of that 'id' will be updated.
         *
         * The chart will be redrawn in response to the change.
         *
         * @param {Object/Object[]/Ext.chart.series.Series/Ext.chart.series.Series[]} newSeries A config object
         * describing the Series to add, or an instantiated Series object. Or an array of these.
         */
        addSeries(newSeries: any|Ext.chart.series.Series);

        /**
         * Changes the data store bound to this chart and refreshes it.
         * @param {Ext.data.Store} store The store to bind to this chart.
         */
        bindStore(store: Ext.data.Store);

        /**
         * Cancel a scheduled layout.
         */
        cancelChartLayout();

        constructor(config: Ext.chart.AbstractChartConfig);

        getAxes();

        /**
         * an axis instance based on the type of data passed.
         * @param {String/Number/Ext.chart.axis.Axis} axis You may request an axis by passing
         * an id, the number of the array key returned by {@link #getAxes}, or an axis instance.
         * @return {Ext.chart.axis.Axis} The axis requested.
         */
        getAxis(axis: string|number|Ext.chart.axis.Axis): Ext.chart.axis.Axis;

        getBackground();

        getHighlightItem();

        getInsetPadding();

        /**
         * Get an interaction by type.
         * @param {String} type The type of the interaction.
         * @return {Ext.chart.interactions.Abstract} The interaction. 'null'
         * if not found.
         */
        getInteraction(type: string): Ext.chart.interactions.Abstract;

        getInteractions();

        /**
         * Given an x/y point relative to the chart, find and return the first series item that
         * matches that point.
         * @return {Object} An object with 'series' and 'item' properties, or 'false' if no item found.
         */
        getItemForPoint(x: number, y: number): any;

        /**
         * Given an x/y point relative to the chart, find and return all series items that match that point.
         * @return {Array} An array of objects with 'series' and 'item' properties.
         */
        getItemsForPoint(x: number, y: number): any[];

        getLegend();

        /**
         * Return the legend store that contains all the legend information.
         * This information is collected from all the series.
         * @return {Ext.data.Store}
         */
        getLegendStore(): Ext.data.Store;

        getSeries();

        getStore();

        getStyle();

        getTheme();

        /**
         * Redraw the chart. If animations are set this will animate the chart too.
         */
        redraw();

        /**
         * Remove a {@link Ext.chart.series.Series Series} from this chart.
         * The Series (or array) passed will be removed from the existing series.
         *
         * The chart will be redrawn in response to the change.
         *
         * @param {Ext.chart.series.Series/String} series The Series or the 'id' of the Series to remove. May be an array.
         */
        removeSeries(series: Ext.chart.series.Series|string);

        /**
         * Decrements chart's layout suspend count.
         * When the suspend count is decremented to zero,
         * a layout is scheduled.
         */
        resumeChartLayout();

        /**
         * Decrements axis thickness suspend count.
         * When axis thickness suspend count is decremented to zero,
         * chart layout is performed.
         */
        resumeThicknessChanged();

        /**
         * Schedule a layout at next frame.
         */
        scheduleLayout();

        setAnimation();

        setAxes();

        setBackground();

        setColors();

        setHighlightItem();

        setInsetPadding();

        setInteractions();

        setLegend();

        setSeries();

        setStore();

        setStyle();

        setTheme();

        /**
         * Suspends chart's layout.
         */
        suspendChartLayout();

        /**
         * Prevent axes from triggering chart layout when their thickness changes.
         * E.g. during an interaction that makes changes to the axes,
         * or when chart layout was triggered by something else,
         * for example a chart resize event.
         */
        suspendThicknessChanged();

        /**
         * Fires before a refresh to the chart data is called.  If the 'beforerefresh' handler returns
         * 'false' the {@link #refresh} action will be canceled.
         */
        beforerefresh(that: Ext.chart.AbstractChart);

        /**
         * Fires when a click event occurs on a series item.
         * *Note*: This event requires the {@link Ext.chart.plugin.ItemEvents chartitemevents}
         * plugin be added to the chart.
         */
        itemclick(chart: Ext.chart.AbstractChart, item: any, event: Event);

        /**
         * Fires when a double click event occurs on a series item.
         * *Note*: This event requires the {@link Ext.chart.plugin.ItemEvents chartitemevents}
         * plugin be added to the chart.
         */
        itemdblclick(chart: Ext.chart.AbstractChart, item: any, event: Event);

        /**
         * Fires when a mousedown event occurs on a series item.
         * *Note*: This event requires the {@link Ext.chart.plugin.ItemEvents chartitemevents}
         * plugin be added to the chart.
         */
        itemmousedown(chart: Ext.chart.AbstractChart, item: any, event: Event);

        /**
         * Fires when the mouse is moved on a series item.
         * *Note*: This event requires the {@link Ext.chart.plugin.ItemEvents chartitemevents}
         * plugin be added to the chart.
         */
        itemmousemove(chart: Ext.chart.AbstractChart, item: any, event: Event);

        /**
         * Fires when the mouse exits a series item.
         * *Note*: This event requires the {@link Ext.chart.plugin.ItemEvents chartitemevents}
         * plugin be added to the chart.
         */
        itemmouseout(chart: Ext.chart.AbstractChart, item: any, event: Event);

        /**
         * Fires when the mouse enters a series item.
         * *Note*: This event requires the {@link Ext.chart.plugin.ItemEvents chartitemevents}
         * plugin be added to the chart.
         */
        itemmouseover(chart: Ext.chart.AbstractChart, item: any, event: Event);

        /**
         * Fires when a mouseup event occurs on a series item.
         * *Note*: This event requires the {@link Ext.chart.plugin.ItemEvents chartitemevents}
         * plugin be added to the chart.
         */
        itemmouseup(chart: Ext.chart.AbstractChart, item: any, event: Event);

        /**
         * Fires when a tap event occurs on a series item.
         * *Note*: This event requires the {@link Ext.chart.plugin.ItemEvents chartitemevents}
         * plugin be added to the chart.
         */
        itemtap(chart: Ext.chart.AbstractChart, item: any, event: Event);

        /**
         * Fires after the chart data has been refreshed.
         */
        refresh(that: Ext.chart.AbstractChart);

        /**
         * Fires when the store of the chart changes.
         */
        storechange(chart: Ext.chart.AbstractChart, newStore: Ext.data.Store, oldStore: Ext.data.Store);
    }

    interface CartesianChartConfig extends Ext.chart.AbstractChartConfig {
        /**
         * Flip the direction of X and Y axis.
         * If flipXY is 'true', the X axes will be vertical and Y axes will be horizontal.
         * Note that {@link Ext.chart.axis.Axis#position positions} of chart axes have
         * to be updated accordingly: axes positioned to the 'top' and 'bottom' should
         * be positioned to the 'left' or 'right' and vice versa.
         */
        flipXY?: boolean;

        /**
         * The amount of inner padding in pixels.
         * Inner padding is the padding from the innermost axes to the series.
         */
        innerPadding?: any;
    }

    /**
     * @extends Ext.chart.AbstractChart
     * @xtype cartesian
     *
     * Represents a chart that uses cartesian coordinates.
     * A cartesian chart has two directions, X direction and Y direction.
     * The series and axes are coordinated along these directions.
     * By default the x direction is horizontal and y direction is vertical,
     * You can swap the direction by setting the {@link #flipXY} config to 'true'.
     *
     * Cartesian series often treats x direction an y direction differently.
     * In most cases, data on x direction are assumed to be monotonically increasing.
     * Based on this property, cartesian series can be trimmed and summarized properly
     * to gain a better performance.
     */
    export class CartesianChart extends Ext.chart.AbstractChart implements Ext.chart.CartesianChartConfig {
        /**
         * Flip the direction of X and Y axis.
         * If flipXY is 'true', the X axes will be vertical and Y axes will be horizontal.
         * Note that {@link Ext.chart.axis.Axis#position positions} of chart axes have
         * to be updated accordingly: axes positioned to the 'top' and 'bottom' should
         * be positioned to the 'left' or 'right' and vice versa.
         */
        flipXY: boolean;

        /**
         * The amount of inner padding in pixels.
         * Inner padding is the padding from the innermost axes to the series.
         */
        innerPadding: any;

        constructor(config: Ext.chart.AbstractChartConfig);

        getFlipXY();

        getInnerPadding();

        getInnerRect();

        /**
         * Layout the axes and series.
         */
        performLayout();

        redraw();

        renderFrame();

        setFlipXY();

        setInnerPadding();

        setInnerRect();
    }

    interface LegendConfig {
        /**
         * The rect of the legend related to its container.
         */
        rect?: any;

        /**
         * 'true' to allow series items to have their visibility
         * toggled by interaction with the legend items.
         */
        toggleable?: boolean;
    }

    export class Legend implements Ext.chart.LegendConfig {
        /**
         * The rect of the legend related to its container.
         */
        rect: any;

        /**
         * 'true' to allow series items to have their visibility
         * toggled by interaction with the legend items.
         */
        toggleable: boolean;

        getBaseCls();

        getDisableSelection();

        getPadding();

        getRect();

        getToggleable();

        setBaseCls();

        setDisableSelection();

        setPadding();

        setRect();

        setToggleable();
    }

    /**
     * Mixin that provides the functionality to place markers.
     */
    export class MarkerHolder extends Ext.Mixin {
        /**
         * Registers the given marker with the marker holder under the specified name.
         * @param {String} name The name of the marker (e.g., "items", "labels", etc.).
         */
        bindMarker(name: string, marker: Ext.chart.Markers);

        constructor();

        destroy();

        /**
         * Returns the markers bound to the given name.
         * @param {String} name The name of the marker (e.g., "items", "labels", etc.).
         * @return {Ext.chart.Markers[]}
         * @deprecated 6.0 Use {@link #getMarker} instead.
         */
        getBoundMarker(name: string): Ext.chart.Markers;

        /**
         * Returns the marker bound to the given name (or null). See {@link #bindMarker}.
         * @param {String} name The name of the marker (e.g., "items", "labels", etc.).
         * @return {Ext.chart.Markers}
         */
        getMarker(name: string): Ext.chart.Markers;

        /**
         * Unregisters the given marker or a marker with the given name.
         * Providing a name of the marker is more efficient as it avoids lookup.
         * @return {Ext.chart.Markers} Released marker or null.
         */
        releaseMarker(): Ext.chart.Markers;
    }

    /**
     * @extends Ext.draw.sprite.Instancing
     *
     * Marker sprite. A specialized version of instancing sprite that groups instances.
     * Putting a marker is grouped by its category id. Clearing removes that category.
     */
    export class Markers extends Ext.draw.sprite.Instancing {
        /**
         * Clears the markers in the category.
         */
        clear(category: string);

        constructor();

        destroy();

        /**
         * @param {Boolean} [isWithoutTransform]
         */
        getMarkerBBoxFor(category: string, index: any, isWithoutTransform?: boolean);

        /**
         * Puts a marker in the category with additional attributes.
         * @param {Boolean} [bypassNormalization]
         * @param {Boolean} [keepRevision]
         */
        putMarkerFor(category: string, attr: any, index: string|number, bypassNormalization?: boolean, keepRevision?: boolean);
    }

    interface PolarChartConfig extends Ext.chart.AbstractChartConfig {
        /**
         * Determines the center of the polar chart.
         * Updated when the chart performs layout.
         */
        center?: any[];

        /**
         * The amount of inner padding in pixels.
         * Inner padding is the padding from the outermost angular axis to the series.
         */
        innerPadding?: number;

        /**
         * Determines the radius of the polar chart.
         * Updated when the chart performs layout.
         */
        radius?: number;
    }

    /**
     * @extends Ext.chart.AbstractChart
     * @xtype polar
     *
     * Represent a chart that uses polar coordinates.
     * A polar chart has two axes: an angular axis (which is a circle) and
     * a radial axis (a straight line from the center to the edge of the circle).
     * The angular axis is usually a Category axis while the radial axis is
     * typically numerical.
     *
     * Pie charts and Radar charts are common examples of Polar charts.
     */
    export class PolarChart extends Ext.chart.AbstractChart implements Ext.chart.PolarChartConfig {
        /**
         * Determines the center of the polar chart.
         * Updated when the chart performs layout.
         */
        center: any[];

        /**
         * The amount of inner padding in pixels.
         * Inner padding is the padding from the outermost angular axis to the series.
         */
        innerPadding: number;

        /**
         * Determines the radius of the polar chart.
         * Updated when the chart performs layout.
         */
        radius: number;

        constructor(config: Ext.chart.AbstractChartConfig);

        getCenter();

        getInnerPadding();

        getRadius();

        redraw();

        renderFrame();

        setCenter();

        setInnerPadding();

        setRadius();
    }

    /**
     * @extends Ext.chart.AbstractChart
     *
     * Creates a chart that fills the entire area of the chart.
     * e.g. Gauge Charts
     */
    export class SpaceFillingChart extends Ext.chart.AbstractChart {
        constructor(config: Ext.chart.AbstractChartConfig);

        redraw();
    }
}

declare module Ext.chart.axis {
    interface Axis3DConfig extends Ext.chart.axis.AxisConfig {
        /**
         * Where to set the axis. Available options are 'left' and 'bottom'.
         */
        position?: string;
    }

    /**
     * @extends Ext.chart.axis.Axis
     * @xtype axis3d
     *
     * Defines a 3D axis for charts.
     *
     * A 3D axis has the same properties as the regular {@link Ext.chart.axis.Axis axis},
     * plus a notion of depth. The depth of the 3D axis is determined automatically
     * based on the depth of the bound series.
     *
     * This type of axis has the following limitations compared to the regular axis class:
     * - supported {@link Ext.chart.axis.Axis#position positions} are 'left' and 'bottom' only;
     * - floating axes are not supported.
     *
     * At the present moment only {@link Ext.chart.series.Bar3D} series can make use of the 3D axis.
     */
    export class Axis3D extends Ext.chart.axis.Axis implements Ext.chart.axis.Axis3DConfig {
        /**
         * Where to set the axis. Available options are 'left' and 'bottom'.
         */
        position: string;

        constructor(config: Ext.chart.axis.AxisConfig);
    }

    interface AxisConfig {
        /**
         * Whether to make the auto-calculated minimum and maximum of the axis
         * a multiple of the interval between the major ticks of the axis.
         * If {@link #majorTickSteps}, {@link #minimum} or {@link #maximum}
         * configs have been set, this config will be ignored.
         * Defaults to 'true'.
         */
        adjustByMajorUnit?: boolean;

        /**
         * The background config for the axis surface.
         */
        background?: any;

        /**
         * An array containing the names of the record fields which should be mapped along the axis.
         * This is optional if the binding between series and fields is clear.
         */
        fields?: any[];

        /**
         * If 'floating' is a number, then it's a percentage displacement of the axis from its initial {@link #position}
         * in the direction opposite to the axis' direction. For instance, '{position:"left", floating:75}' displays a vertical
         * axis at 3/4 of the chart, starting from the left. It is equivalent to '{position:"right", floating:25}'.
         * If 'floating' is an object, then 'floating.value' is the position of this axis along another axis,
         * defined by 'floating.alongAxis', where 'alongAxis' is an ID, an {@link Ext.chart.AbstractChart#axes} config index,
         * or the other axis itself. 'alongAxis' must have an opposite {@link Ext.chart.axis.Axis#getAlignment alignment}.
         * For example:
         *
         *
         *      axes: [
         *          {
         *              title: 'Average Temperature (F)',
         *              type: 'numeric',
         *              position: 'left',
         *              id: 'temperature-vertical-axis',
         *              minimum: -30,
         *              maximum: 130
         *          },
         *          {
         *              title: 'Month (2013)',
         *              type: 'category',
         *              position: 'bottom',
         *              floating: {
         *                  value: 32,
         *                  alongAxis: 'temperature-vertical-axis'
         *              }
         *          }
         *      ]
         */
        floating?: any;

        /**
         * The grid configuration object for the Axis style. Can contain 'stroke' or 'fill' attributes.
         * Also may contain an 'odd' or 'even' property in which you only style things on odd or even rows.
         * For example:
         *
         *
         *     grid {
         *         odd: {
         *             stroke: '#555'
         *         },
         *         even: {
         *             stroke: '#ccc'
         *         }
         *     }
         */
        grid?: any;

        /**
         * Indicate whether to hide the axis.
         * If the axis is hidden, one of the axis line, ticks, labels or the title will be shown and
         * no margin will be taken.
         * The coordination mechanism works fine no matter if the axis is hidden.
         */
        hidden?: boolean;

        /**
         * Given a minimum and maximum bound for the series to be rendered (that can be obtained
         * automatically or by manually setting 'minimum' and 'maximum') tick marks will be added
         * on each 'increment' from the minimum value to the maximum one.
         */
        increment?: number;

        /**
         * The label configuration object for the Axis. This object may include style attributes
         * like 'spacing', 'padding', 'font' that receives a string or number and
         * returns a new string with the modified values.
         *
         * For more supported values, see the configurations for {@link Ext.chart.sprite.Label}.
         */
        label?: any;

        /**
         * Draws the labels in the middle of the spans.
         *
         * Optional
         */
        labelInSpan?: boolean;

        /**
         * The axis layout config. See {@link Ext.chart.axis.layout.Layout}
         */
        layout?: any|Ext.chart.axis.layout.Layout;

        /**
         * The limit lines configuration for the axis.
         * For example:
         *
         *     limits: [{
         *         value: 50,
         *         line: {
         *             strokeStyle: 'red',
         *             lineDash: [6, 3],
         *             title: {
         *                 text: 'Monthly minimum',
         *                 fontSize: 14
         *             }
         *         }
         *     }]
         */
        limits?: any[]|any;

        /**
         * Axis (itself, its ID or index) that this axis is linked to.
         * When an axis is linked to a master axis, it will use the same data as the master axis.
         * It can be used to show additional info, or to ease reading the chart by duplicating the scales.
         */
        linkedTo?: Ext.chart.axis.Axis|string|number;

        /**
         * Forces the number of major ticks to the specified value.
         * Both {@link #minimum} and {@link #maximum} should be specified.
         *
         * Optional, Defaults to: 0
         */
        majorTickSteps?: number;

        /**
         * The margin of the axis. Used to control the spacing between axes in charts with multiple axes.
         * Unlike CSS where the margin is added on all 4 sides of an element, the 'margin' is the total space
         * that is added horizontally for a vertical axis, vertically for a horizontal axis,
         * and radially for an angular axis.
         */
        margin?: number;

        /**
         * The maximum zooming level for axis.
         */
        maxZoom?: number;

        /**
         * The maximum value drawn by the axis. If not set explicitly, the axis
         * maximum will be calculated automatically.
         */
        maximum?: number;

        /**
         * The minimum zooming level for axis.
         */
        minZoom?: number;

        /**
         * The minimum value drawn by the axis. If not set explicitly, the axis
         * minimum will be calculated automatically.
         */
        minimum?: number;

        /**
         * The number of small ticks between two major ticks.
         *
         * Optional, Defaults to: 0
         */
        minorTickSteps?: number;

        /**
         * Indicates that the axis needs high precision surface implementation.
         * See {@link Ext.draw.engine.Canvas#highPrecision}
         */
        needHighPrecision?: boolean;

        /**
         * Where to set the axis. Available options are 'left', 'bottom', 'right', 'top', 'radial' and 'angular'.
         */
        position?: string;

        /**
         * Allows to change the text shown next to the tick.
         * @param {Ext.chart.axis.Axis} axis The axis.
         * @param {String/Number} label The label.
         * @param {Object} layoutContext The object that holds calculated positions
         * of axis' ticks based on current layout, segmenter, axis length and configuration.
         * @param {String/Number/null} lastLabel The last label (if any).
         * @return {String} The label to display.
         */
        renderer?: Function;

        /**
         * The segmenter config. See {@link Ext.chart.axis.segmenter.Segmenter}
         */
        segmenter?: any|Ext.chart.axis.segmenter.Segmenter;

        /**
         * The style for the axis line and ticks.
         * Refer to the {@link Ext.chart.axis.sprite.Axis}
         */
        style?: any;

        /**
         * The title for the Axis.
         * If given a String, the 'text' attribute of the title sprite will be set,
         * otherwise the style will be set.
         */
        title?: string|any;

        /**
         * The margin around the axis title. Unlike CSS where the margin is added on all 4
         * sides of an element, the 'titleMargin' is the total space that is added horizontally
         * for a vertical title and vertically for an horizontal title, with half the 'titleMargin'
         * being added on either side.
         *
         * Optional, Defaults to: 4
         */
        titleMargin?: number;

        /**
         * Specify the proportion of the axis to be rendered. The series bound to
         * this axis will be synchronized and transformed accordingly.
         */
        visibleRange?: any[];
    }

    /**
     * Defines axis for charts.
     *
     * Using the current model, the type of axis can be easily extended. By default, Sencha Charts provide three different
     * types of axis:
     *
     *  * **numeric** - the data attached to this axis is numeric and continuous.
     *  * **time** - the data attached to this axis is (or gets converted into) a date/time value; it is continuous.
     *  * **category** - the data attached to this axis belongs to a finite set. The data points are evenly placed along the axis.
     *
     * The behavior of an axis can be easily changed by setting different types of axis layout and axis segmenter to the axis.
     *
     * Axis layout defines how the data points are placed. Using continuous layout, the data points will be distributed by
     * the numeric value. Using discrete layout the data points will be spaced evenly. Furthermore, if you want to combine
     * the data points with the duplicate values in a discrete layout, you should use combineDuplicate layout.
     *
     * Segmenter defines the way to segment data range. For example, if you have a Date-type data range from Jan 1, 1997 to
     * Jan 1, 2017, the segmenter will segement the data range into years, months or days based on the current zooming
     * level.
     *
     * It is possible to write custom axis layouts and segmenters to extends this behavior by simply implementing interfaces
     * {@link Ext.chart.axis.layout.Layout} and {@link Ext.chart.axis.segmenter.Segmenter}.
     *
     * Here's an example for the axes part of a chart definition:
     * An example of axis for a series (in this case for an area chart that has multiple layers of yFields) could be:
     *
     *     axes: [{
     *         type: 'numeric',
     *         position: 'left',
     *         title: 'Number of Hits',
     *         grid: {
     *             odd: {
     *                 opacity: 1,
     *                 fill: '#ddd',
     *                 stroke: '#bbb',
     *                 lineWidth: 1
     *             }
     *         },
     *         minimum: 0
     *     }, {
     *         type: 'category',
     *         position: 'bottom',
     *         title: 'Month of the Year',
     *         grid: true,
     *         label: {
     *             rotate: {
     *                 degrees: 315
     *             }
     *         }
     *     }]
     *
     * In this case we use a 'numeric' axis for displaying the values of the Area series and a 'category' axis for displaying the names of
     * the store elements. The numeric axis is placed on the left of the screen, while the category axis is placed at the bottom of the chart.
     * Both the category and numeric axes have 'grid' set, which means that horizontal and vertical lines will cover the chart background. In the
     * category axis the labels will be rotated so they can fit the space better.
     */
    export class Axis extends Ext.Base implements Ext.chart.axis.AxisConfig {
        /**
         * Whether to make the auto-calculated minimum and maximum of the axis
         * a multiple of the interval between the major ticks of the axis.
         * If {@link #majorTickSteps}, {@link #minimum} or {@link #maximum}
         * configs have been set, this config will be ignored.
         * Defaults to 'true'.
         */
        adjustByMajorUnit: boolean;

        /**
         * The background config for the axis surface.
         */
        background: any;

        /**
         * The Chart that the Axis is bound.
         */
        protected chart: Ext.chart.AbstractChart;

        /**
         * An array containing the names of the record fields which should be mapped along the axis.
         * This is optional if the binding between series and fields is clear.
         */
        fields: any[];

        /**
         * If 'floating' is a number, then it's a percentage displacement of the axis from its initial {@link #position}
         * in the direction opposite to the axis' direction. For instance, '{position:"left", floating:75}' displays a vertical
         * axis at 3/4 of the chart, starting from the left. It is equivalent to '{position:"right", floating:25}'.
         * If 'floating' is an object, then 'floating.value' is the position of this axis along another axis,
         * defined by 'floating.alongAxis', where 'alongAxis' is an ID, an {@link Ext.chart.AbstractChart#axes} config index,
         * or the other axis itself. 'alongAxis' must have an opposite {@link Ext.chart.axis.Axis#getAlignment alignment}.
         * For example:
         *
         *
         *      axes: [
         *          {
         *              title: 'Average Temperature (F)',
         *              type: 'numeric',
         *              position: 'left',
         *              id: 'temperature-vertical-axis',
         *              minimum: -30,
         *              maximum: 130
         *          },
         *          {
         *              title: 'Month (2013)',
         *              type: 'category',
         *              position: 'bottom',
         *              floating: {
         *                  value: 32,
         *                  alongAxis: 'temperature-vertical-axis'
         *              }
         *          }
         *      ]
         */
        floating: any;

        /**
         * The grid configuration object for the Axis style. Can contain 'stroke' or 'fill' attributes.
         * Also may contain an 'odd' or 'even' property in which you only style things on odd or even rows.
         * For example:
         *
         *
         *     grid {
         *         odd: {
         *             stroke: '#555'
         *         },
         *         even: {
         *             stroke: '#ccc'
         *         }
         *     }
         */
        grid: any;

        /**
         * Indicate whether to hide the axis.
         * If the axis is hidden, one of the axis line, ticks, labels or the title will be shown and
         * no margin will be taken.
         * The coordination mechanism works fine no matter if the axis is hidden.
         */
        hidden: boolean;

        /**
         * Given a minimum and maximum bound for the series to be rendered (that can be obtained
         * automatically or by manually setting 'minimum' and 'maximum') tick marks will be added
         * on each 'increment' from the minimum value to the maximum one.
         */
        increment: number;

        /**
         * The label configuration object for the Axis. This object may include style attributes
         * like 'spacing', 'padding', 'font' that receives a string or number and
         * returns a new string with the modified values.
         *
         * For more supported values, see the configurations for {@link Ext.chart.sprite.Label}.
         */
        label: any;

        /**
         * Draws the labels in the middle of the spans.
         *
         * Optional
         */
        labelInSpan: boolean;

        /**
         * The axis layout config. See {@link Ext.chart.axis.layout.Layout}
         */
        layout: any|Ext.chart.axis.layout.Layout;

        /**
         * The limit lines configuration for the axis.
         * For example:
         *
         *     limits: [{
         *         value: 50,
         *         line: {
         *             strokeStyle: 'red',
         *             lineDash: [6, 3],
         *             title: {
         *                 text: 'Monthly minimum',
         *                 fontSize: 14
         *             }
         *         }
         *     }]
         */
        limits: any[]|any;

        /**
         * Axis (itself, its ID or index) that this axis is linked to.
         * When an axis is linked to a master axis, it will use the same data as the master axis.
         * It can be used to show additional info, or to ease reading the chart by duplicating the scales.
         */
        linkedTo: Ext.chart.axis.Axis|string|number;

        /**
         * Forces the number of major ticks to the specified value.
         * Both {@link #minimum} and {@link #maximum} should be specified.
         *
         * Optional, Defaults to: 0
         */
        majorTickSteps: number;

        /**
         * The margin of the axis. Used to control the spacing between axes in charts with multiple axes.
         * Unlike CSS where the margin is added on all 4 sides of an element, the 'margin' is the total space
         * that is added horizontally for a vertical axis, vertically for a horizontal axis,
         * and radially for an angular axis.
         */
        margin: number;

        /**
         * The maximum value drawn by the axis. If not set explicitly, the axis
         * maximum will be calculated automatically.
         */
        maximum: number;

        /**
         * The maximum zooming level for axis.
         */
        maxZoom: number;

        /**
         * The minimum value drawn by the axis. If not set explicitly, the axis
         * minimum will be calculated automatically.
         */
        minimum: number;

        /**
         * The number of small ticks between two major ticks.
         *
         * Optional, Defaults to: 0
         */
        minorTickSteps: number;

        /**
         * The minimum zooming level for axis.
         */
        minZoom: number;

        /**
         * Indicates that the axis needs high precision surface implementation.
         * See {@link Ext.draw.engine.Canvas#highPrecision}
         */
        needHighPrecision: boolean;

        /**
         * Where to set the axis. Available options are 'left', 'bottom', 'right', 'top', 'radial' and 'angular'.
         */
        position: string;

        /**
         * Allows to change the text shown next to the tick.
         * @param {Ext.chart.axis.Axis} axis The axis.
         * @param {String/Number} label The label.
         * @param {Object} layoutContext The object that holds calculated positions
         * of axis' ticks based on current layout, segmenter, axis length and configuration.
         * @param {String/Number/null} lastLabel The last label (if any).
         * @return {String} The label to display.
         */
        renderer: Function;

        /**
         * The segmenter config. See {@link Ext.chart.axis.segmenter.Segmenter}
         */
        segmenter: any|Ext.chart.axis.segmenter.Segmenter;

        /**
         * The style for the axis line and ticks.
         * Refer to the {@link Ext.chart.axis.sprite.Axis}
         */
        style: any;

        /**
         * The title for the Axis.
         * If given a String, the 'text' attribute of the title sprite will be set,
         * otherwise the style will be set.
         */
        title: string|any;

        /**
         * The margin around the axis title. Unlike CSS where the margin is added on all 4
         * sides of an element, the 'titleMargin' is the total space that is added horizontally
         * for a vertical title and vertically for an horizontal title, with half the 'titleMargin'
         * being added on either side.
         *
         * Optional, Defaults to: 4
         */
        titleMargin: number;

        /**
         * Specify the proportion of the axis to be rendered. The series bound to
         * this axis will be synchronized and transformed accordingly.
         */
        visibleRange: any[];

        constructor(config: Ext.chart.axis.AxisConfig);

        destroy();

        getAdjustByMajorUnit();

        getBackground();

        protected getChart();

        /**
         * Mapping data value into coordinate.
         *
         * @param {Number} [idx]
         * @param {Ext.util.MixedCollection} [items]
         * @return {Number}
         */
        getCoordFor(value: any, field: string, idx?: number, items?: Ext.util.MixedCollection): number;

        getFields();

        getFloating();

        getGrid();

        getHidden();

        getIncrement();

        getLabel();

        getLabelInSpan();

        getLayout();

        getLimits();

        getLinkedTo();

        getMajorTickSteps();

        getMargin();

        getMaximum();

        getMaxZoom();

        getMinimum();

        getMinorTickSteps();

        getMinZoom();

        getNeedHighPrecision();

        getPosition();

        /**
         * Get the range derived from all the bound series.
         * @return {Array}
         */
        getRange(): any[];

        getReconcileRange();

        getRenderer();

        getSegmenter();

        getStyle();

        getTitle();

        getTitleMargin();

        getVisibleRange();

        /**
         * Invoked when data has changed.
         */
        protected processData();

        /**
         * Expands the range of the axis
         * based on the range of other axes with the same direction (if any).
         */
        reconcileRange();

        /**
         * Invokes renderFrame on this axis's surface(s)
         */
        renderFrame();

        protected resolveListenerScope();

        setAdjustByMajorUnit();

        setBackground();

        protected setChart();

        setFields();

        setFloating();

        setGrid();

        setHidden();

        setIncrement();

        setLabel();

        setLabelInSpan();

        setLayout();

        setLimits();

        setLinkedTo();

        setMajorTickSteps();

        setMargin();

        setMaximum();

        setMaxZoom();

        setMinimum();

        setMinorTickSteps();

        setMinZoom();

        setNeedHighPrecision();

        setPosition();

        setReconcileRange();

        setRenderer();

        setSegmenter();

        setStyle();

        setTitle();

        setTitleMargin();

        setVisibleRange();

        /**
         * Fires when the {@link Ext.chart.axis.Axis#range range} of the axis  changes.
         */
        rangechange(axis: Ext.chart.axis.Axis, range: any[]);

        /**
         * Fires when the {@link #visibleRange} of the axis changes.
         */
        visiblerangechange(axis: Ext.chart.axis.Axis, visibleRange: any[]);
    }

    interface Category3DConfig extends Ext.chart.axis.Axis3DConfig {
        layout?: any;

        segmenter?: any;
    }

    /**
     * Category 3D Axis
     */
    export class Category3D extends Ext.chart.axis.Axis3D implements Ext.chart.axis.Category3DConfig {
        layout: any|Ext.chart.axis.layout.Layout;

        segmenter: any|Ext.chart.axis.segmenter.Segmenter;

        constructor(config: Ext.chart.axis.AxisConfig);

        getLayout();

        getSegmenter();

        setLayout();

        setSegmenter();
    }

    interface CategoryConfig extends Ext.chart.axis.AxisConfig {
        layout?: any;

        segmenter?: any;
    }

    /**
     * @extends Ext.chart.axis.Axis
     *
     * A type of axis that displays items in categories. This axis is generally used to
     * display categorical information like names of items, month names, quarters, etc.
     * but no quantitative values. For that other type of information {@link Ext.chart.axis.Numeric Numeric}
     * axis are more suitable.
     *
     * As with other axis you can set the position of the axis and its title. For example:
     *
     *     @example
     *     Ext.create({
     *        xtype: 'cartesian',
     *        renderTo: document.body,
     *        width: 600,
     *        height: 400,
     *        innerPadding: '0 40 0 40',
     *        store: {
     *            fields: ['name', 'data1', 'data2', 'data3'],
     *            data: [{
     *                'name': 'metric one',
     *                'data1': 10,
     *                'data2': 12,
     *                'data3': 14
     *            }, {
     *                'name': 'metric two',
     *                'data1': 7,
     *                'data2': 8,
     *                'data3': 16
     *            }, {
     *                'name': 'metric three',
     *                'data1': 5,
     *                'data2': 2,
     *                'data3': 14
     *            }, {
     *                'name': 'metric four',
     *                'data1': 2,
     *                'data2': 14,
     *                'data3': 6
     *            }, {
     *                'name': 'metric five',
     *                'data1': 27,
     *                'data2': 38,
     *                'data3': 36
     *            }]
     *        },
     *        axes: {
     *            type: 'category',
     *            position: 'bottom',
     *            fields: ['name'],
     *            title: {
     *                text: 'Sample Values',
     *                fontSize: 15
     *            }
     *        },
     *        series: {
     *            type: 'area',
     *            subStyle: {
     *                fill: ['#0A3F50', '#30BDA7', '#96D4C6']
     *            },
     *            xField: 'name',
     *            yField: ['data1', 'data2', 'data3']
     *        }
     *     });
     *
     * In this example with set the category axis to the bottom of the surface, bound the axis to
     * the 'name' property and set as title "Sample Values".
     */
    export class Category extends Ext.chart.axis.Axis implements Ext.chart.axis.CategoryConfig {
        layout: any|Ext.chart.axis.layout.Layout;

        segmenter: any|Ext.chart.axis.segmenter.Segmenter;

        constructor(config: Ext.chart.axis.AxisConfig);

        getLayout();

        getSegmenter();

        setLayout();

        setSegmenter();
    }

    interface Numeric3DConfig extends Ext.chart.axis.Axis3DConfig {
        layout?: any;

        segmenter?: any;
    }

    export class Numeric3D extends Ext.chart.axis.Axis3D implements Ext.chart.axis.Numeric3DConfig {
        layout: any|Ext.chart.axis.layout.Layout;

        segmenter: any|Ext.chart.axis.segmenter.Segmenter;

        constructor(config: Ext.chart.axis.AxisConfig);

        getAggregator();

        getLayout();

        getSegmenter();

        setAggregator();

        setLayout();

        setSegmenter();
    }

    interface NumericConfig extends Ext.chart.axis.AxisConfig {
        layout?: any;

        segmenter?: any;
    }

    /**
     * @extends Ext.chart.axis.Axis
     *
     * An axis to handle numeric values. This axis is used for quantitative data as
     * opposed to the category axis. You can set minimum and maximum values to the
     * axis so that the values are bound to that. If no values are set, then the
     * scale will auto-adjust to the values.
     *
     *     @example
     *     Ext.create({
     *        xtype: 'cartesian',
     *        renderTo: document.body,
     *        width: 600,
     *        height: 400,
     *        store: {
     *            fields: ['name', 'data1', 'data2', 'data3'],
     *            data: [{
     *                'name': 1,
     *                'data1': 10,
     *                'data2': 12,
     *                'data3': 14
     *            }, {
     *                'name': 2,
     *                'data1': 7,
     *                'data2': 8,
     *                'data3': 16
     *            }, {
     *                'name': 3,
     *                'data1': 5,
     *                'data2': 2,
     *                'data3': 14
     *            }, {
     *                'name': 4,
     *                'data1': 2,
     *                'data2': 14,
     *                'data3': 6
     *            }, {
     *                'name': 5,
     *                'data1': 27,
     *                'data2': 38,
     *                'data3': 36
     *            }]
     *        },
     *        axes: {
     *            type: 'numeric',
     *            position: 'left',
     *            minimum: 0,
     *            fields: ['data1', 'data2', 'data3'],
     *            title: 'Sample Values',
     *            grid: {
     *                odd: {
     *                    opacity: 1,
     *                    fill: '#F2F2F2',
     *                    stroke: '#DDD',
     *                    'lineWidth': 1
     *                }
     *            }
     *        },
     *        series: {
     *            type: 'area',
     *            subStyle: {
     *                fill: ['#0A3F50', '#30BDA7', '#96D4C6']
     *            },
     *            xField: 'name',
     *            yField: ['data1', 'data2', 'data3']
     *        }
     *     });
     *
     * In this example we create an axis of Numeric type. We set a minimum value so that
     * even if all series have values greater than zero, the grid starts at zero. We bind
     * the axis onto the left part of the surface by setting _position_ to _left_.
     * We bind three different store fields to this axis by setting _fields_ to an array.
     * We set the title of the axis to _Number of Hits_ by using the _title_ property.
     * We use a _grid_ configuration to set odd background rows to a certain style and even rows
     * to be transparent/ignored.
     */
    export class Numeric extends Ext.chart.axis.Axis implements Ext.chart.axis.NumericConfig {
        layout: any|Ext.chart.axis.layout.Layout;

        segmenter: any|Ext.chart.axis.segmenter.Segmenter;

        constructor(config: Ext.chart.axis.AxisConfig);

        getAggregator();

        getLayout();

        getSegmenter();

        setAggregator();

        setLayout();

        setSegmenter();
    }

    interface Time3DConfig extends Ext.chart.axis.Numeric3DConfig {
        /**
         * The minimum value drawn by the axis. If not set explicitly, the axis
         * minimum will be calculated automatically.
         */
        calculateByLabelSize?: boolean;

        /**
         * Indicates the format the date will be rendered on.
         * For example: 'M d' will render the dates as 'Jan 30', etc.
         */
        dateFormat?: string|boolean;

        /**
         * The starting date for the time axis.
         */
        fromDate?: Date;

        layout?: any;

        segmenter?: any;

        /**
         * An array with two components:
         *
         * - The unit of the step (Ext.Date.DAY, Ext.Date.MONTH, etc).
         * - The number of units for the step (1, 2, etc).
         *
         * Optional, Defaults to: [Ext.Date.DAY, 1
         */
        step?: any[];

        /**
         * The ending date for the time axis.
         */
        toDate?: Date;
    }

    export class Time3D extends Ext.chart.axis.Numeric3D implements Ext.chart.axis.Time3DConfig {
        /**
         * The minimum value drawn by the axis. If not set explicitly, the axis
         * minimum will be calculated automatically.
         */
        calculateByLabelSize: boolean;

        /**
         * Indicates the format the date will be rendered on.
         * For example: 'M d' will render the dates as 'Jan 30', etc.
         */
        dateFormat: string|boolean;

        /**
         * The starting date for the time axis.
         */
        fromDate: Date;

        layout: any|Ext.chart.axis.layout.Layout;

        segmenter: any|Ext.chart.axis.segmenter.Segmenter;

        /**
         * An array with two components:
         *
         * - The unit of the step (Ext.Date.DAY, Ext.Date.MONTH, etc).
         * - The number of units for the step (1, 2, etc).
         *
         * Optional, Defaults to: [Ext.Date.DAY, 1
         */
        step: any[];

        /**
         * The ending date for the time axis.
         */
        toDate: Date;

        constructor(config: Ext.chart.axis.AxisConfig);

        getAggregator();

        getCalculateByLabelSize();

        getDateFormat();

        getFromDate();

        getLayout();

        getSegmenter();

        getStep();

        getToDate();

        setAggregator();

        setCalculateByLabelSize();

        setDateFormat();

        setFromDate();

        setLayout();

        setSegmenter();

        setStep();

        setToDate();
    }

    interface TimeConfig extends Ext.chart.axis.NumericConfig {
        /**
         * The minimum value drawn by the axis. If not set explicitly, the axis
         * minimum will be calculated automatically.
         */
        calculateByLabelSize?: boolean;

        /**
         * Indicates the format the date will be rendered on.
         * For example: 'M d' will render the dates as 'Jan 30', etc.
         */
        dateFormat?: string|boolean;

        /**
         * The starting date for the time axis.
         */
        fromDate?: Date;

        layout?: any;

        segmenter?: any;

        /**
         * An array with two components:
         *
         * - The unit of the step (Ext.Date.DAY, Ext.Date.MONTH, etc).
         * - The number of units for the step (1, 2, etc).
         *
         * Optional, Defaults to: [Ext.Date.DAY, 1
         */
        step?: any[];

        /**
         * The ending date for the time axis.
         */
        toDate?: Date;
    }

    /**
     * @extends Ext.chart.axis.Numeric
     *
     * A type of axis whose units are measured in time values. Use this axis
     * for listing dates that you will want to group or dynamically change.
     * If you just want to display dates as categories then use the
     * Category class for axis instead.
     *
     *     @example
     *     Ext.create({
     *        xtype: 'cartesian',
     *        renderTo: document.body,
     *        width: 600,
     *        height: 400,
     *        store: {
     *            fields: ['time', 'open', 'high', 'low', 'close'],
     *            data: [{
     *                'time': new Date('Jan 1 2010').getTime(),
     *                'open': 600,
     *                'high': 614,
     *                'low': 578,
     *                'close': 590
     *            }, {
     *                'time': new Date('Jan 2 2010').getTime(),
     *                'open': 590,
     *                'high': 609,
     *                'low': 580,
     *                'close': 580
     *            }, {
     *                'time': new Date('Jan 3 2010').getTime(),
     *                'open': 580,
     *                'high': 602,
     *                'low': 578,
     *                'close': 602
     *            }, {
     *                'time': new Date('Jan 4 2010').getTime(),
     *                'open': 602,
     *                'high': 614,
     *                'low': 586,
     *                'close': 586
     *            }]
     *        },
     *        axes: [{
     *            type: 'numeric',
     *            position: 'left',
     *            fields: ['open', 'high', 'low', 'close'],
     *            title: {
     *                text: 'Sample Values',
     *                fontSize: 15
     *            },
     *            grid: true,
     *            minimum: 560,
     *            maximum: 640
     *        }, {
     *            type: 'time',
     *            position: 'bottom',
     *            fields: ['time'],
     *            fromDate: new Date('Dec 31 2009'),
     *            toDate: new Date('Jan 5 2010'),
     *            title: {
     *                text: 'Sample Values',
     *                fontSize: 15
     *            },
     *            style: {
     *                axisLine: false
     *            }
     *        }],
     *        series: {
     *            type: 'candlestick',
     *            xField: 'time',
     *            openField: 'open',
     *            highField: 'high',
     *            lowField: 'low',
     *            closeField: 'close',
     *            style: {
     *                ohlcType: 'ohlc',
     *                dropStyle: {
     *                    fill: 'rgb(255, 128, 128)',
     *                    stroke: 'rgb(255, 128, 128)',
     *                    lineWidth: 3
     *                },
     *                raiseStyle: {
     *                    fill: 'rgb(48, 189, 167)',
     *                    stroke: 'rgb(48, 189, 167)',
     *                    lineWidth: 3
     *                }
     *            }
     *        }
     *     });
     */
    export class Time extends Ext.chart.axis.Numeric implements Ext.chart.axis.TimeConfig {
        /**
         * The minimum value drawn by the axis. If not set explicitly, the axis
         * minimum will be calculated automatically.
         */
        calculateByLabelSize: boolean;

        /**
         * Indicates the format the date will be rendered on.
         * For example: 'M d' will render the dates as 'Jan 30', etc.
         */
        dateFormat: string|boolean;

        /**
         * The starting date for the time axis.
         */
        fromDate: Date;

        layout: any|Ext.chart.axis.layout.Layout;

        segmenter: any|Ext.chart.axis.segmenter.Segmenter;

        /**
         * An array with two components:
         *
         * - The unit of the step (Ext.Date.DAY, Ext.Date.MONTH, etc).
         * - The number of units for the step (1, 2, etc).
         *
         * Optional, Defaults to: [Ext.Date.DAY, 1
         */
        step: any[];

        /**
         * The ending date for the time axis.
         */
        toDate: Date;

        constructor(config: Ext.chart.axis.AxisConfig);

        getAggregator();

        getCalculateByLabelSize();

        getDateFormat();

        getFromDate();

        getLayout();

        getSegmenter();

        getStep();

        getToDate();

        setAggregator();

        setCalculateByLabelSize();

        setDateFormat();

        setFromDate();

        setLayout();

        setSegmenter();

        setStep();

        setToDate();
    }
}

declare module Ext.chart.axis.layout {
    /**
     * @extends Ext.chart.axis.layout.Discrete
     *
     * Discrete processor that combines duplicate data points.
     */
    export class CombineDuplicate extends Ext.chart.axis.layout.Discrete {
        constructor(config: Ext.chart.axis.layout.LayoutConfig);
    }

    /**
     * @extends Ext.chart.axis.layout.Layout
     *
     * Processor for axis data that can be interpolated.
     */
    export class Continuous extends Ext.chart.axis.layout.Layout {
        constructor(config: Ext.chart.axis.layout.LayoutConfig);

        getAdjustMaximumByMajorUnit();

        getAdjustMinimumByMajorUnit();

        setAdjustMaximumByMajorUnit();

        setAdjustMinimumByMajorUnit();
    }

    /**
     * @extends Ext.chart.axis.layout.Layout
     *
     * Simple processor for data that cannot be interpolated.
     */
    export class Discrete extends Ext.chart.axis.layout.Layout {
        constructor(config: Ext.chart.axis.layout.LayoutConfig);
    }

    interface LayoutConfig {
        /**
         * The axis that the Layout is bound.
         */
        axis?: Ext.chart.axis.Axis;
    }

    /**
     * @abstract
     *
     * Interface used by Axis to process its data into a meaningful layout.
     */
    export class Layout extends Ext.Base implements Ext.chart.axis.layout.LayoutConfig {
        /**
         * The axis that the Layout is bound.
         */
        axis: Ext.chart.axis.Axis;

        /**
         * Calculates the position of tick marks for the axis.
         * @return {*}
         */
        calculateLayout(context: any): any;

        /**
         * Calculates the position of major ticks for the axis.
         */
        calculateMajorTicks(context: any);

        /**
         * Calculates the position of sub ticks for the axis.
         */
        calculateMinorTicks(context: any);

        constructor(config: Ext.chart.axis.layout.LayoutConfig);

        getAxis();

        /**
         * Processes the data of the series bound to the axis.
         * @param {Ext.chart.series.Series} series The bound series.
         */
        processData(series: Ext.chart.series.Series);

        setAxis();

        /**
         * Snaps the data bound to the axis to meaningful tick marks.
         */
        snapEnds(context: any, min: number, max: number, estStepSize: number);

        /**
         * Trims the layout of the axis by the defined minimum and maximum.
         */
        trimByRange(context: any, out: any, trimMin: number, trimMax: number);
    }
}

declare module Ext.chart.axis.segmenter {
    /**
     * @extends Ext.chart.axis.segmenter.Segmenter
     *
     * Names data type. Names will be calculated as their indices in the methods in this class.
     * The 'preferredStep' always return '{ unit: 1, step: 1 }' to indicate "show every item".
     */
    export class Names extends Ext.chart.axis.segmenter.Segmenter {
        constructor(config: Ext.chart.axis.segmenter.SegmenterConfig);
    }

    /**
     * @extends Ext.chart.axis.segmenter.Segmenter
     *
     * Numeric data type.
     */
    export class Numeric extends Ext.chart.axis.segmenter.Segmenter {
        constructor(config: Ext.chart.axis.segmenter.SegmenterConfig);

        /**
         * Wraps the provided estimated step size of a range without altering it into a step size object.
         *
         * @param {*} min The start point of range.
         * @param {*} estStepSize The estimated step size.
         * @return {Object} Return the step size by an object of step x unit.
         * @return {Number} return.step The step count of units.
         * @return {Object} return.unit The unit.
         */
        leadingZeros(min: any, estStepSize: any): any;
    }

    interface SegmenterConfig {
        /**
         * The axis that the Segmenter is bound.
         */
        axis?: Ext.chart.axis.Axis;
    }

    /**
     * @abstract
     *
     * Interface for a segmenter in an Axis. A segmenter defines the operations you can do to a specific
     * data type.
     *
     * See {@link Ext.chart.axis.Axis}.
     */
    export class Segmenter extends Ext.Base implements Ext.chart.axis.segmenter.SegmenterConfig {
        /**
         * The axis that the Segmenter is bound.
         */
        axis: Ext.chart.axis.Axis;

        /**
         * Add 'step' 'unit's to the value.
         * @param {*} value  The value to be added.
         * @param {Number} step The step of units. Negative value are allowed.
         * @param {*} unit The unit.
         */
        add(value: any, step: number, unit: any);

        /**
         * Align value with step of units.
         * For example, for the date segmenter, if the unit is "Month" and step is 3, the value will be aligned by
         * seasons.
         *
         * @param {*} value The value to be aligned.
         * @param {Number} step The step of units.
         * @param {*} unit The unit.
         * @return {*} Aligned value.
         */
        align(value: any, step: number, unit: any): any;

        constructor(config: Ext.chart.axis.segmenter.SegmenterConfig);

        /**
         * Returns the difference between the min and max value based on the given unit scale.
         *
         * @param {*} min The smaller value.
         * @param {*} max The larger value.
         * @param {*} unit The unit scale. Unit can be any type.
         * @return {Number} The number of 'unit's between min and max. It is the minimum n that min + n * unit >= max.
         */
        diff(min: any, max: any, unit: any): number;

        /**
         * Convert from any data into the target type.
         * @param {*} value The value to convert from
         * @return {*} The converted value.
         */
        from(value: any): any;

        getAxis();

        /**
         * Given a start point and estimated step size of a range, determine the preferred step size.
         *
         * @param {*} start The start point of range.
         * @param {*} estStepSize The estimated step size.
         * @return {Object} Return the step size by an object of step x unit.
         * @return {Number} return.step The step count of units.
         * @return {Number|Object} return.unit The unit.
         */
        preferredStep(start: any, estStepSize: any): any;

        /**
         * This method formats the value.
         *
         * @param {*} value The value to format.
         * @param {Object} context Axis layout context.
         * @return {String}
         */
        renderer(value: any, context: any): string;

        setAxis();
    }

    interface TimeConfig extends Ext.chart.axis.segmenter.SegmenterConfig {
        /**
         * If specified, the will override the result of {@link #preferredStep}.
         */
        step?: any;
    }

    /**
     * @extends Ext.chart.axis.segmenter.Segmenter
     *
     * Time data type.
     */
    export class Time extends Ext.chart.axis.segmenter.Segmenter implements Ext.chart.axis.segmenter.TimeConfig {
        /**
         * If specified, the will override the result of {@link #preferredStep}.
         */
        step: any;

        constructor(config: Ext.chart.axis.segmenter.SegmenterConfig);

        getStep();

        setStep();
    }
}

declare module Ext.chart.axis.sprite {
    /**
     * @extends Ext.chart.axis.sprite.Axis
     *
     * The {@link Ext.chart.axis.Axis3D 3D axis} sprite.
     * Only 3D cartesian axes are rendered with this sprite.
     */
    export class Axis3D extends Ext.chart.axis.sprite.Axis {
        constructor(config: Ext.chart.axis.sprite.AxisConfig);

        getFx();

        setFx();
    }

    interface AxisConfig extends Ext.draw.sprite.SpriteConfig {
        /**
         * The axis represented by this sprite.
         */
        axis?: Ext.chart.axis.Axis;

        /**
         * 'true' if the main line of the axis is drawn.
         */
        axisLine?: boolean;

        /**
         * The starting rotation of the angular axis.
         */
        baseRotation?: number;

        /**
         * The central point of the angular axis on the x-axis.
         */
        centerX?: number;

        /**
         * The central point of the angular axis on the y-axis.
         */
        centerY?: number;

        /**
         * The maximum value of the axis data.
         */
        dataMax?: number;

        /**
         * The minimum value of the axis data.
         */
        dataMin?: number;

        /**
         * if the estimated step size is adjusted by text size.
         */
        enlargeEstStepSizeByText?: boolean;

        /**
         * 'true' if the axis has a grid.
         */
        grid?: boolean;

        /**
         * The label configuration object for the Axis. This object may include style attributes
         * like 'spacing', 'padding', 'font' that receives a string or number and
         * returns a new string with the modified values.
         */
        label?: any;

        /**
         * The layout configuration used by the axis.
         */
        layout?: any|Ext.chart.axis.layout.Layout;

        /**
         * The total length of the axis.
         */
        length?: number;

        /**
         * The length of the major ticks.
         */
        majorTickSize?: number;

        /**
         * 'true' if the axis has major ticks.
         */
        majorTicks?: boolean;

        /**
         * The maximum value of the axis.
         * {@link #min} and 'max' attributes represent the effective range of the axis
         * after segmentation, layout, and range reconciliation between axes.
         */
        max?: number;

        /**
         * The minimum value of the axis.
         * 'min' and {@link #max} attributes represent the effective range of the axis
         * after segmentation, layout, and range reconciliation between axes.
         */
        min?: number;

        /**
         * The minimum step size between ticks.
         */
        minStepSize?: number;

        /**
         * The length of the minor ticks.
         */
        minorTickSize?: number;

        /**
         * 'true' if the axis has sub ticks.
         */
        minorTricks?: boolean;

        /**
         * The position of the axis on the chart.
         */
        position?: string;

        /**
         * Allows direct customisation of rendered axis sprites.
         */
        renderer?: Function;

        /**
         * The method of segmenter used by the axis.
         */
        segmenter?: any|Ext.chart.axis.segmenter.Segmenter;

        /**
         * The padding around axis labels to determine collision.
         * The default is 0 for all axes except horizontal axes of cartesian charts,
         * where the default is 5 to prevent axis labels from blending one into another.
         * This default is defined in the {@link Ext.chart.theme.Base#axis axis} config
         * of the {@link Ext.chart.theme.Base Base} theme.
         * You may want to change this default to a smaller number or 0, if you have
         * horizontal axis labels rotated, which allows for more text to fit in.
         *
         * Optional, Defaults to: 0
         */
        textPadding?: number;

        /**
         * The maximum value that is displayed.
         */
        visibleMax?: number;

        /**
         * The minimum value that is displayed.
         */
        visibleMin?: number;
    }

    /**
     * @extends Ext.draw.sprite.Sprite
     *
     * The axis sprite. Currently all types of the axis will be rendered with this sprite.
     */
    export class Axis extends Ext.draw.sprite.Sprite implements Ext.chart.axis.sprite.AxisConfig {
        /**
         * The axis represented by this sprite.
         */
        axis: Ext.chart.axis.Axis;

        /**
         * 'true' if the main line of the axis is drawn.
         */
        axisLine: boolean;

        /**
         * The starting rotation of the angular axis.
         */
        baseRotation: number;

        /**
         * The central point of the angular axis on the x-axis.
         */
        centerX: number;

        /**
         * The central point of the angular axis on the y-axis.
         */
        centerY: number;

        /**
         * The maximum value of the axis data.
         */
        dataMax: number;

        /**
         * The minimum value of the axis data.
         */
        dataMin: number;

        /**
         * if the estimated step size is adjusted by text size.
         */
        enlargeEstStepSizeByText: boolean;

        /**
         * 'true' if the axis has a grid.
         */
        grid: boolean;

        /**
         * The label configuration object for the Axis. This object may include style attributes
         * like 'spacing', 'padding', 'font' that receives a string or number and
         * returns a new string with the modified values.
         */
        label: any;

        /**
         * The layout configuration used by the axis.
         */
        layout: any|Ext.chart.axis.layout.Layout;

        /**
         * The total length of the axis.
         */
        length: number;

        /**
         * 'true' if the axis has major ticks.
         */
        majorTicks: boolean;

        /**
         * The length of the major ticks.
         */
        majorTickSize: number;

        /**
         * The maximum value of the axis.
         * {@link #min} and 'max' attributes represent the effective range of the axis
         * after segmentation, layout, and range reconciliation between axes.
         */
        max: number;

        /**
         * The minimum value of the axis.
         * 'min' and {@link #max} attributes represent the effective range of the axis
         * after segmentation, layout, and range reconciliation between axes.
         */
        min: number;

        /**
         * The length of the minor ticks.
         */
        minorTickSize: number;

        /**
         * 'true' if the axis has sub ticks.
         */
        minorTricks: boolean;

        /**
         * The minimum step size between ticks.
         */
        minStepSize: number;

        /**
         * The position of the axis on the chart.
         */
        position: string;

        /**
         * Allows direct customisation of rendered axis sprites.
         */
        renderer: Function;

        /**
         * The method of segmenter used by the axis.
         */
        segmenter: any|Ext.chart.axis.segmenter.Segmenter;

        /**
         * The padding around axis labels to determine collision.
         * The default is 0 for all axes except horizontal axes of cartesian charts,
         * where the default is 5 to prevent axis labels from blending one into another.
         * This default is defined in the {@link Ext.chart.theme.Base#axis axis} config
         * of the {@link Ext.chart.theme.Base Base} theme.
         * You may want to change this default to a smaller number or 0, if you have
         * horizontal axis labels rotated, which allows for more text to fit in.
         *
         * Optional, Defaults to: 0
         */
        textPadding: number;

        /**
         * The maximum value that is displayed.
         */
        visibleMax: number;

        /**
         * The minimum value that is displayed.
         */
        visibleMin: number;

        constructor(config: Ext.chart.axis.sprite.AxisConfig);

        getAxis();

        getLabel();

        getLayout();

        getRenderer();

        getSegmenter();

        setAxis();

        setLabel();

        setLayout();

        setRenderer();

        setSegmenter();
    }
}

declare module Ext.chart.grid {
    /**
     * @extends Ext.draw.sprite.Circle
     *
     * Circular Grid sprite. Used by Radar chart to render a series of concentric circles.
     */
    export class CircularGrid extends Ext.draw.sprite.Circle {
        constructor(config: Ext.chart.axis.sprite.AxisConfig);
    }

    /**
     * @extends Ext.draw.sprite.Sprite
     *
     * Horizontal Grid sprite. Used in Cartesian Charts.
     */
    export class HorizontalGrid extends Ext.draw.sprite.Sprite {
        constructor(config: Ext.chart.axis.sprite.AxisConfig);
    }

    /**
     * @extends Ext.chart.grid.HorizontalGrid
     *
     * Horizontal 3D Grid sprite. Used in 3D Cartesian Charts.
     */
    export class HorizontalGrid3D extends Ext.chart.grid.HorizontalGrid {
        constructor(config: Ext.chart.axis.sprite.AxisConfig);
    }

    /**
     * @extends Ext.draw.sprite.Path
     *
     * Radial Grid sprite. Used by Radar chart to render a series of radial lines.
     * Represents the scale of the radar chart on the yField.
     */
    export class RadialGrid extends Ext.draw.sprite.Path {
        constructor(config: Ext.chart.axis.sprite.AxisConfig);
    }

    /**
     * @extends Ext.draw.sprite.Sprite
     *
     * Vertical Grid sprite. Used in Cartesian Charts.
     */
    export class VerticalGrid extends Ext.draw.sprite.Sprite {
        constructor(config: Ext.chart.axis.sprite.AxisConfig);
    }

    /**
     * @extends Ext.chart.grid.VerticalGrid
     *
     * Vertical 3D Grid sprite. Used in 3D Cartesian Charts.
     */
    export class VerticalGrid3D extends Ext.chart.grid.VerticalGrid {
        constructor(config: Ext.chart.axis.sprite.AxisConfig);
    }
}

declare module Ext.chart.interactions {
    interface AbstractConfig {
        /**
         * The chart that the interaction is bound.
         */
        chart?: Ext.chart.AbstractChart;

        /**
         * 'true' if the interaction is enabled.
         */
        enabled?: boolean;
    }

    /**
     * Defines a common abstract parent class for all interactions.
     */
    export class Abstract extends Ext.Base implements Ext.chart.interactions.AbstractConfig {
        /**
         * Android device is emerging too many events so if we re-render every frame it will take forever to finish a frame.
         * This throttle technique will limit the timespan between two frames.
         */
        throttleGap: any;

        /**
         * The chart that the interaction is bound.
         */
        chart: Ext.chart.AbstractChart;

        /**
         * 'true' if the interaction is enabled.
         */
        enabled: boolean;

        constructor(config: Ext.chart.interactions.AbstractConfig);

        destroy();

        getChart();

        getEnabled();

        /**
         * Find and return a single series item corresponding to the given event,
         * or null if no matching item is found.
         * @return {Object} the item object or null if none found.
         */
        protected getItemForEvent(e: Event): any;

        /**
         * Find and return all series items corresponding to the given event.
         * @return {Array} array of matching item objects
         */
        protected getItemsForEvent(e: Event): any[];

        /**
         * A method to be implemented by subclasses where all event attachment should occur.
         */
        protected initialize();

        /**
         * Placeholder method.
         */
        protected onGesture();

        setChart();

        setEnabled();
    }

    interface CrosshairConfig extends Ext.chart.interactions.AbstractConfig {
        /**
         * Specifies label text and label rect configs on per axis basis or as a single config for all axes.
         *
         *     {
         *         type: 'crosshair',
         *         axes: {
         *             label: { fillStyle: 'white' },
         *             rect: { fillStyle: 'maroon'}
         *         }
         *     }
         *
         * In case per axis configuration is used, an object with keys corresponding
         * to the {@link Ext.chart.axis.Axis#position position} must be provided.
         *
         *     {
         *         type: 'crosshair',
         *         axes: {
         *             left: {
         *                 label: { fillStyle: 'white' },
         *                 rect: {
         *                     fillStyle: 'maroon',
         *                     radius: 4
         *                 }
         *             },
         *             bottom: {
         *                 label: {
         *                     fontSize: '14px',
         *                     fontWeight: 'bold'
         *                 },
         *                 rect: { fillStyle: 'white' }
         *             }
         *         }
         *
         * If the 'axes' config is not specified, the following defaults will be used:
         * - 'label' will use values from the {@link Ext.chart.axis.Axis#label label} config.
         * - 'rect' will use the 'white' fillStyle.
         */
        axes?: any;

        /**
         * Specifies which gesture should be used for starting/maintaining/ending the interaction.
         */
        gesture?: string;

        /**
         * Specifies attributes of horizontal and vertical lines that make up the crosshair.
         * If this config is missing, black dashed lines will be used.
         *
         *     {
         *         horizontal: {
         *             strokeStyle: 'red',
         *             lineDash: [] // solid line
         *         },
         *         vertical: {
         *             lineWidth: 2,
         *             lineDash: [15, 5, 5, 5]
         *         }
         *     }
         */
        lines?: any;
    }

    /**
     * The Crosshair interaction allows the user to get precise values for a specific point on the chart.
     * The values are obtained by single-touch dragging on the chart.
     *
     *     @example
     *     Ext.create('Ext.Container', {
     *         renderTo: Ext.getBody(),
     *         width: 600,
     *         height: 400,
     *         layout: 'fit',
     *         items: {
     *             xtype: 'cartesian',
     *             innerPadding: 20,
     *             interactions: {
     *                 type: 'crosshair',
     *                 axes: {
     *                     left: {
     *                         label: {
     *                             fillStyle: 'white'
     *                         },
     *                         rect: {
     *                             fillStyle: 'brown',
     *                             radius: 6
     *                         }
     *                     },
     *                     bottom: {
     *                         label: {
     *                             fontSize: '14px',
     *                             fontWeight: 'bold'
     *                         }
     *                     }
     *                 },
     *                 lines: {
     *                     horizontal: {
     *                         strokeStyle: 'brown',
     *                         lineWidth: 2,
     *                         lineDash: [20, 2, 2, 2, 2, 2, 2, 2]
     *                     }
     *                 }
     *             },
     *             store: {
     *                 fields: ['name', 'data'],
     *                 data: [
     *                     {name: 'apple', data: 300},
     *                     {name: 'orange', data: 900},
     *                     {name: 'banana', data: 800},
     *                     {name: 'pear', data: 400},
     *                     {name: 'grape', data: 500}
     *                 ]
     *             },
     *             axes: [{
     *                 type: 'numeric',
     *                 position: 'left',
     *                 fields: ['data'],
     *                 title: {
     *                     text: 'Value',
     *                     fontSize: 15
     *                 },
     *                 grid: true,
     *                 label: {
     *                     rotationRads: -Math.PI / 4
     *                 }
     *             }, {
     *                 type: 'category',
     *                 position: 'bottom',
     *                 fields: ['name'],
     *                 title: {
     *                     text: 'Category',
     *                     fontSize: 15
     *                 }
     *             }],
     *             series: {
     *                 type: 'line',
     *                 style: {
     *                     strokeStyle: 'black'
     *                 },
     *                 xField: 'name',
     *                 yField: 'data',
     *                 marker: {
     *                     type: 'circle',
     *                     radius: 5,
     *                     fillStyle: 'lightblue'
     *                 }
     *             }
     *         }
     *     });
     */
    export class Crosshair extends Ext.chart.interactions.Abstract implements Ext.chart.interactions.CrosshairConfig {
        /**
         * Specifies label text and label rect configs on per axis basis or as a single config for all axes.
         *
         *     {
         *         type: 'crosshair',
         *         axes: {
         *             label: { fillStyle: 'white' },
         *             rect: { fillStyle: 'maroon'}
         *         }
         *     }
         *
         * In case per axis configuration is used, an object with keys corresponding
         * to the {@link Ext.chart.axis.Axis#position position} must be provided.
         *
         *     {
         *         type: 'crosshair',
         *         axes: {
         *             left: {
         *                 label: { fillStyle: 'white' },
         *                 rect: {
         *                     fillStyle: 'maroon',
         *                     radius: 4
         *                 }
         *             },
         *             bottom: {
         *                 label: {
         *                     fontSize: '14px',
         *                     fontWeight: 'bold'
         *                 },
         *                 rect: { fillStyle: 'white' }
         *             }
         *         }
         *
         * If the 'axes' config is not specified, the following defaults will be used:
         * - 'label' will use values from the {@link Ext.chart.axis.Axis#label label} config.
         * - 'rect' will use the 'white' fillStyle.
         */
        axes: any;

        /**
         * Specifies which gesture should be used for starting/maintaining/ending the interaction.
         */
        gesture: string;

        /**
         * Specifies attributes of horizontal and vertical lines that make up the crosshair.
         * If this config is missing, black dashed lines will be used.
         *
         *     {
         *         horizontal: {
         *             strokeStyle: 'red',
         *             lineDash: [] // solid line
         *         },
         *         vertical: {
         *             lineWidth: 2,
         *             lineDash: [15, 5, 5, 5]
         *         }
         *     }
         */
        lines: any;

        constructor(config: Ext.chart.interactions.AbstractConfig);

        getAxes();

        getGesture();

        getLines();

        setAxes();

        setGesture();

        setLines();
    }

    interface CrossZoomConfig extends Ext.chart.interactions.AbstractConfig {
        /**
         * Specifies which axes should be made navigable. The config value can take the following formats:
         *
         * - An Object whose keys correspond to the {@link Ext.chart.axis.Axis#position position} of each
         *   axis that should be made navigable. Each key's value can either be an Object with further
         *   configuration options for each axis or simply 'true' for a default set of options.
         *       {
         *           type: 'crosszoom',
         *           axes: {
         *               left: {
         *                   maxZoom: 5,
         *                   allowPan: false
         *               },
         *               bottom: true
         *           }
         *       }
         *
         *   If using the full Object form, the following options can be specified for each axis:
         *
         *   - minZoom (Number) A minimum zoom level for the axis. Defaults to '1' which is its natural size.
         *   - maxZoom (Number) A maximum zoom level for the axis. Defaults to '10'.
         *   - startZoom (Number) A starting zoom level for the axis. Defaults to '1'.
         *   - allowZoom (Boolean) Whether zooming is allowed for the axis. Defaults to 'true'.
         *   - allowPan (Boolean) Whether panning is allowed for the axis. Defaults to 'true'.
         *   - startPan (Boolean) A starting panning offset for the axis. Defaults to '0'.
         *
         * - An Array of strings, each one corresponding to the {@link Ext.chart.axis.Axis#position position}
         *   of an axis that should be made navigable. The default options will be used for each named axis.
         *
         *       {
         *           type: 'crosszoom',
         *           axes: ['left', 'bottom']
         *       }
         *
         * If the 'axes' config is not specified, it will default to making all axes navigable with the
         * default axis options.
         */
        axes?: any|any[];
    }

    /**
     * @extends Ext.chart.interactions.Abstract
     *
     * The CrossZoom interaction allows the user to zoom in on a selected area of the chart.
     *
     *     @example
     *     Ext.create({
     *         xtype: 'cartesian',
     *         renderTo: Ext.getBody(),
     *         width: 600,
     *         height: 400,
     *         insetPadding: 40,
     *         interactions: 'crosszoom',
     *         store: {
     *             fields: ['name', 'data1', 'data2', 'data3', 'data4', 'data5'],
     *             data: [{
     *                 'name': 'metric one',
     *                 'data1': 10,
     *                 'data2': 12,
     *                 'data3': 14,
     *                 'data4': 8,
     *                 'data5': 13
     *             }, {
     *                 'name': 'metric two',
     *                 'data1': 7,
     *                 'data2': 8,
     *                 'data3': 16,
     *                 'data4': 10,
     *                 'data5': 3
     *             }, {
     *                 'name': 'metric three',
     *                 'data1': 5,
     *                 'data2': 2,
     *                 'data3': 14,
     *                 'data4': 12,
     *                 'data5': 7
     *             }, {
     *                 'name': 'metric four',
     *                 'data1': 2,
     *                 'data2': 14,
     *                 'data3': 6,
     *                 'data4': 1,
     *                 'data5': 23
     *             }, {
     *                 'name': 'metric five',
     *                 'data1': 27,
     *                 'data2': 38,
     *                 'data3': 36,
     *                 'data4': 13,
     *                 'data5': 33
     *             }]
     *         },
     *         axes: [{
     *             type: 'numeric',
     *             position: 'left',
     *             fields: ['data1'],
     *             title: {
     *                 text: 'Sample Values',
     *                 fontSize: 15
     *             },
     *             grid: true,
     *             minimum: 0
     *         }, {
     *             type: 'category',
     *             position: 'bottom',
     *             fields: ['name'],
     *             title: {
     *                 text: 'Sample Values',
     *                 fontSize: 15
     *             }
     *         }],
     *         series: [{
     *             type: 'line',
     *             highlight: {
     *                 size: 7,
     *                 radius: 7
     *             },
     *             style: {
     *                 stroke: 'rgb(143,203,203)'
     *             },
     *             xField: 'name',
     *             yField: 'data1',
     *             marker: {
     *                 type: 'path',
     *                 path: ['M', - 2, 0, 0, 2, 2, 0, 0, - 2, 'Z'],
     *                 stroke: 'blue',
     *                 lineWidth: 0
     *             }
     *         }, {
     *             type: 'line',
     *             highlight: {
     *                 size: 7,
     *                 radius: 7
     *             },
     *             fill: true,
     *             xField: 'name',
     *             yField: 'data3',
     *             marker: {
     *                 type: 'circle',
     *                 radius: 4,
     *                 lineWidth: 0
     *             }
     *         }]
     *     });
     */
    export class CrossZoom extends Ext.chart.interactions.Abstract implements Ext.chart.interactions.CrossZoomConfig {
        /**
         * Specifies which axes should be made navigable. The config value can take the following formats:
         *
         * - An Object whose keys correspond to the {@link Ext.chart.axis.Axis#position position} of each
         *   axis that should be made navigable. Each key's value can either be an Object with further
         *   configuration options for each axis or simply 'true' for a default set of options.
         *       {
         *           type: 'crosszoom',
         *           axes: {
         *               left: {
         *                   maxZoom: 5,
         *                   allowPan: false
         *               },
         *               bottom: true
         *           }
         *       }
         *
         *   If using the full Object form, the following options can be specified for each axis:
         *
         *   - minZoom (Number) A minimum zoom level for the axis. Defaults to '1' which is its natural size.
         *   - maxZoom (Number) A maximum zoom level for the axis. Defaults to '10'.
         *   - startZoom (Number) A starting zoom level for the axis. Defaults to '1'.
         *   - allowZoom (Boolean) Whether zooming is allowed for the axis. Defaults to 'true'.
         *   - allowPan (Boolean) Whether panning is allowed for the axis. Defaults to 'true'.
         *   - startPan (Boolean) A starting panning offset for the axis. Defaults to '0'.
         *
         * - An Array of strings, each one corresponding to the {@link Ext.chart.axis.Axis#position position}
         *   of an axis that should be made navigable. The default options will be used for each named axis.
         *
         *       {
         *           type: 'crosszoom',
         *           axes: ['left', 'bottom']
         *       }
         *
         * If the 'axes' config is not specified, it will default to making all axes navigable with the
         * default axis options.
         */
        axes: any|any[];

        constructor();

        destroy();

        getAxes();

        getGestures();

        getUndoButton();

        setAxes();

        setGestures();

        setUndoButton();
    }

    interface ItemEditConfig extends Ext.chart.interactions.ItemHighlightConfig {
        /**
         * A function that returns style attributes for the item that's being dragged.
         * This is useful if you want to give a visual feedback to the user when
         * they dragged to a certain point.
         *
         * @param {Object} [data] The following properties are available:
         *
         * @param {Object} data.target The object containing the xField/xValue or/and
         * yField/yValue properties, where the xField/yField specify the store records
         * being edited and the xValue/yValue the target values to be set when
         * the interaction ends. The object also contains the 'index' of the record
         * being edited.
         * @param {Object} data.style The style that is going to be used for the dragged item.
         * The attributes returned by the renderer will be applied on top of this style.
         * @param {Object} data.item The series item being dragged.
         * This is actually the {@link Ext.chart.AbstractChart#highlightItem}.
         *
         * @return {Object} The style attributes to be set on the dragged item.
         *
         * Optional, Defaults to: null
         */
        renderer?: Function|string;

        /**
         * The style that will be applied to the series item on dragging.
         * By default, series item will have no fill,
         * and will have a dashed stroke of the same color.
         *
         * Optional, Defaults to: null
         */
        style?: any;

        /**
         * Optional, Defaults to: true
         */
        tooltip?: any|boolean;
    }

    /**
     * @extends Ext.chart.interactions.ItemHighlight
     *
     * The 'itemedit' interaction allows the user to edit store data
     * by dragging series items in the chart.
     *
     * The 'itemedit' interaction extends the
     * {@link Ext.chart.interactions.ItemHighlight 'itemhighlight'} interaction,
     * so it also acts like one. If you need both interactions in a single chart,
     * 'itemedit' should be sufficient. Hovering/tapping will result in highlighting,
     * and dragging will result in editing.
     */
    export class ItemEdit extends Ext.chart.interactions.ItemHighlight implements Ext.chart.interactions.ItemEditConfig {
        /**
         * A function that returns style attributes for the item that's being dragged.
         * This is useful if you want to give a visual feedback to the user when
         * they dragged to a certain point.
         *
         * @param {Object} [data] The following properties are available:
         *
         * @param {Object} data.target The object containing the xField/xValue or/and
         * yField/yValue properties, where the xField/yField specify the store records
         * being edited and the xValue/yValue the target values to be set when
         * the interaction ends. The object also contains the 'index' of the record
         * being edited.
         * @param {Object} data.style The style that is going to be used for the dragged item.
         * The attributes returned by the renderer will be applied on top of this style.
         * @param {Object} data.item The series item being dragged.
         * This is actually the {@link Ext.chart.AbstractChart#highlightItem}.
         *
         * @return {Object} The style attributes to be set on the dragged item.
         *
         * Optional, Defaults to: null
         */
        renderer: Function|string;

        /**
         * The style that will be applied to the series item on dragging.
         * By default, series item will have no fill,
         * and will have a dashed stroke of the same color.
         *
         * Optional, Defaults to: null
         */
        style: any;

        /**
         * Optional, Defaults to: true
         */
        tooltip: any|boolean;

        constructor(config: Ext.chart.interactions.AbstractConfig);

        destroy();

        getCursors();

        getGestures();

        getRenderer();

        getStyle();

        getTooltip();

        setCursors();

        setGestures();

        setRenderer();

        setStyle();

        setTooltip();

        /**
         * Fires when item edit operation (dragging) begins.
         * @param {Ext.chart.AbstractChart} chart The chart the interaction belongs to.
         * @param {Ext.chart.interactions.ItemEdit} interaction The interaction.
         * @param {Object} item The item that is about to be edited.
         */
        beginitemedit(chart: Ext.chart.AbstractChart, interaction: Ext.chart.interactions.ItemEdit, item: any);

        /**
         * Fires when item edit operation (dragging) ends.
         * @param {Ext.chart.AbstractChart} chart The chart the interaction belongs to.
         * @param {Ext.chart.interactions.ItemEdit} interaction The interaction.
         * @param {Object} item The item that was edited.
         * @param {Object} target The object containing target values the were used.
         */
        enditemedit(chart: Ext.chart.AbstractChart, interaction: Ext.chart.interactions.ItemEdit, item: any, target: any);
    }

    interface ItemHighlightConfig extends Ext.chart.interactions.AbstractConfig {
        /**
         * Disables mouse tracking.
         * Series items will only be highlighted/unhighlighted on mouse click.
         * This config has no effect on touch devices.
         *
         * Optional, Defaults to: false
         */
        sticky?: boolean;
    }

    /**
     * @extends Ext.chart.interactions.Abstract
     *
     * The 'itemhighlight' interaction allows the user to highlight series items in the chart.
     */
    export class ItemHighlight extends Ext.chart.interactions.Abstract implements Ext.chart.interactions.ItemHighlightConfig {
        /**
         * Disables mouse tracking.
         * Series items will only be highlighted/unhighlighted on mouse click.
         * This config has no effect on touch devices.
         *
         * Optional, Defaults to: false
         */
        sticky: boolean;

        constructor(config: Ext.chart.interactions.AbstractConfig);

        getGestures();

        getSticky();

        setGestures();

        setSticky();
    }

    interface ItemInfoConfig extends Ext.chart.interactions.AbstractConfig {
        /**
         * Defines the gestures that should trigger the item info panel to be displayed.
         */
        gestures?: any;

        /**
         * An optional set of configuration overrides for the {@link Ext.Panel} that gets
         * displayed. This object will be merged with the default panel configuration.
         */
        panel?: any;
    }

    /**
     * The ItemInfo interaction allows displaying detailed information about a series data
     * point in a popup panel.
     *
     * To attach this interaction to a chart, include an entry in the chart's
     * {@link Ext.chart.AbstractChart#interactions interactions} config with the 'iteminfo' type:
     *
     *     new Ext.chart.AbstractChart({
     *         renderTo: Ext.getBody(),
     *         width: 800,
     *         height: 600,
     *         store: store1,
     *         axes: [ ...some axes options... ],
     *         series: [ ...some series options... ],
     *         interactions: [{
     *             type: 'iteminfo',
     *             listeners: {
     *                 show: function(me, item, panel) {
     *                     panel.setHtml('Stock Price: $' + item.record.get('price'));
     *                 }
     *             }
     *         }]
     *     });
     */
    export class ItemInfo extends Ext.chart.interactions.Abstract implements Ext.chart.interactions.ItemInfoConfig {
        /**
         * Defines the gestures that should trigger the item info panel to be displayed.
         */
        gestures: any;

        /**
         * An optional set of configuration overrides for the {@link Ext.Panel} that gets
         * displayed. This object will be merged with the default panel configuration.
         */
        panel: any;

        constructor(config: Ext.chart.interactions.AbstractConfig);

        getGestures();

        getPanel();

        setGestures();

        setPanel();

        /**
         * Fires when the info panel is shown.
         * @param {Ext.chart.interactions.ItemInfo} this The interaction instance
         * @param {Object} item The item whose info is being displayed
         * @param {Ext.Panel} panel The panel for displaying the info
         */
        show(that: Ext.chart.interactions.ItemInfo, item: any, panel: Ext.Panel);
    }

    interface PanZoomConfig extends Ext.chart.interactions.AbstractConfig {
        /**
         * Specifies which axes should be made navigable. The config value can take the following formats:
         *
         * - An Object with keys corresponding to the {@link Ext.chart.axis.Axis#position position} of each
         *   axis that should be made navigable. Each key's value can either be an Object with further
         *   configuration options for each axis or simply 'true' for a default set of options.
         *
         *       {
         *           type: 'panzoom',
         *           axes: {
         *               left: {
         *                   maxZoom: 5,
         *                   allowPan: false
         *               },
         *               bottom: true
         *           }
         *       }
         *
         *   If using the full Object form, the following options can be specified for each axis:
         *
         *   - minZoom (Number) A minimum zoom level for the axis. Defaults to '1' which is its natural size.
         *   - maxZoom (Number) A maximum zoom level for the axis. Defaults to '10'.
         *   - startZoom (Number) A starting zoom level for the axis. Defaults to '1'.
         *   - allowZoom (Boolean) Whether zooming is allowed for the axis. Defaults to 'true'.
         *   - allowPan (Boolean) Whether panning is allowed for the axis. Defaults to 'true'.
         *   - startPan (Boolean) A starting panning offset for the axis. Defaults to '0'.
         *
         * - An Array of strings, each one corresponding to the {@link Ext.chart.axis.Axis#position position}
         *   of an axis that should be made navigable. The default options will be used for each named axis.
         *
         *       {
         *           type: 'panzoom',
         *           axes: ['left', 'bottom']
         *       }
         *
         * If the 'axes' config is not specified, it will default to making all axes navigable with the
         * default axis options.
         */
        axes?: any|any[];

        /**
         * A set of optional overrides for the overflow arrow sprites' options. Only relevant when
         * {@link #showOverflowArrows} is 'true'.
         */
        overflowArrowOptions?: any;

        /**
         * If 'true', arrows will be conditionally shown at either end of each axis to indicate that the
         * axis is overflowing and can therefore be panned in that direction. Set this to 'false' to
         * prevent the arrows from being displayed.
         */
        showOverflowArrows?: boolean;

        /**
         * If 'true', the pan gesture will zoom the chart. Ignored on touch devices.
         */
        zoomOnPanGesture?: boolean;
    }

    /**
     * The PanZoom interaction allows the user to navigate the data for one or more chart
     * axes by panning and/or zooming. Navigation can be limited to particular axes. Zooming is
     * performed by pinching on the chart or axis area; panning is performed by single-touch dragging.
     *
     * For devices which do not support multiple-touch events, zooming can not be done via pinch gestures; in this case the
     * interaction will allow the user to perform both zooming and panning using the same single-touch drag gesture.
     * {@link #modeToggleButton} provides a button to indicate and toggle between two modes.
     *
     *     @example
     *     Ext.create({
     *         renderTo: document.body,
     *         xtype: 'cartesian',
     *         width: 600,
     *         height: 400,
     *         insetPadding: 40,
     *         interactions: [{
     *             type: 'panzoom',
     *             zoomOnPanGesture: true
     *         }],
     *         store: {
     *             fields: ['name', 'data1', 'data2', 'data3', 'data4', 'data5'],
     *             data: [{
     *                 'name': 'metric one',
     *                 'data1': 10,
     *                 'data2': 12,
     *                 'data3': 14,
     *                 'data4': 8,
     *                 'data5': 13
     *             }, {
     *                 'name': 'metric two',
     *                 'data1': 7,
     *                 'data2': 8,
     *                 'data3': 16,
     *                 'data4': 10,
     *                 'data5': 3
     *             }, {
     *                 'name': 'metric three',
     *                 'data1': 5,
     *                 'data2': 2,
     *                 'data3': 14,
     *                 'data4': 12,
     *                 'data5': 7
     *             }, {
     *                 'name': 'metric four',
     *                 'data1': 2,
     *                 'data2': 14,
     *                 'data3': 6,
     *                 'data4': 1,
     *                 'data5': 23
     *             }, {
     *                 'name': 'metric five',
     *                 'data1': 27,
     *                 'data2': 38,
     *                 'data3': 36,
     *                 'data4': 13,
     *                 'data5': 33
     *             }]
     *         },
     *         axes: [{
     *             type: 'numeric',
     *             position: 'left',
     *             fields: ['data1'],
     *             title: {
     *                 text: 'Sample Values',
     *                 fontSize: 15
     *             },
     *             grid: true,
     *             minimum: 0
     *         }, {
     *             type: 'category',
     *             position: 'bottom',
     *             fields: ['name'],
     *             title: {
     *                 text: 'Sample Values',
     *                 fontSize: 15
     *             }
     *         }],
     *         series: [{
     *             type: 'line',
     *             highlight: {
     *                 size: 7,
     *                 radius: 7
     *             },
     *             style: {
     *                 stroke: 'rgb(143,203,203)'
     *             },
     *             xField: 'name',
     *             yField: 'data1',
     *             marker: {
     *                 type: 'path',
     *                 path: ['M', - 2, 0, 0, 2, 2, 0, 0, - 2, 'Z'],
     *                 stroke: 'blue',
     *                 lineWidth: 0
     *             }
     *         }, {
     *             type: 'line',
     *             highlight: {
     *                 size: 7,
     *                 radius: 7
     *             },
     *             fill: true,
     *             xField: 'name',
     *             yField: 'data3',
     *             marker: {
     *                 type: 'circle',
     *                 radius: 4,
     *                 lineWidth: 0
     *             }
     *         }]
     *     });
     *
     * The configuration object for the 'panzoom' interaction type should specify which axes
     * will be made navigable via the 'axes' config. See the {@link #axes} config documentation
     * for details on the allowed formats. If the 'axes' config is not specified, it will default
     * to making all axes navigable with the default axis options.
     */
    export class PanZoom extends Ext.chart.interactions.Abstract implements Ext.chart.interactions.PanZoomConfig {
        /**
         * Specifies which axes should be made navigable. The config value can take the following formats:
         *
         * - An Object with keys corresponding to the {@link Ext.chart.axis.Axis#position position} of each
         *   axis that should be made navigable. Each key's value can either be an Object with further
         *   configuration options for each axis or simply 'true' for a default set of options.
         *
         *       {
         *           type: 'panzoom',
         *           axes: {
         *               left: {
         *                   maxZoom: 5,
         *                   allowPan: false
         *               },
         *               bottom: true
         *           }
         *       }
         *
         *   If using the full Object form, the following options can be specified for each axis:
         *
         *   - minZoom (Number) A minimum zoom level for the axis. Defaults to '1' which is its natural size.
         *   - maxZoom (Number) A maximum zoom level for the axis. Defaults to '10'.
         *   - startZoom (Number) A starting zoom level for the axis. Defaults to '1'.
         *   - allowZoom (Boolean) Whether zooming is allowed for the axis. Defaults to 'true'.
         *   - allowPan (Boolean) Whether panning is allowed for the axis. Defaults to 'true'.
         *   - startPan (Boolean) A starting panning offset for the axis. Defaults to '0'.
         *
         * - An Array of strings, each one corresponding to the {@link Ext.chart.axis.Axis#position position}
         *   of an axis that should be made navigable. The default options will be used for each named axis.
         *
         *       {
         *           type: 'panzoom',
         *           axes: ['left', 'bottom']
         *       }
         *
         * If the 'axes' config is not specified, it will default to making all axes navigable with the
         * default axis options.
         */
        axes: any|any[];

        /**
         * A set of optional overrides for the overflow arrow sprites' options. Only relevant when
         * {@link #showOverflowArrows} is 'true'.
         */
        overflowArrowOptions: any;

        /**
         * If 'true', arrows will be conditionally shown at either end of each axis to indicate that the
         * axis is overflowing and can therefore be panned in that direction. Set this to 'false' to
         * prevent the arrows from being displayed.
         */
        showOverflowArrows: boolean;

        /**
         * If 'true', the pan gesture will zoom the chart. Ignored on touch devices.
         */
        zoomOnPanGesture: boolean;

        constructor(config: Ext.chart.interactions.AbstractConfig);

        destroy();

        getAxes();

        getHideLabelInGesture();

        getMaxZoom();

        getMinZoom();

        getModeToggleButton();

        getShowOverflowArrows();

        getZoomOnPanGesture();

        setAxes();

        setHideLabelInGesture();

        setMaxZoom();

        setMinZoom();

        setModeToggleButton();

        setShowOverflowArrows();

        setZoomOnPanGesture();
    }

    /**
     * @extends Ext.chart.interactions.Abstract
     *
     * The Rotate interaction allows the user to rotate a polar chart about its central point.
     *
     *     @example
     *     Ext.create('Ext.Container', {
     *         renderTo: Ext.getBody(),
     *         width: 600,
     *         height: 400,
     *         layout: 'fit',
     *         items: {
     *             xtype: 'polar',
     *             interactions: 'rotate',
     *             colors: ["#115fa6", "#94ae0a", "#a61120", "#ff8809", "#ffd13e"],
     *             store: {
     *                 fields: ['name', 'data1', 'data2', 'data3', 'data4', 'data5'],
     *                 data: [
     *                     {'name':'metric one', 'data1':10, 'data2':12, 'data3':14, 'data4':8, 'data5':13},
     *                     {'name':'metric two', 'data1':7, 'data2':8, 'data3':16, 'data4':10, 'data5':3},
     *                     {'name':'metric three', 'data1':5, 'data2':2, 'data3':14, 'data4':12, 'data5':7},
     *                     {'name':'metric four', 'data1':2, 'data2':14, 'data3':6, 'data4':1, 'data5':23},
     *                     {'name':'metric five', 'data1':27, 'data2':38, 'data3':36, 'data4':13, 'data5':33}
     *                 ]
     *             },
     *             series: {
     *                 type: 'pie',
     *                 label: {
     *                     field: 'name',
     *                     display: 'rotate'
     *                 },
     *                 xField: 'data3',
     *                 donut: 30
     *             }
     *         }
     *     });
     */
    export class Rotate extends Ext.chart.interactions.Abstract {
        constructor(config: Ext.chart.interactions.AbstractConfig);

        getGestures();

        /**
         * Rotates a polar chart about its center point to the specified angle.
         * @param {Number} angle The angle to rotate to.
         * @param {Boolean} [relative=false] Whether the rotation is relative to the current angle or not.
         * @param {Boolean} [animate=false] Whether to animate the rotation or not.
         */
        rotateTo(angle: number, relative?: boolean, animate?: boolean);

        setGestures();

        /**
         * Fires on every tick of the rotation
         * @param {Ext.chart.interactions.Rotate} this This interaction.
         * @param {Number} angle The new current rotation angle.
         */
        rotate(that: Ext.chart.interactions.Rotate, angle: number);

        /**
         * Fires after a user finishes the rotation
         * @param {Ext.chart.interactions.Rotate} this This interaction.
         * @param {Number} angle The new current rotation angle.
         */
        rotationEnd(that: Ext.chart.interactions.Rotate, angle: number);
    }

    /**
     * @extends Ext.chart.interactions.Rotate
     *
     * A special version of the Rotate interaction used by Pie3D Chart.
     */
    export class RotatePie3D extends Ext.chart.interactions.Rotate {
        constructor(config: Ext.chart.interactions.AbstractConfig);
    }
}

declare module Ext.chart.label {
    /**
     * @extends Ext.draw.modifier.Modifier
     *
     * This is a modifier to place labels and callouts by additional attributes.
     */
    export class Callout extends Ext.draw.modifier.Modifier {
        constructor(config: Ext.draw.modifier.HighlightConfig);

        prepareAttributes(attr: any);
    }
}

declare module Ext.chart.plugin {
    interface ItemEventsConfig extends Ext.plugin.AbstractConfig {
        /**
         * If 'itemmousemove', 'itemmouseover' or 'itemmouseout' event listeners are attached
         * to the chart, the plugin will detect those and will hit test series items on
         * every move. However, if the above item events are attached on the series level
         * only, this config has to be set to true, as the plugin won't perform a similar
         * detection on every series.
         *
         * Optional, Defaults to: false
         */
        moveEvents?: boolean;
    }

    /**
     * A chart {@link Ext.AbstractPlugin plugin} that adds ability to listen to chart series
     * items events. Item event listeners are passed two parameters: the target item and the
     * event itself. The item object has the following properties:
     *
     * * **category** - the category the item falls under: 'items' or 'markers'
     * * **field** - the store field used by this series item
     * * **index** - the index of the series item
     * * **record** - the store record associated with this series item
     * * **series** - the series the item belongs to
     * * **sprite** - the sprite used to represents this series item
     *
     * For example:
     *
     *     Ext.create('Ext.chart.CartesianChart', {
     *         plugins: {
     *             ptype: 'chartitemevents',
     *             moveEvents: true
     *         },
     *         store: {
     *             fields: ['pet', 'households', 'total'],
     *             data: [
     *                 {pet: 'Cats', households: 38, total: 93},
     *                 {pet: 'Dogs', households: 45, total: 79},
     *                 {pet: 'Fish', households: 13, total: 171}
     *             ]
     *         },
     *         axes: [{
     *             type: 'numeric',
     *             position: 'left'
     *         }, {
     *             type: 'category',
     *             position: 'bottom'
     *         }],
     *         series: [{
     *             type: 'bar',
     *             xField: 'pet',
     *             yField: 'households',
     *             listeners: {
     *                 itemmousemove: function (series, item, event) {
     *                      console.log('itemmousemove', item.category, item.field);
     *                 }
     *             }
     *         }, {
     *             type: 'line',
     *             xField: 'pet',
     *             yField: 'total',
     *             marker: true
     *         }],
     *         listeners: { // Listen to itemclick events on all series.
     *             itemclick: function (chart, item, event) {
     *                 console.log('itemclick', item.category, item.field);
     *             }
     *         }
     *     });
     */
    export class ItemEvents extends Ext.plugin.Abstract implements Ext.chart.plugin.ItemEventsConfig {
        /**
         * If 'itemmousemove', 'itemmouseover' or 'itemmouseout' event listeners are attached
         * to the chart, the plugin will detect those and will hit test series items on
         * every move. However, if the above item events are attached on the series level
         * only, this config has to be set to true, as the plugin won't perform a similar
         * detection on every series.
         *
         * Optional, Defaults to: false
         */
        moveEvents: boolean;

        /**
         * Instantiates the plugin.
         * @param {Object} [config] Configuration object.
         */
        constructor(config?: Ext.chart.plugin.ItemEventsConfig);
    }
}

declare module Ext.chart.series {
    interface AreaConfig extends Ext.chart.series.StackedCartesianConfig {
        /**
         * Optional, Defaults to: false
         */
        splitStacks?: boolean;
    }

    /**
     * @extends Ext.chart.series.StackedCartesian
     *
     * Creates an Area Chart.
     *
     *     @example
     *     Ext.create({
     *        xtype: 'cartesian',
     *        renderTo: document.body,
     *        width: 600,
     *        height: 400,
     *        insetPadding: 40,
     *        store: {
     *            fields: ['name', 'data1', 'data2', 'data3'],
     *            data: [{
     *                name: 'metric one',
     *                data1: 10,
     *                data2: 12,
     *                data3: 14
     *            }, {
     *                name: 'metric two',
     *                data1: 7,
     *                data2: 8,
     *                data3: 16
     *            }, {
     *                name: 'metric three',
     *                data1: 5,
     *                data2: 2,
     *                data3: 14
     *            }, {
     *                name: 'metric four',
     *                data1: 2,
     *                data2: 14,
     *                data3: 6
     *            }, {
     *                name: 'metric five',
     *                data1: 27,
     *                data2: 38,
     *                data3: 36
     *            }]
     *        },
     *        axes: [{
     *            type: 'numeric',
     *            position: 'left',
     *            fields: ['data1'],
     *            grid: true,
     *            minimum: 0
     *        }, {
     *            type: 'category',
     *            position: 'bottom',
     *            fields: ['name']
     *        }],
     *        series: {
     *            type: 'area',
     *            subStyle: {
     *                fill: ['#0A3F50', '#30BDA7', '#96D4C6']
     *            },
     *            xField: 'name',
     *            yField: ['data1', 'data2', 'data3']
     *        }
     *     });
     */
    export class Area extends Ext.chart.series.StackedCartesian implements Ext.chart.series.AreaConfig {
        seriesType: string;

        protected type: string;

        /**
         * 'true' to stack negative/positive values in respective y-axis directions.
         *
         * Optional, Defaults to: true
         *
         * Optional, Defaults to: false
         */
        splitStacks: boolean;

        /**
         * @abstract
         * @extends Ext.chart.series.Series
         *
         * Common base class for series implementations that plot values using cartesian coordinates.
         *
         * @constructor
         */
        constructor();

        getSplitStacks();

        setSplitStacks();
    }

    /**
     * @extends Ext.chart.series.StackedCartesian
     *
     * Creates a Bar or Column Chart (depending on the value of the
     * {@link Ext.chart.CartesianChart#flipXY flipXY} config).
     *
     * Note: 'bar' series is meant to be used with the
     * {@link Ext.chart.axis.Category 'category'} axis as its x-axis.
     *
     *     @example
     *     Ext.create({
     *        xtype: 'cartesian',
     *        renderTo: document.body,
     *        width: 600,
     *        height: 400,
     *        store: {
     *            fields: ['name', 'value'],
     *            data: [{
     *                name: 'metric one',
     *                value: 10
     *            }, {
     *                name: 'metric two',
     *                value: 7
     *            }, {
     *                name: 'metric three',
     *                value: 5
     *            }, {
     *                name: 'metric four',
     *                value: 2
     *            }, {
     *                name: 'metric five',
     *                value: 27
     *            }]
     *        },
     *        axes: [{
     *            type: 'numeric',
     *            position: 'left',
     *            title: {
     *                text: 'Sample Values',
     *                fontSize: 15
     *            },
     *            fields: 'value'
     *        }, {
     *            type: 'category',
     *            position: 'bottom',
     *            title: {
     *                text: 'Sample Values',
     *                fontSize: 15
     *            },
     *            fields: 'name'
     *        }],
     *        series: {
     *            type: 'bar',
     *            subStyle: {
     *                fill: ['#388FAD'],
     *                stroke: '#1F6D91'
     *            },
     *            xField: 'name',
     *            yField: 'value'
     *        }
     *     });
     */
    export class Bar extends Ext.chart.series.StackedCartesian {
        seriesType: string;

        protected type: string;

        /**
         * @abstract
         * @extends Ext.chart.series.Series
         *
         * Common base class for series implementations that plot values using cartesian coordinates.
         *
         * @constructor
         */
        constructor();
    }

    interface Bar3DConfig extends Ext.chart.series.StackedCartesianConfig {
    }

    /**
     * @extends Ext.chart.series.Bar
     *
     * Creates a 3D Bar or 3D Column Chart (depending on the value of the
     * {@link Ext.chart.CartesianChart#flipXY flipXY} config).
     *
     * Note: 'bar3d' series is meant to be used with the
     * {@link Ext.chart.axis.Category 'category3d'} axis as its x-axis.
     *
     *     @example
     *     Ext.create({
     *        xtype: 'cartesian',
     *        renderTo: Ext.getBody(),
     *        width: 600,
     *        height: 400,
     *        innerPadding: '0 10 0 10',
     *        store: {
     *            fields: ['name', 'apples', 'oranges'],
     *            data: [{
     *                name: 'Eric',
     *                apples: 10,
     *                oranges: 3
     *            }, {
     *                name: 'Mary',
     *                apples: 7,
     *                oranges: 2
     *            }, {
     *                name: 'John',
     *                apples: 5,
     *                oranges: 2
     *            }, {
     *                name: 'Bob',
     *                apples: 2,
     *                oranges: 3
     *            }, {
     *                name: 'Joe',
     *                apples: 19,
     *                oranges: 1
     *            }, {
     *                name: 'Macy',
     *                apples: 13,
     *                oranges: 4
     *            }]
     *        },
     *        axes: [{
     *            type: 'numeric3d',
     *            position: 'left',
     *            fields: ['apples', 'oranges'],
     *            title: {
     *                text: 'Inventory',
     *                fontSize: 15
     *            },
     *            grid: {
     *                odd: {
     *                    fillStyle: 'rgba(255, 255, 255, 0.06)'
     *                },
     *                even: {
     *                    fillStyle: 'rgba(0, 0, 0, 0.03)'
     *                }
     *            }
     *        }, {
     *            type: 'category3d',
     *            position: 'bottom',
     *            title: {
     *                text: 'People',
     *                fontSize: 15
     *            },
     *            fields: 'name'
     *        }],
     *        series: {
     *            type: 'bar3d',
     *            xField: 'name',
     *            yField: ['apples', 'oranges']
     *        }
     *     });
     */
    export class Bar3D extends Ext.chart.series.Bar implements Ext.chart.series.Bar3DConfig {
        seriesType: string;

        protected type: string;

        protected highlightCfg: any;

        /**
         * @abstract
         * @extends Ext.chart.series.Series
         *
         * Common base class for series implementations that plot values using cartesian coordinates.
         *
         * @constructor
         */
        constructor();

        getSprites();
    }

    interface CandleStickConfig extends Ext.chart.series.CartesianConfig {
        /**
         * The store record field name that represents the closing value of the given period.
         */
        closeField?: string;

        /**
         * The store record field name that represents the highest value of the time interval represented.
         */
        highField?: string;

        /**
         * The store record field name that represents the lowest value of the time interval represented.
         */
        lowField?: string;

        /**
         * The store record field name that represents the opening value of the given period.
         */
        openField?: string;
    }

    /**
     * @extends Ext.chart.series.Cartesian
     *
     * Creates a candlestick or OHLC Chart.
     *
     *     @example
     *     Ext.create({
     *        xtype: 'cartesian',
     *        renderTo: document.body,
     *        width: 600,
     *        height: 400,
     *        insetPadding: 40,
     *        store: {
     *            fields: ['time', 'open', 'high', 'low', 'close'],
     *            data: [{
     *                'time': new Date('Jan 1 2010').getTime(),
     *                'open': 600,
     *                'high': 614,
     *                'low': 578,
     *                'close': 590
     *            }, {
     *                'time': new Date('Jan 2 2010').getTime(),
     *                'open': 590,
     *                'high': 609,
     *                'low': 580,
     *                'close': 580
     *            }, {
     *                'time': new Date('Jan 3 2010').getTime(),
     *                'open': 580,
     *                'high': 602,
     *                'low': 578,
     *                'close': 602
     *            }, {
     *                'time': new Date('Jan 4 2010').getTime(),
     *                'open': 602,
     *                'high': 614,
     *                'low': 586,
     *                'close': 586
     *            }, {
     *                'time': new Date('Jan 5 2010').getTime(),
     *                'open': 586,
     *                'high': 602,
     *                'low': 565,
     *                'close': 565
     *            }]
     *        },
     *        axes: [{
     *            type: 'numeric',
     *            position: 'left',
     *            fields: ['open', 'high', 'low', 'close'],
     *            title: {
     *                text: 'Sample Values',
     *                fontSize: 15
     *            },
     *            grid: true,
     *            minimum: 560,
     *            maximum: 640
     *        }, {
     *            type: 'time',
     *            position: 'bottom',
     *            fields: ['time'],
     *            fromDate: new Date('Dec 31 2009'),
     *            toDate: new Date('Jan 6 2010'),
     *            title: {
     *                text: 'Sample Values',
     *                fontSize: 15
     *            },
     *            style: {
     *                axisLine: false
     *            }
     *        }],
     *        series: {
     *            type: 'candlestick',
     *            xField: 'time',
     *            openField: 'open',
     *            highField: 'high',
     *            lowField: 'low',
     *            closeField: 'close',
     *            style: {
     *                dropStyle: {
     *                    fill: 'rgb(222, 87, 87)',
     *                    stroke: 'rgb(222, 87, 87)',
     *                    lineWidth: 3
     *                },
     *                raiseStyle: {
     *                    fill: 'rgb(48, 189, 167)',
     *                    stroke: 'rgb(48, 189, 167)',
     *                    lineWidth: 3
     *                }
     *            }
     *        }
     *     });
     */
    export class CandleStick extends Ext.chart.series.Cartesian implements Ext.chart.series.CandleStickConfig {
        seriesType: string;

        protected type: string;

        /**
         * The store record field name that represents the closing value of the given period.
         */
        closeField: string;

        /**
         * The store record field name that represents the highest value of the time interval represented.
         */
        highField: string;

        /**
         * The store record field name that represents the lowest value of the time interval represented.
         */
        lowField: string;

        /**
         * The store record field name that represents the opening value of the given period.
         */
        openField: string;

        /**
         * @abstract
         * @extends Ext.chart.series.Series
         *
         * Common base class for series implementations that plot values using cartesian coordinates.
         *
         * @constructor
         */
        constructor();

        getCloseField();

        getHighField();

        getLowField();

        getOpenField();

        setCloseField();

        setHighField();

        setLowField();

        setOpenField();
    }

    interface CartesianConfig extends Ext.chart.series.SeriesConfig {
        /**
         * xAxis The chart axis the series is bound to in the 'X' direction.
         * Normally, this would be set automatically by the series.
         * For charts with multiple x-axes, this defines which x-axis is used by the series.
         * It refers to either axis' ID or the (zero-based) index of the axis
         * in the chart's {@link Ext.chart.AbstractChart#axes axes} config.
         */
        xAxis?: any;

        /**
         * The field used to access the x axis value from the items from the data source.
         */
        xField?: string;

        /**
         * yAxis The chart axis the series is bound to in the 'Y' direction.
         * Normally, this would be set automatically by the series.
         * For charts with multiple y-axes, this defines which y-axis is used by the series.
         * It refers to either axis' ID or the (zero-based) index of the axis
         * in the chart's {@link Ext.chart.AbstractChart#axes axes} config.
         */
        yAxis?: any;

        /**
         * The field(s) used to access the y-axis value(s) of the items from the data source.
         */
        yField?: string;
    }

    export class Cartesian extends Ext.chart.series.Series implements Ext.chart.series.CartesianConfig {
        /**
         * xAxis The chart axis the series is bound to in the 'X' direction.
         * Normally, this would be set automatically by the series.
         * For charts with multiple x-axes, this defines which x-axis is used by the series.
         * It refers to either axis' ID or the (zero-based) index of the axis
         * in the chart's {@link Ext.chart.AbstractChart#axes axes} config.
         */
        xAxis: any;

        /**
         * The field used to access the x axis value from the items from the data source.
         */
        xField: string;

        /**
         * yAxis The chart axis the series is bound to in the 'Y' direction.
         * Normally, this would be set automatically by the series.
         * For charts with multiple y-axes, this defines which y-axis is used by the series.
         * It refers to either axis' ID or the (zero-based) index of the axis
         * in the chart's {@link Ext.chart.AbstractChart#axes axes} config.
         */
        yAxis: any;

        /**
         * The field(s) used to access the y-axis value(s) of the items from the data source.
         */
        yField: string;

        /**
         * @abstract
         * @extends Ext.chart.series.Series
         *
         * Common base class for series implementations that plot values using cartesian coordinates.
         *
         * @constructor
         */
        constructor();

        getSprites();

        getXAxis();

        getXField();

        getYAxis();

        getYField();

        setXAxis();

        setXField();

        setYAxis();

        setYField();
    }

    interface GaugeConfig extends Ext.chart.series.SeriesConfig {
        /**
         * The store record field name to be used for the gauge value.
         * The values bound to this field name must be positive real numbers.
         */
        angleField?: string;

        /**
         * (required)
         * An array of color values which is used for the needle and the 'sectors'.
         */
        colors?: any[];

        /**
         * Percentage of the radius of the donut hole compared to the entire disk.
         */
        donut?: number;

        /**
         * The maximum value of the gauge.
         */
        maximum?: number;

        /**
         * The minimum value of the gauge.
         */
        minimum?: number;

        /**
         * If true, display the gauge as a needle, otherwise as a sector.
         */
        needle?: boolean;

        /**
         * Percentage of the length of needle compared to the radius of the entire disk.
         */
        needleLength?: number;

        /**
         * Width of the needle in pixels.
         */
        needleWidth?: number;

        /**
         * Allows to paint sectors of different colors in the background of the gauge,
         * with optional labels.
         *
         * It can be an array of numbers (each between 'minimum' and 'maximum') that
         * define the highest value of each sector. For N sectors, only (N-1) values are
         * needed because it is assumed that the first sector starts at 'minimum' and the
         * last sector ends at 'maximum'. Example: a water temperature gauge that is blue
         * below 20C, red above 80C, gray in-between, and with an orange needle...
         *
         *      minimum: 0,
         *      maximum: 100,
         *      sectors: [20, 80],
         *      colors: ['orange', 'blue', 'lightgray', 'red']
         *
         * It can be also an array of objects, each with the following properties:
         *
         * The starting value of the sector. If omitted, it
         * uses the previous sector's 'end' value or the chart's 'minimum'.
         * The ending value of the sector. If omitted, it uses
         * the 'maximum' defined for the chart.
         * The label for this sector. Labels are styled using
         * the series' {@link Ext.chart.series.Series#label label} config.
         * The color of the sector. If omitted, it uses one
         * of the 'colors' defined for the series or for the chart.
         * An additional style object for the sector (for
         * instance to set the opacity or to draw a line of a different color around the
         * sector).
         *
         *      minimum: 0,
         *      maximum: 100,
         *      sectors: [{
         *              end: 20,
         *              label: 'Cold',
         *              color: 'aqua'
         *          },
         *          {
         *              end: 80,
         *              label: 'Temp.',
         *              color: 'lightgray',
         *              style: { strokeStyle:'black', strokeOpacity:1, lineWidth:1 }
         *          },
         *          {
         *              label: 'Hot',
         *              color: 'tomato'
         *          }]
         */
        sectors?: any[];

        /**
         * Whether to add the gauge chart elements as legend items.
         */
        showInLegend?: boolean;

        /**
         * The size of the sector that the series will occupy.
         */
        totalAngle?: number;

        /**
         * Directly sets the displayed value of the gauge.
         * It is ignored if {@link #angleField} is provided.
         */
        value?: number;

        /**
         * Indicates whether to show the whole disk or only the marked part.
         */
        wholeDisk?: boolean;
    }

    /**
     * @extends Ext.chart.series.Series
     *
     * Creates a Gauge Chart.
     *
     *     @example
     *     Ext.create({
     *        xtype: 'polar',
     *        renderTo: document.body,
     *        width: 600,
     *        height: 400,
     *        store: {
     *            fields: ['mph', 'fuel', 'temp', 'rpm'],
     *            data: [{
     *                mph: 65,
     *                fuel: 50,
     *                temp: 150,
     *                rpm: 6000
     *            }]
     *        },
     *        series: {
     *            type: 'gauge',
     *            colors: ['#1F6D91', '#90BCC9'],
     *            angleField: 'mph',
     *            needle: true,
     *            donut: 30
     *        }
     *     });
     */
    export class Gauge extends Ext.chart.series.Series implements Ext.chart.series.GaugeConfig {
        seriesType: string;

        protected type: string;

        /**
         * The store record field name to be used for the gauge value.
         * The values bound to this field name must be positive real numbers.
         */
        angleField: string;

        /**
         * (required)
         * An array of color values which is used for the needle and the 'sectors'.
         */
        colors: any[];

        /**
         * Percentage of the radius of the donut hole compared to the entire disk.
         */
        donut: number;

        /**
         * The maximum value of the gauge.
         */
        maximum: number;

        /**
         * The minimum value of the gauge.
         */
        minimum: number;

        /**
         * If true, display the gauge as a needle, otherwise as a sector.
         */
        needle: boolean;

        /**
         * Percentage of the length of needle compared to the radius of the entire disk.
         */
        needleLength: number;

        /**
         * Width of the needle in pixels.
         */
        needleWidth: number;

        /**
         * Allows to paint sectors of different colors in the background of the gauge,
         * with optional labels.
         *
         * It can be an array of numbers (each between 'minimum' and 'maximum') that
         * define the highest value of each sector. For N sectors, only (N-1) values are
         * needed because it is assumed that the first sector starts at 'minimum' and the
         * last sector ends at 'maximum'. Example: a water temperature gauge that is blue
         * below 20C, red above 80C, gray in-between, and with an orange needle...
         *
         *      minimum: 0,
         *      maximum: 100,
         *      sectors: [20, 80],
         *      colors: ['orange', 'blue', 'lightgray', 'red']
         *
         * It can be also an array of objects, each with the following properties:
         *
         * The starting value of the sector. If omitted, it
         * uses the previous sector's 'end' value or the chart's 'minimum'.
         * The ending value of the sector. If omitted, it uses
         * the 'maximum' defined for the chart.
         * The label for this sector. Labels are styled using
         * the series' {@link Ext.chart.series.Series#label label} config.
         * The color of the sector. If omitted, it uses one
         * of the 'colors' defined for the series or for the chart.
         * An additional style object for the sector (for
         * instance to set the opacity or to draw a line of a different color around the
         * sector).
         *
         *      minimum: 0,
         *      maximum: 100,
         *      sectors: [{
         *              end: 20,
         *              label: 'Cold',
         *              color: 'aqua'
         *          },
         *          {
         *              end: 80,
         *              label: 'Temp.',
         *              color: 'lightgray',
         *              style: { strokeStyle:'black', strokeOpacity:1, lineWidth:1 }
         *          },
         *          {
         *              label: 'Hot',
         *              color: 'tomato'
         *          }]
         */
        sectors: any[];

        /**
         * Whether to add the gauge chart elements as legend items.
         */
        showInLegend: boolean;

        /**
         * The size of the sector that the series will occupy.
         */
        totalAngle: number;

        /**
         * Directly sets the displayed value of the gauge.
         * It is ignored if {@link #angleField} is provided.
         */
        value: number;

        /**
         * Indicates whether to show the whole disk or only the marked part.
         */
        wholeDisk: boolean;

        constructor(config: Ext.chart.series.GaugeConfig);

        getCenter();

        getColors();

        getDonut();

        getMaximum();

        getMinimum();

        getNeedle();

        getNeedleLength();

        getNeedleWidth();

        getRadius();

        getRect();

        getRotation();

        getSectors();

        getShowInLegend();

        getSprites();

        getTotalAngle();

        getValue();

        getWholeDisk();

        setCenter();

        setColors();

        setDonut();

        setMaximum();

        setMinimum();

        setNeedle();

        setNeedleLength();

        setNeedleWidth();

        setRadius();

        setRect();

        setRotation();

        setSectors();

        setShowInLegend();

        setTotalAngle();

        setValue();

        setWholeDisk();
    }

    interface LineConfig extends Ext.chart.series.CartesianConfig {
        /**
         * If set to 'true', the area underneath the line is filled with the color defined as follows, listed by priority:
         * - The color that is configured for this series ({@link Ext.chart.series.Series#colors}).
         * - The color that is configured for this chart ({@link Ext.chart.AbstractChart#colors}).
         * - The fill color that is set in the {@link #style} config.
         * - The stroke color that is set in the {@link #style} config, or the same color as the line.
         *
         * Note: Do not confuse 'series.config.fill' (which is a boolean) with 'series.style.fill' (which is an alias
         * for the 'fillStyle' property and contains a color). For compatibility with previous versions of the API,
         * if 'config.fill' is undefined but a 'style.fill' color is provided, 'config.fill' is considered true.
         * So the default value below must be undefined, not false.
         */
        fill?: boolean;

        /**
         * Possible values:
         * 'gap' - null points are rendered as gaps.
         * 'connect' - non-null points are connected across null points, so that
         * there is no gap, unless null points are at the beginning/end of the line.
         * Only the visible data points are connected - if a visible data point
         * is followed by a series of null points that go off screen and eventually
         * terminate with a non-null point, the connection won't be made.
         * 'origin' - null data points are rendered at the origin,
         * which is the y-coordinate of a point where the x and y axes meet.
         * This requires that at least the x-coordinate of a point is a valid value.
         *
         * Optional, Defaults to: "gap"
         */
        nullStyle?: any;

        /**
         * The offset distance from the cursor position to the line series to trigger events (then used for highlighting series, etc).
         */
        selectionTolerance?: number;

        /**
         * 'true' if the series' line should be smoothed.
         * Line smoothing only works with gapless data.
         */
        smooth?: boolean;

        /**
         * If set to 'true', the line uses steps instead of straight lines to connect the dots.
         * It is ignored if 'smooth' is true.
         */
        step?: boolean;

        /**
         * An object containing styles for the visualization lines. These styles will override the theme styles.
         * Some options contained within the style object will are described next.
         */
        style?: any;
    }

    /**
     * @extends Ext.chart.series.Cartesian
     *
     * Creates a Line Chart. A Line Chart is a useful visualization technique to display quantitative information for different
     * categories or other real values (as opposed to the bar chart), that can show some progression (or regression) in the dataset.
     * As with all other series, the Line Series must be appended in the *series* Chart array configuration. See the Chart
     * documentation for more information. A typical configuration object for the line series could be:
     *
     *     @example
     *     Ext.create({
     *        xtype: 'cartesian',
     *        renderTo: document.body,
     *        width: 600,
     *        height: 400,
     *        insetPadding: 40,
     *        store: {
     *            fields: ['name', 'data1', 'data2'],
     *            data: [{
     *                'name': 'metric one',
     *                'data1': 10,
     *                'data2': 14
     *            }, {
     *                'name': 'metric two',
     *                'data1': 7,
     *                'data2': 16
     *            }, {
     *                'name': 'metric three',
     *                'data1': 5,
     *                'data2': 14
     *            }, {
     *                'name': 'metric four',
     *                'data1': 2,
     *                'data2': 6
     *            }, {
     *                'name': 'metric five',
     *                'data1': 27,
     *                'data2': 36
     *            }]
     *        },
     *        axes: [{
     *            type: 'numeric',
     *            position: 'left',
     *            fields: ['data1'],
     *            title: {
     *                text: 'Sample Values',
     *                fontSize: 15
     *            },
     *            grid: true,
     *            minimum: 0
     *        }, {
     *            type: 'category',
     *            position: 'bottom',
     *            fields: ['name'],
     *            title: {
     *                text: 'Sample Values',
     *                fontSize: 15
     *            }
     *        }],
     *        series: [{
     *            type: 'line',
     *            style: {
     *                stroke: '#30BDA7',
     *                lineWidth: 2
     *            },
     *            xField: 'name',
     *            yField: 'data1',
     *            marker: {
     *                type: 'path',
     *                path: ['M', - 4, 0, 0, 4, 4, 0, 0, - 4, 'Z'],
     *                stroke: '#30BDA7',
     *                lineWidth: 2,
     *                fill: 'white'
     *            }
     *        }, {
     *            type: 'line',
     *            fill: true,
     *            style: {
     *                fill: '#96D4C6',
     *                fillOpacity: .6,
     *                stroke: '#0A3F50',
     *                strokeOpacity: .6,
     *            },
     *            xField: 'name',
     *            yField: 'data2',
     *            marker: {
     *                type: 'circle',
     *                radius: 4,
     *                lineWidth: 2,
     *                fill: 'white'
     *            }
     *        }]
     *     });
     *
     * In this configuration we're adding two series (or lines), one bound to the 'data1'
     * property of the store and the other to 'data3'. The type for both configurations is
     * 'line'. The 'xField' for both series is the same, the 'name' property of the store.
     * Both line series share the same axis, the left axis. You can set particular marker
     * configuration by adding properties onto the marker object. Both series have
     * an object as highlight so that markers animate smoothly to the properties in highlight
     * when hovered. The second series has 'fill = true' which means that the line will also
     * have an area below it of the same color.
     *
     * **Note:** In the series definition remember to explicitly set the axis to bind the
     * values of the line series to. This can be done by using the 'axis' configuration property.
     */
    export class Line extends Ext.chart.series.Cartesian implements Ext.chart.series.LineConfig {
        seriesType: string;

        protected type: string;

        /**
         * If set to 'true', the area underneath the line is filled with the color defined as follows, listed by priority:
         * - The color that is configured for this series ({@link Ext.chart.series.Series#colors}).
         * - The color that is configured for this chart ({@link Ext.chart.AbstractChart#colors}).
         * - The fill color that is set in the {@link #style} config.
         * - The stroke color that is set in the {@link #style} config, or the same color as the line.
         *
         * Note: Do not confuse 'series.config.fill' (which is a boolean) with 'series.style.fill' (which is an alias
         * for the 'fillStyle' property and contains a color). For compatibility with previous versions of the API,
         * if 'config.fill' is undefined but a 'style.fill' color is provided, 'config.fill' is considered true.
         * So the default value below must be undefined, not false.
         */
        fill: boolean;

        /**
         * Possible values:
         * 'gap' - null points are rendered as gaps.
         * 'connect' - non-null points are connected across null points, so that
         * there is no gap, unless null points are at the beginning/end of the line.
         * Only the visible data points are connected - if a visible data point
         * is followed by a series of null points that go off screen and eventually
         * terminate with a non-null point, the connection won't be made.
         * 'origin' - null data points are rendered at the origin,
         * which is the y-coordinate of a point where the x and y axes meet.
         * This requires that at least the x-coordinate of a point is a valid value.
         *
         * Optional, Defaults to: "gap"
         */
        nullStyle: any;

        /**
         * The offset distance from the cursor position to the line series to trigger events (then used for highlighting series, etc).
         */
        selectionTolerance: number;

        /**
         * 'true' if the series' line should be smoothed.
         * Line smoothing only works with gapless data.
         */
        smooth: boolean;

        /**
         * If set to 'true', the line uses steps instead of straight lines to connect the dots.
         * It is ignored if 'smooth' is true.
         */
        step: boolean;

        /**
         * An object containing styles for the visualization lines. These styles will override the theme styles.
         * Some options contained within the style object will are described next.
         */
        style: any;

        /**
         * @abstract
         * @extends Ext.chart.series.Series
         *
         * Common base class for series implementations that plot values using cartesian coordinates.
         *
         * @constructor
         */
        constructor();

        getAggregator();

        getFill();

        getNullStyle();

        getSelectionTolerance();

        getSmooth();

        getStep();

        setAggregator();

        setFill();

        setNullStyle();

        setSelectionTolerance();

        setSmooth();

        setStep();
    }

    interface Pie3DConfig extends Ext.chart.series.PolarConfig {
        /**
         * (required)
         * The store record field name to be used for the pie angles.
         * The values bound to this field name must be positive real numbers.
         */
        angleField?: string;

        /**
         * Whether to set the pie chart as donut chart.
         * Can be set to a particular percentage to set the radius
         * of the donut chart.
         */
        donut?: boolean|number;

        /**
         * The starting angle of the pie slices.
         *
         * Optional, Defaults to: 0
         */
        rotation?: number;
    }

    /**
     * @extends Ext.chart.series.Polar
     *
     * Creates a 3D Pie Chart.
     *
     * **Note:** Labels, legends, and lines are not currently available when using the
     * 3D Pie chart series.
     *
     *     @example
     *     Ext.create({
     *        xtype: 'polar',
     *        renderTo: document.body,
     *        width: 600,
     *        height: 400,
     *        theme: 'green',
     *        interactions: 'rotate',
     *        store: {
     *            fields: ['data3'],
     *            data: [{
     *                'data3': 14
     *            }, {
     *                'data3': 16
     *            }, {
     *                'data3': 14
     *            }, {
     *                'data3': 6
     *            }, {
     *                'data3': 36
     *            }]
     *        },
     *        series: {
     *            type: 'pie3d',
     *            angleField: 'data3',
     *            donut: 30
     *        }
     *     });
     */
    export class Pie3D extends Ext.chart.series.Polar implements Ext.chart.series.Pie3DConfig {
        seriesType: string;

        protected type: string;

        /**
         * (required)
         * The store record field name to be used for the pie angles.
         * The values bound to this field name must be positive real numbers.
         */
        angleField: string;

        /**
         * Whether to set the pie chart as donut chart.
         * Can be set to a particular percentage to set the radius
         * of the donut chart.
         */
        donut: boolean|number;

        /**
         * The starting angle of the pie slices.
         *
         * Optional, Defaults to: 0
         */
        rotation: number;

        constructor(config: Ext.chart.series.PieConfig);

        getDistortion();

        getDonut();

        getHidden();

        getRect();

        getSprites();

        getThickness();

        setDistortion();

        setDonut();

        setHidden();

        setRect();

        setThickness();
    }

    interface PieConfig extends Ext.chart.series.PolarConfig {
        /**
         * Whether the pie slices are displayed clockwise. Default's true.
         */
        clockwise?: boolean;

        /**
         * Specifies the radius of the donut hole, as a percentage of the chart's radius.
         * Defaults to 0 (no donut hole).
         */
        donut?: number;

        /**
         * Allows adjustment of the radius by a specific percentage.
         *
         * Optional, Defaults to: 100
         */
        radiusFactor?: number;

        /**
         * The store record field name to be used for the pie slice lengths.
         * The values bound to this field name must be positive real numbers.
         */
        radiusField?: string;

        /**
         * The starting angle of the pie slices.
         */
        rotation?: number;

        style?: any;

        /**
         * The total angle of the pie series.
         *
         * Optional, Defaults to: 2*PI
         */
        totalAngle?: number;
    }

    /**
     * @extends Ext.chart.series.Polar
     *
     * Creates a Pie Chart. A Pie Chart is a useful visualization technique to display
     * quantitative information for different categories that also have a meaning as a whole.
     * As with all other series, the Pie Series must be appended in the *series* Chart array
     * configuration. See the Chart documentation for more information. A typical configuration
     * object for the pie series could be:
     *
     *     @example
     *     Ext.create({
     *        xtype: 'polar',
     *        renderTo: document.body,
     *        width: 400,
     *        height: 400,
     *        theme: 'green',
     *        interactions: ['rotate', 'itemhighlight'],
     *        store: {
     *            fields: ['name', 'data1'],
     *            data: [{
     *                name: 'metric one',
     *                data1: 14
     *            }, {
     *                name: 'metric two',
     *                data1: 16
     *            }, {
     *                name: 'metric three',
     *                data1: 14
     *            }, {
     *                name: 'metric four',
     *                data1: 6
     *            }, {
     *                name: 'metric five',
     *                data1: 36
     *            }]
     *        },
     *        series: {
     *            type: 'pie',
     *            highlight: true,
     *            angleField: 'data1',
     *            label: {
     *                field: 'name',
     *                display: 'rotate'
     *            },
     *            donut: 30
     *        }
     *     });
     *
     * In this configuration we set 'pie' as the type for the series, then set the 'highlight' config
     * to 'true' (we can also specify an object with specific style properties for highlighting options)
     * which is triggered when hovering or tapping elements.
     * We set 'data1' as the value of the 'angleField' to determine the angle span for each pie slice.
     * We also set a label configuration object where we set the name of the store field
     * to be rendered as text for the label. The labels will also be displayed rotated.
     * And finally, we specify the donut hole radius for the pie series in percentages of the series radius.
     */
    export class Pie extends Ext.chart.series.Polar implements Ext.chart.series.PieConfig {
        seriesType: string;

        protected type: string;

        /**
         * Whether the pie slices are displayed clockwise. Default's true.
         */
        clockwise: boolean;

        /**
         * Specifies the radius of the donut hole, as a percentage of the chart's radius.
         * Defaults to 0 (no donut hole).
         */
        donut: number;

        /**
         * Allows adjustment of the radius by a specific percentage.
         *
         * Optional, Defaults to: 100
         */
        radiusFactor: number;

        /**
         * The store record field name to be used for the pie slice lengths.
         * The values bound to this field name must be positive real numbers.
         */
        radiusField: string;

        /**
         * The starting angle of the pie slices.
         */
        rotation: number;

        style: any;

        /**
         * The total angle of the pie series.
         *
         * Optional, Defaults to: 2*PI
         */
        totalAngle: number;

        constructor(config: Ext.chart.series.PieConfig);

        getClockwise();

        getDonut();

        getHidden();

        /**
         * Returns the pie slice for a given angle
         * @param {Number} angle The angle to search for the slice
         * @return {Object} An object containing the reocord, sprite, scope etc.
         */
        getItemForAngle(angle: number): any;

        getRadiusFactor();

        getRotation();

        getSprites();

        getStyle();

        getTotalAngle();

        setClockwise();

        setDonut();

        setHidden();

        setRadiusFactor();

        setRotation();

        setStyle();

        setTotalAngle();
    }

    interface PolarConfig extends Ext.chart.series.SeriesConfig {
        /**
         * The store record field name for the angular axes in radar charts,
         * or the size of the slices in pie charts.
         */
        angleField?: string;

        /**
         * for the polar series.
         */
        center?: any[];

        /**
         * The x-offset of center of the polar series related to the center of the boundary.
         *
         * Optional, Defaults to: 0
         */
        offsetX?: number;

        /**
         * The y-offset of center of the polar series related to the center of the boundary.
         *
         * Optional, Defaults to: 0
         */
        offsetY?: number;

        /**
         * The radius of the polar series. Set to 'null' will fit the polar series to the boundary.
         */
        radius?: number;

        /**
         * The store record field name for the radial axes in radar charts,
         * or the radius of the slices in pie charts.
         */
        radiusField?: string;

        /**
         * The angle in degrees at which the first polar series item should start.
         *
         * Optional, Defaults to: 0
         */
        rotation?: number;

        /**
         * Whether to add the series elements as legend items.
         *
         * Optional, Defaults to: true
         */
        showInLegend?: boolean;
    }

    /**
     * @abstract
     * @extends Ext.chart.series.Series
     *
     * Common base class for series implementations that plot values using polar coordinates.
     */
    export class Polar extends Ext.chart.series.Series implements Ext.chart.series.PolarConfig {
        /**
         * The store record field name for the angular axes in radar charts,
         * or the size of the slices in pie charts.
         */
        angleField: string;

        /**
         * for the polar series.
         */
        center: any[];

        /**
         * The x-offset of center of the polar series related to the center of the boundary.
         *
         * Optional, Defaults to: 0
         */
        offsetX: number;

        /**
         * The y-offset of center of the polar series related to the center of the boundary.
         *
         * Optional, Defaults to: 0
         */
        offsetY: number;

        /**
         * The radius of the polar series. Set to 'null' will fit the polar series to the boundary.
         */
        radius: number;

        /**
         * The store record field name for the radial axes in radar charts,
         * or the radius of the slices in pie charts.
         */
        radiusField: string;

        /**
         * The angle in degrees at which the first polar series item should start.
         *
         * Optional, Defaults to: 0
         */
        rotation: number;

        /**
         * Whether to add the series elements as legend items.
         *
         * Optional, Defaults to: true
         */
        showInLegend: boolean;

        constructor(config: Ext.chart.series.PieConfig);

        getAngleField();

        getCenter();

        getOffsetX();

        getOffsetY();

        getRadius();

        getRadiusField();

        getRotation();

        getShowInLegend();

        getXAxis();

        getYAxis();

        setAngleField();

        setCenter();

        setOffsetX();

        setOffsetY();

        setRadius();

        setRadiusField();

        setRotation();

        setShowInLegend();

        setXAxis();

        setYAxis();
    }

    /**
     * @extends Ext.chart.series.Polar
     *
     * Creates a Radar Chart. A Radar Chart is a useful visualization technique for comparing different quantitative values for
     * a constrained number of categories.
     * As with all other series, the Radar series must be appended in the *series* Chart array configuration. See the Chart
     * documentation for more information. A typical configuration object for the radar series could be:
     *
     *     @example
     *     Ext.create({
     *        xtype: 'polar',
     *        renderTo: document.body,
     *        width: 500,
     *        height: 400,
     *        interactions: 'rotate',
     *        store: {
     *            fields: ['name', 'data1'],
     *            data: [{
     *                'name': 'metric one',
     *                'data1': 8
     *            }, {
     *                'name': 'metric two',
     *                'data1': 10
     *            }, {
     *                'name': 'metric three',
     *                'data1': 12
     *            }, {
     *                'name': 'metric four',
     *                'data1': 1
     *            }, {
     *                'name': 'metric five',
     *                'data1': 13
     *            }]
     *        },
     *        series: {
     *            type: 'radar',
     *            angleField: 'name',
     *            radiusField: 'data1',
     *            style: {
     *                fillStyle: '#388FAD',
     *                fillOpacity: .1,
     *                strokeStyle: '#388FAD',
     *                strokeOpacity: .8,
     *                lineWidth: 1
     *            }
     *        },
     *        axes: [{
     *            type: 'numeric',
     *            position: 'radial',
     *            fields: 'data1',
     *            style: {
     *                estStepSize: 10
     *            },
     *            grid: true
     *        }, {
     *            type: 'category',
     *            position: 'angular',
     *            fields: 'name',
     *            style: {
     *                estStepSize: 1
     *            },
     *            grid: true
     *        }]
     *     });
     */
    export class Radar extends Ext.chart.series.Polar {
        seriesType: string;

        protected type: string;

        constructor(config: Ext.chart.series.PieConfig);

        getSprites();
    }

    interface ScatterConfig extends Ext.chart.series.CartesianConfig {
    }

    /**
     * @extends Ext.chart.series.Cartesian
     *
     * Creates a Scatter Chart. The scatter plot is useful when trying to display more than two variables in the same visualization.
     * These variables can be mapped into x, y coordinates and also to an element's radius/size, color, etc.
     * As with all other series, the Scatter Series must be appended in the *series* Chart array configuration. See the Chart
     * documentation for more information on creating charts. A typical configuration object for the scatter could be:
     *
     *     @example
     *     Ext.create({
     *        xtype: 'cartesian',
     *        renderTo: document.body,
     *        width: 600,
     *        height: 400,
     *        insetPadding: 40,
     *        interactions: ['itemhighlight'],
     *        store: {
     *            fields: ['name', 'data1', 'data2'],
     *            data: [{
     *                'name': 'metric one',
     *                'data1': 10,
     *                'data2': 14
     *            }, {
     *                'name': 'metric two',
     *                'data1': 7,
     *                'data2': 16
     *            }, {
     *                'name': 'metric three',
     *                'data1': 5,
     *                'data2': 14
     *            }, {
     *                'name': 'metric four',
     *                'data1': 2,
     *                'data2': 6
     *            }, {
     *                'name': 'metric five',
     *                'data1': 27,
     *                'data2': 36
     *            }]
     *        },
     *        axes: [{
     *            type: 'numeric',
     *            position: 'left',
     *            fields: ['data1'],
     *            title: {
     *                text: 'Sample Values',
     *                fontSize: 15
     *            },
     *            grid: true,
     *            minimum: 0
     *        }, {
     *            type: 'category',
     *            position: 'bottom',
     *            fields: ['name'],
     *            title: {
     *                text: 'Sample Values',
     *                fontSize: 15
     *            }
     *        }],
     *        series: {
     *            type: 'scatter',
     *            highlight: {
     *                size: 12,
     *                radius: 12,
     *                fill: '#96D4C6',
     *                stroke: '#30BDA7'
     *            },
     *            fill: true,
     *            xField: 'name',
     *            yField: 'data2',
     *            marker: {
     *                type: 'circle',
     *                fill: '#30BDA7',
     *                radius: 10,
     *                lineWidth: 0
     *            }
     *        }
     *     });
     *
     * In this configuration we add three different categories of scatter series. Each of them is bound to a different field of the same data store,
     * 'data1', 'data2' and 'data3' respectively. All x-fields for the series must be the same field, in this case 'name'.
     * Each scatter series has a different styling configuration for markers, specified by the 'marker' object. Finally we set the left axis as
     * axis to show the current values of the elements.
     */
    export class Scatter extends Ext.chart.series.Cartesian implements Ext.chart.series.ScatterConfig {
        seriesType: string;

        protected type: string;

        protected itemInstancing: any;

        /**
         * @abstract
         * @extends Ext.chart.series.Series
         *
         * Common base class for series implementations that plot values using cartesian coordinates.
         *
         * @constructor
         */
        constructor();
    }

    interface SeriesConfig {
        /**
         * The series animation configuration.
         */
        animation?: any;

        /**
         * Sets the background of the surface the series is attached.
         */
        background?: any;

        /**
         * An array of color values which is used, in order of appearance, by the series. Each series
         * can request one or more colors from the array. Radar, Scatter or Line charts require just
         * one color each. Candlestick and OHLC require two (1 for drops + 1 for rises). Pie charts
         * and Stacked charts (like Column or Pie charts) require one color for each data category
         * they represent, so one color for each slice of a Pie chart or each segment of a Column chart.
         * It overrides the colors that are provided by the current theme.
         */
        colors?: any[];

        hidden?: boolean|any[];

        /**
         * The sprite attributes that will be applied to the highlighted items in the series.
         * If set to 'true', the default highlight style from {@link #highlightCfg} will be used.
         * If the value of this config is an object, it will be merged with the {@link #highlightCfg}.
         * In case merging of 'highlight' and 'highlightCfg' configs in not the desired behavior,
         * provide the 'highlightCfg' instead.
         */
        highlight?: boolean|any;

        /**
         * The item currently highlighted in the series.
         */
        highlightItem?: any;

        /**
         * Object with the following properties:
         *
         *
         * Specifies the presence and position of the labels. The possible values depend on the series type.
         * For Line and Scatter series: 'under' | 'over' | 'rotate'.
         * For Bar and 3D Bar series: 'insideStart' | 'insideEnd' | 'outside'.
         * For Pie series: 'outside' | 'rotate' | 'horizontal' | 'vertical'.
         * Area, Radar and Candlestick series don't support labels.
         * For Area and Radar series please consider using {@link #tooltip tooltips} instead.
         * 3D Pie series currently always display labels 'outside'.
         * For all series: 'none' hides the labels.
         *
         * Default value: 'none'.
         *
         *
         * The color of the label text.
         *
         * Default value: '#000' (black).
         *
         *
         * The name(s) of the field(s) to be displayed in the labels. If your chart has 3 series
         * that correspond to the fields 'a', 'b', and 'c' of your model, and you only want to
         * display labels for the series 'c', you must still provide an array '[null, null, 'c']'.
         *
         * Default value: null.
         *
         *
         * The font used for the labels.
         *
         * Default value: '14px Helvetica'.
         *
         *
         * Either 'horizontal' or 'vertical'. If not set (default), the orientation is inferred
         * from the value of the flipXY property of the series.
         *
         * Default value: ''.
         *
         *
         * Optional function for formatting the label into a displayable value.
         *
         * The arguments to the method are:
         *
         *   - *'text'*, *'sprite'*, *'config'*, *'rendererData'*, *'index'*
         *
         *     Label's renderer is passed the same arguments as {@link #renderer}
         *     plus one extra 'text' argument which comes first.
         *
         * @return {Object|String} The attributes that have been changed or added, or the text for the label.
         * Example to enclose every other label in parentheses:
         *
         *      renderer: function (text) {
         *          if (index % 2 == 0) {
         *              return '(' + text + ')'
         *          }
         *      }
         *
         * Default value: null.
         */
        label?: any;

        /**
         * Extra distance value for which the labelOverflow listener is triggered.
         */
        labelOverflowPadding?: number;

        /**
         * The sprite template used by marker instances on the series.
         * If the value of the marker config is set to 'true' or the type
         * of the sprite instance is not specified, the {@link Ext.draw.sprite.Circle}
         * sprite will be used.
         *
         * Examples:
         *
         *     marker: true
         *
         *     marker: {
         *         radius: 8
         *     }
         *
         *     marker: {
         *         type: 'arrow',
         *         fx: {
         *             duration: 200,
         *             easing: 'backOut'
         *         }
         *     }
         */
        marker?: any|boolean;

        /**
         * This is cyclic used if series have multiple marker sprites.
         */
        markerSubStyle?: any;

        /**
         * A function that can be provided to set custom styling properties to each rendered element.
         * It receives '(sprite, config, rendererData, index)' as parameters.
         *
         * @param {Object} sprite The sprite affected by the renderer. The visual attributes are in 'sprite.attr'.
         * The data field is available in 'sprite.getField()'.
         * @param {Object} config The sprite configuration. It varies with the series and the type of sprite:
         * for instance, a Line chart sprite might have just the 'x' and 'y' properties while a Bar
         * chart sprite also has 'width' and 'height'. A 'type' might be present too. For instance to
         * draw each marker and each segment of a Line chart, the renderer is called with the
         * 'config.type' set to either 'marker' or 'line'.
         * @param {Object} rendererData A record with different properties depending on the type of chart.
         * The only guaranteed property is 'rendererData.store', the store used by the series.
         * In some cases, a store may not exist: for instance a Gauge chart may read its value directly
         * from its configuration; in this case rendererData.store is null and the value is
         * available in rendererData.value.
         * @param {Number} index The index of the sprite. It is usually the index of the store record associated
         * with the sprite, in which case the record can be obtained with 'store.getData().items[index]'.
         * If the chart is not associated with a store, the index represents the index of the sprite within
         * the series. For instance a Gauge chart may have as many sprites as there are sectors in the
         * background of the gauge, plus one for the needle.
         *
         * @return {Object} The attributes that have been changed or added. Note: it is usually possible to
         * add or modify the attributes directly into the 'config' parameter and not return anything,
         * but returning an object with only those attributes that have been changed may allow for
         * optimizations in the rendering of some series. Example to draw every other marker in red:
         *
         *      renderer: function (sprite, config, rendererData, index) {
         *          if (config.type === 'marker') {
         *              return { strokeStyle: (index % 2 === 0 ? 'red' : 'black') };
         *          }
         *      }
         */
        renderer?: Function;

        /**
         * Whether to show this series in the legend.
         */
        showInLegend?: boolean;

        /**
         * Whether markers should be displayed at the data points along the line. If true,
         * then the {@link #marker} config item will determine the markers' styling.
         */
        showMarkers?: boolean;

        /**
         * Custom style configuration for the sprite used in the series.
         * It overrides the style that is provided by the current theme.
         */
        style?: any;

        /**
         * This is the cyclic used if the series has multiple sprites.
         */
        subStyle?: any;

        /**
         * The human-readable name of the series (displayed in the legend).
         */
        title?: string;

        /**
         * Add tooltips to the visualization's markers. The config options for the
         * tooltip are the same configuration used with {@link Ext.tip.ToolTip} plus a
         * 'renderer' config option and a 'scope' for the renderer. For example:
         *
         *     tooltip: {
         *       trackMouse: true,
         *       width: 140,
         *       height: 28,
         *       renderer: function (toolTip, record, ctx) {
         *           toolTip.setHtml(record.get('name') + ': ' + record.get('data1') + ' views');
         *       }
         *     }
         *
         * Note that tooltips are shown for series markers and won't work
         * if the {@link #marker} is not configured.
         * The scope to use when the renderer function is
         * called.  Defaults to the Series instance.
         * An 'interceptor' method which can be used to
         * modify the tooltip attributes before it is shown.  The renderer function is
         * passed the following params:
         * The tooltip instance
         * The record instance for the
         * chart item (sprite) currently targeted by the tooltip.
         * A data object with values relating to the
         * currently targeted chart sprite
         * The type of sprite passed to the
         * renderer function (will be "items", "markers", or "labels" depending on the
         * target sprite of the tooltip)
         * The {@link #yField} for the series
         * The target sprite's index within the
         * series' items
         * The record instance for the
         * chart item (sprite) currently targeted by the tooltip.
         * The series instance
         * containing the tooltip's target sprite
         * The sprite (item)
         * target of the tooltip
         */
        tooltip?: any;

        /**
         * Colors for the series can be set directly through the 'colors' config, or indirectly
         * with the current theme or the 'colors' config that is set onto the chart. These colors
         * are used as "fill color". Set this config to true, if you want a darker color for the
         * strokes. Set it to false if you want to use the same color as the fill color.
         * Alternatively, you can set it to a number between 0 and 1 to control how much darker
         * the strokes should be.
         * Note: this should be initial config and cannot be changed later on.
         */
        useDarkerStrokeColor?: boolean|number;
    }

    /**
     * Series is the abstract class containing the common logic to all chart series. Series includes
     * methods from Labels, Highlights, and Callouts mixins. This class implements the logic of
     * animating, hiding, showing all elements and returning the color of the series to be used as a legend item.
     *
     * ## Listeners
     *
     * The series class supports listeners via the Observable syntax.
     *
     * For example:
     *
     *     Ext.create('Ext.chart.CartesianChart', {
     *         plugins: {
     *             ptype: 'chartitemevents',
     *             moveEvents: true
     *         },
     *         store: {
     *             fields: ['pet', 'households', 'total'],
     *             data: [
     *                 {pet: 'Cats', households: 38, total: 93},
     *                 {pet: 'Dogs', households: 45, total: 79},
     *                 {pet: 'Fish', households: 13, total: 171}
     *             ]
     *         },
     *         axes: [{
     *             type: 'numeric',
     *             position: 'left'
     *         }, {
     *             type: 'category',
     *             position: 'bottom'
     *         }],
     *         series: [{
     *             type: 'bar',
     *             xField: 'pet',
     *             yField: 'households',
     *             listeners: {
     *                 itemmousemove: function (series, item, event) {
     *                     console.log('itemmousemove', item.category, item.field);
     *                 }
     *             }
     *         }, {
     *             type: 'line',
     *             xField: 'pet',
     *             yField: 'total',
     *             marker: true
     *         }]
     *     });
     */
    export class Series extends Ext.Base implements Ext.chart.series.SeriesConfig {
        protected defaultBindProperty: any;

        /**
         * Default series sprite type.
         */
        seriesType: string;

        /**
         * The type of series. Set in subclasses.
         */
        protected type: string;

        /**
         * The series animation configuration.
         */
        animation: any;

        /**
         * Sets the background of the surface the series is attached.
         */
        background: any;

        /**
         * An array of color values which is used, in order of appearance, by the series. Each series
         * can request one or more colors from the array. Radar, Scatter or Line charts require just
         * one color each. Candlestick and OHLC require two (1 for drops + 1 for rises). Pie charts
         * and Stacked charts (like Column or Pie charts) require one color for each data category
         * they represent, so one color for each slice of a Pie chart or each segment of a Column chart.
         * It overrides the colors that are provided by the current theme.
         */
        colors: any[];

        hidden: boolean|any[];

        /**
         * The sprite attributes that will be applied to the highlighted items in the series.
         * If set to 'true', the default highlight style from {@link #highlightCfg} will be used.
         * If the value of this config is an object, it will be merged with the {@link #highlightCfg}.
         * In case merging of 'highlight' and 'highlightCfg' configs in not the desired behavior,
         * provide the 'highlightCfg' instead.
         */
        highlight: boolean|any;

        /**
         * The default style for the highlighted item.
         * Used when {@link #highlight} config was simply set to 'true' instead of specifying a style.
         */
        protected highlightCfg: any;

        /**
         * The item currently highlighted in the series.
         */
        highlightItem: any;

        /**
         * The sprite template used to create sprite instances in the series.
         */
        protected itemInstancing: any;

        /**
         * Object with the following properties:
         *
         *
         * Specifies the presence and position of the labels. The possible values depend on the series type.
         * For Line and Scatter series: 'under' | 'over' | 'rotate'.
         * For Bar and 3D Bar series: 'insideStart' | 'insideEnd' | 'outside'.
         * For Pie series: 'outside' | 'rotate' | 'horizontal' | 'vertical'.
         * Area, Radar and Candlestick series don't support labels.
         * For Area and Radar series please consider using {@link #tooltip tooltips} instead.
         * 3D Pie series currently always display labels 'outside'.
         * For all series: 'none' hides the labels.
         *
         * Default value: 'none'.
         *
         *
         * The color of the label text.
         *
         * Default value: '#000' (black).
         *
         *
         * The name(s) of the field(s) to be displayed in the labels. If your chart has 3 series
         * that correspond to the fields 'a', 'b', and 'c' of your model, and you only want to
         * display labels for the series 'c', you must still provide an array '[null, null, 'c']'.
         *
         * Default value: null.
         *
         *
         * The font used for the labels.
         *
         * Default value: '14px Helvetica'.
         *
         *
         * Either 'horizontal' or 'vertical'. If not set (default), the orientation is inferred
         * from the value of the flipXY property of the series.
         *
         * Default value: ''.
         *
         *
         * Optional function for formatting the label into a displayable value.
         *
         * The arguments to the method are:
         *
         *   - *'text'*, *'sprite'*, *'config'*, *'rendererData'*, *'index'*
         *
         *     Label's renderer is passed the same arguments as {@link #renderer}
         *     plus one extra 'text' argument which comes first.
         *
         * @return {Object|String} The attributes that have been changed or added, or the text for the label.
         * Example to enclose every other label in parentheses:
         *
         *      renderer: function (text) {
         *          if (index % 2 == 0) {
         *              return '(' + text + ')'
         *          }
         *      }
         *
         * Default value: null.
         */
        label: any;

        /**
         * Extra distance value for which the labelOverflow listener is triggered.
         */
        labelOverflowPadding: number;

        /**
         * The sprite template used by marker instances on the series.
         * If the value of the marker config is set to 'true' or the type
         * of the sprite instance is not specified, the {@link Ext.draw.sprite.Circle}
         * sprite will be used.
         *
         * Examples:
         *
         *     marker: true
         *
         *     marker: {
         *         radius: 8
         *     }
         *
         *     marker: {
         *         type: 'arrow',
         *         fx: {
         *             duration: 200,
         *             easing: 'backOut'
         *         }
         *     }
         */
        marker: any|boolean;

        /**
         * This is cyclic used if series have multiple marker sprites.
         */
        markerSubStyle: any;

        /**
         * The surface used to render series labels.
         */
        protected overlaySurface: any;

        /**
         * A function that can be provided to set custom styling properties to each rendered element.
         * It receives '(sprite, config, rendererData, index)' as parameters.
         *
         * @param {Object} sprite The sprite affected by the renderer. The visual attributes are in 'sprite.attr'.
         * The data field is available in 'sprite.getField()'.
         * @param {Object} config The sprite configuration. It varies with the series and the type of sprite:
         * for instance, a Line chart sprite might have just the 'x' and 'y' properties while a Bar
         * chart sprite also has 'width' and 'height'. A 'type' might be present too. For instance to
         * draw each marker and each segment of a Line chart, the renderer is called with the
         * 'config.type' set to either 'marker' or 'line'.
         * @param {Object} rendererData A record with different properties depending on the type of chart.
         * The only guaranteed property is 'rendererData.store', the store used by the series.
         * In some cases, a store may not exist: for instance a Gauge chart may read its value directly
         * from its configuration; in this case rendererData.store is null and the value is
         * available in rendererData.value.
         * @param {Number} index The index of the sprite. It is usually the index of the store record associated
         * with the sprite, in which case the record can be obtained with 'store.getData().items[index]'.
         * If the chart is not associated with a store, the index represents the index of the sprite within
         * the series. For instance a Gauge chart may have as many sprites as there are sectors in the
         * background of the gauge, plus one for the needle.
         *
         * @return {Object} The attributes that have been changed or added. Note: it is usually possible to
         * add or modify the attributes directly into the 'config' parameter and not return anything,
         * but returning an object with only those attributes that have been changed may allow for
         * optimizations in the rendering of some series. Example to draw every other marker in red:
         *
         *      renderer: function (sprite, config, rendererData, index) {
         *          if (config.type === 'marker') {
         *              return { strokeStyle: (index % 2 === 0 ? 'red' : 'black') };
         *          }
         *      }
         */
        renderer: Function;

        /**
         * Whether to show this series in the legend.
         */
        showInLegend: boolean;

        /**
         * Whether markers should be displayed at the data points along the line. If true,
         * then the {@link #marker} config item will determine the markers' styling.
         */
        showMarkers: boolean;

        /**
         * The store of values used in the series.
         */
        protected store: any;

        /**
         * Custom style configuration for the sprite used in the series.
         * It overrides the style that is provided by the current theme.
         */
        style: any;

        /**
         * This is the cyclic used if the series has multiple sprites.
         */
        subStyle: any;

        /**
         * The surface that the series is attached.
         */
        protected surface: any;

        /**
         * The human-readable name of the series (displayed in the legend).
         */
        title: string;

        /**
         * Add tooltips to the visualization's markers. The config options for the
         * tooltip are the same configuration used with {@link Ext.tip.ToolTip} plus a
         * 'renderer' config option and a 'scope' for the renderer. For example:
         *
         *     tooltip: {
         *       trackMouse: true,
         *       width: 140,
         *       height: 28,
         *       renderer: function (toolTip, record, ctx) {
         *           toolTip.setHtml(record.get('name') + ': ' + record.get('data1') + ' views');
         *       }
         *     }
         *
         * Note that tooltips are shown for series markers and won't work
         * if the {@link #marker} is not configured.
         * The scope to use when the renderer function is
         * called.  Defaults to the Series instance.
         * An 'interceptor' method which can be used to
         * modify the tooltip attributes before it is shown.  The renderer function is
         * passed the following params:
         * The tooltip instance
         * The record instance for the
         * chart item (sprite) currently targeted by the tooltip.
         * A data object with values relating to the
         * currently targeted chart sprite
         * The type of sprite passed to the
         * renderer function (will be "items", "markers", or "labels" depending on the
         * target sprite of the tooltip)
         * The {@link #yField} for the series
         * The target sprite's index within the
         * series' items
         * The record instance for the
         * chart item (sprite) currently targeted by the tooltip.
         * The series instance
         * containing the tooltip's target sprite
         * The sprite (item)
         * target of the tooltip
         */
        tooltip: any;

        /**
         * Colors for the series can be set directly through the 'colors' config, or indirectly
         * with the current theme or the 'colors' config that is set onto the chart. These colors
         * are used as "fill color". Set this config to true, if you want a darker color for the
         * strokes. Set it to false if you want to use the same color as the fill color.
         * Alternatively, you can set it to a number between 0 and 1 to control how much darker
         * the strokes should be.
         * Note: this should be initial config and cannot be changed later on.
         */
        useDarkerStrokeColor: boolean|number;

        constructor(config: Ext.chart.series.GaugeConfig);

        destroy();

        getBackground();

        getColors();

        getHidden();

        getHighlight();

        protected getHighlightCfg();

        getHighlightItem();

        /**
         * Returns a series item by index and (optional) category.
         * @param {Number} index The index of the item (matches store record index).
         * @param {String} [category] The category of item, e.g.: 'items', 'markers', 'sprites'.
         * @return {Object} item
         */
        getItemByIndex(index: number, category?: string): any;

        /**
         * For a given x/y point relative to the main rect, find a corresponding item from this
         * series, if any.
         * @param {Object} [target] optional target to receive the result
         * @return {Object} An object describing the item, or null if there is no matching item. The exact contents of
         * this object will vary by series type, but should always contain at least the following:
         *
         * @return {Ext.data.Model} return.record the record of the item.
         * @return {Array} return.point the x/y coordinates relative to the chart box of a single point
         * for this data item, which can be used as e.g. a tooltip anchor point.
         * @return {Ext.draw.sprite.Sprite} return.sprite the item's rendering Sprite.
         * @return {Number} return.subSprite the index if sprite is an instancing sprite.
         */
        getItemForPoint(x: number, y: number, target?: any): any;

        protected getItemInstancing();

        getLabel();

        getLabelOverflowPadding();

        getMarker();

        getMarkerSubStyle();

        protected getOverlaySurface();

        getRenderer();

        getShowInLegend();

        getShowMarkers();

        /**
         * Returns sprites the are used to draw this series.
         */
        getSprites();

        getStyle();

        getSubStyle();

        protected getSurface();

        getTitle();

        getTooltip();

        getUseDarkerStrokeColor();

        lookupViewModel(skipThis: any);

        /**
         * Provide legend information to target array.
         *
         *
         * The information consists:
         */
        provideLegendInfo(target: any[], target_name: string, target_markColor: string, target_disabled: boolean, target_series: string, target_index: number);

        protected resolveListenerScope(defaultScope: any);

        setAnimation();

        setBackground();

        setColors();

        setHidden();

        setHiddenByIndex(index: number, value: boolean);

        setHighlight();

        protected setHighlightCfg();

        setHighlightItem();

        protected setItemInstancing();

        setLabel();

        setLabelOverflowPadding();

        setMarker();

        setMarkerSubStyle();

        protected setOverlaySurface();

        setRenderer();

        setShowInLegend();

        setShowMarkers();

        protected setStore();

        setStyle();

        setSubStyle();

        protected setSurface();

        setTitle();

        setTooltip();

        setUseDarkerStrokeColor();

        /**
         * Fires when the {@link Ext.chart.AbstractChart} has been attached to this series.
         */
        chartattached(chart: Ext.chart.AbstractChart, series: Ext.chart.series.Series);

        /**
         * Fires when the {@link Ext.chart.AbstractChart} has been detached from this series.
         */
        chartdetached(chart: Ext.chart.AbstractChart, series: Ext.chart.series.Series);

        /**
         * Fires when a click event occurs on a series item.
         * *Note*: This event requires the {@link Ext.chart.plugin.ItemEvents chartitemevents}
         * plugin be added to the chart.
         */
        itemclick(series: Ext.chart.series.Series, item: any, event: Event);

        /**
         * Fires when a double click event occurs on a series item.
         * *Note*: This event requires the {@link Ext.chart.plugin.ItemEvents chartitemevents}
         * plugin be added to the chart.
         */
        itemdblclick(series: Ext.chart.series.Series, item: any, event: Event);

        /**
         * Fires when a mousedown event occurs on a series item.
         * *Note*: This event requires the {@link Ext.chart.plugin.ItemEvents chartitemevents}
         * plugin be added to the chart.
         */
        itemmousedown(series: Ext.chart.series.Series, item: any, event: Event);

        /**
         * Fires when the mouse is moved on a series item.
         * *Note*: This event requires the {@link Ext.chart.plugin.ItemEvents chartitemevents}
         * plugin be added to the chart.
         */
        itemmousemove(series: Ext.chart.series.Series, item: any, event: Event);

        /**
         * Fires when the mouse exits a series item.
         * *Note*: This event requires the {@link Ext.chart.plugin.ItemEvents chartitemevents}
         * plugin be added to the chart.
         */
        itemmouseout(series: Ext.chart.series.Series, item: any, event: Event);

        /**
         * Fires when the mouse enters a series item.
         * *Note*: This event requires the {@link Ext.chart.plugin.ItemEvents chartitemevents}
         * plugin be added to the chart.
         */
        itemmouseover(series: Ext.chart.series.Series, item: any, event: Event);

        /**
         * Fires when a mouseup event occurs on a series item.
         * *Note*: This event requires the {@link Ext.chart.plugin.ItemEvents chartitemevents}
         * plugin be added to the chart.
         */
        itemmouseup(series: Ext.chart.series.Series, item: any, event: Event);

        /**
         * Fires when a tap event occurs on a series item.
         * *Note*: This event requires the {@link Ext.chart.plugin.ItemEvents chartitemevents}
         * plugin be added to the chart.
         */
        itemtap(series: Ext.chart.series.Series, item: any, event: Event);

        /**
         * Fires when the store of the series changes.
         */
        storechange(series: Ext.chart.series.Series, newStore: Ext.data.Store, oldStore: Ext.data.Store);
    }

    interface StackedCartesianConfig extends Ext.chart.series.CartesianConfig {
        /**
         * If 'true', the height of a stacked bar is always the full height of the chart,
         * with individual components viewed as shares of the whole determined by the
         * {@link #fullStackTotal} config.
         *
         * Optional, Defaults to: false
         */
        fullStack?: boolean;

        /**
         * If the {@link #fullStack} config is set to 'true', this will determine
         * the absolute total value of each stack.
         *
         * Optional, Defaults to: 100
         */
        fullStackTotal?: boolean;

        /**
         * 'true' to stack negative/positive values in respective y-axis directions.
         *
         * Optional, Defaults to: true
         */
        splitStacks?: boolean;

        /**
         * 'true' to display the series in its stacked configuration.
         *
         * Optional, Defaults to: true
         */
        stacked?: boolean;
    }

    /**
     * @abstract
     * @extends Ext.chart.series.Cartesian
     * Abstract class for all the stacked cartesian series including area series
     * and bar series.
     */
    export class StackedCartesian extends Ext.chart.series.Cartesian implements Ext.chart.series.StackedCartesianConfig {
        /**
         * If 'true', the height of a stacked bar is always the full height of the chart,
         * with individual components viewed as shares of the whole determined by the
         * {@link #fullStackTotal} config.
         *
         * Optional, Defaults to: false
         */
        fullStack: boolean;

        /**
         * If the {@link #fullStack} config is set to 'true', this will determine
         * the absolute total value of each stack.
         *
         * Optional, Defaults to: 100
         */
        fullStackTotal: boolean;

        /**
         * 'true' to stack negative/positive values in respective y-axis directions.
         *
         * Optional, Defaults to: true
         */
        splitStacks: boolean;

        /**
         * 'true' to display the series in its stacked configuration.
         *
         * Optional, Defaults to: true
         */
        stacked: boolean;

        /**
         * @abstract
         * @extends Ext.chart.series.Series
         *
         * Common base class for series implementations that plot values using cartesian coordinates.
         *
         * @constructor
         */
        constructor();

        getFullStack();

        getFullStackTotal();

        getHidden();

        getSplitStacks();

        getSprites();

        getStacked();

        setFullStack();

        setFullStackTotal();

        setHidden();

        setSplitStacks();

        setStacked();
    }
}

declare module Ext.chart.series.sprite {
    interface AggregativeConfig extends Ext.chart.series.sprite.CartesianConfig {
        /**
         * Data items representing the closing values of the aggregated data.
         *
         * Optional, Defaults to: null
         */
        dataClose?: any;

        /**
         * Data items representing the high values of the aggregated data.
         *
         * Optional, Defaults to: null
         */
        dataHigh?: any;

        /**
         * Data items representing the low values of the aggregated data.
         *
         * Optional, Defaults to: null
         */
        dataLow?: any;

        /**
         * Data items representing the opening values of the aggregated data.
         *
         * Optional, Defaults to: null
         */
        dataOpen?: any;
    }

    export class Aggregative extends Ext.chart.series.sprite.Cartesian implements Ext.chart.series.sprite.AggregativeConfig {
        /**
         * Data items representing the closing values of the aggregated data.
         *
         * Optional, Defaults to: null
         */
        dataClose: any;

        /**
         * Data items representing the high values of the aggregated data.
         *
         * Optional, Defaults to: null
         */
        dataHigh: any;

        /**
         * Data items representing the low values of the aggregated data.
         *
         * Optional, Defaults to: null
         */
        dataLow: any;

        /**
         * Data items representing the opening values of the aggregated data.
         *
         * Optional, Defaults to: null
         */
        dataOpen: any;

        constructor();

        getAggregator();

        setAggregator();
    }

    interface AreaConfig extends Ext.chart.series.sprite.CartesianConfig {
        /**
         * 'true' if the area is represented with steps instead of lines.
         *
         * Optional, Defaults to: false
         */
        step?: boolean;
    }

    /**
     * @extends Ext.chart.series.sprite.StackedCartesian
     *
     * Area series sprite.
     */
    export class Area extends Ext.chart.series.sprite.StackedCartesian implements Ext.chart.series.sprite.AreaConfig {
        /**
         * 'true' if the area is represented with steps instead of lines.
         *
         * Optional, Defaults to: false
         */
        step: boolean;

        constructor(config: Ext.chart.axis.sprite.AxisConfig);
    }

    interface Bar3DConfig extends Ext.chart.series.sprite.BarConfig {
        /**
         * The factor applied to the brightness of the bars.
         *
         * Optional, Defaults to: 1
         */
        brightnessFactor?: number;

        /**
         * An attribute used to control how flat the bar gradient looks.
         * A value of 0 essentially means no gradient (flat color).
         *
         * Optional, Defaults to: 1
         */
        colorSpread?: number;

        /**
         * The factor applied to the saturation of the bars.
         *
         * Optional, Defaults to: 1
         */
        saturationFactor?: number;
    }

    /**
     * @extends Ext.chart.series.sprite.Bar
     *
     * Draws a sprite used in {@link Ext.chart.series.Bar3D} series.
     */
    export class Bar3D extends Ext.chart.series.sprite.Bar implements Ext.chart.series.sprite.Bar3DConfig {
        /**
         * The factor applied to the brightness of the bars.
         *
         * Optional, Defaults to: 1
         */
        brightnessFactor: number;

        /**
         * An attribute used to control how flat the bar gradient looks.
         * A value of 0 essentially means no gradient (flat color).
         *
         * Optional, Defaults to: 1
         */
        colorSpread: number;

        /**
         * The factor applied to the saturation of the bars.
         *
         * Optional, Defaults to: 1
         */
        saturationFactor: number;

        constructor(config: Ext.chart.axis.sprite.AxisConfig);

        getShowStroke();

        setShowStroke();
    }

    interface BarConfig extends Ext.chart.series.sprite.CartesianConfig {
        /**
         * The gap between grouped bars.
         *
         * Optional, Defaults to: 3
         */
        inGroupGapWidth?: number;

        /**
         * The maximum bar width.
         *
         * Optional, Defaults to: 100
         */
        maxBarWidth?: number;

        /**
         * The minimum bar width.
         *
         * Optional, Defaults to: 2
         */
        minBarWidth?: number;

        /**
         * The minimum gap between bars.
         *
         * Optional, Defaults to: 5
         */
        minGapWidth?: number;

        /**
         * The degree of rounding for rounded bars.
         *
         * Optional, Defaults to: 0
         */
        radius?: number;
    }

    /**
     * @extends Ext.chart.series.sprite.StackedCartesian
     *
     * Draws a sprite used in the bar series.
     */
    export class Bar extends Ext.chart.series.sprite.StackedCartesian implements Ext.chart.series.sprite.BarConfig {
        /**
         * The gap between grouped bars.
         *
         * Optional, Defaults to: 3
         */
        inGroupGapWidth: number;

        /**
         * The maximum bar width.
         *
         * Optional, Defaults to: 100
         */
        maxBarWidth: number;

        /**
         * The minimum bar width.
         *
         * Optional, Defaults to: 2
         */
        minBarWidth: number;

        /**
         * The minimum gap between bars.
         *
         * Optional, Defaults to: 5
         */
        minGapWidth: number;

        /**
         * The degree of rounding for rounded bars.
         *
         * Optional, Defaults to: 0
         */
        radius: number;

        constructor(config: Ext.chart.axis.sprite.AxisConfig);
    }

    interface BoxConfig extends Ext.draw.sprite.SpriteConfig {
        /**
         * The factor applied to the brightness of the box.
         *
         * Optional, Defaults to: 1
         */
        brightnessFactor?: number;

        /**
         * An attribute used to control how flat the bar gradient looks.
         * A value of 0 essentially means no gradient (flat color).
         *
         * Optional, Defaults to: 1
         */
        colorSpread?: number;

        /**
         * The depth of the box.
         *
         * Optional, Defaults to: 8
         */
        depth?: number;

        /**
         * The height of the box.
         *
         * Optional, Defaults to: 8
         */
        height?: number;

        /**
         * The orientation of the box.
         *
         * Optional, Defaults to: 'vertical'
         */
        orientation?: string;

        /**
         * The factor applied to the saturation of the box.
         *
         * Optional, Defaults to: 1
         */
        saturationFactor?: number;

        /**
         * Whether to render the stroke or not.
         *
         * Optional, Defaults to: false
         */
        showStroke?: boolean;

        /**
         * The width of the box.
         *
         * Optional, Defaults to: 8
         */
        width?: number;

        /**
         * The position of the sprite on the x-axis.
         * Corresponds to the center of the front face of the box.
         *
         * Optional, Defaults to: 0
         */
        x?: number;

        /**
         * The position of the sprite on the y-axis.
         * Corresponds to the top of the front face of the box.
         *
         * Optional, Defaults to: 0
         */
        y?: number;
    }

    /**
     * @extends Ext.draw.sprite.Sprite
     *
     * A sprite that represents a 3D bar or column.
     * Used as an item template by the {@link Ext.chart.series.sprite.Bar3D} marker holder.
     */
    export class Box extends Ext.draw.sprite.Sprite implements Ext.chart.series.sprite.BoxConfig {
        /**
         * The factor applied to the brightness of the box.
         *
         * Optional, Defaults to: 1
         */
        brightnessFactor: number;

        /**
         * An attribute used to control how flat the bar gradient looks.
         * A value of 0 essentially means no gradient (flat color).
         *
         * Optional, Defaults to: 1
         */
        colorSpread: number;

        /**
         * The depth of the box.
         *
         * Optional, Defaults to: 8
         */
        depth: number;

        /**
         * The height of the box.
         *
         * Optional, Defaults to: 8
         */
        height: number;

        /**
         * The orientation of the box.
         *
         * Optional, Defaults to: 'vertical'
         */
        orientation: string;

        /**
         * The factor applied to the saturation of the box.
         *
         * Optional, Defaults to: 1
         */
        saturationFactor: number;

        /**
         * Whether to render the stroke or not.
         *
         * Optional, Defaults to: false
         */
        showStroke: boolean;

        /**
         * The width of the box.
         *
         * Optional, Defaults to: 8
         */
        width: number;

        /**
         * The position of the sprite on the x-axis.
         * Corresponds to the center of the front face of the box.
         *
         * Optional, Defaults to: 0
         */
        x: number;

        /**
         * The position of the sprite on the y-axis.
         * Corresponds to the top of the front face of the box.
         *
         * Optional, Defaults to: 0
         */
        y: number;

        constructor(config: Ext.chart.series.sprite.BoxConfig);

        protected updatePlainBBox(plain: any);
    }

    interface CandleStickConfig extends Ext.chart.series.sprite.AggregativeConfig {
        /**
         * The bar width of the candles.
         *
         * Optional, Defaults to: 15
         */
        barWidth?: number;

        /**
         * Determines whether candlestick or ohlc is used.
         *
         * Optional, Defaults to: 'candlestick'
         */
        ohlcType?: string;

        /**
         * The amount of padding between candles.
         *
         * Optional, Defaults to: 3
         */
        padding?: number;
    }

    /**
     * @extends Ext.chart.series.sprite.Aggregative
     *
     * CandleStick series sprite.
     */
    export class CandleStick extends Ext.chart.series.sprite.Aggregative implements Ext.chart.series.sprite.CandleStickConfig {
        /**
         * The bar width of the candles.
         *
         * Optional, Defaults to: 15
         */
        barWidth: number;

        /**
         * Determines whether candlestick or ohlc is used.
         *
         * Optional, Defaults to: 'candlestick'
         */
        ohlcType: string;

        /**
         * The amount of padding between candles.
         *
         * Optional, Defaults to: 3
         */
        padding: number;

        constructor();
    }

    interface CartesianConfig extends Ext.draw.sprite.SpriteConfig {
        /**
         * If flipXY is 'true', the series is flipped.
         */
        flipXY?: boolean;

        /**
         * Padding around labels to determine overlap.
         *
         * Optional, Defaults to: 10
         */
        labelOverflowPadding?: number;

        /**
         * Labels used in the series.
         *
         * Optional, Defaults to: null
         */
        labels?: any;

        /**
         * The distance from the event position to the sprite's data points to trigger interactions (used for 'iteminfo', etc).
         *
         * Optional, Defaults to: 20
         */
        selectionTolerance?: number;
    }

    /**
     * @extends Ext.draw.sprite.Sprite
     *
     * Cartesian sprite.
     */
    export class Cartesian extends Ext.draw.sprite.Sprite implements Ext.chart.series.sprite.CartesianConfig {
        /**
         * If flipXY is 'true', the series is flipped.
         */
        flipXY: boolean;

        /**
         * Padding around labels to determine overlap.
         *
         * Optional, Defaults to: 10
         */
        labelOverflowPadding: number;

        /**
         * Labels used in the series.
         *
         * Optional, Defaults to: null
         */
        labels: any;

        /**
         * The distance from the event position to the sprite's data points to trigger interactions (used for 'iteminfo', etc).
         *
         * Optional, Defaults to: 20
         */
        selectionTolerance: number;

        /**
         * Does a binary search of the data on the x-axis using the given key.
         * @return {*}
         */
        binarySearch(key: string): any;

        constructor(config: Ext.chart.axis.sprite.AxisConfig);

        /**
         * Get the nearest item index from point (x, y). -1 as not found.
         * @return {Number} The index
         */
        getIndexNearPoint(x: number, y: number): number;

        /**
         * Render the given visible clip range.
         */
        renderClipped(surface: Ext.draw.Surface, ctx: Ext.draw.engine.Canvas|Ext.draw.engine.SvgContext, clip: any[], rect: any[]);

        protected updatePlainBBox(plain: any);
    }

    interface LineConfig extends Ext.chart.series.sprite.AggregativeConfig {
        /**
         * 'true' if the sprite paints the area underneath the line.
         *
         * Optional, Defaults to: false
         */
        fillArea?: boolean;

        /**
         * Possible values:
         * 'gap' - null points are rendered as gaps.
         * 'connect' - non-null points are connected across null points, so that
         * there is no gap, unless null points are at the beginning/end of the line.
         * Only the visible data points are connected - if a visible data point
         * is followed by a series of null points that go off screen and eventually
         * terminate with a non-null point, the connection won't be made.
         * 'origin' - null data points are rendered at the origin,
         * which is the y-coordinate of a point where the x and y axes meet.
         * This requires that at least the x-coordinate of a point is a valid value.
         *
         * Optional, Defaults to: "gap"
         */
        nullStyle?: any;

        /**
         * 'true' if the line uses precise stroke.
         *
         * Optional, Defaults to: true
         */
        preciseStroke?: boolean;

        /**
         * 'true' if the sprite uses line smoothing.
         * Line smoothing only works with gapless data.
         *
         * Optional, Defaults to: false
         */
        smooth?: boolean;

        /**
         * 'true' if the line uses steps instead of straight lines to connect the dots.
         * It is ignored if 'smooth' is 'true'.
         *
         * Optional, Defaults to: false
         */
        step?: boolean;

        /**
         * Absolute maximum y-value.
         * Larger values will be capped to avoid rendering issues.
         *
         * Optional, Defaults to: Math.pow(2, 20)
         */
        yCap?: number;
    }

    /**
     * @extends Ext.chart.series.sprite.Aggregative
     *
     * Line series sprite.
     */
    export class Line extends Ext.chart.series.sprite.Aggregative implements Ext.chart.series.sprite.LineConfig {
        /**
         * 'true' if the sprite paints the area underneath the line.
         *
         * Optional, Defaults to: false
         */
        fillArea: boolean;

        /**
         * Possible values:
         * 'gap' - null points are rendered as gaps.
         * 'connect' - non-null points are connected across null points, so that
         * there is no gap, unless null points are at the beginning/end of the line.
         * Only the visible data points are connected - if a visible data point
         * is followed by a series of null points that go off screen and eventually
         * terminate with a non-null point, the connection won't be made.
         * 'origin' - null data points are rendered at the origin,
         * which is the y-coordinate of a point where the x and y axes meet.
         * This requires that at least the x-coordinate of a point is a valid value.
         *
         * Optional, Defaults to: "gap"
         */
        nullStyle: any;

        /**
         * 'true' if the line uses precise stroke.
         *
         * Optional, Defaults to: true
         */
        preciseStroke: boolean;

        /**
         * 'true' if the sprite uses line smoothing.
         * Line smoothing only works with gapless data.
         *
         * Optional, Defaults to: false
         */
        smooth: boolean;

        /**
         * 'true' if the line uses steps instead of straight lines to connect the dots.
         * It is ignored if 'smooth' is 'true'.
         *
         * Optional, Defaults to: false
         */
        step: boolean;

        /**
         * Absolute maximum y-value.
         * Larger values will be capped to avoid rendering issues.
         *
         * Optional, Defaults to: Math.pow(2, 20)
         */
        yCap: number;

        constructor();

        protected updatePlainBBox(plain: any);
    }

    interface Pie3DPartConfig extends Ext.draw.sprite.PathConfig {
        /**
         * The color of the 3D pie part before adding the 3D effect.
         *
         * Optional, Defaults to: 'white'
         */
        baseColor?: any;

        /**
         * The starting rotation of the polar series.
         *
         * Optional, Defaults to: 0
         */
        baseRotation?: number;

        /**
         * The size of the 3D pie bevel.
         *
         * Optional, Defaults to: 5
         */
        bevelWidth?: number;

        /**
         * The central point of the series on the x-axis.
         *
         * Optional, Defaults to: 0
         */
        centerX?: number;

        /**
         * The central point of the series on the x-axis.
         *
         * Optional, Defaults to: 0
         */
        centerY?: number;

        /**
         * An attribute used to control how flat the gradient of the sprite looks.
         * A value of 0 essentially means no gradient (flat color).
         *
         * Optional, Defaults to: 1
         */
        colorSpread?: number;

        /**
         * The distortion of the 3D pie part.
         *
         * Optional, Defaults to: 0
         */
        distortion?: number;

        /**
         * The ending angle of the polar series.
         *
         * Optional, Defaults to: Math.PI
         */
        endAngle?: number;

        /**
         * The ending radius of the polar series.
         *
         * Optional, Defaults to: 150
         */
        endRho?: number;

        /**
         * The label associated with the 'top' part of the sprite.
         *
         * Optional, Defaults to: ''
         */
        label?: string;

        /**
         * Margin from the center of the pie. Used for donut.
         *
         * Optional, Defaults to: 0
         */
        margin?: number;

        /**
         * The part of the 3D Pie represented by the sprite.
         *
         * Optional, Defaults to: 'top'
         */
        part?: string;

        /**
         * The starting angle of the polar series.
         *
         * Optional, Defaults to: 0
         */
        startAngle?: number;

        /**
         * The starting radius of the polar series.
         *
         * Optional, Defaults to: 0
         */
        startRho?: number;

        /**
         * The thickness of the 3D pie part.
         *
         * Optional, Defaults to: 0
         */
        thickness?: number;
    }

    /**
     * @extends Ext.draw.sprite.Path
     *
     * Pie3D series sprite.
     */
    export class Pie3DPart extends Ext.draw.sprite.Path implements Ext.chart.series.sprite.Pie3DPartConfig {
        /**
         * The color of the 3D pie part before adding the 3D effect.
         *
         * Optional, Defaults to: 'white'
         */
        baseColor: any;

        /**
         * The starting rotation of the polar series.
         *
         * Optional, Defaults to: 0
         */
        baseRotation: number;

        /**
         * The size of the 3D pie bevel.
         *
         * Optional, Defaults to: 5
         */
        bevelWidth: number;

        /**
         * The central point of the series on the x-axis.
         *
         * Optional, Defaults to: 0
         */
        centerX: number;

        /**
         * The central point of the series on the x-axis.
         *
         * Optional, Defaults to: 0
         */
        centerY: number;

        /**
         * An attribute used to control how flat the gradient of the sprite looks.
         * A value of 0 essentially means no gradient (flat color).
         *
         * Optional, Defaults to: 1
         */
        colorSpread: number;

        /**
         * The distortion of the 3D pie part.
         *
         * Optional, Defaults to: 0
         */
        distortion: number;

        /**
         * The ending angle of the polar series.
         *
         * Optional, Defaults to: Math.PI
         */
        endAngle: number;

        /**
         * The ending radius of the polar series.
         *
         * Optional, Defaults to: 150
         */
        endRho: number;

        /**
         * The label associated with the 'top' part of the sprite.
         *
         * Optional, Defaults to: ''
         */
        label: string;

        /**
         * Margin from the center of the pie. Used for donut.
         *
         * Optional, Defaults to: 0
         */
        margin: number;

        /**
         * The part of the 3D Pie represented by the sprite.
         *
         * Optional, Defaults to: 'top'
         */
        part: string;

        /**
         * The starting angle of the polar series.
         *
         * Optional, Defaults to: 0
         */
        startAngle: number;

        /**
         * The starting radius of the polar series.
         *
         * Optional, Defaults to: 0
         */
        startRho: number;

        /**
         * The thickness of the 3D pie part.
         *
         * Optional, Defaults to: 0
         */
        thickness: number;

        constructor(config: Ext.chart.series.sprite.Pie3DPartConfig);

        protected updatePlainBBox(plain: any);
    }

    interface PieSliceConfig extends Ext.draw.sprite.SectorConfig {
        /**
         * 'true' if the pie series uses label callouts.
         *
         * Optional, Defaults to: true
         */
        doCallout?: boolean;

        /**
         * Label associated with the Pie sprite.
         *
         * Optional, Defaults to: ''
         */
        label?: string;

        /**
         * Padding around labels to determine overlap.
         * Any negative number allows the labels to overlap.
         *
         * Optional, Defaults to: 10
         */
        labelOverflowPadding?: number;
    }

    /**
     * Pie slice sprite.
     */
    export class PieSlice extends Ext.draw.sprite.Sector implements Ext.chart.series.sprite.PieSliceConfig {
        /**
         * 'true' if the pie series uses label callouts.
         *
         * Optional, Defaults to: true
         */
        doCallout: boolean;

        /**
         * Label associated with the Pie sprite.
         *
         * Optional, Defaults to: ''
         */
        label: string;

        /**
         * Padding around labels to determine overlap.
         * Any negative number allows the labels to overlap.
         *
         * Optional, Defaults to: 10
         */
        labelOverflowPadding: number;

        constructor(config: Ext.chart.axis.sprite.AxisConfig);

        getRendererIndex();

        getSeries();

        setRendererIndex();

        setSeries();
    }

    interface PolarConfig extends Ext.draw.sprite.SpriteConfig {
        /**
         * The starting rotation of the polar series.
         *
         * Optional, Defaults to: 0
         */
        baseRotation?: number;

        /**
         * The central point of the series on the x-axis.
         *
         * Optional, Defaults to: 0
         */
        centerX?: number;

        /**
         * The central point of the series on the y-axis.
         *
         * Optional, Defaults to: 0
         */
        centerY?: number;

        /**
         * The ending angle of the polar series.
         *
         * Optional, Defaults to: Math.PI
         */
        endAngle?: number;

        /**
         * The ending radius of the polar series.
         *
         * Optional, Defaults to: 150
         */
        endRho?: number;

        /**
         * Padding around labels to determine overlap.
         *
         * Optional, Defaults to: 10
         */
        labelOverflowPadding?: number;

        /**
         * Labels used in the series.
         *
         * Optional, Defaults to: null
         */
        labels?: any;

        /**
         * The starting angle of the polar series.
         *
         * Optional, Defaults to: 0
         */
        startAngle?: number;

        /**
         * The starting radius of the polar series.
         *
         * Optional, Defaults to: 0
         */
        startRho?: number;
    }

    /**
     * @extends Ext.draw.sprite.Sprite
     *
     * Polar sprite.
     */
    export class Polar extends Ext.draw.sprite.Sprite implements Ext.chart.series.sprite.PolarConfig {
        /**
         * The starting rotation of the polar series.
         *
         * Optional, Defaults to: 0
         */
        baseRotation: number;

        /**
         * The central point of the series on the x-axis.
         *
         * Optional, Defaults to: 0
         */
        centerX: number;

        /**
         * The central point of the series on the y-axis.
         *
         * Optional, Defaults to: 0
         */
        centerY: number;

        /**
         * The ending angle of the polar series.
         *
         * Optional, Defaults to: Math.PI
         */
        endAngle: number;

        /**
         * The ending radius of the polar series.
         *
         * Optional, Defaults to: 150
         */
        endRho: number;

        /**
         * Padding around labels to determine overlap.
         *
         * Optional, Defaults to: 10
         */
        labelOverflowPadding: number;

        /**
         * Labels used in the series.
         *
         * Optional, Defaults to: null
         */
        labels: any;

        /**
         * The starting angle of the polar series.
         *
         * Optional, Defaults to: 0
         */
        startAngle: number;

        /**
         * The starting radius of the polar series.
         *
         * Optional, Defaults to: 0
         */
        startRho: number;

        constructor(config: Ext.chart.axis.sprite.AxisConfig);

        protected updatePlainBBox(plain: any);
    }

    /**
     * @extends Ext.chart.series.sprite.Polar
     *
     * Radar series sprite.
     */
    export class Radar extends Ext.chart.series.sprite.Polar {
        constructor(config: Ext.chart.axis.sprite.AxisConfig);
    }

    /**
     * @extends Ext.chart.series.sprite.Cartesian
     *
     * Scatter series sprite.
     */
    export class Scatter extends Ext.chart.series.sprite.Cartesian {
        constructor(config: Ext.chart.axis.sprite.AxisConfig);
    }

    interface SeriesConfig extends Ext.draw.sprite.SpriteConfig {
        /**
         * Data maximum on the x-axis.
         *
         * Optional, Defaults to: 1
         */
        dataMaxX?: number;

        /**
         * Data maximum on the y-axis.
         *
         * Optional, Defaults to: 1
         */
        dataMaxY?: number;

        /**
         * Data minimum on the x-axis.
         *
         * Optional, Defaults to: 0
         */
        dataMinX?: number;

        /**
         * Data minimum on the y-axis.
         *
         * Optional, Defaults to: 0
         */
        dataMinY?: number;

        /**
         * Data items on the x-axis.
         *
         * Optional, Defaults to: null
         */
        dataX?: any;

        /**
         * Data items on the y-axis.
         *
         * Optional, Defaults to: null
         */
        dataY?: any;

        /**
         * The store field used by the series.
         */
        field?: string;

        /**
         * Data range derived from all the series bound to the x-axis.
         *
         * Optional, Defaults to: null
         */
        rangeX?: any[];

        /**
         * Data range derived from all the series bound to the y-axis.
         *
         * Optional, Defaults to: null
         */
        rangeY?: any[];
    }

    /**
     * Base class for all series sprites.
     * Defines attributes common to all series sprites, like data in x/y directions and its min/max values,
     * and configs, like the {@link Ext.chart.series.Series} instance that manages the sprite.
     */
    export class Series extends Ext.draw.sprite.Sprite implements Ext.chart.series.sprite.SeriesConfig {
        /**
         * Data maximum on the x-axis.
         *
         * Optional, Defaults to: 1
         */
        dataMaxX: number;

        /**
         * Data maximum on the y-axis.
         *
         * Optional, Defaults to: 1
         */
        dataMaxY: number;

        /**
         * Data minimum on the x-axis.
         *
         * Optional, Defaults to: 0
         */
        dataMinX: number;

        /**
         * Data minimum on the y-axis.
         *
         * Optional, Defaults to: 0
         */
        dataMinY: number;

        /**
         * Data items on the x-axis.
         *
         * Optional, Defaults to: null
         */
        dataX: any;

        /**
         * Data items on the y-axis.
         *
         * Optional, Defaults to: null
         */
        dataY: any;

        /**
         * The store field used by the series.
         */
        field: string;

        /**
         * Data range derived from all the series bound to the x-axis.
         *
         * Optional, Defaults to: null
         */
        rangeX: any[];

        /**
         * Data range derived from all the series bound to the y-axis.
         *
         * Optional, Defaults to: null
         */
        rangeY: any[];

        constructor(config: Ext.chart.axis.sprite.AxisConfig);

        getField();

        getSeries();

        setField();

        setSeries();
    }

    /**
     * @extends Ext.chart.series.sprite.Cartesian
     *
     * Stacked cartesian sprite.
     */
    export class StackedCartesian extends Ext.chart.series.sprite.Cartesian {
        constructor(config: Ext.chart.axis.sprite.AxisConfig);
    }
}

declare module Ext.chart.sprite {
    interface LabelConfig extends Ext.draw.sprite.TextConfig {
        /**
         * True to draw a line between the label and the chart with the default settings,
         * or an Object that defines the 'color', 'width' and 'length' properties of the line.
         * This config is only applicable when the label is displayed outside the chart.
         *
         * Default value: false.
         */
        calloutLine?: boolean|any;

        /**
         * Animation configuration.
         */
        fx?: any;
    }

    /**
     * @extends Ext.draw.sprite.Text
     *
     * Sprite used to represent labels in series.
     *
     * Important: the actual default values are determined by the theme used.
     * Please see the 'label' config of the {@link Ext.chart.theme.Base#axis}.
     */
    export class Label extends Ext.draw.sprite.Text implements Ext.chart.sprite.LabelConfig {
        /**
         * True to draw a line between the label and the chart with the default settings,
         * or an Object that defines the 'color', 'width' and 'length' properties of the line.
         * This config is only applicable when the label is displayed outside the chart.
         *
         * Default value: false.
         */
        calloutLine: boolean|any;

        /**
         * Animation configuration.
         */
        fx: any;

        constructor(config: Ext.chart.axis.sprite.AxisConfig);

        getCalloutLine();

        getField();

        getFx();

        setCalloutLine();

        setField();

        setFx();
    }
}

declare module Ext.chart.theme {
    interface BaseConfig {
        /**
         * Theme defaults for the axes.
         * Can apply to all axes or only axes with a specific position.
         * For example:
         *
         *     axis: {
         *       defaults: {
         *         style: {strokeStyle: 'red'}
         *       },
         *       left: {
         *         title: {fillStyle: 'green'}
         *       }
         *     }
         *
         * The values from the axis.defaults and axis.*position* configs (where *position*
         * is a valid axis {@link Ext.chart.axis.Axis#position}, e.g. 'bottom') will be
         * applied to corresponding {@link Ext.chart.axis.Axis axis} configs.
         * E.g., the axis.defaults.label config will apply to the {@link Ext.chart.axis.Axis#label}
         * config of all axes, where the axis.left.titleMargin config will only apply to the
         * {@link Ext.chart.axis.Axis#titleMargin} config of all axes positioned to the left.
         */
        axis?: any;

        /**
         * @deprecated Use the {@link Ext.chart.AbstractChart#background} config instead.
         * @since 5.0.1
         */
        background?: any;

        /**
         * The base color used to generate the {@link Ext.chart.AbstractChart#colors} of the theme.
         */
        baseColor?: string|Ext.draw.Color;

        /**
         * Theme defaults for the chart.
         * Can apply to all charts or just a specific type of chart.
         * For example:
         *
         *     chart: {
         *       defaults: {
         *         background: 'lightgray'
         *       },
         *       polar: {
         *         background: 'green'
         *       }
         *     }
         *
         * The values from the chart.defaults and chart.*type* configs (where *type* is a valid
         * chart xtype, e.g. '{@link Ext.chart.CartesianChart cartesian}' or '{@link Ext.chart.PolarChart polar}')
         * will be applied to corresponding chart configs.
         * E.g., the chart.defaults.background config will set the {@link Ext.chart.AbstractChart#background}
         * config of all charts, where the chart.cartesian.flipXY config will only set the
         * {@link Ext.chart.CartesianChart#flipXY} config of all cartesian charts.
         */
        chart?: any;

        /**
         * Array of colors/gradients to be used by the theme.
         * Defaults to {@link #colorDefaults}.
         */
        colors?: any[];

        /**
         * The gradient config to be used by series' sprites. E.g.:
         *
         *     {
         *       type: 'linear',
         *       degrees: 90
         *     }
         *
         * Please refer to the documentation for the {@link Ext.draw.gradient.Linear linear}
         * and {@link Ext.draw.gradient.Radial radial} gradients for all possible options.
         * The color {@link Ext.draw.gradient.Gradient#stops stops} for the gradients
         * will be generated by the theme based on the {@link #colors} config.
         */
        gradients?: any;

        /**
         * Theme defaults for the series.
         * Can apply to all series or just a specific type of series.
         * For example:
         *
         *     series: {
         *       defaults: {
         *         style: {
         *           lineWidth: 2
         *         }
         *       },
         *       bar: {
         *         animation: {
         *           easing: 'bounceOut',
         *           duration: 1000
         *         }
         *       }
         *     }
         *
         * The values from the series.defaults and series.*type* configs (where *type*
         * is a valid series {@link Ext.chart.series.Series#type}, e.g. 'line') will be
         * applied to corresponding series configs.
         * E.g., the series.defaults.label config will apply to the {@link Ext.chart.series.Series#label}
         * config of all series, where the series.line.step config will only apply to the
         * {@link Ext.chart.series.Line#step} config of {@link Ext.chart.series.Line line} series.
         */
        series?: any;

        /**
         * Default style for the custom chart sprites by type.
         * For example:
         *
         *     sprites: {
         *       text: {
         *         fontWeight: 300
         *       }
         *     }
         *
         * These sprite attribute overrides will apply to custom sprites of all charts
         * specified using the {@link Ext.draw.Container#sprites} config.
         * The overrides are specified by sprite type, e.g. sprites.text config
         * tells to apply given attributes to all {@link Ext.draw.sprite.Text text} sprites.
         */
        sprites?: any;

        /**
         * @deprecated Use the {@link Ext.draw.Container#gradients} config instead.
         * @since 5.0.1
         */
        useGradients?: any;
    }

    /**
     * Abstract class that provides default styles for non-specified things.
     * Should be sub-classed when creating new themes.
     * For example:
     *
     *     Ext.define('Ext.chart.theme.Custom', {
     *         extend: 'Ext.chart.theme.Base',
     *         singleton: true,
     *         alias: 'chart.theme.custom',
     *         config: {
     *             baseColor: '#ff9f00'
     *         }
     *     });
     *
     * Theme provided values will not override the values provided in an instance config.
     * However, if a theme provided value is an object, it will be merged with the value
     * from the instance config, unless the theme provided object has a '$default' key
     * set to 'true'.
     *
     * Certain chart theme configs (e.g. 'fontSize') may use the 'default' value to indicate
     * that they should inherit a value from the corresponding CSS style provided by
     * a framework theme. Additionally, one can use basic binary operators like multiplication,
     * addition and subtraction to derive from the default value, e.g. fontSize: 'default*1.3'.
     *
     * Important: the theme should not use the 'font' shorthand to specify the font of labels
     * and other text elements of a chart. Instead, individual font properties should be used:
     * 'fontStyle', 'fontVariant', 'fontWeight', 'fontSize' and 'fontFamily'.
     */
    export class Base extends Ext.Base implements Ext.chart.theme.BaseConfig {
        factoryConfig: any;

        /**
         * Theme defaults for the axes.
         * Can apply to all axes or only axes with a specific position.
         * For example:
         *
         *     axis: {
         *       defaults: {
         *         style: {strokeStyle: 'red'}
         *       },
         *       left: {
         *         title: {fillStyle: 'green'}
         *       }
         *     }
         *
         * The values from the axis.defaults and axis.*position* configs (where *position*
         * is a valid axis {@link Ext.chart.axis.Axis#position}, e.g. 'bottom') will be
         * applied to corresponding {@link Ext.chart.axis.Axis axis} configs.
         * E.g., the axis.defaults.label config will apply to the {@link Ext.chart.axis.Axis#label}
         * config of all axes, where the axis.left.titleMargin config will only apply to the
         * {@link Ext.chart.axis.Axis#titleMargin} config of all axes positioned to the left.
         */
        axis: any;

        /**
         * @deprecated Use the {@link Ext.chart.AbstractChart#background} config instead.
         * @since 5.0.1
         */
        background: any;

        /**
         * The base color used to generate the {@link Ext.chart.AbstractChart#colors} of the theme.
         */
        baseColor: string|Ext.draw.Color;

        /**
         * Theme defaults for the chart.
         * Can apply to all charts or just a specific type of chart.
         * For example:
         *
         *     chart: {
         *       defaults: {
         *         background: 'lightgray'
         *       },
         *       polar: {
         *         background: 'green'
         *       }
         *     }
         *
         * The values from the chart.defaults and chart.*type* configs (where *type* is a valid
         * chart xtype, e.g. '{@link Ext.chart.CartesianChart cartesian}' or '{@link Ext.chart.PolarChart polar}')
         * will be applied to corresponding chart configs.
         * E.g., the chart.defaults.background config will set the {@link Ext.chart.AbstractChart#background}
         * config of all charts, where the chart.cartesian.flipXY config will only set the
         * {@link Ext.chart.CartesianChart#flipXY} config of all cartesian charts.
         */
        chart: any;

        /**
         * Array of colors/gradients to be used by the theme.
         * Defaults to {@link #colorDefaults}.
         */
        colors: any[];

        /**
         * The gradient config to be used by series' sprites. E.g.:
         *
         *     {
         *       type: 'linear',
         *       degrees: 90
         *     }
         *
         * Please refer to the documentation for the {@link Ext.draw.gradient.Linear linear}
         * and {@link Ext.draw.gradient.Radial radial} gradients for all possible options.
         * The color {@link Ext.draw.gradient.Gradient#stops stops} for the gradients
         * will be generated by the theme based on the {@link #colors} config.
         */
        gradients: any;

        /**
         * Theme defaults for the series.
         * Can apply to all series or just a specific type of series.
         * For example:
         *
         *     series: {
         *       defaults: {
         *         style: {
         *           lineWidth: 2
         *         }
         *       },
         *       bar: {
         *         animation: {
         *           easing: 'bounceOut',
         *           duration: 1000
         *         }
         *       }
         *     }
         *
         * The values from the series.defaults and series.*type* configs (where *type*
         * is a valid series {@link Ext.chart.series.Series#type}, e.g. 'line') will be
         * applied to corresponding series configs.
         * E.g., the series.defaults.label config will apply to the {@link Ext.chart.series.Series#label}
         * config of all series, where the series.line.step config will only apply to the
         * {@link Ext.chart.series.Line#step} config of {@link Ext.chart.series.Line line} series.
         */
        series: any;

        /**
         * Default style for the custom chart sprites by type.
         * For example:
         *
         *     sprites: {
         *       text: {
         *         fontWeight: 300
         *       }
         *     }
         *
         * These sprite attribute overrides will apply to custom sprites of all charts
         * specified using the {@link Ext.draw.Container#sprites} config.
         * The overrides are specified by sprite type, e.g. sprites.text config
         * tells to apply given attributes to all {@link Ext.draw.sprite.Text text} sprites.
         */
        sprites: any;

        /**
         * @deprecated Use the {@link Ext.draw.Container#gradients} config instead.
         * @since 5.0.1
         */
        useGradients: any;

        constructor(config: Ext.chart.theme.BaseConfig);

        getAxis();

        getBackground();

        getBaseColor();

        getChart();

        getColors();

        getGradients();

        getMarkerThemes();

        getSeries();

        getSprites();

        getUseGradients();

        setAxis();

        setBackground();

        setBaseColor();

        setChart();

        setColors();

        setGradients();

        setMarkerThemes();

        setSeries();

        setSprites();

        setUseGradients();
    }

    export class Default {
        constructor(config: Ext.chart.theme.BaseConfig);
    }
}

declare module Ext.data {
    interface AbstractStoreConfig {
        /**
         * When a Store is used by only one {@link Ext.view.View DataView}, and should only exist for the lifetime of that view, then
         * configure the autoDestroy flag as 'true'. This causes the destruction of the view to trigger the destruction of its Store.
         *
         * Optional
         */
        autoDestroy?: boolean;

        /**
         * Array of {@link Ext.util.Filter Filters} for this store. Can also be passed array of
         * functions which will be used as the {@link Ext.util.Filter#filterFn filterFn} config
         * for filters:
         *
         *     filters: [
         *         function(item) {
         *             return item.weight > 0;
         *         }
         *     ]
         *
         * To filter after the grid is loaded use the {@link Ext.data.Store#filterBy filterBy} function.
         */
        filters?: any|Function;

        /**
         * The direction in which sorting should be applied when grouping. Supported values are "ASC" and "DESC".
         */
        groupDir?: string;

        /**
         * The field by which to group data in the store. Internally, grouping is very similar to sorting - the
         * groupField and {@link #groupDir} are injected as the first sorter (see {@link #method-sort}). Stores support a single
         * level of grouping, and groups can be fetched via the {@link #getGroups} method.
         */
        groupField?: string;

        /**
         * The grouper by which to group the data store. May also be specified by the {@link #groupField} config, however
         * they should not be used together.
         */
        grouper?: any|Ext.util.Grouper;

        /**
         * The number of records considered to form a 'page'. This is used to power the built-in
         * paging using the nextPage and previousPage functions when the grid is paged using a
         * {@link Ext.toolbar.Paging PagingToolbar} Defaults to 25.
         *
         * To disable paging, set the pageSize to '0'.
         */
        pageSize?: number;

        /**
         * 'true' to defer any filtering operation to the server. If 'false', filtering is done locally on the client.
         *
         * Optional, Defaults to: false
         */
        remoteFilter?: boolean;

        /**
         * 'true' if the sorting should be performed on the server side, false if it is local only.
         *
         * Optional, Defaults to: false
         */
        remoteSort?: boolean;

        /**
         * The initial set of {@link Ext.util.Sorter Sorters}
         */
        sorters?: Ext.util.Sorter|any;

        /**
         * Configure as 'true' to have the filters saved when a client {@link Ext.grid.Panel grid} saves its state.
         *
         * Optional, Defaults to: false
         */
        statefulFilters?: boolean;

        /**
         * Unique identifier for this store. If present, this Store will be registered with the {@link Ext.data.StoreManager},
         * making it easy to reuse elsewhere.
         *
         * Note that when a store is instantiated by a Controller, the storeId will default
         * to the name of the store if not specified in the class.
         */
        storeId?: string;
    }

    /**
     * AbstractStore is a superclass of {@link Ext.data.ProxyStore} and {@link Ext.data.ChainedStore}. It's never used directly,
     * but offers a set of methods used by both of those subclasses.
     *
     * We've left it here in the docs for reference purposes, but unless you need to make a whole new type of Store, what
     * you're probably looking for is {@link Ext.data.Store}.
     */
    export class AbstractStore extends Ext.Base implements Ext.data.AbstractStoreConfig {
        /**
         * The page that the Store has most recently loaded (see {@link Ext.data.Store#loadPage loadPage})
         */
        currentPage: number;

        factoryConfig: any;

        /**
         * 'true' in this class to identify an object as an instantiated Store, or subclass thereof.
         */
        isStore: boolean;

        /**
         * A counter that is increased by 'beginUpdate' and decreased by 'endUpdate'. When
         * this transitions from 0 to 1 the '{@link #event-beginupdate beginupdate}' event is
         * fired. When it transitions back from 1 to 0 the '{@link #event-endupdate endupdate}'
         * event is fired.
         * @readonly
         * @since 5.0.0
         */
        updating: number;

        /**
         * When a Store is used by only one {@link Ext.view.View DataView}, and should only exist for the lifetime of that view, then
         * configure the autoDestroy flag as 'true'. This causes the destruction of the view to trigger the destruction of its Store.
         *
         * Optional
         */
        autoDestroy: boolean;

        /**
         * Array of {@link Ext.util.Filter Filters} for this store. Can also be passed array of
         * functions which will be used as the {@link Ext.util.Filter#filterFn filterFn} config
         * for filters:
         *
         *     filters: [
         *         function(item) {
         *             return item.weight > 0;
         *         }
         *     ]
         *
         * To filter after the grid is loaded use the {@link Ext.data.Store#filterBy filterBy} function.
         */
        filters: any|Function;

        /**
         * The direction in which sorting should be applied when grouping. Supported values are "ASC" and "DESC".
         */
        groupDir: string;

        /**
         * The grouper by which to group the data store. May also be specified by the {@link #groupField} config, however
         * they should not be used together.
         */
        grouper: any|Ext.util.Grouper;

        /**
         * The field by which to group data in the store. Internally, grouping is very similar to sorting - the
         * groupField and {@link #groupDir} are injected as the first sorter (see {@link #method-sort}). Stores support a single
         * level of grouping, and groups can be fetched via the {@link #getGroups} method.
         */
        groupField: string;

        /**
         * The number of records considered to form a 'page'. This is used to power the built-in
         * paging using the nextPage and previousPage functions when the grid is paged using a
         * {@link Ext.toolbar.Paging PagingToolbar} Defaults to 25.
         *
         * To disable paging, set the pageSize to '0'.
         */
        pageSize: number;

        /**
         * 'true' to defer any filtering operation to the server. If 'false', filtering is done locally on the client.
         *
         * Optional, Defaults to: false
         */
        remoteFilter: boolean;

        /**
         * 'true' if the sorting should be performed on the server side, false if it is local only.
         *
         * Optional, Defaults to: false
         */
        remoteSort: boolean;

        /**
         * The initial set of {@link Ext.util.Sorter Sorters}
         */
        sorters: Ext.util.Sorter|any;

        /**
         * Configure as 'true' to have the filters saved when a client {@link Ext.grid.Panel grid} saves its state.
         *
         * Optional, Defaults to: false
         */
        statefulFilters: boolean;

        /**
         * Unique identifier for this store. If present, this Store will be registered with the {@link Ext.data.StoreManager},
         * making it easy to reuse elsewhere.
         *
         * Note that when a store is instantiated by a Controller, the storeId will default
         * to the name of the store if not specified in the class.
         */
        storeId: string;

        /**
         * Adds a new Filter to this Store's {@link #cfg-filters filter set} and
         * by default, applies the updated filter set to the Store's unfiltered dataset.
         * @param {Object[]/Ext.util.Filter[]} filters The set of filters to add to the current {@link #cfg-filters filter set}.
         * @param {Boolean} [suppressEvent] If 'true' the filter is cleared silently.
         */
        addFilter(filters: any|Ext.util.Filter, suppressEvent?: boolean);

        /**
         * This method may be called to indicate the start of multiple changes to the store.
         *
         * Automatic synchronization as configured by the {@link Ext.data.ProxyStore#autoSync autoSync} flag is deferred
         * until the {@link #endUpdate} method is called, so multiple mutations can be coalesced
         * into one synchronization operation.
         *
         * Internally this method increments a counter that is decremented by 'endUpdate'. It
         * is important, therefore, that if you call 'beginUpdate' directly you match that
         * call with a call to 'endUpdate' or you will prevent the collection from updating
         * properly.
         *
         * For example:
         *
         *      var store = Ext.StoreManager.lookup({
         *          //...
         *          autoSync: true
         *      });
         *
         *      store.beginUpdate();
         *
         *      record.set('fieldName', 'newValue');
         *
         *      store.add(item);
         *      // ...
         *
         *      store.insert(index, otherItem);
         *      //...
         *
         *      // Interested parties will listen for the endupdate event
         *      store.endUpdate();
         *
         * @since 5.0.0
         */
        beginUpdate();

        /**
         * Reverts to a view of the Record cache with no filtering applied.
         * @param {Boolean} [suppressEvent] If 'true' the filter is cleared silently.
         *
         * For a locally filtered Store, this means that the filter collection is cleared without firing the
         * {@link #datachanged} event.
         *
         * For a remotely filtered Store, this means that the filter collection is cleared, but the store
         * is not reloaded from the server.
         */
        clearFilter(suppressEvent?: boolean);

        /**
         * Clear the store grouping
         */
        clearGrouping();

        constructor();

        /**
         * Checks if a record is in the current active data set.
         * @param {Ext.data.Model} record The record
         * @return {Boolean} 'true' if the record is in the current active data set.
         */
        contains(record: Ext.data.Model): boolean;

        destroy();

        /**
         * This method is called after modifications are complete on a store. For details
         * see '{@link #beginUpdate}'.
         * @since 5.0.0
         */
        endUpdate();

        /**
         * Filters the data in the Store by one or more fields. Example usage:
         *
         *     //filter with a single field
         *     myStore.filter('firstName', 'Don');
         *
         *     //filtering with multiple filters
         *     myStore.filter([
         *         {
         *             property : 'firstName',
         *             value    : 'Don'
         *         },
         *         {
         *             property : 'lastName',
         *             value    : 'Griffin'
         *         }
         *     ]);
         *
         * Internally, Store converts the passed arguments into an array of {@link Ext.util.Filter} instances, and delegates
         * the actual filtering to its internal {@link Ext.util.MixedCollection}.
         *
         * @param {String/Ext.util.Filter[]} [filters] Either a string name of one of the fields in this Store's configured
         * {@link Ext.data.Model Model}, or an array of filter configurations.
         * @param {String} [value] The property value by which to filter. Only applicable if 'filters' is a string.
         */
        filter(filters?: string|Ext.util.Filter, value?: string);

        /**
         * Filters by a function. The specified function will be called for each
         * Record in this Store. If the function returns 'true' the Record is included,
         * otherwise it is filtered out.
         *
         * When store is filtered, most of the methods for accessing store data will be working only
         * within the set of filtered records. The notable exception is {@link #getById}.
         *
         * @param {Function} fn The function to be called. It will be passed the following parameters:
         *  @param {Ext.data.Model} fn.record The record to test for filtering. Access field values
         *  using {@link Ext.data.Model#get}.
         * @param {Object} [scope] The scope (this reference) in which the function is executed.
         * Defaults to this Store.
         */
        filterBy(fn: Function, scope?: any);

        /**
         * Finds the index of the first matching Record in this store by a specific field value.
         *
         * When store is filtered, finds records only within filter.
         *
         * **IMPORTANT
         *
         * If this store is {@link Ext.data.BufferedStore Buffered}, this can ONLY find records which happen to be cached in the page cache.
         * This will be parts of the dataset around the currently visible zone, or recently visited zones if the pages
         * have not yet been purged from the cache.**
         *
         * @param {String} property The name of the Record field to test.
         * @param {String/RegExp} value Either a string that the field value
         * should begin with, or a RegExp to test against the field.
         * @param {Number} [startIndex=0] The index to start searching at
         * @param {Boolean} [anyMatch=false] True to match any part of the string, not just the
         * beginning.
         * @param {Boolean} [caseSensitive=false] True for case sensitive comparison
         * @param {Boolean} [exactMatch=false] True to force exact match (^ and $ characters
         * added to the regex). Ignored if 'anyMatch' is 'true'.
         * @return {Number} The matched index or -1
         */
        find(property: string, value: string|RegExp, startIndex?: number, anyMatch?: boolean, caseSensitive?: boolean, exactMatch?: boolean): number;

        /**
         * Find the index of the first matching Record in this Store by a function.
         * If the function returns 'true' it is considered a match.
         *
         * When store is filtered, finds records only within filter.
         *
         * **IMPORTANT
         *
         * If this store is {@link Ext.data.BufferedStore Buffered}, this can ONLY find records which happen to be cached in the page cache.
         * This will be parts of the dataset around the currently visible zone, or recently visited zones if the pages
         * have not yet been purged from the cache.**
         *
         * @param {Function} fn The function to be called. It will be passed the following parameters:
         *  @param {Ext.data.Model} fn.record The record to test for filtering. Access field values
         *  using {@link Ext.data.Model#get}.
         *  @param {Object} fn.id The ID of the Record passed.
         * @param {Object} [scope] The scope (this reference) in which the function is executed.
         * Defaults to this Store.
         * @param {Number} [startIndex=0] The index to start searching at
         * @return {Number} The matched index or -1
         */
        findBy(fn: Function, scope?: any, startIndex?: number): number;

        /**
         * Finds the index of the first matching Record in this store by a specific field value.
         *
         * When store is filtered, finds records only within filter.
         *
         * **IMPORTANT
         *
         * If this store is {@link Ext.data.BufferedStore Buffered}, this can ONLY find records which happen to be cached in the page cache.
         * This will be parts of the dataset around the currently visible zone, or recently visited zones if the pages
         * have not yet been purged from the cache.**
         *
         * @param {String} fieldName The name of the Record field to test.
         * @param {Object} value The value to match the field against.
         * @param {Number} [startIndex=0] The index to start searching at
         * @return {Number} The matched index or -1
         */
        findExact(fieldName: string, value: any, startIndex?: number): number;

        /**
         * Finds the first matching Record in this store by a specific field value.
         *
         * When store is filtered, finds records only within filter.
         *
         * **IMPORTANT
         *
         * If this store is {@link Ext.data.BufferedStore Buffered}, this can ONLY find records which happen to be cached in the page cache.
         * This will be parts of the dataset around the currently visible zone, or recently visited zones if the pages
         * have not yet been purged from the cache.**
         *
         * @param {String} fieldName The name of the Record field to test.
         * @param {String/RegExp} value Either a string that the field value
         * should begin with, or a RegExp to test against the field.
         * @param {Number} [startIndex=0] The index to start searching at
         * @param {Boolean} [anyMatch=false] True to match any part of the string, not just the
         * beginning.
         * @param {Boolean} [caseSensitive=false] True for case sensitive comparison
         * @param {Boolean} [exactMatch=false] True to force exact match (^ and $ characters
         * added to the regex). Ignored if 'anyMatch' is 'true'.
         * @return {Ext.data.Model} The matched record or null
         */
        findRecord(fieldName: string, value: string|RegExp, startIndex?: number, anyMatch?: boolean, caseSensitive?: boolean, exactMatch?: boolean): Ext.data.Model;

        /**
         * Get the Record at the specified index.
         *
         * The index is effected by filtering.
         *
         * @param {Number} index The index of the Record to find.
         * @return {Ext.data.Model} The Record at the passed index. Returns null if not found.
         */
        getAt(index: number): Ext.data.Model;

        getAutoDestroy();

        /**
         * Get the Record with the specified id.
         *
         * This method is not affected by filtering, lookup will be performed from all records
         * inside the store, filtered or not.
         *
         * @param {Mixed} id The id of the Record to find.
         * @return {Ext.data.Model} The Record with the passed id. Returns null if not found.
         */
        getById(id: any): Ext.data.Model;

        /**
         * Gets the number of records in store.
         *
         * If using paging, this may not be the total size of the dataset. If the data object
         * used by the Reader contains the dataset size, then the {@link Ext.data.ProxyStore#getTotalCount} function returns
         * the dataset size.  **Note**: see the Important note in {@link Ext.data.ProxyStore#method-load}.
         *
         * When store is filtered, it's the number of records matching the filter.
         *
         * @return {Number} The number of Records in the Store.
         */
        getCount(): number;

        /**
         * Gets the filters for this store.
         * @return {Ext.util.FilterCollection} The filters
         */
        getFilters(): Ext.util.FilterCollection;

        getGroupDir();

        getGrouper();

        /**
         * Returns a collection of readonly sub-collections of your store's records
         * with grouping applied. These sub-collections are maintained internally by
         * the collection.
         *
         * See {@link #groupField}, {@link #groupDir}. Example for a store
         * containing records with a color field:
         *
         *     var myStore = Ext.create('Ext.data.Store', {
         *         groupField: 'color',
         *         groupDir  : 'DESC'
         *     });
         *
         *     myStore.getGroups();
         *
         * The above should result in the following format:
         *
         *     [
         *         {
         *             name: 'yellow',
         *             children: [
         *                 // all records where the color field is 'yellow'
         *             ]
         *         },
         *         {
         *             name: 'red',
         *             children: [
         *                 // all records where the color field is 'red'
         *             ]
         *         }
         *     ]
         *
         * Group contents are affected by filtering.
         *
         * @return {Ext.util.Collection} The grouped data
         */
        getGroups(): Ext.util.Collection;

        getPageSize();

        /**
         * Gathers a range of Records between specified indices.
         *
         * This method is affected by filtering.
         *
         * @param {Number} start The starting index. Defaults to zero.
         * @param {Number} end The ending index. Defaults to the last record. The end index **is included**.
         * @return {Ext.data.Model[]} An array of records.
         */
        getRange(start: number, end: number): Ext.data.Model;

        getRemoteFilter();

        getRemoteSort();

        /**
         * Gets the sorters for this store.
         * @return {Ext.util.SorterCollection} The sorters
         */
        getSorters(): Ext.util.SorterCollection;

        getStatefulFilters();

        getStoreId();

        /**
         * Groups data inside the store.
         * @param {String/Object} grouper Either a string name of one of the fields in this Store's
         * configured {@link Ext.data.Model Model}, or an object, or a {@link Ext.util.Grouper grouper} configuration object.
         * @param {String} [direction] The overall direction to group the data by. Defaults to the value of {@link #groupDir}.
         */
        group(grouper: string|any, direction?: string);

        /**
         * Tests whether the store currently has any active filters.
         * @return {Boolean} 'true' if the store is filtered.
         */
        isFiltered(): boolean;

        /**
         * Tests whether the store currently has an active grouper.
         * @return {Boolean} 'true' if the store is grouped.
         */
        isGrouped(): boolean;

        /**
         * Returns 'true' if the Store has been loaded.
         * @return {Boolean} 'true' if the Store has been loaded.
         */
        isLoaded(): boolean;

        /**
         * Returns 'true' if the Store is currently performing a load operation.
         * @return {Boolean} 'true' if the Store is currently loading.
         */
        isLoading(): boolean;

        /**
         * Tests whether the store currently has any active sorters.
         * @return {Boolean} 'true' if the store is sorted.
         */
        isSorted(): boolean;

        /**
         * Removes an individual Filter from the current {@link #cfg-filters filter set} using the passed Filter/Filter id and
         * by default, applies the updated filter set to the Store's unfiltered dataset.
         *
         * @param {String/Ext.util.Filter} toRemove The id of a Filter to remove from the filter set, or a Filter instance to remove.
         * @param {Boolean} [suppressEvent] If 'true' the filter is cleared silently.
         */
        removeFilter(toRemove: string|Ext.util.Filter, suppressEvent?: boolean);

        setAutoDestroy();

        setFilters();

        setGroupDir();

        setGrouper();

        setGroupField();

        setPageSize();

        setRemoteFilter();

        setRemoteSort();

        setSorters();

        setStatefulFilters();

        setStoreId();

        /**
         * Sorts the data in the Store by one or more of its properties. Example usage:
         *
         *     //sort by a single field
         *     myStore.sort('myField', 'DESC');
         *
         *     //sorting by multiple fields
         *     myStore.sort([
         *         {
         *             property : 'age',
         *             direction: 'ASC'
         *         },
         *         {
         *             property : 'name',
         *             direction: 'DESC'
         *         }
         *     ]);
         *
         * Internally, Store converts the passed arguments into an array of {@link Ext.util.Sorter} instances, and delegates
         * the actual sorting to its internal {@link Ext.util.MixedCollection}.
         *
         * When passing a single string argument to sort, Store maintains a ASC/DESC toggler per field, so this code:
         *
         *     store.sort('myField');
         *     store.sort('myField');
         *
         * Is equivalent to this code, because Store handles the toggling automatically:
         *
         *     store.sort('myField', 'ASC');
         *     store.sort('myField', 'DESC');
         *
         * @param {String/Ext.util.Sorter[]} [sorters] Either a string name of one of the fields in this Store's configured
         * {@link Ext.data.Model Model}, or an array of sorter configurations.
         * @param {String} [direction="ASC"] The overall direction to sort the data by.
         * @return {Ext.util.Sorter[]}
         */
        sort(sorters?: string|Ext.util.Sorter, direction?: string): Ext.util.Sorter;

        /**
         * Fired when a Model instance has been added to this Store.
         *
         * @param {Ext.data.Store} store The store.
         * @param {Ext.data.Model[]} records The records that were added.
         * @param {Number} index The index at which the records were inserted.
         * @since 1.1.0
         */
        add(store: Ext.data.Store, records: Ext.data.Model, index: number);

        /**
         * Fires before a store is sorted.
         *
         * For {@link #remoteSort remotely sorted} stores, this will be just before the load operation triggered by changing the
         * store's sorters.
         *
         * For locally sorted stores, this will be just before the data items in the store's backing collection are sorted.
         * @param {Ext.data.Store} store The store being sorted
         * @param {Ext.util.Sorter[]} sorters Array of sorters applied to the store
         */
        beforesort(store: Ext.data.Store, sorters: Ext.util.Sorter);

        /**
         * Fires when the {@link #beginUpdate} method is called. Automatic synchronization as configured
         * by the {@link Ext.data.ProxyStore#autoSync autoSync} flag is deferred until the {@link #endUpdate} method is called, so multiple
         * mutations can be coalesced into one synchronization operation.
         */
        beginupdate();

        /**
         * Fired after the {@link Ext.data.Store#removeAll removeAll} method is called.
         * @since 1.1.0
         */
        clear(that: Ext.data.Store);

        /**
         * Fires whenever records are added to or removed from the Store.
         *
         * To hook into modifications of records in this Store use the {@link #update} event.
         * @param {Ext.data.Store} this The data store
         * @since 1.1.0
         */
        datachanged(that: Ext.data.Store);

        /**
         * Fires when the {@link #endUpdate} method is called. Automatic synchronization as configured
         * by the {@link Ext.data.ProxyStore#autoSync autoSync} flag is deferred until the {@link #endUpdate} method is called, so multiple
         * mutations can be coalesced into one synchronization operation.
         */
        endupdate();

        /**
         * Fires when the data cache has changed in a bulk manner (e.g., it has been sorted, filtered, etc.) and a
         * widget that is using this Store as a Record cache should refresh its view.
         * @param {Ext.data.Store} this The data store
         */
        refresh(that: Ext.data.Store);

        /**
         * Fired when one or more records have been removed from this Store.
         *
         * **The signature for this event has changed in 5.0: **
         *
         * @param {Ext.data.Store} store The Store object
         * @param {Ext.data.Model[]} records The records that were removed. In previous
         * releases this was a single record, not an array.
         * @param {Number} index The index at which the records were removed.
         * @param {Boolean} isMove 'true' if the child node is being removed so it can be
         * moved to another position in this Store.
         * @since 5.0.0
         */
        remove(store: Ext.data.Store, records: Ext.data.Model, index: number, isMove: boolean);

        /**
         * Fires when a Model instance has been updated.
         * @param {Ext.data.Model} record The Model instance that was updated
         * @param {String} operation The update operation being performed. Value may be one of:
         *
         *     Ext.data.Model.EDIT
         *     Ext.data.Model.REJECT
         *     Ext.data.Model.COMMIT
         * @param {String[]} modifiedFieldNames Array of field names changed during edit.
         * @param {Object} details An object describing the change. See the
         * {@link Ext.util.Collection#event-itemchange itemchange event} of the store's backing collection
         * @since 1.1.0
         */
        update(that: Ext.data.Store, record: Ext.data.Model, operation: string, modifiedFieldNames: string, details: any);
    }

    interface ArrayStoreConfig extends Ext.data.StoreConfig {
        proxy?: any;
    }

    /**
     * Small helper class to make creating {@link Ext.data.Store}s from Array data easier. An ArrayStore will be
     * automatically configured with a {@link Ext.data.reader.Array}.
     *
     * A store configuration would be something like:
     *
     *     var store = Ext.create('Ext.data.ArrayStore', {
     *         // store configs
     *         storeId: 'myStore',
     *         // reader configs
     *         fields: [
     *            'company',
     *            {name: 'price', type: 'float'},
     *            {name: 'change', type: 'float'},
     *            {name: 'pctChange', type: 'float'},
     *            {name: 'lastChange', type: 'date', dateFormat: 'n/j h:ia'}
     *         ]
     *     });
     *
     * This store is configured to consume a returned object of the form:
     *
     *     var myData = [
     *         ['3m Co',71.72,0.02,0.03,'9/1 12:00am'],
     *         ['Alcoa Inc',29.01,0.42,1.47,'9/1 12:00am'],
     *         ['Boeing Co.',75.43,0.53,0.71,'9/1 12:00am'],
     *         ['Hewlett-Packard Co.',36.53,-0.03,-0.08,'9/1 12:00am'],
     *         ['Wal-Mart Stores, Inc.',45.45,0.73,1.63,'9/1 12:00am']
     *     ];
     *
     * An object literal of this form could also be used as the {@link #cfg-data} config option.
     */
    export class ArrayStore extends Ext.data.Store implements Ext.data.ArrayStoreConfig {
        proxy: string|Ext.data.proxy.Proxy|any;

        /**
         * Creates the store.
         * @param {Object} [config] Config object.
         */
        constructor(config?: Ext.data.ArrayStoreConfig);

        getProxy();

        setProxy();
    }

    interface BatchConfig {
        /**
         * True to pause the execution of the batch if any operation encounters an exception
         * (defaults to false). If you set this to true you are responsible for implementing the appropriate
         * handling logic and restarting or discarding the batch as needed. There are different ways you could
         * do this, e.g. by handling the batch's {@link #event-exception} event directly, or perhaps by overriding
         * {@link Ext.data.ProxyStore#onBatchException onBatchException} at the store level. If you do pause
         * and attempt to handle the exception you can call {@link #retry} to process the same operation again.
         *
         * Note that {@link Ext.data.operation.Operation operations} are atomic, so any operations that may have succeeded
         * prior to an exception (and up until pausing the batch) will be finalized at the server level and will
         * not be automatically reversible. Any transactional / rollback behavior that might be desired would have
         * to be implemented at the application level. Pausing on exception will likely be most beneficial when
         * used in coordination with such a scheme, where an exception might actually affect subsequent operations
         * in the same batch and so should be handled before continuing with the next operation.
         *
         * If you have not implemented transactional operation handling then this option should typically be left
         * to the default of false (e.g. process as many operations as possible, and handle any exceptions
         * asynchronously without holding up the rest of the batch).
         */
        pauseOnException?: boolean;
    }

    /**
     * Provides a mechanism to run one or more {@link Ext.data.operation.Operation operations}
     * in a given order. Fires the 'operationcomplete' event after the completion of each
     * Operation, and the 'complete' event when all Operations have been successfully executed.
     * Fires an 'exception' event if any of the Operations encounter an exception.
     *
     * Usually these are only used internally by {@link Ext.data.proxy.Proxy} classes.
     */
    export class Batch extends Ext.Base implements Ext.data.BatchConfig {
        /**
         * Ordered array of operations that raised an exception during the most recent
         * batch execution and did not successfully complete
         */
        exceptions: Ext.data.operation.Operation;

        /**
         * True to pause the execution of the batch if any operation encounters an exception
         * (defaults to false). If you set this to true you are responsible for implementing the appropriate
         * handling logic and restarting or discarding the batch as needed. There are different ways you could
         * do this, e.g. by handling the batch's {@link #event-exception} event directly, or perhaps by overriding
         * {@link Ext.data.ProxyStore#onBatchException onBatchException} at the store level. If you do pause
         * and attempt to handle the exception you can call {@link #retry} to process the same operation again.
         *
         * Note that {@link Ext.data.operation.Operation operations} are atomic, so any operations that may have succeeded
         * prior to an exception (and up until pausing the batch) will be finalized at the server level and will
         * not be automatically reversible. Any transactional / rollback behavior that might be desired would have
         * to be implemented at the application level. Pausing on exception will likely be most beneficial when
         * used in coordination with such a scheme, where an exception might actually affect subsequent operations
         * in the same batch and so should be handled before continuing with the next operation.
         *
         * If you have not implemented transactional operation handling then this option should typically be left
         * to the default of false (e.g. process as many operations as possible, and handle any exceptions
         * asynchronously without holding up the rest of the batch).
         */
        pauseOnException: boolean;

        /**
         * Adds a new operation to this batch at the end of the {@link #operations} array
         * The {@link Ext.data.operation.Operation Operation} object or an array of operations.
         * @return {Ext.data.Batch} this
         */
        add(operation: Ext.data.operation.Operation): Ext.data.Batch;

        /**
         * Creates new Batch object.
         * @param {Object} [config] Config object
         */
        constructor(config?: Ext.data.BatchConfig);

        /**
         * Gets the currently running operation. Will return null if the batch has
         * not started or is completed.
         * @return {Ext.data.operation.Operation} The operation
         */
        getCurrent(): Ext.data.operation.Operation;

        /**
         * Gets any operations that have returned without success in this batch.
         * @return {Ext.data.operation.Operation[]} The exceptions
         */
        getExceptions(): Ext.data.operation.Operation;

        /**
         * Gets the operations for this batch.
         * @return {Ext.data.operation.Operation[]} The operations.
         */
        getOperations(): Ext.data.operation.Operation;

        getPauseOnException();

        /**
         * Gets the total number of operations in this batch.
         * @return {Number} The total
         */
        getTotal(): number;

        /**
         * Checks if this batch has any exceptions.
         * @return {Boolean} 'true' if this batch has any exceptions.
         */
        hasException(): boolean;

        /**
         * Checks if this batch is complete.
         * @return {Boolean} 'true' if this batch is complete.
         */
        isComplete(): boolean;

        /**
         * Checks if this batch is running.
         * @return {Boolean} 'true' if this batch is running.
         */
        isRunning(): boolean;

        /**
         * Pauses execution of the batch, but does not cancel the current operation
         * @return {Ext.data.Batch} this
         */
        pause(): Ext.data.Batch;

        /**
         * Kicks off execution of the batch, continuing from the current operation. This is intended
         * for restarting a {@link #pause paused} batch after an exception, and the operation that raised
         * the exception will now be retried. The batch will then continue with its normal processing until
         * all operations are complete or another exception is encountered.
         *
         * Note that if the batch is already running any call to retry will be ignored.
         *
         * @return {Ext.data.Batch} this
         */
        retry(): Ext.data.Batch;

        setPauseOnException();

        /**
         * Sorts the '{@link Ext.data.operation.Operation operations}' based on their type and
         * the foreign key dependencies of the entities. Consider a simple Parent and Child
         * case where the Child has a "parentId" field. If this batch contains two 'create'
         * operations, one of a Parent and one for its Child, the server must receive and
         * process the 'create' of the Parent before the Child can be created.
         *
         * In the case of 'destroy' operations this order is reversed. The Child entity must be
         * destroyed before the Parent to avoid any foreign key constraints (a Child with an
         * invalid parentId field).
         *
         * Further, 'create' operations must all occur before 'update' operations to ensure
         * that all entities exist that might be now referenced by the updates. The created
         * entities can safely reference already existing entities.
         *
         * Finally, 'destroy' operations are sorted after 'update' operations to allow those
         * updates to remove references to the soon-to-be-deleted entities.
         */
        sort();

        /**
         * Kicks off execution of the batch, continuing from the next operation if the previous
         * operation encountered an exception, or if execution was paused. Use this method to start
         * the batch for the first time or to restart a paused batch by skipping the current
         * unsuccessful operation.
         *
         * To retry processing the current operation before continuing to the rest of the batch (e.g.
         * because you explicitly handled the operation's exception), call {@link #retry} instead.
         *
         * Note that if the batch is already running any call to start will be ignored.
         *
         * @return {Ext.data.Batch} this
         */
        start(): Ext.data.Batch;

        /**
         * Fired when all operations of this batch have been completed
         * @param {Ext.data.Batch} batch The batch object
         * @param {Object} operation The last operation that was executed
         */
        complete(batch: Ext.data.Batch, operation: any);

        /**
         * Fired when a operation encountered an exception
         * @param {Ext.data.Batch} batch The batch object
         * @param {Object} operation The operation that encountered the exception
         */
        exception(batch: Ext.data.Batch, operation: any);

        /**
         * Fired when each operation of the batch completes
         * @param {Ext.data.Batch} batch The batch object
         * @param {Object} operation The operation that just completed
         */
        operationcomplete(batch: Ext.data.Batch, operation: any);
    }

    interface BufferedStoreConfig extends Ext.data.ProxyStoreConfig {
        /**
         * The number of extra rows to keep cached on the leading side of scrolling buffer
         * as scrolling proceeds. A larger number means fewer replenishments from the server.
         */
        leadingBufferZone?: number;

        pageSize?: any;

        /**
         * The number of pages *in addition to twice the required buffered range* to keep in the prefetch cache before purging least recently used records.
         *
         * For example, if the height of the view area and the configured {@link #trailingBufferZone} and {@link #leadingBufferZone} require that there
         * are three pages in the cache, then a 'purgePageCount' of 5 ensures that up to 11 pages can be in the page cache any any one time. This is enough
         * to allow the user to scroll rapidly between different areas of the dataset without evicting pages which are still needed.
         *
         * A value of 0 indicates to never purge the prefetched data.
         */
        purgePageCount?: number;

        remoteFilter?: any;

        remoteSort?: any;

        sortOnLoad?: any;

        trackRemoved?: any;

        /**
         * The number of extra records to keep cached on the trailing side of scrolling buffer
         * as scrolling proceeds. A larger number means fewer replenishments from the server.
         */
        trailingBufferZone?: number;
    }

    /**
     * A BufferedStore maintains a sparsely populated map of pages corresponding to an extremely large server-side dataset.
     *
     * Use a BufferedStore when the dataset size is so large that the database and network latency, and client memory requirements
     * preclude caching the entire dataset in a regular {@link Ext.data.Store Store}.
     *
     * When using a BufferedStore *not all of the dataset is present in the client*. Only pages which have been
     * requested by the UI (usually a {@link Ext.grid.Panel GridPanel}) and surrounding pages will be present. Retention
     * of viewed pages in the BufferedStore after they have been scrolled out of view is configurable. See {@link #leadingBufferZone},
     * {@link #trailingBufferZone} and {@link #purgePageCount}.
     *
     * To use a BufferedStore, initiate the loading process by loading the first page. The number of rows rendered are
     * determined automatically, and the range of pages needed to keep the cache primed for scrolling is
     * requested and cached.
     * Example:
     *
     *     myBufferedStore.loadPage(1); // Load page 1
     *
     * A {@link Ext.grid.plugin.BufferedRenderer BufferedRenderer} is instantiated which will monitor the scrolling in the grid, and
     * refresh the view's rows from the page cache as needed. It will also pull new data into the page
     * cache when scrolling of the view draws upon data near either end of the prefetched data.
     *
     * The margins which trigger view refreshing from the prefetched data are {@link Ext.grid.plugin.BufferedRenderer#numFromEdge},
     * {@link Ext.grid.plugin.BufferedRenderer#leadingBufferZone} and {@link Ext.grid.plugin.BufferedRenderer#trailingBufferZone}.
     *
     * The margins which trigger loading more data into the page cache are, {@link #leadingBufferZone} and
     * {@link #trailingBufferZone}.
     *
     * By default, only 5 pages of data (in addition to the pages which over the visible region) are cached in the page cache,
     * with old pages being evicted from the cache as the view moves down through the dataset. This is controlled by the
     * {@link #purgePageCount} setting.
     *
     * Setting this value to zero means that no pages are *ever* scrolled out of the page cache, and
     * that eventually the whole dataset may become present in the page cache. This is sometimes desirable
     * as long as datasets do not reach astronomical proportions.
     *
     * Selection state may be maintained across page boundaries by configuring the SelectionModel not to discard
     * records from its collection when those Records cycle out of the Store's primary collection. This is done
     * by configuring the SelectionModel like this:
     *
     *     selModel: {
     *         pruneRemoved: false
     *     }
     */
    export class BufferedStore extends Ext.data.ProxyStore implements Ext.data.BufferedStoreConfig {
        /**
         * 'true' in this class to identify an object as an instantiated BufferedStore, or subclass thereof.
         */
        isBufferedStore: boolean;

        /**
         * The number of extra rows to keep cached on the leading side of scrolling buffer
         * as scrolling proceeds. A larger number means fewer replenishments from the server.
         */
        leadingBufferZone: number;

        pageSize: number;

        /**
         * The number of pages *in addition to twice the required buffered range* to keep in the prefetch cache before purging least recently used records.
         *
         * For example, if the height of the view area and the configured {@link #trailingBufferZone} and {@link #leadingBufferZone} require that there
         * are three pages in the cache, then a 'purgePageCount' of 5 ensures that up to 11 pages can be in the page cache any any one time. This is enough
         * to allow the user to scroll rapidly between different areas of the dataset without evicting pages which are still needed.
         *
         * A value of 0 indicates to never purge the prefetched data.
         */
        purgePageCount: number;

        remoteFilter: boolean;

        remoteSort: boolean;

        sortOnLoad: boolean;

        /**
         * This config controls whether removed records are remembered by this store for
         * later saving to the server.
         *
         * Optional, Defaults to: true
         */
        trackRemoved: boolean;

        /**
         * The number of extra records to keep cached on the trailing side of scrolling buffer
         * as scrolling proceeds. A larger number means fewer replenishments from the server.
         */
        trailingBufferZone: number;

        /**
         * We are using applyData so that we can return nothing and prevent the 'this.data'
         * property to be overridden.
         */
        applyData(data: any[]|any);

        constructor();

        flushLoad();

        /**
         * Get the Record with the specified id.
         *
         * This method is not affected by filtering, lookup will be performed from all records
         * inside the store, filtered or not.
         *
         * @param {Mixed} id The id of the Record to find.
         * @return {Ext.data.Model} The Record with the passed id. Returns null if not found.
         */
        getById(id: any): Ext.data.Model;

        getData();

        getGrouper();

        getLeadingBufferZone();

        /**
         * Determines the page from a record index
         * @param {Number} index The record index
         * @return {Number} The page the record belongs to
         */
        getPageFromRecordIndex(index: number): number;

        getPageSize();

        getPurgePageCount();

        getRemoteFilter();

        getRemoteSort();

        getSortOnLoad();

        getTrackRemoved();

        getTrailingBufferZone();

        /**
         * Guarantee a specific range, this will load the store with a range (that
         * must be the 'pageSize' or smaller) and take care of any loading that may
         * be necessary.
         * @deprecated Use {@link #getRange}
         */
        guaranteeRange();

        /**
         * Get the index of the record within the store.
         *
         * When store is filtered, records outside of filter will not be found.
         *
         * @param {Ext.data.Model} record The Ext.data.Model object to find.
         * @return {Number} The index of the passed Record. Returns -1 if not found.
         */
        indexOf(record: Ext.data.Model): number;

        /**
         * Get the index within the store of the Record with the passed id.
         *
         * Like #indexOf, this method is effected by filtering.
         *
         * @param {String} id The id of the Record to find.
         * @return {Number} The index of the Record. Returns -1 if not found.
         */
        indexOfId(id: string): number;

        /**
         * Prefetches data into the store using its configured {@link #proxy}.
         * @param {Object} options (Optional) config object, passed into the Ext.data.operation.Operation object before loading.
         * See {@link #method-load}
         */
        prefetch(options: any);

        /**
         * Prefetches a page of data.
         * @param {Number} page The page to prefetch
         * @param {Object} options (Optional) config object, passed into the Ext.data.operation.Operation object before loading.
         * See {@link #method-load}
         */
        prefetchPage(page: number, options: any);

        /**
         * Ensures that the specified range of rows is present in the cache.
         *
         * Converts the row range to a page range and then only load pages which are not already
         * present in the page cache.
         */
        prefetchRange();

        removeAll();

        setData();

        setLeadingBufferZone();

        setPageSize();

        setPurgePageCount();

        setRemoteFilter();

        setRemoteSort();

        setSortOnLoad();

        setTrackRemoved();

        setTrailingBufferZone();
    }

    interface ChainedStoreConfig extends Ext.data.AbstractStoreConfig {
        remoteFilter?: any;

        remoteSort?: any;

        /**
         * The backing data source for this chained store. Either a store instance
         * or the id of an existing store.
         */
        source?: Ext.data.Store|string;
    }

    /**
     * A chained store is a store that is a "view" of an existing store. The data comes from the
     * {@link #source}, however this view of the store may be sorted & filtered independently without
     * having any impact on the {@link #source} store.
     */
    export class ChainedStore extends Ext.data.AbstractStore implements Ext.data.ChainedStoreConfig {
        /**
         * 'true' to defer any filtering operation to the server. If 'false', filtering is done locally on the client.
         *
         * Optional, Defaults to: false
         */
        remoteFilter: boolean;

        /**
         * 'true' if the sorting should be performed on the server side, false if it is local only.
         *
         * Optional, Defaults to: false
         */
        remoteSort: boolean;

        /**
         * The backing data source for this chained store. Either a store instance
         * or the id of an existing store.
         */
        source: Ext.data.Store|string;

        aggregate();

        average();

        collect();

        constructor();

        count();

        each();

        first();

        getByInternalId();

        /**
         * Get the model used for this store.
         * @return {Ext.data.Model} The model
         */
        getModel(): Ext.data.Model;

        getRemoteFilter();

        getRemoteSort();

        getSource();

        indexOf();

        indexOfId();

        insert();

        last();

        max();

        min();

        query();

        queryBy();

        setRemoteFilter();

        setRemoteSort();

        setSource();

        sum();
    }

    interface ConnectionConfig {
        /**
         * 'true' if this request should run asynchronously. Setting this to 'false' should generally
         * be avoided, since it will cause the UI to be blocked, the user won't be able to interact
         * with the browser until the request completes.
         */
        async?: boolean;

        /**
         * Whether this request should abort any pending requests.
         *
         * Optional, Defaults to: false
         */
        autoAbort?: boolean;

        /**
         * True if the response should be treated as binary data.  If true, the binary
         * data will be accessible as a "responseBytes" property on the response object.
         */
        binary?: boolean;

        /**
         * True to enable CORS support on the XHR object. Currently the only effect of this option
         * is to use the XDomainRequest object instead of XMLHttpRequest if the browser is IE8 or above.
         */
        cors?: boolean;

        /**
         * An object containing request headers which are added to each request made by this object.
         */
        defaultHeaders?: any;

        /**
         * The default header to be sent out with any post request.
         */
        defaultPostHeader?: string;

        /**
         * The header to send with Ajax requests. Also see {@link #useDefaultXhrHeader}.
         */
        defaultXhrHeader?: any;

        /**
         * True to add a unique cache-buster param to GET requests.
         */
        disableCaching?: boolean;

        /**
         * Change the parameter which is sent went disabling caching through a cache buster.
         */
        disableCachingParam?: string;

        /**
         * Any parameters to be appended to the request.
         *
         * Optional
         */
        extraParams?: any;

        /**
         * The default HTTP method to be used for requests.
         *
         * If not set, but {@link #request} params are present, POST will be used;
         * otherwise, GET will be used.
         */
        method?: string;

        /**
         * The password to pass when using {@link #withCredentials}.
         */
        password?: string;

        /**
         * The timeout in milliseconds to be used for
         * requests.
         * Defaults to 30000 milliseconds (30 seconds).
         *
         * When a request fails due to timeout the XMLHttpRequest response object will
         * contain:
         *
         *     timedout: true
         *
         * Optional, Defaults to: 30000
         */
        timeout?: number;

        /**
         * The URL for this connection.
         */
        url?: string;

        /**
         * 'true' to send the {@link #defaultXhrHeader} along with any request.
         */
        useDefaultXhrHeader?: boolean;

        /**
         * The username to pass when using {@link #withCredentials}.
         */
        username?: string;

        /**
         * True to set 'withCredentials = true' on the XHR object
         */
        withCredentials?: boolean;
    }

    /**
     * The Connection class encapsulates a connection to the page's originating domain, allowing requests to be made either
     * to a configured URL, or to a URL specified at request time.
     *
     * Requests made by this class are asynchronous, and will return immediately. No data from the server will be available
     * to the statement immediately following the {@link #request} call. To process returned data, use a success callback
     * in the request options object, or an {@link #requestcomplete event listener}.
     *
     * # File Uploads
     *
     * File uploads are not performed using normal "Ajax" techniques, that is they are not performed using XMLHttpRequests.
     * Instead the form is submitted in the standard manner with the DOM &lt;form&gt; element temporarily modified to have its
     * target set to refer to a dynamically generated, hidden &lt;iframe&gt; which is inserted into the document but removed
     * after the return data has been gathered.
     *
     * The server response is parsed by the browser to create the document for the IFRAME. If the server is using JSON to
     * send the return object, then the Content-Type header must be set to "text/html" in order to tell the browser to
     * insert the text unchanged into the document body.
     *
     * Characters which are significant to an HTML parser must be sent as HTML entities, so encode '<' as '&lt;', '&' as
     * '&amp;' etc.
     *
     * The response text is retrieved from the document, and a fake XMLHttpRequest object is created containing a
     * responseText property in order to conform to the requirements of event handlers and callbacks.
     *
     * Be aware that file upload packets are sent with the content type multipart/form and some server technologies
     * (notably JEE) may require some custom processing in order to retrieve parameter names and parameter values from the
     * packet content.
     *
     * Also note that it's not possible to check the response code of the hidden iframe, so the success handler will ALWAYS fire.
     *
     * # Binary Posts
     *
     * The class supports posting binary data to the server by using native browser capabilities, or a flash polyfill plugin in browsers that do not support native binary posting (e.g. Internet Explorer version 9 or less). A number of limitations exist when the polyfill is used:
     *
     * - Only asynchronous connections are supported.
     * - Only the POST method can be used.
     * - The return data can only be binary for now. Set the {@link Ext.data.Connection#binary binary} parameter to <tt>true</tt>.
     * - Only the 0, 1 and 4 (complete) readyState values will be reported to listeners.
     * - The flash object will be injected at the bottom of the document and should be invisible.
     * - Important: See note about packaing the flash plugin with the app in the documenetation of {@link Ext.data.flash.BinaryXhr BinaryXhr}.
     */
    export class Connection extends Ext.Base implements Ext.data.ConnectionConfig {
        /**
         * 'true' if this request should run asynchronously. Setting this to 'false' should generally
         * be avoided, since it will cause the UI to be blocked, the user won't be able to interact
         * with the browser until the request completes.
         */
        async: boolean;

        /**
         * Whether this request should abort any pending requests.
         *
         * Optional, Defaults to: false
         */
        autoAbort: boolean;

        /**
         * True if the response should be treated as binary data.  If true, the binary
         * data will be accessible as a "responseBytes" property on the response object.
         */
        binary: boolean;

        /**
         * True to enable CORS support on the XHR object. Currently the only effect of this option
         * is to use the XDomainRequest object instead of XMLHttpRequest if the browser is IE8 or above.
         */
        cors: boolean;

        /**
         * An object containing request headers which are added to each request made by this object.
         */
        defaultHeaders: any;

        /**
         * The default header to be sent out with any post request.
         */
        defaultPostHeader: string;

        /**
         * The header to send with Ajax requests. Also see {@link #useDefaultXhrHeader}.
         */
        defaultXhrHeader: any;

        /**
         * True to add a unique cache-buster param to GET requests.
         */
        disableCaching: boolean;

        /**
         * Change the parameter which is sent went disabling caching through a cache buster.
         */
        disableCachingParam: string;

        /**
         * Any parameters to be appended to the request.
         *
         * Optional
         */
        extraParams: any;

        /**
         * The default HTTP method to be used for requests.
         *
         * If not set, but {@link #request} params are present, POST will be used;
         * otherwise, GET will be used.
         */
        method: string;

        /**
         * The password to pass when using {@link #withCredentials}.
         */
        password: string;

        /**
         * The timeout in milliseconds to be used for
         * requests.
         * Defaults to 30000 milliseconds (30 seconds).
         *
         * When a request fails due to timeout the XMLHttpRequest response object will
         * contain:
         *
         *     timedout: true
         *
         * Optional, Defaults to: 30000
         */
        timeout: number;

        /**
         * The URL for this connection.
         */
        url: string;

        /**
         * 'true' to send the {@link #defaultXhrHeader} along with any request.
         */
        useDefaultXhrHeader: boolean;

        /**
         * The username to pass when using {@link #withCredentials}.
         */
        username: string;

        /**
         * True to set 'withCredentials = true' on the XHR object
         */
        withCredentials: boolean;

        /**
         * Aborts an active request.
         * @param {Ext.ajax.Request} [request] Defaults to the last request
         */
        abort(request?: any);

        /**
         * Aborts all active requests
         */
        abortAll();

        getAsync();

        getAutoAbort();

        getBinary();

        getCors();

        getDefaultHeaders();

        getDefaultPostHeader();

        getDefaultXdrContentType();

        getDefaultXhrHeader();

        getDisableCaching();

        getDisableCachingParam();

        getExtraParams();

        getIsXdr();

        getMethod();

        getPassword();

        getTimeout();

        getUrl();

        getUseDefaultXhrHeader();

        getUsername();

        getWithCredentials();

        /**
         * Determines whether this object has a request outstanding.
         *
         * @param {Object} [request] Defaults to the last transaction
         *
         * @return {Boolean} True if there is an outstanding request.
         */
        isLoading(request?: any): boolean;

        /**
         * Sends an HTTP (Ajax) request to a remote server.
         *
         * **Important:** Ajax server requests are asynchronous, and this call will
         * return before the response has been received.
         *
         * Instead, process any returned data using a promise:
         *
         *      Ext.Ajax.request({
         *          url: 'ajax_demo/sample.json'
         *      }).then(function(response, opts) {
         *          var obj = Ext.decode(response.responseText);
         *          console.dir(obj);
         *      },
         *      function(response, opts) {
         *          console.log('server-side failure with status code ' + response.status);
         *      });
         *
         * Or in callback functions:
         *
         *      Ext.Ajax.request({
         *          url: 'ajax_demo/sample.json',
         *
         *          success: function(response, opts) {
         *              var obj = Ext.decode(response.responseText);
         *              console.dir(obj);
         *          },
         *
         *          failure: function(response, opts) {
         *              console.log('server-side failure with status code ' + response.status);
         *          }
         *      });
         *
         * To execute a callback function in the correct scope, use the 'scope' option.
         *
         * @param {Object} options An object which may contain the following properties:
         *
         * (The options object may also contain any other property which might be needed to perform
         * postprocessing in a callback because it is passed to callback functions.)
         *
         * @param {String/Function} options.url The URL to which to send the request, or a function
         * to call which returns a URL string. The scope of the function is specified by the 'scope' option.
         * Defaults to the configured 'url'.
         *
         * @param {Boolean} options.async 'true' if this request should run asynchronously.
         * Setting this to 'false' should generally be avoided, since it will cause the UI to be
         * blocked, the user won't be able to interact with the browser until the request completes.
         * Defaults to 'true'.
         *
         * @param {Object/String/Function} options.params An object containing properties which are
         * used as parameters to the request, a url encoded string or a function to call to get either. The scope
         * of the function is specified by the 'scope' option.
         *
         * @param {String} options.method The HTTP method to use
         * for the request. Defaults to the configured method, or if no method was configured,
         * "GET" if no parameters are being sent, and "POST" if parameters are being sent.  Note that
         * the method name is case-sensitive and should be all caps.
         *
         * @param {Function} options.callback The function to be called upon receipt of the HTTP response.
         * The callback is called regardless of success or failure and is passed the following parameters:
         * @param {Object} options.callback.options The parameter to the request call.
         * @param {Boolean} options.callback.success True if the request succeeded.
         * @param {Object} options.callback.response The XMLHttpRequest object containing the response data.
         * See [www.w3.org/TR/XMLHttpRequest/](http://www.w3.org/TR/XMLHttpRequest/) for details about
         * accessing elements of the response.
         *
         * @param {Function} options.success The function to be called upon success of the request.
         * The callback is passed the following parameters:
         * @param {Object} options.success.response The XMLHttpRequest object containing the response data.
         * @param {Object} options.success.options The parameter to the request call.
         *
         * @param {Function} options.failure The function to be called upon failure of the request.
         * The callback is passed the following parameters:
         * @param {Object} options.failure.response The XMLHttpRequest object containing the response data.
         * @param {Object} options.failure.options The parameter to the request call.
         *
         * @param {Object} options.scope The scope in which to execute the callbacks: The "this" object for
         * the callback function. If the 'url', or 'params' options were specified as functions from which to
         * draw values, then this also serves as the scope for those function calls. Defaults to the browser
         * window.
         *
         * @param {Number} options.timeout The timeout in milliseconds to be used for this
         * request.
         * Defaults to 30000 milliseconds (30 seconds).
         *
         * When a request fails due to timeout the XMLHttpRequest response object will
         * contain:
         *
         *     timedout: true
         *
         * @param {Ext.Element/HTMLElement/String} options.form The '<form>' Element or the id of the '<form>'
         * to pull parameters from.
         *
         * @param {Boolean} options.isUpload **Only meaningful when used with the 'form' option.**
         *
         * True if the form object is a file upload (will be set automatically if the form was configured
         * with **'enctype'** '"multipart/form-data"').
         *
         * File uploads are not performed using normal "Ajax" techniques, that is they are **not**
         * performed using XMLHttpRequests. Instead the form is submitted in the standard manner with the
         * DOM '<form>' element temporarily modified to have its [target][] set to refer to a dynamically
         * generated, hidden '<iframe>' which is inserted into the document but removed after the return data
         * has been gathered.
         *
         * The server response is parsed by the browser to create the document for the IFRAME. If the
         * server is using JSON to send the return object, then the [Content-Type][] header must be set to
         * "text/html" in order to tell the browser to insert the text unchanged into the document body.
         *
         * The response text is retrieved from the document, and a fake XMLHttpRequest object is created
         * containing a 'responseText' property in order to conform to the requirements of event handlers
         * and callbacks.
         *
         * Be aware that file upload packets are sent with the content type [multipart/form][] and some server
         * technologies (notably JEE) may require some custom processing in order to retrieve parameter names
         * and parameter values from the packet content.
         *
         * [target]: http://www.w3.org/TR/REC-html40/present/frames.html#adef-target
         * [Content-Type]: http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17
         * [multipart/form]: http://www.faqs.org/rfcs/rfc2388.html
         *
         * @param {Object} options.headers Request headers to set for the request.
         * The XHR will attempt to set an appropriate Content-Type based on the params/data passed
         * to the request. To prevent this, setting the Content-Type header to 'null' or 'undefined'
         * will not attempt to set any Content-Type and it will be left to the browser.
         *
         * @param {Object} options.xmlData XML document to use for the post. Note: This will be used instead
         * of params for the post data. Any params will be appended to the URL.
         *
         * @param {Object/String} options.jsonData JSON data to use as the post. Note: This will be used
         * instead of params for the post data. Any params will be appended to the URL.
         *
         * @param {String} options.rawData A raw string to use as the post. Note: This will be used
         * instead of params for the post data. Any params will be appended to the URL.
         *
         * @param {Array} options.binaryData An array of bytes to submit in binary form. Any params will be appended to the URL. If binaryData is present, you must set {@link Ext.data.Connection#binary binary} to <tt>true</tt> and options.method to <tt>POST</tt>.
         *
         * @param {Boolean} options.disableCaching True to add a unique cache-buster param to GET requests.
         *
         * @param {Boolean} options.withCredentials True to add the withCredentials property to the XHR object
         *
         * @param {String} options.username The username to pass when using 'withCredentials'.
         *
         * @param {String} options.password The password to pass when using 'withCredentials'.
         *
         * @param {Boolean} options.binary True if the response should be treated as binary data.  If true, the binary
         * data will be accessible as a "responseBytes" property on the response object.
         *
         * @return {Ext.data.request.Base} The request object. This may be used to abort the
         * request.
         */
        request(options: any, options_url: string|Function, options_async: boolean, options_params: any|string|Function, options_method: string, options_callback: Function, options_callback_options: any, options_callback_success: boolean, options_callback_response: any, options_success: Function, options_success_response: any, options_success_options: any, options_failure: Function, options_failure_response: any, options_failure_options: any, options_scope: any, options_timeout: number, options_form: Ext.dom.Element|HTMLElement|string, options_isUpload: boolean, options_headers: any, options_xmlData: any, options_jsonData: any|string, options_rawData: string, options_binaryData: any[], options_disableCaching: boolean, options_withCredentials: boolean, options_username: string, options_password: string, options_binary: boolean): Ext.data.request.Base;

        setAsync();

        setAutoAbort();

        setBinary();

        setCors();

        setDefaultHeaders();

        setDefaultPostHeader();

        setDefaultXdrContentType();

        setDefaultXhrHeader();

        setDisableCaching();

        setDisableCachingParam();

        setExtraParams();

        setIsXdr();

        setMethod();

        /**
         * Sets various options such as the url, params for the request
         * @param {Object} options The initial options
         * @param {Object} scope The scope to execute in
         * @return {Object} The params for the request
         */
        setOptions(options: any, scope: any): any;

        setPassword();

        setTimeout();

        setUrl();

        setUseDefaultXhrHeader();

        setUsername();

        setWithCredentials();

        /**
         * Fires before a network request is made to retrieve a data object.
         * @param {Ext.data.Connection} conn This Connection object.
         * @param {Object} options The options config object passed to the {@link #request} method.
         */
        beforerequest(conn: Ext.data.Connection, options: any);

        /**
         * Fires if the request was successfully completed.
         * @param {Ext.data.Connection} conn This Connection object.
         * @param {Object} response The XHR object containing the response data.
         * See [The XMLHttpRequest Object](http://www.w3.org/TR/XMLHttpRequest/) for details.
         * @param {Object} options The options config object passed to the {@link #request} method.
         */
        requestcomplete(conn: Ext.data.Connection, response: any, options: any);

        /**
         * Fires if an error HTTP status was returned from the server. This event may also
         * be listened to in the event that a request has timed out or has been aborted.
         * See [HTTP Status Code Definitions](http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html)
         * for details of HTTP status codes.
         * @param {Ext.data.Connection} conn This Connection object.
         * @param {Object} response The XHR object containing the response data.
         * See [The XMLHttpRequest Object](http://www.w3.org/TR/XMLHttpRequest/) for details.
         * @param {Object} options The options config object passed to the {@link #request} method.
         */
        requestexception(conn: Ext.data.Connection, response: any, options: any);
    }

    /**
     * Small helper class to create an {@link Ext.data.Store} configured with an {@link Ext.data.proxy.Direct}
     * and {@link Ext.data.reader.Json} to make interacting with an {@link Ext.direct.Manager} server-side
     * {@link Ext.direct.Provider Provider} easier. To create a different proxy/reader combination create a basic
     * {@link Ext.data.Store} configured as needed.
     *
     * **Note:** Although they are not listed, this class inherits all of the config options of:
     *
     * - **{@link Ext.data.Store Store}**
     *
     * - **{@link Ext.data.reader.Json JsonReader}**
     *
     *   - **{@link Ext.data.reader.Json#cfg-rootProperty rootProperty}**
     *   - **{@link Ext.data.reader.Json#totalProperty totalProperty}**
     *
     * - **{@link Ext.data.proxy.Direct DirectProxy}**
     *
     *   - **{@link Ext.data.proxy.Direct#directFn directFn}**
     *   - **{@link Ext.data.proxy.Direct#paramOrder paramOrder}**
     *   - **{@link Ext.data.proxy.Direct#paramsAsHash paramsAsHash}**
     */
    export class DirectStore extends Ext.data.Store {
        constructor();
    }

    /**
     * Wraps a collection of validation error responses and provides convenient functions for
     * accessing and errors for specific fields.
     *
     * Usually this class does not need to be instantiated directly - instances are instead
     * created automatically when {@link Ext.data.Model#validate validate} on a model instance:
     *
     *      // Validate some existing model instance - in this case it returned 2 failures
     *      // messages
     *
     *      var errors = myModel.validate();
     *      errors.isValid(); //false
     *
     *      errors.length; //2
     *      errors.getByField('name');  // [{field: 'name',  message: 'must be present'}]
     *      errors.getByField('title'); // [{field: 'title', message: 'is too short'}]
     */
    export class ErrorCollection extends Ext.util.MixedCollection {
        /**
         * Creates new MixedCollection.
         * @param {Object} config A configuration object.
         *  @param {Boolean} [config.allowFunctions=false] Specify 'true' if the {@link #addAll}
         * function should add function references to the collection.
         *  @param {Function} [config.getKey] A function that can accept an item of the type(s) stored in this MixedCollection
         * and return the key value for that item.  This is used when available to look up the key on items that
         * were passed without an explicit key parameter to a MixedCollection method.  Passing this parameter is
         * equivalent to overriding the {@link #method-getKey} method.
         */
        constructor(config: Ext.util.MixedCollectionConfig);

        /**
         * Returns all of the errors for the given field
         * @param {String} fieldName The field to get errors for
         * @return {Object[]} All errors for the given field
         */
        getByField(fieldName: string): any;

        /**
         * Returns true if there are no errors in the collection
         * @return {Boolean}
         */
        isValid(): boolean;
    }

    interface ErrorConfig {
        /**
         * The name of the field this error belongs to.
         */
        field?: string;

        /**
         * The message containing the description of the error.
         */
        message?: string;
    }

    /**
     * This class hols the results of a validator for an 'Ext.data.Model'. These objects are
     * placed in an 'Ext.data.ErrorCollection' and returned by '{@link Ext.data.Model#validate}'.
     *
     * Usually this class does not need to be instantiated directly - instances are instead created
     * automatically when {@link Ext.data.Model#validate validate} on a model instance.
     *
     * @deprecated 5.0 Use 'Ext.data.Validation' instead.
     */
    export class Error extends Ext.Base implements Ext.data.ErrorConfig {
        /**
         * The name of the field this error belongs to.
         */
        field: string;

        /**
         * The message containing the description of the error.
         */
        message: string;

        constructor(config: Ext.data.ErrorConfig);

        getField();

        getMessage();

        setField();

        setMessage();
    }

    /**
     * This class is used to create JSONP requests. JSONP is a mechanism that allows for making
     * requests for data cross domain. JSONP is basically a '<script>' node with the source of the url executing
     * a function that was created by Ext.data.JsonP. Once the resource has loaded, the '<script>' node will be destroyed.
     *
     * If you have a request such as:
     *
     *     Ext.data.JsonP.request({
     *         url : 'foo.php'
     *     });
     *
     * Ext.data.JsonP will create a '<script>' node in the '<head>' with the 'src' attribute pointing to
     * 'foo.php?callback=Ext.data.JsonP.callback1'. The 'foo.php' script will have to detect the 'callback' URL parameter
     * and return valid JavaScript:
     *
     *     Ext.data.JsonP.callback1({"foo":"bar"});
     *
     * A simple PHP example would look like:
     *
     *     <?php
     *
     *     $data = array('foo' => 'bar');
     *
     *     if (!empty($_REQUEST['callback'])) {
     *         header('Content-Type: application/javascript');
     *         echo $_REQUEST['callback'] . '(';
     *     }
     *
     *     echo json_encode($data);
     *
     *     if (!empty($_REQUEST['callback']) {
     *         echo ');';
     *     }
     *
     *     ?>
     *
     * More information is available <a href="http://en.wikipedia.org/wiki/JSONP">here</a>. You can also use <a href="http://www.jsonplint.com">JSONPLint</a> to test your JSONP.
     */
    export class JsonP {
        /**
         * Specifies the GET parameter that will be sent to the server containing the function name to be executed when
         * the request completes. Defaults to <tt>callback</tt>. Thus, a common request will be in the form of
         * url?callback=Ext.data.JsonP.callback1
         */
        static callbackKey: string;

        /**
         * True to add a unique cache-buster param to requests. Defaults to <tt>true</tt>.
         */
        static disableCaching: boolean;

        /**
         * Change the parameter which is sent went disabling caching through a cache buster. Defaults to <tt>'_dc'</tt>.
         */
        static disableCachingParam: string;

        /**
         * A default timeout for any JsonP requests. If the request has not completed in this time the
         * failure callback will be fired. The timeout is in ms. Defaults to <tt>30000</tt>.
         */
        static timeout: number;

        /**
         * Abort a request. If the request parameter is not specified all open requests will
         * be aborted.
         * @param {Object/String} request (Optional) The request to abort
         */
        static abort(request: any|string);

        /**
         * Makes a JSONP request.
         * @param {Object} options An object which may contain the following properties. Note that options will
         * take priority over any defaults that are specified in the class.
         * <ul>
         * <li><b>url</b> : String <div class="sub-desc">The URL to request.</div></li>
         * <li><b>params</b> : Object (Optional)<div class="sub-desc">An object containing a series of
         * key value pairs that will be sent along with the request.</div></li>
         * <li><b>timeout</b> : Number (Optional) <div class="sub-desc">See {@link #timeout}</div></li>
         * <li><b>callbackKey</b> : String (Optional) <div class="sub-desc">See {@link #callbackKey}</div></li>
         * <li><b>callbackName</b> : String (Optional) <div class="sub-desc">The function name to use for this request.
         * By default this name will be auto-generated: Ext.data.JsonP.callback1, Ext.data.JsonP.callback2, etc.
         * Setting this option to "my_name" will force the function name to be Ext.data.JsonP.my_name.
         * Use this if you want deterministic behavior, but be careful - the callbackName should be different
         * in each JsonP request that you make.</div></li>
         * <li><b>disableCaching</b> : Boolean (Optional) <div class="sub-desc">See {@link #disableCaching}</div></li>
         * <li><b>disableCachingParam</b> : String (Optional) <div class="sub-desc">See {@link #disableCachingParam}</div></li>
         * <li><b>success</b> : Function (Optional) <div class="sub-desc">A function to execute if the request succeeds.</div></li>
         * <li><b>failure</b> : Function (Optional) <div class="sub-desc">A function to execute if the request fails.</div></li>
         * <li><b>callback</b> : Function (Optional) <div class="sub-desc">A function to execute when the request
         * completes, whether it is a success or failure.</div></li>
         * <li><b>scope</b> : Object (Optional)<div class="sub-desc">The scope in
         * which to execute the callbacks: The "this" object for the callback function. Defaults to the browser window.</div></li>
         * </ul>
         * @return {Object} request An object containing the request details.
         */
        static request(options: any): any;
    }

    /**
     * @extends Ext.data.Store
     * <p>Small helper class to make creating {@link Ext.data.Store}s from different domain JSON data easier.
     * A JsonPStore will be automatically configured with a {@link Ext.data.reader.Json} and a {@link Ext.data.proxy.JsonP JsonPProxy}.</p>
     * <p>A store configuration would be something like:<pre><code>
     var store = new Ext.data.JsonPStore({
     // store configs
     storeId: 'myStore',
     // proxy configs
     url: 'get-images.php',
     // reader configs
     root: 'images',
     fields: ['name', 'url', {name:'size', type: 'float'}, {name:'lastmod', type:'date'}]
     });
     * </code></pre></p>
     * <p>This store is configured to consume a returned object of the form:<pre><code>
     stcCallback({
     images: [
     {name: 'Image one', url:'/GetImage.php?id=1', size:46.5, lastmod: new Date(2007, 10, 29)},
     {name: 'Image Two', url:'/GetImage.php?id=2', size:43.2, lastmod: new Date(2007, 10, 30)}
     ]
     })
     * </code></pre>
     * <p>Where stcCallback is the callback name passed in the request to the remote domain. See {@link Ext.data.proxy.JsonP JsonPProxy}
     * for details of how this works.</p>
     * An object literal of this form could also be used as the {@link #cfg-data} config option.</p>
     * @xtype jsonpstore
     */
    export class JsonPStore extends Ext.data.Store {
        constructor(config: any);
    }

    /**
     * Small helper class to make creating {@link Ext.data.Store}s from JSON data easier.
     * A JsonStore will be automatically configured with a {@link Ext.data.reader.Json}.
     *
     * A store configuration would be something like:
     *
     *     var store = new Ext.data.JsonStore({
     *         // store configs
     *         storeId: 'myStore',
     *
     *         proxy: {
     *             type: 'ajax',
     *             url: 'get-images.php',
     *             reader: {
     *                 type: 'json',
     *                 rootProperty: 'images'
     *             }
     *         },
     *
     *         //alternatively, a Model name can be given (see Ext.data.Store for an example)
     *         fields: ['name', 'url', {name:'size', type: 'float'}, {name:'lastmod', type:'date'}]
     *     });
     *
     * This store is configured to consume a returned object of the form:
     *
     *     {
     *         images: [
     *             {name: 'Image one', url:'/GetImage.php?id=1', size:46.5, lastmod: new Date(2007, 10, 29)},
     *             {name: 'Image Two', url:'/GetImage.php?id=2', size:43.2, lastmod: new Date(2007, 10, 30)}
     *         ]
     *     }
     *
     * An object literal of this form could also be used as the {@link #cfg-data} config option.
     */
    export class JsonStore extends Ext.data.Store {
        constructor(config: any);
    }

    /**
     * A mixin that provides common store methods for Ext.data.Store & Ext.data.ChainedStore.
     */
    export class LocalStore extends Ext.Mixin {
        /**
         * Adds Model instance to the Store. This method accepts either:
         *
         * - An array of Model instances or Model configuration objects.
         * - Any number of Model instance or Model configuration object arguments.
         *
         * The new Model instances will be added at the end of the existing collection.
         *
         * Sample usage:
         *
         *     myStore.add({some: 'data'}, {some: 'other data'});
         *
         * Note that if this Store is sorted, the new Model instances will be inserted
         * at the correct point in the Store to maintain the sort order.
         *
         * @param {Ext.data.Model[]/Ext.data.Model.../Object[]/Object...} model An array of Model instances
         * or Model configuration objects, or variable number of Model instance or config arguments.
         * @return {Ext.data.Model[]} The model instances that were added
         */
        add(model: Ext.data.Model[]|any[]): Ext.data.Model;

        /**
         * Runs the aggregate function for all the records in the store.
         *
         * When store is filtered, only items within the filter are aggregated.
         *
         * @param {Function} fn The function to execute. The function is called with a single parameter,
         * an array of records for that group.
         * @param {Object} [scope] The scope to execute the function in. Defaults to the store.
         * @param {Boolean} [grouped] True to perform the operation for each group
         * in the store. The value returned will be an object literal with the key being the group
         * name and the group average being the value. The grouped parameter is only honored if
         * the store has a groupField.
         * @param {String} field The field to get the value from
         * @return {Object} An object literal with the group names and their appropriate values.
         */
        aggregate(fn: Function, scope?: any, grouped?: boolean, field?: string): any;

        /**
         * Gets the average value in the store.
         *
         * When store is filtered, only items within the filter are aggregated.
         *
         * @param {String} field The field in each record
         * @param {Boolean} [grouped] True to perform the operation for each group
         * in the store. The value returned will be an object literal with the key being the group
         * name and the group average being the value. The grouped parameter is only honored if
         * the store has a groupField.
         * @return {Object} The average value, if no items exist, 0.
         */
        average(field: string, grouped?: boolean): any;

        /**
         * Collects unique values for a particular dataIndex from this store.
         *
         * Note that the 'filtered' option can also be passed as a separate parameter for
         * compatibility with previous versions.
         *
         *     var store = Ext.create('Ext.data.Store', {
         *         fields: ['name'],
         *         data: [{
         *             name: 'Larry'
         *         }, {
         *             name: 'Darryl'
         *         }, {
         *             name: 'Darryl'
         *         }]
         *     });
         *
         *     store.collect('name');
         *     // returns ["Larry", "Darryl"]
         *
         * @param {String} property The property to collect
         * @param {Object} [includeOptions] An object which contains options which modify how the store is traversed.
         * @param {Boolean} [includeOptions.allowNull] Pass true to allow null, undefined or empty string values.
         * @param {Boolean} [includeOptions.filtered] Pass 'true' to collect from all records, even ones which are filtered.
         *
         * @return {Object[]} An array of the unique values
         */
        collect(property: string, includeOptions?: any, includeOptions_allowNull?: boolean, includeOptions_filtered?: boolean): any;

        /**
         * Gets the count of items in the store.
         *
         * When store is filtered, only items within the filter are counted.
         *
         * @param {Boolean} [grouped] True to perform the operation for each group
         * in the store. The value returned will be an object literal with the key being the group
         * name and the count for each group being the value. The grouped parameter is only honored if
         * the store has a groupField.
         * @return {Number} the count
         */
        count(grouped?: boolean): number;

        /**
         * Calls the specified function for each {@link Ext.data.Model record} in the store.
         *
         * When store is filtered, only loops over the filtered records.
         *
         * @param {Function} fn The function to call. The {@link Ext.data.Model Record} is passed as the first parameter.
         * Returning 'false' aborts and exits the iteration.
         * @param {Object} [scope] The scope ('this' reference) in which the function is executed.
         * Defaults to the current {@link Ext.data.Model record} in the iteration.
         * @param {Object} [includeOptions] An object which contains options which modify how the store is traversed.
         * @param {Boolean} [includeOptions.filtered] Pass 'true' to include filtered out nodes in the iteration.
         *
         * Note that the 'filtered' option can also be passed as a separate parameter for
         * compatibility with previous versions.
         */
        each(fn: Function, scope?: any, includeOptions?: any, includeOptions_filtered?: boolean);

        /**
         * Convenience function for getting the first model instance in the store.
         *
         * When store is filtered, will return first item within the filter.
         *
         * @param {Boolean} [grouped] True to perform the operation for each group
         * in the store. The value returned will be an object literal with the key being the group
         * name and the first record being the value. The grouped parameter is only honored if
         * the store has a groupField.
         * @return {Ext.data.Model/undefined} The first model instance in the store, or undefined
         */
        first(grouped?: boolean): Ext.data.Model;

        /**
         * Get the Record with the specified id.
         *
         * This method is not affected by filtering, lookup will be performed from all records
         * inside the store, filtered or not.
         *
         * @param {Mixed} id The id of the Record to find.
         * @return {Ext.data.Model} The Record with the passed id. Returns null if not found.
         */
        getById(id: any): Ext.data.Model;

        getExtraKeys();

        /**
         * Get the index of the record within the store.
         *
         * When store is filtered, records outside of filter will not be found.
         *
         * @param {Ext.data.Model} record The Ext.data.Model object to find.
         * @return {Number} The index of the passed Record. Returns -1 if not found.
         */
        indexOf(record: Ext.data.Model): number;

        /**
         * Get the index within the store of the Record with the passed id.
         *
         * Like #indexOf, this method is affected by filtering.
         *
         * @param {String} id The id of the Record to find.
         * @return {Number} The index of the Record. Returns -1 if not found.
         */
        indexOfId(id: string): number;

        /**
         * Inserts Model instances into the Store at the given index and fires the add event.
         * See also {@link #method-add}.
         *
         * @param {Number} index The start index at which to insert the passed Records.
         * @param {Ext.data.Model/Ext.data.Model[]/Object/Object[]} records An 'Ext.data.Model' instance, the
         * data needed to populate an instance or an array of either of these.
         *
         * @return {Ext.data.Model[]} records The added records
         */
        insert(index: number, records: Ext.data.Model|any): Ext.data.Model;

        /**
         * Convenience function for getting the last model instance in the store.
         *
         * When store is filtered, will return last item within the filter.
         *
         * @param {Boolean} [grouped] True to perform the operation for each group
         * in the store. The value returned will be an object literal with the key being the group
         * name and the last record being the value. The grouped parameter is only honored if
         * the store has a groupField.
         * @return {Ext.data.Model/undefined} The last model instance in the store, or undefined
         */
        last(grouped?: boolean): Ext.data.Model;

        /**
         * Gets the maximum value in the store.
         *
         * When store is filtered, only items within the filter are aggregated.
         *
         * @param {String} field The field in each record
         * @param {Boolean} [grouped] True to perform the operation for each group
         * in the store. The value returned will be an object literal with the key being the group
         * name and the maximum in the group being the value. The grouped parameter is only honored if
         * the store has a groupField.
         * @return {Object} The maximum value, if no items exist, undefined.
         */
        max(field: string, grouped?: boolean): any;

        /**
         * Gets the minimum value in the store.
         *
         * When store is filtered, only items within the filter are aggregated.
         *
         * @param {String} field The field in each record
         * @param {Boolean} [grouped] True to perform the operation for each group
         * in the store. The value returned will be an object literal with the key being the group
         * name and the minimum in the group being the value. The grouped parameter is only honored if
         * the store has a groupField.
         * @return {Object} The minimum value, if no items exist, undefined.
         */
        min(field: string, grouped?: boolean): any;

        /**
         * Query all the cached records in this Store by name/value pair.
         * The parameters will be used to generated a filter function that is given
         * to the queryBy method.
         *
         * This method complements queryBy by generating the query function automatically.
         *
         * This method is not affected by filtering, it will always search *all* records in the store
         * regardless of filtering.
         *
         * @param {String} property The property to create the filter function for
         * @param {String/RegExp} value The string/regex to compare the property value to
         * @param {Boolean} [anyMatch=false] True to match any part of the string, not just the
         * beginning.
         * @param {Boolean} [caseSensitive=false] 'true' to create a case-sensitive regex.
         * @param {Boolean} [exactMatch=false] True to force exact match (^ and $ characters
         * added to the regex). Ignored if 'anyMatch' is 'true'.
         * @return {Ext.util.Collection} The matched records
         */
        query(property: string, value: string|RegExp, anyMatch?: boolean, caseSensitive?: boolean, exactMatch?: boolean): Ext.util.Collection;

        /**
         * Query all the cached records in this Store using a filtering function. The specified function
         * will be called with each record in this Store. If the function returns 'true' the record is
         * included in the results.
         *
         * This method is not affected by filtering, it will always search *all* records in the store
         * regardless of filtering.
         *
         * @param {Function} fn The function to be called. It will be passed the following parameters:
         *  @param {Ext.data.Model} fn.record The record to test for filtering. Access field values
         *  using {@link Ext.data.Model#get}.
         *  @param {Object} fn.id The ID of the Record passed.
         * @param {Object} [scope] The scope (this reference) in which the function is executed
         * Defaults to this Store.
         * @return {Ext.util.Collection} The matched records
         */
        queryBy(fn: Function, scope?: any): Ext.util.Collection;

        setExtraKeys();

        /**
         * Sums the value of 'field' for each {@link Ext.data.Model record} in store
         * and returns the result.
         *
         * When store is filtered, only sums items within the filter.
         *
         * @param {String} field A field in each record
         * @param {Boolean} [grouped] True to perform the operation for each group
         * in the store. The value returned will be an object literal with the key being the group
         * name and the sum for that group being the value. The grouped parameter is only honored if
         * the store has a groupField.
         * @return {Number} The sum
         */
        sum(field: string, grouped?: boolean): number;
    }

    interface ModelConfig {
        /**
         * An array of {@link Ext.data.schema.Association associations} for this model.
         */
        associations?: any;

        /**
         * One or more BelongsTo associations for this model.
         */
        belongsTo?: string|any;

        /**
         * The name of the property a server will use to send back a client-generated id in a
         * 'create' or 'update' '{@link Ext.data.operation.Operation operation}'.
         *
         * If specified, this property cannot have the same name as any other field.
         *
         * For example:
         *
         *      Ext.define('Person', {
         *          idProperty: 'id',  // this is the default value (for clarity)
         *
         *          clientIdProperty: 'clientId',
         *
         *          identifier: 'negative', // to generate -1, -2 etc on the client
         *
         *          fields: [ 'name' ]
         *      });
         *
         *      var person = new Person({
         *          // no id provided, so -1 is generated
         *          name: 'Clark Kent'
         *      });
         *
         * The server is given this data during the 'create':
         *
         *      {
         *          id: -1,
         *          name: 'Clark Kent'
         *      }
         *
         * The server allocates a real id and responds like so:
         *
         *      {
         *          id: 427,
         *          clientId: -1
         *      }
         *
         * This property is most useful when creating multiple entities in a single call to
         * the server in a '{@link Ext.data.operation.Create create operation}'. Alternatively,
         * the server could respond with records that correspond one-to-one to those sent in
         * the 'operation'.
         *
         * For example the client could send a 'create' with this data:
         *
         *      [ { id: -1, name: 'Clark Kent' },
         *        { id: -2, name: 'Peter Parker' },
         *        { id: -3, name: 'Bruce Banner' } ]
         *
         * And the server could respond in the same order:
         *
         *      [ { id: 427 },      // updates id = -1
         *        { id: 428 },      // updates id = -2
         *        { id: 429 } ]     // updates id = -3
         *
         * Or using 'clientIdProperty' the server could respond in arbitrary order:
         *
         *      [ { id: 427, clientId: -3 },
         *        { id: 428, clientId: -1 },
         *        { id: 429, clientId: -2 } ]
         *
         * **IMPORTANT:** When upgrading from previous versions be aware that this property
         * used to perform the role of '{@link Ext.data.writer.Writer#clientIdProperty}' as
         * well as that described above. To continue send a client-generated id as other than
         * the 'idProperty', set 'clientIdProperty' on the 'writer'. A better solution, however,
         * is most likely a properly configured 'identifier' as that would work better with
         * associations.
         *
         * Optional
         */
        clientIdProperty?: string;

        /**
         * Set to 'false' to prevent any converters from being called on fields specified in
         * a {@link Ext.data.Model#set set} operation.
         *
         * **Note:** Setting the config to 'false' will only prevent the convert / calculate
         * call when the set 'fieldName' param matches the field's '{@link #name}'.  In the
         * following example the calls to set 'salary' will not execute the convert method
         * on 'set' while the calls to set 'vested' will execute the convert method on the
         * initial read as well as on 'set'.
         *
         * Example model definition:
         *
         *     Ext.define('MyApp.model.Employee', {
         *         extend: 'Ext.data.Model',
         *         fields: ['yearsOfService', {
         *             name: 'salary',
         *             convert: function (val) {
         *                 var startingBonus = val * .1;
         *                 return val + startingBonus;
         *             }
         *         }, {
         *             name: 'vested',
         *             convert: function (val, record) {
         *                 return record.get('yearsOfService') >= 4;
         *             },
         *             depends: 'yearsOfService'
         *         }],
         *         convertOnSet: false
         *     });
         *
         *     var tina = Ext.create('MyApp.model.Employee', {
         *         salary: 50000,
         *         yearsOfService: 3
         *     });
         *
         *     console.log(tina.get('salary')); // logs 55000
         *     console.log(tina.get('vested')); // logs false
         *
         *     tina.set({
         *         salary: 60000,
         *         yearsOfService: 4
         *     });
         *     console.log(tina.get('salary')); // logs 60000
         *     console.log(tina.get('vested')); // logs true
         *
         * Optional, Defaults to: true
         */
        convertOnSet?: boolean;

        /**
         * An Array of 'Ext.data.field.Field' config objects, simply the field
         * {@link Ext.data.field.Field#name name}, or a mix of config objects and strings.
         * If just a name is given, the field type defaults to 'auto'.
         *
         * In a {@link Ext.data.field.Field Field} config object you may pass the alias of
         * the 'Ext.data.field.*' type using the 'type' config option.
         *
         *     // two fields are set:
         *     // - an 'auto' field with a name of 'firstName'
         *     // - and an Ext.data.field.Integer field with a name of 'age'
         *     fields: ['firstName', {
         *         type: 'int',
         *         name: 'age'
         *     }]
         *
         * Fields will automatically be created at read time for any for any keys in the
         * data passed to the Model's {@link #proxy proxy's}
         * {@link Ext.data.reader.Reader reader} whose name is not explicitly configured in
         * the 'fields' config.
         *
         * Extending a Model class will inherit all the 'fields' from the superclass /
         * ancestor classes.
         */
        fields?: any|string;

        /**
         * One or more HasMany associations for this model.
         */
        hasMany?: string|any;

        /**
         * The name of the field treated as this Model's unique id.
         *
         * If changing the idProperty in a subclass, the generated id field will replace the one
         * generated by the superclass, for example;
         *
         *      Ext.define('Super', {
         *          extend: 'Ext.data.Model',
         *          fields: ['name']
         *      });
         *
         *      Ext.define('Sub', {
         *          extend: 'Super',
         *          idProperty: 'customId'
         *      });
         *
         *      var fields = Super.getFields();
         *      // Has 2 fields, "name" & "id"
         *      console.log(fields[0].name, fields[1].name, fields.length);
         *
         *      fields = Sub.getFields();
         *      // Has 2 fields, "name" & "customId", "id" is replaced
         *      console.log(fields[0].name, fields[1].name, fields.length);
         *
         * The data values for this field must be unique or there will be id value collisions
         * in the {@link Ext.data.Store Store}.
         *
         * Optional, Defaults to: 'id'
         */
        idProperty?: string;

        /**
         * The id generator to use for this model. The 'identifier' generates values for the
         * {@link #idProperty} when no value is given. Records with client-side generated
         * values for {@link #idProperty} are called {@link #phantom} records since they are
         * not yet known to the server.
         *
         * This can be overridden at the model level to provide a custom generator for a model.
         * The simplest form of this would be:
         *
         *      Ext.define('MyApp.data.MyModel', {
         *          extend: 'Ext.data.Model',
         *          requires: ['Ext.data.identifier.Sequential'],
         *          identifier: 'sequential',
         *          ...
         *      });
         *
         * The above would generate {@link Ext.data.identifier.Sequential sequential} id's such
         * as 1, 2, 3 etc..
         *
         * Another useful id generator is {@link Ext.data.identifier.Uuid}:
         *
         *      Ext.define('MyApp.data.MyModel', {
         *          extend: 'Ext.data.Model',
         *          requires: ['Ext.data.identifier.Uuid'],
         *          identifier: 'uuid',
         *          ...
         *      });
         *
         * An id generator can also be further configured:
         *
         *      Ext.define('MyApp.data.MyModel', {
         *          extend: 'Ext.data.Model',
         *          identifier: {
         *              type: 'sequential',
         *              seed: 1000,
         *              prefix: 'ID_'
         *          }
         *      });
         *
         * The above would generate id's such as ID_1000, ID_1001, ID_1002 etc..
         *
         * If multiple models share an id space, a single generator can be shared:
         *
         *      Ext.define('MyApp.data.MyModelX', {
         *          extend: 'Ext.data.Model',
         *          identifier: {
         *              type: 'sequential',
         *              id: 'xy'
         *          }
         *      });
         *
         *      Ext.define('MyApp.data.MyModelY', {
         *          extend: 'Ext.data.Model',
         *          identifier: {
         *              type: 'sequential',
         *              id: 'xy'
         *          }
         *      });
         *
         * For more complex, shared id generators, a custom generator is the best approach.
         * See {@link Ext.data.identifier.Generator} for details on creating custom id generators.
         */
        identifier?: string|any;

        /**
         * A config object for a {@link Ext.data.schema.ManyToMany ManyToMany} association.
         * See the class description for {@link Ext.data.schema.ManyToMany ManyToMany} for
         * configuration examples.
         */
        manyToMany?: any;

        /**
         * The {@link Ext.data.proxy.Proxy proxy} to use for this class.
         */
        proxy?: string|any|Ext.data.proxy.Proxy;

        /**
         * If specified this property is used to concatenate multiple errors for each field
         * as reported by the 'validators'.
         *
         * Optional, Defaults to: null
         */
        validationSeparator?: string;

        /**
         * An array of {@link Ext.data.validator.Validator validators} for this model.
         */
        validators?: any;

        /**
         * If specified, this is the name of the property that contains the entity "version".
         * The version property is used to manage a long-running transaction and allows the
         * detection of simultaneous modification.
         *
         * The way a version property is used is that the client receives the version as it
         * would any other entity property. When saving an entity, this property is always
         * included in the request and the server uses the value in a "conditional update".
         * If the current version of the entity on the server matches the version property
         * sent by the client, the update is allowed. Otherwise, the update fails.
         *
         * On successful update, both the client and server increment the version. This is
         * done on the server in the conditional update and on the client when it receives a
         * success on its update request.
         *
         * Optional
         */
        versionProperty?: string;
    }

    /**
     * A Model or Entity represents some object that your application manages. For example, one
     * might define a Model for Users, Products, Cars, or other real-world object that we want
     * to model in the system. Models are used by {@link Ext.data.Store stores}, which are in
     * turn used by many of the data-bound components in Ext.
     *
     * # Fields
     *
     * Models are defined as a set of fields and any arbitrary methods and properties relevant
     * to the model. For example:
     *
     *     Ext.define('User', {
     *         extend: 'Ext.data.Model',
     *         fields: [
     *             {name: 'name',  type: 'string'},
     *             {name: 'age',   type: 'int', convert: null},
     *             {name: 'phone', type: 'string'},
     *             {name: 'alive', type: 'boolean', defaultValue: true, convert: null}
     *         ],
     *
     *         changeName: function() {
     *             var oldName = this.get('name'),
     *                 newName = oldName + " The Barbarian";
     *
     *             this.set('name', newName);
     *         }
     *     });
     *
     * Now we can create instances of our User model and call any model logic we defined:
     *
     *     var user = Ext.create('User', {
     *         id   : 'ABCD12345',
     *         name : 'Conan',
     *         age  : 24,
     *         phone: '555-555-5555'
     *     });
     *
     *     user.changeName();
     *     user.get('name'); //returns "Conan The Barbarian"
     *
     * By default, the built in field types such as number and boolean coerce string values
     * in the raw data by virtue of their {@link Ext.data.field.Field#method-convert} method.
     * When the server can be relied upon to send data in a format that does not need to be
     * converted, disabling this can improve performance. The {@link Ext.data.reader.Json Json}
     * and {@link Ext.data.reader.Array Array} readers are likely candidates for this
     * optimization. To disable field conversions you simply specify 'null' for the field's
     * {@link Ext.data.field.Field#cfg-convert convert config}.
     *
     * ## The "id" Field and 'idProperty'
     *
     * A Model definition always has an *identifying field* which should yield a unique key
     * for each instance. By default, a field named "id" will be created with a
     * {@link Ext.data.Field#mapping mapping} of "id". This happens because of the default
     * {@link #idProperty} provided in Model definitions.
     *
     * To alter which field is the identifying field, use the {@link #idProperty} config.
     *
     * # Validators
     *
     * Models have built-in support for field validators. Validators are added to models as in
     * the follow example:
     *
     *     Ext.define('User', {
     *         extend: 'Ext.data.Model',
     *         fields: [
     *             { name: 'name',     type: 'string' },
     *             { name: 'age',      type: 'int' },
     *             { name: 'phone',    type: 'string' },
     *             { name: 'gender',   type: 'string' },
     *             { name: 'username', type: 'string' },
     *             { name: 'alive',    type: 'boolean', defaultValue: true }
     *         ],
     *
     *         validators: {
     *             age: 'presence',
     *             name: { type: 'length', min: 2 },
     *             gender: { type: 'inclusion', list: ['Male', 'Female'] },
     *             username: [
     *                 { type: 'exclusion', list: ['Admin', 'Operator'] },
     *                 { type: 'format', matcher: /([a-z]+)[0-9]{2,3}/i }
     *             ]
     *         }
     *     });
     *
     * The derived type of 'Ext.data.field.Field' can also provide validation. If 'validators'
     * need to be duplicated on multiple fields, instead consider creating a custom field type.
     *
     * ## Validation
     *
     * The results of the validators can be retrieved via the "associated" validation record:
     *
     *     var instance = Ext.create('User', {
     *         name: 'Ed',
     *         gender: 'Male',
     *         username: 'edspencer'
     *     });
     *
     *     var validation = instance.getValidation();
     *
     * The returned object is an instance of 'Ext.data.Validation' and has as its fields the
     * result of the field 'validators'. The validation object is "dirty" if there are one or
     * more validation errors present.
     *
     * This record is also available when using data binding as a "pseudo-association" called
     * "validation". This pseudo-association can be hidden by an explicitly declared
     * association by the same name (for compatibility reasons), but doing so is not
     * recommended.
     *
     * The '{@link Ext.Component#modelValidation}' config can be used to enable automatic
     * binding from the "validation" of a record to the form fields that may be bound to its
     * values.
     *
     * # Associations
     *
     * Models often have associations with other Models. These associations can be defined by
     * fields (often called "foreign keys") or by other data such as a many-to-many (or "matrix").
     *
     * ## Foreign-Key Associations - One-to-Many
     *
     * The simplest way to define an association from one Model to another is to add a
     * {@link Ext.data.field.Field#cfg-reference reference config} to the appropriate field.
     *
     *      Ext.define('Post', {
     *          extend: 'Ext.data.Model',
     *
     *          fields: [
     *              { name: 'user_id', reference: 'User' }
     *          ]
     *      });
     *
     *      Ext.define('Comment', {
     *          extend: 'Ext.data.Model',
     *
     *          fields: [
     *              { name: 'user_id', reference: 'User' },
     *              { name: 'post_id', reference: 'Post' }
     *          ]
     *      });
     *
     *      Ext.define('User', {
     *          extend: 'Ext.data.Model',
     *
     *          fields: [
     *              'name'
     *          ]
     *      });
     *
     * The placement of 'reference' on the appropriate fields tells the Model which field has
     * the foreign-key and the type of Model it identifies. That is, the value of these fields
     * is set to value of the 'idProperty' field of the target Model.
     *
     * ### One-to-Many Without Foreign-Keys
     *
     * To define an association without a foreign-key field, you will need to use either the
     * '{@link #cfg-hasMany}' or '{@link #cfg-belongsTo}'.
     *
     *      Ext.define('Post', {
     *          extend: 'Ext.data.Model',
     *
     *          belongsTo: 'User'
     *      });
     *
     *      Ext.define('Comment', {
     *          extend: 'Ext.data.Model',
     *
     *          belongsTo: [ 'Post', 'User' ]
     *      });
     *
     *      // User is as above
     *
     * These declarations have changed slightly from previous releases. In previous releases
     * both "sides" of an association had to declare their particular roles. This is now only
     * required if the defaults assumed for names are not satisfactory.
     *
     * ## Foreign-Key Associations - One-to-One
     *
     * A special case of one-to-many associations is the one-to-one case. This is defined as
     * a '{@link Ext.data.field.Field#reference unique reference}'.
     *
     *      Ext.define('Address', {
     *          extend: 'Ext.data.Model',
     *
     *          fields: [
     *              'address',
     *              'city',
     *              'state'
     *          ]
     *      });
     *
     *      Ext.define('User', {
     *          extend: 'Ext.data.Model',
     *
     *          fields: [{
     *              name: 'addressId',
     *              reference: 'Address',
     *              unique: true
     *          }]
     *      });
     *
     * ## Many-to-Many
     *
     * The classic use case for many-to-many is a User and Group. Users can belong to many
     * Groups and Groups can contain many Users. This association is declared using the
     * '{@link #cfg-manyToMany}' config like so:
     *
     *
     *      Ext.define('User', {
     *          extend: 'Ext.data.Model',
     *
     *          fields: [
     *              'name'
     *          ],
     *
     *          manyToMany: 'Group'
     *      });
     *
     *      Ext.define('Group', {
     *          extend: 'Ext.data.Model',
     *
     *          fields: [
     *              'name'
     *          ],
     *
     *          manyToMany: 'User'
     *      });
     *
     * As with other associations, only one "side" needs to be declared.
     *
     * To manage the relationship between a 'manyToMany' relationship, a {@link Ext.data.Session}
     * must be used.
     *
     * # Using a Proxy
     *
     * Models are great for representing types of data and relationships, but sooner or later we're going to want to load or
     * save that data somewhere. All loading and saving of data is handled via a {@link Ext.data.proxy.Proxy Proxy}, which
     * can be set directly on the Model:
     *
     *     Ext.define('User', {
     *         extend: 'Ext.data.Model',
     *         fields: ['id', 'name', 'email'],
     *
     *         proxy: {
     *             type: 'rest',
     *             url : '/users'
     *         }
     *     });
     *
     * Here we've set up a {@link Ext.data.proxy.Rest Rest Proxy}, which knows how to load and save data to and from a
     * RESTful backend. Let's see how this works:
     *
     *     var user = Ext.create('User', {name: 'Ed Spencer', email: 'ed@sencha.com'});
     *
     *     user.save(); //POST /users
     *
     * Calling {@link #save} on the new Model instance tells the configured RestProxy that we wish to persist this Model's
     * data onto our server. RestProxy figures out that this Model hasn't been saved before because it doesn't have an id,
     * and performs the appropriate action - in this case issuing a POST request to the url we configured (/users). We
     * configure any Proxy on any Model and always follow this API - see {@link Ext.data.proxy.Proxy} for a full list.
     *
     * Loading data via the Proxy is accomplished with the static 'load' method:
     *
     *     //Uses the configured RestProxy to make a GET request to /users/123
     *     User.load(123, {
     *         success: function(user) {
     *             console.log(user.getId()); //logs 123
     *         }
     *     });
     *
     * Models can also be updated and destroyed easily:
     *
     *     //the user Model we loaded in the last snippet:
     *     user.set('name', 'Edward Spencer');
     *
     *     //tells the Proxy to save the Model. In this case it will perform a PUT request to /users/123 as this Model already has an id
     *     user.save({
     *         success: function() {
     *             console.log('The User was updated');
     *         }
     *     });
     *
     *     //tells the Proxy to destroy the Model. Performs a DELETE request to /users/123
     *     user.erase({
     *         success: function() {
     *             console.log('The User was destroyed!');
     *         }
     *     });
     *
     * # HTTP Parameter names when using a {@link Ext.data.proxy.Ajax Ajax proxy}
     *
     * By default, the model ID is specified in an HTTP parameter named 'id'. To change the
     * name of this parameter use the Proxy's {@link Ext.data.proxy.Ajax#idParam idParam}
     * configuration.
     *
     * Parameters for other commonly passed values such as
     * {@link Ext.data.proxy.Ajax#pageParam page number} or
     * {@link Ext.data.proxy.Ajax#startParam start row} may also be configured.
     *
     * # Usage in Stores
     *
     * It is very common to want to load a set of Model instances to be displayed and manipulated in the UI. We do this by
     * creating a {@link Ext.data.Store Store}:
     *
     *     var store = Ext.create('Ext.data.Store', {
     *         model: 'User'
     *     });
     *
     *     //uses the Proxy we set up on Model to load the Store data
     *     store.load();
     *
     * A Store is just a collection of Model instances - usually loaded from a server somewhere. Store can also maintain a
     * set of added, updated and removed Model instances to be synchronized with the server via the Proxy. See the {@link
     * Ext.data.Store Store docs} for more information on Stores.
     */
    export class Model extends Ext.Base implements Ext.data.ModelConfig {
        /**
         * True if this record has been modified.
         * @readonly
         */
        dirty: boolean;

        /**
         * True if this record is pending delete on the server. This is set by the 'drop'
         * method and transmitted to the server by the 'save' method.
         * @readonly
         */
        dropped: boolean;

        /**
         * Internal flag used to track whether or not the model instance is currently being edited.
         * @readonly
         */
        editing: boolean;

        /**
         * The short name of this entity class. This name is derived from the 'namespace' of
         * the associated 'schema' and this class name. By default, a class is not given a
         * shortened name.
         *
         * All entities in a given 'schema' must have a unique 'entityName'.
         *
         * For more details see "Relative Naming" in {@link Ext.data.schema.Schema}.
         */
        entityName: string;

        /**
         * True if this record has been erased on the server. This flag is set of the 'erase'
         * method.
         * @readonly
         */
        erased: boolean;

        /**
         * This property is incremented on each modification of a record.
         * @readonly
         * @since 5.0.0
         */
        generation: number;

        /**
         * The value 'true' to identify this class and its subclasses.
         * @readonly
         */
        isEntity: boolean;

        /**
         * The value 'true' to identify this class and its subclasses.
         * @readonly
         */
        isModel: boolean;

        /**
         * A hash of field values which holds the initial values of fields before a set of edits
         * are {@link #commit committed}.
         */
        modified: any;

        /**
         * True when the record does not yet exist in a server-side database. Any record which
         * has a real database identity set as its 'idProperty' is NOT a phantom -- it's real.
         */
        phantom: boolean;

        /**
         * The 'Ext.data.schema.Schema' to which this entity and its associations belong.
         * @readonly
         */
        schema: Ext.data.schema.Schema;

        /**
         * The {@link Ext.data.Session} for this record.
         * @readonly
         */
        session: Ext.data.Session;

        /**
         * The {@link Ext.data.Store Store} to which this instance belongs.
         *
         * **Note:** If this instance is bound to multiple stores, this property
         * will reference only the first.
         */
        store: Ext.data.Store;

        /**
         * An array of {@link Ext.data.schema.Association associations} for this model.
         */
        associations: any;

        /**
         * One or more BelongsTo associations for this model.
         */
        belongsTo: string|any;

        /**
         * The name of the property a server will use to send back a client-generated id in a
         * 'create' or 'update' '{@link Ext.data.operation.Operation operation}'.
         *
         * If specified, this property cannot have the same name as any other field.
         *
         * For example:
         *
         *      Ext.define('Person', {
         *          idProperty: 'id',  // this is the default value (for clarity)
         *
         *          clientIdProperty: 'clientId',
         *
         *          identifier: 'negative', // to generate -1, -2 etc on the client
         *
         *          fields: [ 'name' ]
         *      });
         *
         *      var person = new Person({
         *          // no id provided, so -1 is generated
         *          name: 'Clark Kent'
         *      });
         *
         * The server is given this data during the 'create':
         *
         *      {
         *          id: -1,
         *          name: 'Clark Kent'
         *      }
         *
         * The server allocates a real id and responds like so:
         *
         *      {
         *          id: 427,
         *          clientId: -1
         *      }
         *
         * This property is most useful when creating multiple entities in a single call to
         * the server in a '{@link Ext.data.operation.Create create operation}'. Alternatively,
         * the server could respond with records that correspond one-to-one to those sent in
         * the 'operation'.
         *
         * For example the client could send a 'create' with this data:
         *
         *      [ { id: -1, name: 'Clark Kent' },
         *        { id: -2, name: 'Peter Parker' },
         *        { id: -3, name: 'Bruce Banner' } ]
         *
         * And the server could respond in the same order:
         *
         *      [ { id: 427 },      // updates id = -1
         *        { id: 428 },      // updates id = -2
         *        { id: 429 } ]     // updates id = -3
         *
         * Or using 'clientIdProperty' the server could respond in arbitrary order:
         *
         *      [ { id: 427, clientId: -3 },
         *        { id: 428, clientId: -1 },
         *        { id: 429, clientId: -2 } ]
         *
         * **IMPORTANT:** When upgrading from previous versions be aware that this property
         * used to perform the role of '{@link Ext.data.writer.Writer#clientIdProperty}' as
         * well as that described above. To continue send a client-generated id as other than
         * the 'idProperty', set 'clientIdProperty' on the 'writer'. A better solution, however,
         * is most likely a properly configured 'identifier' as that would work better with
         * associations.
         *
         * Optional
         */
        clientIdProperty: string;

        /**
         * Set to 'false' to prevent any converters from being called on fields specified in
         * a {@link Ext.data.Model#set set} operation.
         *
         * **Note:** Setting the config to 'false' will only prevent the convert / calculate
         * call when the set 'fieldName' param matches the field's '{@link #name}'.  In the
         * following example the calls to set 'salary' will not execute the convert method
         * on 'set' while the calls to set 'vested' will execute the convert method on the
         * initial read as well as on 'set'.
         *
         * Example model definition:
         *
         *     Ext.define('MyApp.model.Employee', {
         *         extend: 'Ext.data.Model',
         *         fields: ['yearsOfService', {
         *             name: 'salary',
         *             convert: function (val) {
         *                 var startingBonus = val * .1;
         *                 return val + startingBonus;
         *             }
         *         }, {
         *             name: 'vested',
         *             convert: function (val, record) {
         *                 return record.get('yearsOfService') >= 4;
         *             },
         *             depends: 'yearsOfService'
         *         }],
         *         convertOnSet: false
         *     });
         *
         *     var tina = Ext.create('MyApp.model.Employee', {
         *         salary: 50000,
         *         yearsOfService: 3
         *     });
         *
         *     console.log(tina.get('salary')); // logs 55000
         *     console.log(tina.get('vested')); // logs false
         *
         *     tina.set({
         *         salary: 60000,
         *         yearsOfService: 4
         *     });
         *     console.log(tina.get('salary')); // logs 60000
         *     console.log(tina.get('vested')); // logs true
         *
         * Optional, Defaults to: true
         */
        convertOnSet: boolean;

        /**
         * An Array of 'Ext.data.field.Field' config objects, simply the field
         * {@link Ext.data.field.Field#name name}, or a mix of config objects and strings.
         * If just a name is given, the field type defaults to 'auto'.
         *
         * In a {@link Ext.data.field.Field Field} config object you may pass the alias of
         * the 'Ext.data.field.*' type using the 'type' config option.
         *
         *     // two fields are set:
         *     // - an 'auto' field with a name of 'firstName'
         *     // - and an Ext.data.field.Integer field with a name of 'age'
         *     fields: ['firstName', {
         *         type: 'int',
         *         name: 'age'
         *     }]
         *
         * Fields will automatically be created at read time for any for any keys in the
         * data passed to the Model's {@link #proxy proxy's}
         * {@link Ext.data.reader.Reader reader} whose name is not explicitly configured in
         * the 'fields' config.
         *
         * Extending a Model class will inherit all the 'fields' from the superclass /
         * ancestor classes.
         */
        fields: any|string;

        /**
         * One or more HasMany associations for this model.
         */
        hasMany: string|any;

        /**
         * The id generator to use for this model. The 'identifier' generates values for the
         * {@link #idProperty} when no value is given. Records with client-side generated
         * values for {@link #idProperty} are called {@link #phantom} records since they are
         * not yet known to the server.
         *
         * This can be overridden at the model level to provide a custom generator for a model.
         * The simplest form of this would be:
         *
         *      Ext.define('MyApp.data.MyModel', {
         *          extend: 'Ext.data.Model',
         *          requires: ['Ext.data.identifier.Sequential'],
         *          identifier: 'sequential',
         *          ...
         *      });
         *
         * The above would generate {@link Ext.data.identifier.Sequential sequential} id's such
         * as 1, 2, 3 etc..
         *
         * Another useful id generator is {@link Ext.data.identifier.Uuid}:
         *
         *      Ext.define('MyApp.data.MyModel', {
         *          extend: 'Ext.data.Model',
         *          requires: ['Ext.data.identifier.Uuid'],
         *          identifier: 'uuid',
         *          ...
         *      });
         *
         * An id generator can also be further configured:
         *
         *      Ext.define('MyApp.data.MyModel', {
         *          extend: 'Ext.data.Model',
         *          identifier: {
         *              type: 'sequential',
         *              seed: 1000,
         *              prefix: 'ID_'
         *          }
         *      });
         *
         * The above would generate id's such as ID_1000, ID_1001, ID_1002 etc..
         *
         * If multiple models share an id space, a single generator can be shared:
         *
         *      Ext.define('MyApp.data.MyModelX', {
         *          extend: 'Ext.data.Model',
         *          identifier: {
         *              type: 'sequential',
         *              id: 'xy'
         *          }
         *      });
         *
         *      Ext.define('MyApp.data.MyModelY', {
         *          extend: 'Ext.data.Model',
         *          identifier: {
         *              type: 'sequential',
         *              id: 'xy'
         *          }
         *      });
         *
         * For more complex, shared id generators, a custom generator is the best approach.
         * See {@link Ext.data.identifier.Generator} for details on creating custom id generators.
         */
        identifier: string|any;

        /**
         * The name of the field treated as this Model's unique id.
         *
         * If changing the idProperty in a subclass, the generated id field will replace the one
         * generated by the superclass, for example;
         *
         *      Ext.define('Super', {
         *          extend: 'Ext.data.Model',
         *          fields: ['name']
         *      });
         *
         *      Ext.define('Sub', {
         *          extend: 'Super',
         *          idProperty: 'customId'
         *      });
         *
         *      var fields = Super.getFields();
         *      // Has 2 fields, "name" & "id"
         *      console.log(fields[0].name, fields[1].name, fields.length);
         *
         *      fields = Sub.getFields();
         *      // Has 2 fields, "name" & "customId", "id" is replaced
         *      console.log(fields[0].name, fields[1].name, fields.length);
         *
         * The data values for this field must be unique or there will be id value collisions
         * in the {@link Ext.data.Store Store}.
         *
         * Optional, Defaults to: 'id'
         */
        idProperty: string;

        /**
         * A config object for a {@link Ext.data.schema.ManyToMany ManyToMany} association.
         * See the class description for {@link Ext.data.schema.ManyToMany ManyToMany} for
         * configuration examples.
         */
        manyToMany: any;

        /**
         * The {@link Ext.data.proxy.Proxy proxy} to use for this class.
         */
        proxy: string|any|Ext.data.proxy.Proxy;

        /**
         * If specified this property is used to concatenate multiple errors for each field
         * as reported by the 'validators'.
         *
         * Optional, Defaults to: null
         */
        validationSeparator: string;

        /**
         * An array of {@link Ext.data.validator.Validator validators} for this model.
         */
        validators: any;

        /**
         * If specified, this is the name of the property that contains the entity "version".
         * The version property is used to manage a long-running transaction and allows the
         * detection of simultaneous modification.
         *
         * The way a version property is used is that the client receives the version as it
         * would any other entity property. When saving an entity, this property is always
         * included in the request and the server uses the value in a "conditional update".
         * If the current version of the entity on the server matches the version property
         * sent by the client, the update is allowed. Otherwise, the update fails.
         *
         * On successful update, both the client and server increment the version. This is
         * done on the server in the conditional update and on the client when it receives a
         * success on its update request.
         *
         * Optional
         */
        versionProperty: string;

        /**
         * Aborts a pending {@link #load} operation. If the record is not loading, this does nothing.
         */
        abort();

        /**
         * Begins an edit. While in edit mode, no events (e.g.. the 'update' event) are
         * relayed to the containing store. When an edit has begun, it must be followed by
         * either 'endEdit' or 'cancelEdit'.
         */
        beginEdit();

        /**
         * Cancels all changes made in the current edit operation.
         */
        cancelEdit();

        /**
         * Creates a clone of this record. States like 'dropped', 'phantom' and 'dirty' are
         * all preserved in the cloned record.
         *
         * @param {Ext.data.Session} [session] The session to which the new record
         * belongs.
         * @return {Ext.data.Model} The cloned record.
         */
        clone(session?: Ext.data.Session): Ext.data.Model;

        /**
         * Usually called by the {@link Ext.data.Store} which owns the model instance. Commits all changes made to the
         * instance since either creation or the last commit operation.
         *
         * Developers should subscribe to the {@link Ext.data.Store#event-update} event to have their code notified of commit
         * operations.
         *
         * @param {Boolean} [silent=false] Pass 'true' to skip notification of the owning store of the change.
         * @param {String[]} [modifiedFieldNames] Array of field names changed during sync with server if known.
         * Omit or pass 'null' if unknown. An empty array means that it is known that no fields were modified
         * by the server's response.
         * Defaults to false.
         */
        commit(silent?: boolean, modifiedFieldNames?: string);

        constructor(data: any, session: any);

        /**
         * Creates a clean copy of this record. The returned record will not consider any its
         * fields as modified.
         *
         * To generate a phantom instance with a new id pass 'null':
         *
         *     var rec = record.copy(null); // clone the record but no id (one is generated)
         *
         * @param {String} [newId] A new id, defaults to the id of the instance being copied.
         * See '{@link Ext.data.Model#idProperty idProperty}'.
         * @param {Ext.data.Session} [session] The session to which the new record
         * belongs.
         *
         * @return {Ext.data.Model}
         */
        copy(newId?: string, session?: Ext.data.Session): Ext.data.Model;

        /**
         * Marks this record as 'dropped' and waiting to be deleted on the server. When a
         * record is dropped, it is automatically removed from all association stores and
         * any child records associated to this record are also dropped (a "cascade delete")
         * depending on the 'cascade' parameter.
         *
         * @param {Boolean} [cascade=true] Pass 'false' to disable the cascade to drop child
         * records.
         * @since 5.0.0
         */
        drop(cascade?: boolean);

        /**
         * Ends an edit. If any data was modified, the containing store is notified
         * (ie, the store's 'update' event will fire).
         * @param {Boolean} [silent] True to not notify any stores of the change.
         * @param {String[]} [modifiedFieldNames] Array of field names changed during edit.
         */
        endEdit(silent?: boolean, modifiedFieldNames?: string);

        /**
         * asynchronous.  Any processing of the erased record should be done in a callback.
         *
         *     Ext.define('MyApp.model.User', {
         *         extend: 'Ext.data.Model',
         *         fields: [
         *             {name: 'id', type: 'int'},
         *             {name: 'name', type: 'string'}
         *         ],
         *         proxy: {
         *             type: 'ajax',
         *             url: 'server.url'
         *         }
         *     });
         *
         *     var user = new MyApp.model.User({
         *         name: 'Foo'
         *     });
         *
         *     // pass the phantom record data to the server to be saved
         *     user.save({
         *         success: function(record, operation) {
         *             // do something if the save succeeded
         *             // erase the created record
         *             record.erase({
         *                 failure: function(record, operation) {
         *                     // do something if the erase failed
         *                 },
         *                 success: function(record, operation) {
         *                     // do something if the erase succeeded
         *                 },
         *                 callback: function(record, operation, success) {
         *                     // do something if the erase succeeded or failed
         *                 }
         *             });
         *         }
         *     });
         *
         * **NOTE:** If a {@link #phantom} record is erased it will not be processed via the
         * proxy.  However, any passed 'success' or 'callback' functions will be called.
         *
         * The options param is an {@link Ext.data.operation.Destroy} config object
         * containing success, failure and callback functions, plus optional scope.
         *
         * @return {Ext.data.operation.Destroy} The destroy operation
         */
        erase(): Ext.data.operation.Destroy;

        /**
         * Returns the value of the given field.
         * @param {String} fieldName The name of the field.
         * @return {Object} The value of the specified field.
         */
        get(fieldName: string): any;

        /**
         * Gets all of the data from this Models *loaded* associations. It does this
         * recursively. For example if we have a User which hasMany Orders, and each Order
         * hasMany OrderItems, it will return an object like this:
         *
         *     {
         *         orders: [
         *             {
         *                 id: 123,
         *                 status: 'shipped',
         *                 orderItems: [
         *                     ...
         *                 ]
         *             }
         *         ]
         *     }
         *
         * @param {Object} [result] The object on to which the associations will be added. If
         * no object is passed one is created. This object is then returned.
         * @param {Boolean/Object} [options] An object containing options describing the data
         * desired.
         * @param {Boolean} [options.associated=true] Pass 'true' to include associated data from
         * other associated records.
         * @param {Boolean} [options.changes=false] Pass 'true' to only include fields that
         * have been modified. Note that field modifications are only tracked for fields that
         * are not declared with 'persist' set to 'false'. In other words, only persistent
         * fields have changes tracked so passing 'true' for this means 'options.persist' is
         * redundant.
         * @param {Boolean} [options.critical] Pass 'true' to include fields set as 'critical'.
         * This is only meaningful when 'options.changes' is 'true' since critical fields may
         * not have been modified.
         * @param {Boolean} [options.persist] Pass 'true' to only return persistent fields.
         * This is implied when 'options.changes' is set to 'true'.
         * @param {Boolean} [options.serialize=false] Pass 'true' to invoke the 'serialize'
         * method on the returned fields.
         * @return {Object} The nested data set for the Model's loaded associations.
         */
        getAssociatedData(result?: any, options?: boolean|any, options_associated?: boolean, options_changes?: boolean, options_critical?: boolean, options_persist?: boolean, options_serialize?: boolean): any;

        /**
         * Gets an object of only the fields that have been modified since this record was
         * created or committed. Only persistent fields are tracked in the 'modified' set so
         * this method will only return changes to persistent fields.
         *
         * For more control over the returned data, see '{@link #getData}'.
         * @return {Object}
         */
        getChanges(): any;

        /**
         * Returns the array of fields that are declared as critical (must always send).
         * @return {Ext.data.field.Field[]}
         */
        getCriticalFields(): Ext.data.field.Field;

        /**
         * Gets all values for each field in this model and returns an object containing the
         * current data. This can be tuned by passing an 'options' object with various
         * properties describing the desired result. Passing 'true' simply returns all fields
         * *and* all associated record data.
         *
         * @param {Boolean/Object} [options] An object containing options describing the data
         * desired. If 'true' is passed it is treated as an object with 'associated' set to
         * 'true'.
         * @param {Boolean} [options.associated=false] Pass 'true' to include associated data.
         * This is equivalent to pass 'true' as the only argument. See 'getAssociatedData'.
         * @param {Boolean} [options.changes=false] Pass 'true' to only include fields that
         * have been modified. Note that field modifications are only tracked for fields that
         * are not declared with 'persist' set to 'false'. In other words, only persistent
         * fields have changes tracked so passing 'true' for this means 'options.persist' is
         * redundant.
         * @param {Boolean} [options.critical] Pass 'true' to include fields set as 'critical'.
         * This is only meaningful when 'options.changes' is 'true' since critical fields may
         * not have been modified.
         * @param {Boolean} [options.persist] Pass 'true' to only return persistent fields.
         * This is implied when 'options.changes' is set to 'true'.
         * @param {Boolean} [options.serialize=false] Pass 'true' to invoke the 'serialize'
         * method on the returned fields.
         * @return {Object} An object containing all the values in this model.
         */
        getData(options?: boolean|any, options_associated?: boolean, options_changes?: boolean, options_critical?: boolean, options_persist?: boolean, options_serialize?: boolean): any;

        /**
         * Get the fields array for this model.
         * @return {Ext.data.field.Field[]} The fields array
         */
        getFields(): Ext.data.field.Field;

        /**
         * Returns the unique ID allocated to this model instance as defined by 'idProperty'.
         * @return {Number/String} The id
         */
        getId(): number|string;

        /**
         * Get the idProperty for this model.
         * @return {String} The idProperty
         */
        getIdProperty(): string;

        /**
         * Returns the original value of a modified field. If there is no modified value,
         * 'undefined' will be return. Also see {@link #isModified}.
         * @param {String} fieldName The name of the field for which to return the original value.
         * @return {Object} modified
         */
        getModified(fieldName: string): any;

        /**
         * Return a unique observable ID. Model is not observable but tree nodes ('Ext.data.NodeInterface') are, so
         * they must be globally unique within the {@link #observableType}.
         */
        protected getObservableId();

        /**
         * This method returns the value of a field given its name prior to its most recent
         * change.
         * @param {String} fieldName The field's {@link Ext.data.field.Field#name name}.
         * @return {Object} The value of the given field prior to its current value. 'undefined'
         * if there is no previous value;
         */
        getPrevious(fieldName: string): any;

        /**
         * Returns the array of fields that are declared as non-persist or "transient".
         * @return {Ext.data.field.Field[]}
         * @since 5.0.0
         */
        getTransientFields(): Ext.data.field.Field;

        /**
         * Returns the 'Ext.data.Validation' record holding the results of this record's
         * 'validators'. This record is lazily created on first request and is then kept on
         * this record to be updated later.
         *
         * See the class description for more about 'validators'.
         *
         * @param {Boolean} [refresh] Pass 'false' to not call the 'refresh' method on the
         * validation instance prior to returning it. Pass 'true' to force a 'refresh' of the
         * validation instance. By default the returned record is only refreshed if changes
         * have been made to this record.
         * @return {Ext.data.Validation} The 'Validation' record for this record.
         * @since 5.0.0
         */
        getValidation(refresh?: boolean): Ext.data.Validation;

        /**
         * Checks whether this model is loading data from the {@link #proxy}.
         * @return {Boolean} 'true' if in a loading state.
         */
        isLoading(): boolean;

        /**
         * Returns true if the passed field name has been '{@link #modified}' since the load or last commit.
         * @param {String} fieldName The field's {@link Ext.data.field.Field#name name}.
         * @return {Boolean}
         */
        isModified(fieldName: string): boolean;

        /**
         * Checks if the model is valid. See {@link #getValidation}.
         * @return {Boolean} True if the model is valid.
         */
        isValid(): boolean;

        /**
         * Tells this model instance that an observer is looking at it.
         * @param {Ext.data.Store} item The store to which this model has been added.
         */
        join(item: Ext.data.Store);

        /**
         * This method is called by the {@link Ext.data.reader.Reader} after loading a model from
         * the server. This is after processing any inline associations that are available.
         */
        protected onLoad();

        /**
         * Usually called by the {@link Ext.data.Store} to which this model instance has been {@link #join joined}. Rejects
         * all changes made to the model instance since either creation, or the last commit operation. Modified fields are
         * reverted to their original values.
         *
         * Developers should subscribe to the {@link Ext.data.Store#event-update} event to have their code notified of reject
         * operations.
         *
         * @param {Boolean} [silent=false] 'true' to skip notification of the owning store of the change.
         */
        reject(silent?: boolean);

        /**
         * is asynchronous.  Any processing of the saved record should be done in a callback.
         *
         * Create example:
         *
         *     Ext.define('MyApp.model.User', {
         *         extend: 'Ext.data.Model',
         *         fields: [
         *             {name: 'id', type: 'int'},
         *             {name: 'name', type: 'string'}
         *         ],
         *         proxy: {
         *             type: 'ajax',
         *             url: 'server.url'
         *         }
         *     });
         *
         *     var user = new MyApp.model.User({
         *         name: 'Foo'
         *     });
         *
         *     // pass the phantom record data to the server to be saved
         *     user.save({
         *         failure: function(record, operation) {
         *             // do something if the save failed
         *         },
         *         success: function(record, operation) {
         *             // do something if the save succeeded
         *         },
         *         callback: function(record, operation, success) {
         *             // do something whether the save succeeded or failed
         *         }
         *     });
         *
         * The response from a create operation should include the ID for the newly created
         * record:
         *
         *     // sample response
         *     {
         *         success: true,
         *         id: 1
         *     }
         *
         *     // the id may be nested if the proxy's reader has a rootProperty config
         *     Ext.define('MyApp.model.User', {
         *         extend: 'Ext.data.Model',
         *         proxy: {
         *             type: 'ajax',
         *             url: 'server.url',
         *             reader: {
         *                 type: 'ajax',
         *                 rootProperty: 'data'
         *             }
         *         }
         *     });
         *
         *     // sample nested response
         *     {
         *         success: true,
         *         data: {
         *             id: 1
         *         }
         *     }
         *
         * (Create + ) Update example:
         *
         *     Ext.define('MyApp.model.User', {
         *         extend: 'Ext.data.Model',
         *         fields: [
         *             {name: 'id', type: 'int'},
         *             {name: 'name', type: 'string'}
         *         ],
         *         proxy: {
         *             type: 'ajax',
         *             url: 'server.url'
         *         }
         *     });
         *
         *     var user = new MyApp.model.User({
         *         name: 'Foo'
         *     });
         *     user.save({
         *         success: function(record, operation) {
         *             record.set('name', 'Bar');
         *             // updates the remote record via the proxy
         *             record.save();
         *         }
         *     });
         *
         * (Create + ) Destroy example - see also {@link #erase}:
         *
         *     Ext.define('MyApp.model.User', {
         *         extend: 'Ext.data.Model',
         *         fields: [
         *             {name: 'id', type: 'int'},
         *             {name: 'name', type: 'string'}
         *         ],
         *         proxy: {
         *             type: 'ajax',
         *             url: 'server.url'
         *         }
         *     });
         *
         *     var user = new MyApp.model.User({
         *         name: 'Foo'
         *     });
         *     user.save({
         *         success: function(record, operation) {
         *             record.drop();
         *             // destroys the remote record via the proxy
         *             record.save();
         *         }
         *     });
         *
         * **NOTE:** If a {@link #phantom} record is {@link #drop dropped} and subsequently
         * saved it will not be processed via the proxy.  However, any passed 'success'
         * or 'callback' functions will be called.
         *
         * The options param is an Operation config object containing success, failure and
         * callback functions, plus optional scope.  The type of Operation depends on the
         * state of the model being saved.
         *
         *  - {@link #phantom} model - {@link Ext.data.operation.Create}
         *  - {@link #isModified modified} model - {@link Ext.data.operation.Update}
         *  - {@link #dropped} model - {@link Ext.data.operation.Destroy}
         *
         * @return {Ext.data.operation.Create/Ext.data.operation.Update/Ext.data.operation.Destroy}
         * The operation instance for saving this model.  The type of operation returned
         * depends on the model state at the time of the action.
         *
         *  - {@link #phantom} model - {@link Ext.data.operation.Create}
         *  - {@link #isModified modified} model - {@link Ext.data.operation.Update}
         *  - {@link #dropped} model - {@link Ext.data.operation.Destroy}
         */
        save(): Ext.data.operation.Create|Ext.data.operation.Update|Ext.data.operation.Destroy;

        /**
         * Sets the given field to the given value. For example:
         *
         *      record.set('name', 'value');
         *
         * This method can also be passed an object containing multiple values to set at once.
         * For example:
         *
         *      record.set({
         *          name: 'value',
         *          age: 42
         *      });
         *
         * The following store events are fired when the modified record belongs to a store:
         *
         *  - {@link Ext.data.Store#event-beginupdate beginupdate}
         *  - {@link Ext.data.Store#event-update update}
         *  - {@link Ext.data.Store#event-endupdate endupdate}
         *
         * @param {String/Object} fieldName The field to set, or an object containing key/value
         * pairs.
         * @param {Object} newValue The value for the field (if 'fieldName' is a string).
         * @param {Object} [options] Options for governing this update.
         * @param {Boolean} [options.convert=true] Set to 'false' to  prevent any converters from
         * being called during the set operation. This may be useful when setting a large bunch of
         * raw values.
         * @param {Boolean} [options.dirty=true] Pass 'false' if the field values are to be
         * understood as non-dirty (fresh from the server). When 'true', this change will be
         * reflected in the 'modified' collection.
         * @param {Boolean} [options.commit=false] Pass 'true' to call the {@link #commit} method
         * after setting fields. If this option is passed, the usual after change processing will
         * be bypassed. {@link #commit Commit} will be called even if there are no field changes.
         * @param {Boolean} [options.silent=false] Pass 'true' to suppress notification of any
         * changes made by this call. Use with caution.
         * @return {String[]} The array of modified field names or null if nothing was modified.
         */
        set(fieldName: string|any, newValue: any, options?: any, options_convert?: boolean, options_dirty?: boolean, options_commit?: boolean, options_silent?: boolean): string;

        /**
         * Sets the model instance's id field to the given id.
         * @param {Number/String} id The new id.
         * @param {Object} [options] See {@link #set}.
         */
        setId(id: number|string, options?: any);

        /**
         * Set the session for this record.
         * @param {Ext.data.Session} session The session
         */
        setSession(session: Ext.data.Session);

        /**
         * Returns a url-suitable string for this model instance. By default this just returns the name of the Model class
         * followed by the instance ID - for example an instance of MyApp.model.User with ID 123 will return 'user/123'.
         * @return {String} The url string for this model instance.
         */
        toUrl(): string;

        /**
         * Tells this model instance that it has been removed from the store.
         * @param {Ext.data.Store} store The store from which this model has been removed.
         */
        unjoin(store: Ext.data.Store);

        /**
         * Validates the current data against all of its configured {@link #validators}. The
         * returned collection holds an object for each reported problem from a 'validator'.
         *
         * @return {Ext.data.ErrorCollection} The errors collection.
         * @deprecated 5.0 Use 'getValidation' instead.
         */
        validate(): Ext.data.ErrorCollection;

        /**
         * The default proxy to use for instances of this Model when no proxy is configured
         * on the instance.  When specified, the model will use this proxy instead of
         * requesting one from the {@link Ext.data.Session Session}.
         *
         * Can be a string "type", or a {@link Ext.data.proxy.Proxy Proxy} config object.
         *
         * This proxy is not inherited by subclasses.
         */
        protected static defaultProxy: any;

        /**
         * This method adds the given set of fields to this model class.
         *
         * @param {String[]/Object[]} newFields The new fields to add. Based on the 'name'
         * of a field this may replace a previous field definition.
         *
         * @inheritable
         * @since 5.0.0
         */
        protected static addFields(newFields: string|any);

        /**
         * Returns the configured Proxy for this Model.
         * @return {Ext.data.proxy.Proxy} The proxy
         * @inheritable
         */
        static getProxy(): Ext.data.proxy.Proxy;

        /**
         * Asynchronously loads a model instance by id. Any processing of the loaded
         * record should be done in a callback.
         *
         * Sample usage:
         *
         *     Ext.define('MyApp.User', {
         *         extend: 'Ext.data.Model',
         *         fields: [
         *             {name: 'id', type: 'int'},
         *             {name: 'name', type: 'string'}
         *         ]
         *     });
         *
         *     MyApp.User.load(10, {
         *         scope: this,
         *         failure: function(record, operation) {
         *             //do something if the load failed
         *         },
         *         success: function(record, operation) {
         *             //do something if the load succeeded
         *         },
         *         callback: function(record, operation, success) {
         *             //do something whether the load succeeded or failed
         *         }
         *     });
         *
         * @param {Number/String} id The ID of the model to load.
         * **NOTE:** The model returned must have an ID matching the param in the load
         * request.
         *
         * @param {Object} [options] The options param is an
         * {@link Ext.data.operation.Read} config object containing success, failure and
         * callback functions, plus optional scope.
         *
         * @param {Function} options.success A function to be called when the
         * model is processed by the proxy successfully.
         * The callback is passed the following parameters:
         * @param {Ext.data.Model} options.success.record The record.
         * @param {Ext.data.operation.Operation} options.success.operation The operation.
         *
         * @param {Function} options.failure A function to be called when the
         * model is unable to be processed by the server.
         * The callback is passed the following parameters:
         * @param {Ext.data.Model} options.failure.record The record.
         * @param {Ext.data.operation.Operation} options.failure.operation The operation.
         *
         * @param {Function} options.callback A function to be called whether the proxy
         * transaction was successful or not.
         * The callback is passed the following parameters:
         * @param {Ext.data.Model} options.callback.record The record.
         * @param {Ext.data.operation.Operation} options.callback.operation The
         * operation.
         * @param {Boolean} options.callback.success 'true' if the operation was
         * successful.
         *
         * @param {Object} options.scope The scope in which to execute the callback
         * functions.  Defaults to the model instance.
         *
         * @param {Ext.data.Session} [session] The session for this record.
         *
         * @return {Ext.data.Model} The newly created model. Note that the model will
         * (probably) still be loading once it is returned from this method. To do any
         * post-processing on the data, the appropriate place to do see is in the
         * callback.
         *
         * @inheritable
         */
        static load(id: number|string, options?: any, options_success?: Function, options_success_record?: Ext.data.Model, options_success_operation?: Ext.data.operation.Operation, options_failure?: Function, options_failure_record?: Ext.data.Model, options_failure_operation?: Ext.data.operation.Operation, options_callback?: Function, options_callback_record?: Ext.data.Model, options_callback_operation?: Ext.data.operation.Operation, options_callback_success?: boolean, options_scope?: any, session?: Ext.data.Session): Ext.data.Model;

        /**
         * Removes the given set of fields from this model.
         *
         * @param {Boolean/String[]} removeFields The names of fields to remove or 'true'
         * to remove all existing fields. Removes are processed first followed by adds so
         * if a field name appears in 'newFields' as well that field will effectively be
         * added (however, in that case there is no need to include the field in this
         * array).
         *
         * @inheritable
         * @since 5.0.0
         */
        protected static removeFields(removeFields: boolean|string);

        /**
         * This method replaces the specified set of fields with a given set of new fields.
         * Fields should normally be considered immutable, but if the timing is right (that
         * is, before derived classes are declared), it is permissible to change the fields
         * collection.
         *
         * @param {String[]/Object[]} newFields The new fields to add. Based on the 'name'
         * of a field this may replace a previous field definition.
         * @param {Boolean/String[]} removeFields The names of fields to remove or 'true'
         * to remove all existing fields. Removes are processed first followed by adds so
         * if a field name appears in 'newFields' as well that field will effectively be
         * added (however, in that case there is no need to include the field in this
         * array).
         *
         * @inheritable
         * @since 5.0.0
         */
        protected static replaceFields(newFields: string|any, removeFields: boolean|string);

        /**
         * Sets the Proxy to use for this model. Accepts any options that can be accepted by
         * {@link Ext#createByAlias Ext.createByAlias}.
         * @param {String/Object/Ext.data.proxy.Proxy} proxy The proxy
         * @return {Ext.data.proxy.Proxy}
         * @inheritable
         */
        static setProxy(proxy: string|any|Ext.data.proxy.Proxy): Ext.data.proxy.Proxy;
    }

    /**
     * This class has been deprecated. Use 'Ext.data.schema.Schema' instead.
     */
    export class ModelManager {
        /**
         * Returns the {@link Ext.data.Model} class for a given model name
         * @param {String/Object} id The classname of the model or the model class itself.
         * @return {Ext.data.Model} a model class.
         * @deprecated Use {@link Ext.data.schema.Schema#lookupEntity} instead.
         */
        static getModel(id: string|any): Ext.data.Model;
    }

    interface NodeInterfaceConfig {
        /**
         * Set to false to deny dragging of this node.
         *
         * Applicable when using the {@link Ext.tree.plugin.TreeViewDragDrop
         * TreeViewDragDrop} plugin.
         *
         * Optional, Defaults to: true
         */
        allowDrag?: boolean;

        /**
         * Set to false to deny dropping on this node.
         *
         * Applicable when using the {@link Ext.tree.plugin.TreeViewDragDrop
         * TreeViewDragDrop} plugin.
         *
         * Optional, Defaults to: true
         */
        allowDrop?: boolean;

        /**
         * Set to true or false to show a checkbox alongside this node.
         *
         * To fetch an array of checked nodes use {@link Ext.tree.Panel#method-getChecked
         * getChecked()}.
         *
         * Optional, Defaults to: null
         */
        checked?: boolean;

        /**
         * Array of child nodes.
         *
         * **Note:** By default the child nodes root is 'children', but can be set using the
         * reader {@link Ext.data.reader.Reader#cfg-rootProperty rootProperty} config on the
         * {@link Ext.data.TreeStore TreeStore's} {@link Ext.data.TreeStore#cfg-proxy proxy}.
         */
        children?: Ext.data.NodeInterface;

        /**
         * CSS class to apply to this node.
         */
        cls?: string;

        /**
         * False to prevent expanding/collapsing of this node.
         *
         * See also: {@link #isExpandable}.
         *
         * Optional, Defaults to: true
         */
        expandable?: boolean;

        /**
         * True if the node is expanded.
         *
         * When the tree is asynchronously remote loaded, expanding a collapsed node loads
         * the children of that node (if the node has not already been loaded previously).
         *
         * See also: {@link #isExpanded}.
         *
         * Optional, Defaults to: false
         */
        expanded?: boolean;

        /**
         * A URL for a link that's created when this config is specified.
         *
         * See also {@link #hrefTarget}.
         */
        href?: string;

        /**
         * Target for link. Only applicable when {@link #href} is also specified.
         */
        hrefTarget?: string;

        icon?: string;

        iconCls?: string;

        /**
         * Set to true to indicate that this child can have no children. The expand icon/arrow will then not be
         * rendered for this node.
         *
         * See also: {@link #isLeaf}.
         *
         * Optional, Defaults to: false
         */
        leaf?: boolean;

        /**
         * Tooltip showDelay.
         *
         * See also {@link #qtip}.
         * See also {@link #qtitle}.
         */
        qshowDelay?: number;

        /**
         * Tooltip text to show on this node.
         *
         * See also {@link #qtitle}.
         * See also {@link #qshowDelay}.
         */
        qtip?: string;

        /**
         * Tooltip title.
         *
         * See also {@link #qtip}.
         * See also {@link #qshowDelay}.
         */
        qtitle?: string;

        /**
         * The text to show on node label (_html tags are accepted_).
         * The default text for the root node is 'ROOT'.  All other nodes default to ''.
         *
         * **Note:** By default the node label is 'text', but can be set using the tree's
         * {@link Ext.tree.Panel#cfg-displayField displayField} config.
         */
        text?: string;
    }

    /**
     * This class is used as a set of methods that are applied to the prototype of a
     * {@link Ext.data.Model Model} to decorate it with a Node API. This means that models
     * used in conjunction with a tree will have all of the tree related methods available
     * on the model. In general, this class will not be used directly by the developer.
     *
     * This class also creates extra {@link Ext.data.Field fields} on the model, if they do
     * not exist, to help maintain the tree state and UI. These fields are documented as
     * config options.
     *
     * The data fields used to render a tree node are: {@link #text}, {@link #leaf},
     * {@link #children}, and {@link #expanded}.  Once a node is loaded to the tree store
     * you can use {@link Ext.data.Model#get get()} to fetch the value of a given field
     * name (provided there is not a convenience accessor on the Node for that field).
     *
     *     @example
     *     Ext.tip.QuickTipManager.init(); // not required when using Ext.application()
     *
     *     var root = {
     *         expanded: true,
     *         children: [{
     *             text: "Leaf node (<i>no folder/arrow icon</i>)",
     *             leaf: true,
     *             qtitle: 'Sample Tip Title',
     *             qtip: 'Tip body'
     *         }, {
     *             text: "Parent node expanded",
     *             expanded: true,
     *             children: [{
     *                 text: "Expanded leaf node 1",
     *                 leaf: true
     *             }, {
     *                 text: "Expanded leaf node 2",
     *                 leaf: true
     *             }]
     *         }, {
     *             text: "Parent node collapsed",
     *             children: [{
     *                 text: "Collapsed leaf node 1",
     *                 leaf: true
     *             }, {
     *                 text: "Collapsed leaf node 2",
     *                 leaf: true
     *             }]
     *         }]
     *     };
     *
     *     var tree = Ext.create('Ext.tree.Panel', {
     *         title: 'TreePanel',
     *         width: 260,
     *         height: 200,
     *         root: root,
     *         rootVisible: false,
     *         renderTo: document.body,
     *         bbar: ['The first node ', {
     *             text: 'is a leaf?',
     *             handler: function () {
     *                 var firstChild = tree.getRootNode().getChildAt(0);
     *                 Ext.Msg.alert('Is Leaf?', firstChild.isLeaf());
     *             }
     *         }, {
     *             text: 'has text?',
     *             handler: function () {
     *                 var firstChild = tree.getRootNode().getChildAt(0);
     *                 Ext.Msg.alert('Has Text:', firstChild.get('text'));
     *             }
     *         }]
     *     });
     *
     * The following configs have methods used to set the value / state of the node at
     * runtime:
     *
     * **{@link #children} / {@link #leaf}**
     *
     *  - {@link #appendChild}
     *  - {@link #hasChildNodes}
     *  - {@link #insertBefore}
     *  - {@link #insertChild}
     *  - {@link #method-remove}
     *  - {@link #removeAll}
     *  - {@link #removeChild}
     *  - {@link #replaceChild}
     *
     * **{@link #expanded}**
     *
     *  - {@link #method-expand}
     *  - {@link #expandChildren}
     *  - {@link #method-collapse}
     *  - {@link #collapseChildren}
     *
     * The remaining configs may be set using {@link Ext.data.Model#method-set set()}.
     *
     *     node.set('text', 'Changed Text'); // example showing how to change the node label
     *
     * The {@link #qtip}, {@link #qtitle}, and {@link #qshowDelay} use QuickTips and
     * requires initializing {@link Ext.tip.QuickTipManager} unless the application is
     * created using {@link Ext#method-application}.
     *
     *     Ext.tip.QuickTipManager.init();
     *
     * For additional information and examples see the description for
     * {@link Ext.tree.Panel}.
     */
    export class NodeInterface extends Ext.Base implements Ext.data.NodeInterfaceConfig {
        /**
         * An array of this nodes children.  Array will be empty if this node has no children.
         */
        childNodes: Ext.data.NodeInterface;

        /**
         * A reference to this node's first child node. 'null' if this node has no children.
         */
        firstChild: Ext.data.NodeInterface;

        /**
         * 'true' in this class to identify an object as an instantiated Node, or subclass thereof.
         */
        isNode: boolean;

        /**
         * A reference to this node's last child node. 'null' if this node has no children.
         */
        lastChild: Ext.data.NodeInterface;

        /**
         * A reference to this node's next sibling node. 'null' if this node does not have a next sibling.
         */
        nextSibling: Ext.data.NodeInterface;

        /**
         * A reference to this node's parent node. 'null' if this node is the root node.
         */
        parentNode: Ext.data.NodeInterface;

        /**
         * A reference to this node's previous sibling node. 'null' if this node does not have a previous sibling.
         */
        previousSibling: Ext.data.NodeInterface;

        /**
         * Set to false to deny dragging of this node.
         *
         * Applicable when using the {@link Ext.tree.plugin.TreeViewDragDrop
         * TreeViewDragDrop} plugin.
         *
         * Optional, Defaults to: true
         */
        allowDrag: boolean;

        /**
         * Set to false to deny dropping on this node.
         *
         * Applicable when using the {@link Ext.tree.plugin.TreeViewDragDrop
         * TreeViewDragDrop} plugin.
         *
         * Optional, Defaults to: true
         */
        allowDrop: boolean;

        /**
         * Set to true or false to show a checkbox alongside this node.
         *
         * To fetch an array of checked nodes use {@link Ext.tree.Panel#method-getChecked
         * getChecked()}.
         *
         * Optional, Defaults to: null
         */
        checked: boolean;

        /**
         * Array of child nodes.
         *
         * **Note:** By default the child nodes root is 'children', but can be set using the
         * reader {@link Ext.data.reader.Reader#cfg-rootProperty rootProperty} config on the
         * {@link Ext.data.TreeStore TreeStore's} {@link Ext.data.TreeStore#cfg-proxy proxy}.
         */
        children: Ext.data.NodeInterface;

        /**
         * CSS class to apply to this node.
         */
        cls: string;

        /**
         * False to prevent expanding/collapsing of this node.
         *
         * See also: {@link #isExpandable}.
         *
         * Optional, Defaults to: true
         */
        expandable: boolean;

        /**
         * True if the node is expanded.
         *
         * When the tree is asynchronously remote loaded, expanding a collapsed node loads
         * the children of that node (if the node has not already been loaded previously).
         *
         * See also: {@link #isExpanded}.
         *
         * Optional, Defaults to: false
         */
        expanded: boolean;

        /**
         * A URL for a link that's created when this config is specified.
         *
         * See also {@link #hrefTarget}.
         */
        href: string;

        /**
         * Target for link. Only applicable when {@link #href} is also specified.
         */
        hrefTarget: string;

        icon: string;

        iconCls: string;

        /**
         * Set to true to indicate that this child can have no children. The expand icon/arrow will then not be
         * rendered for this node.
         *
         * See also: {@link #isLeaf}.
         *
         * Optional, Defaults to: false
         */
        leaf: boolean;

        /**
         * Tooltip showDelay.
         *
         * See also {@link #qtip}.
         * See also {@link #qtitle}.
         */
        qshowDelay: number;

        /**
         * Tooltip text to show on this node.
         *
         * See also {@link #qtitle}.
         * See also {@link #qshowDelay}.
         */
        qtip: string;

        /**
         * Tooltip title.
         *
         * See also {@link #qtip}.
         * See also {@link #qshowDelay}.
         */
        qtitle: string;

        /**
         * The text to show on node label (_html tags are accepted_).
         * The default text for the root node is 'ROOT'.  All other nodes default to ''.
         *
         * **Note:** By default the node label is 'text', but can be set using the tree's
         * {@link Ext.tree.Panel#cfg-displayField displayField} config.
         */
        text: string;

        /**
         * Inserts node(s) as the last child node of this node.
         *
         * If the node was previously a child node of another parent node, it will be removed from that node first.
         *
         * @param {Ext.data.NodeInterface/Ext.data.NodeInterface[]/Object} node The node or Array of nodes to append
         * @param {Boolean} [suppressEvents=false] True to suppress firing of
         * events.
         * @param {Boolean} [commit=false]
         * @return {Ext.data.NodeInterface} The appended node if single append, or null if an array was passed
         */
        appendChild(node: Ext.data.NodeInterface|any, suppressEvents?: boolean, commit?: boolean): Ext.data.NodeInterface;

        /**
         * Bubbles up the tree from this node, calling the specified function with each node. The arguments to the function
         * will be the args provided or the current node. If the function returns false at any point,
         * the bubble is stopped.
         * @param {Function} fn The function to call
         * @param {Object} [scope] The scope (this reference) in which the function is executed. Defaults to the current Node.
         * @param {Array} [args] The args to call the function with. Defaults to passing the current Node.
         */
        bubble(fn: Function, scope?: any, args?: any[]);

        /**
         * Cascades down the tree from this node, calling the specified functions with each node. The arguments to the function
         * will be the args provided or the current node. If the 'before' function returns false at any point,
         * the cascade is stopped on that branch.
         *
         * Note that the 3 argument form passing 'fn, scope, args' is still supported. The 'fn' function is as before, called
         * *before* cascading down into child nodes. If it returns 'false', the child nodes are not traversed.
         *
         * @param {Object} spec An object containing before and after functions, scope and an argument list.
         * @param {Function} [spec.before] A function to call on a node *before* cascading down into child nodes.
         * If it returns 'false', the child nodes are not traversed.
         * @param {Function} [spec.after] A function to call on a node *after* cascading down into child nodes.
         * @param {Object} [spec.scope] The scope (this reference) in which the functions are executed. Defaults to the current Node.
         * @param {Array} [spec.args] The args to call the function with. Defaults to passing the current Node.
         */
        cascadeBy(spec: any, spec_before?: Function, spec_after?: Function, spec_scope?: any, spec_args?: any[]);

        /**
         * Collapse this node.
         * @param {Boolean} [recursive=false] True to recursively collapse all the children
         * @param {Function} [callback] The function to execute once the collapse completes
         * @param {Object} [scope] The scope to run the callback in
         */
        collapse(recursive?: boolean, callback?: Function, scope?: any);

        /**
         * Collapse all the children of this node.
         * @param {Function} [recursive=false] True to recursively collapse all the children
         * @param {Function} [callback] The function to execute once all the children are collapsed
         * @param {Object} [scope] The scope to run the callback in
         */
        collapseChildren(recursive?: Function, callback?: Function, scope?: any);

        /**
         * Returns true if this node is an ancestor (at any point) of the passed node.
         * @return {Boolean}
         */
        contains(node: Ext.data.NodeInterface): boolean;

        /**
         * Creates a copy (clone) of this Node.
         * @param {String} [id] A new id, defaults to this Node's id.
         * @param {Boolean} [deep=false] True to recursively copy all child Nodes into the new Node.
         * False to copy without child Nodes.
         * @return {Ext.data.NodeInterface} A copy of this Node.
         */
        copy(id?: string, deep?: boolean): Ext.data.NodeInterface;

        /**
         * Ensures that the passed object is an instance of a Record with the NodeInterface applied
         * @return {Ext.data.NodeInterface}
         */
        createNode(): Ext.data.NodeInterface;

        /**
         * Iterates the child nodes of this node, calling the specified function
         * with each node. The arguments to the function will be the args
         * provided or the current node. If the function returns false at any
         * point, the iteration stops.
         * @param {Function} fn The function to call
         * @param {Object} [scope] The scope (_this_ reference) in which the
         * function is executed. Defaults to the Node on which eachChild is
         * called.
         * @param {Array} [args] The args to call the function with. Defaults to
         * passing the current Node.
         */
        eachChild(fn: Function, scope?: any, args?: any[]);

        /**
         * Destroys the node.
         */
        erase();

        /**
         * Expand this node.
         * @param {Boolean} [recursive=false] True to recursively expand all the children
         * @param {Function} [callback] The function to execute once the expand completes
         * @param {Object} [scope] The scope to run the callback in
         */
        expand(recursive?: boolean, callback?: Function, scope?: any);

        /**
         * Expand all the children of this node.
         * @param {Boolean} [recursive=false] True to recursively expand all the children
         * @param {Function} [callback] The function to execute once all the children are expanded
         * @param {Object} [scope] The scope to run the callback in
         */
        expandChildren(recursive?: boolean, callback?: Function, scope?: any);

        /**
         * Finds the first child that has the attribute with the specified value.
         * @param {String} attribute The attribute name
         * @param {Object} value The value to search for
         * @param {Boolean} [deep=false] True to search through nodes deeper than the immediate children
         * @return {Ext.data.NodeInterface} The found child or null if none was found
         */
        findChild(attribute: string, value: any, deep?: boolean): Ext.data.NodeInterface;

        /**
         * Finds the first child by a custom function. The child matches if the function passed returns true.
         * @param {Function} fn A function which must return true if the passed Node is the required Node.
         * @param {Object} [scope] The scope (this reference) in which the function is executed. Defaults to the Node being tested.
         * @param {Boolean} [deep=false] True to search through nodes deeper than the immediate children
         * @return {Ext.data.NodeInterface} The found child or null if none was found
         */
        findChildBy(fn: Function, scope?: any, deep?: boolean): Ext.data.NodeInterface;

        /**
         * Fires the specified event with the passed parameters (minus the event name, plus the 'options' object passed
         * to {@link Ext.mixin.Observable#addListener addListener}).
         *
         * An event may be set to bubble up an Observable parent hierarchy (See {@link Ext.Component#getBubbleTarget}) by
         * calling {@link Ext.mixin.Observable#enableBubble enableBubble}.
         *
         * @param {String} eventName The name of the event to fire.
         * @param {Object...} args Variable number of parameters are passed to handlers.
         * @return {Boolean} returns false if any of the handlers return false otherwise it returns true.
         */
        fireEvent(eventName: string, args: any): boolean;

        /**
         * Returns the child node at the specified index.
         * @return {Ext.data.NodeInterface}
         */
        getChildAt(index: number): Ext.data.NodeInterface;

        /**
         * Returns depth of this node (the root node has a depth of 0)
         * @return {Number}
         */
        getDepth(): number;

        /**
         * Returns the tree this node is in.
         * @return {Ext.tree.Panel} The tree panel which owns this node.
         */
        getOwnerTree(): any;

        /**
         * Gets the hierarchical path from the root of the current node.
         * @param {String} [field] The field to construct the path from. Defaults to the model idProperty.
         * @param {String} [separator='/'] A separator to use.
         * @return {String} The node path
         */
        getPath(field?: string, separator?: string): string;

        /**
         * Returns the {@link Ext.data.TreeStore} which owns this node.
         * @return {Ext.data.TreeStore} The TreeStore which owns this node.
         */
        getTreeStore(): Ext.data.TreeStore;

        /**
         * Returns true if this node has one or more child nodes, else false.
         * @return {Boolean}
         */
        hasChildNodes(): boolean;

        /**
         * Returns the index of a child node
         * @return {Number} The index of the node or -1 if it was not found
         */
        indexOf(node: Ext.data.NodeInterface): number;

        /**
         * Returns the index of a child node that matches the id
         * @param {String} id The id of the node to find
         * @return {Number} The index of the node or -1 if it was not found
         */
        indexOfId(id: string): number;

        /**
         * Inserts the first node before the second node in this nodes childNodes collection.
         * @param {Ext.data.NodeInterface/Ext.data.NodeInterface[]/Object} node The node to insert
         * @param {Ext.data.NodeInterface} refNode The node to insert before (if null the node is appended)
         * @return {Ext.data.NodeInterface} The inserted node
         */
        insertBefore(node: Ext.data.NodeInterface|any, refNode: Ext.data.NodeInterface): Ext.data.NodeInterface;

        /**
         * Inserts a node into this node.
         * @param {Number} index The zero-based index to insert the node at
         * @param {Ext.data.NodeInterface/Object} node The node to insert
         * @return {Ext.data.NodeInterface} The node you just inserted
         */
        insertChild(index: number, node: Ext.data.NodeInterface|any): Ext.data.NodeInterface;

        /**
         * Returns true if the passed node is an ancestor (at any point) of this node.
         * @return {Boolean}
         */
        isAncestor(node: Ext.data.NodeInterface): boolean;

        /**
         * Returns true if this node is a branch node, and the entire branch is fully loaded.
         *
         * Using this method, it is possible to ascertain whether an
         * 'expandAll()' call (_classic toolkit TreePanel method_) will have
         * access to all descendant nodes without incurring a store load.
         * @return {Boolean}
         */
        isBranchLoaded(): boolean;

        /**
         * Returns true if this node has one or more child nodes, or if the <tt>expandable</tt>
         * node attribute is explicitly specified as true, otherwise returns false.
         * @return {Boolean}
         */
        isExpandable(): boolean;

        /**
         * Returns 'true' if this node is expanded.
         * @return {Boolean}
         */
        isExpanded(): boolean;

        /**
         * Returns true if this node is the first child of its parent
         * @return {Boolean}
         */
        isFirst(): boolean;

        /**
         * Returns true if this node is the last child of its parent
         * @return {Boolean}
         */
        isLast(): boolean;

        /**
         * Returns true if this node is a leaf
         * @return {Boolean}
         */
        isLeaf(): boolean;

        /**
         * Returns true if this node is loaded
         * @return {Boolean}
         */
        isLoaded(): boolean;

        /**
         * Returns true if this node is loading
         * @return {Boolean}
         */
        isLoading(): boolean;

        /**
         * Returns true if this node is the root node
         * @return {Boolean}
         */
        isRoot(): boolean;

        /**
         * Returns true if this node is visible. Note that visibility refers to
         * the structure of the tree, the {@link Ext.tree.Panel#rootVisible}
         * configuration is not taken into account here. If this method is called
         * on the root node, it will always be visible.
         * @return {Boolean}
         */
        isVisible(): boolean;

        /**
         * Removes this node from its parent.
         *
         * **If** the node is not phantom (only added in the client side), then it may be marked for removal.
         *
         * If the owning {@link Ext.data.TreeStore tree store} is set to {@link Ext.data.ProxyStore#trackRemoved track removed}
         * then the node will be added to the stack of nodes due to be removed the next time the store is synced with the server.
         *
         * If the owning {@link Ext.data.TreeStore tree store} is set to {@link Ext.data.ProxyStore#autoSync auto synchronize}
         * then the synchronize request will be initiated immediately.
         *
         * @param {Boolean} [erase=false] True to erase the node using the configured proxy. This is only needed when the
         * owning {@link Ext.data.TreeStore tree store} is not taking care of synchronization operations.
         *
         * @return {Ext.data.NodeInterface} this
         */
        remove(erase?: boolean): Ext.data.NodeInterface;

        /**
         * Removes all child nodes from this node.
         * @param {Boolean} [erase=false] True to erase the node using the configured
         * proxy.
         * @return {Ext.data.NodeInterface} this
         */
        removeAll(erase?: boolean): Ext.data.NodeInterface;

        /**
         * Removes a child node from this node.
         * @param {Ext.data.NodeInterface} node The node to remove
         * @param {Boolean} [erase=false] True to erase the record using the
         * configured proxy.
         * @return {Ext.data.NodeInterface} The removed node
         */
        removeChild(node: Ext.data.NodeInterface, erase?: boolean): Ext.data.NodeInterface;

        /**
         * Replaces one child node in this node with another.
         * @param {Ext.data.NodeInterface} newChild The replacement node
         * @param {Ext.data.NodeInterface} oldChild The node to replace
         * @return {Ext.data.NodeInterface} The replaced node
         */
        replaceChild(newChild: Ext.data.NodeInterface, oldChild: Ext.data.NodeInterface): Ext.data.NodeInterface;

        /**
         * Creates an object representation of this node including its children.
         */
        serialize();

        /**
         * Sorts this nodes children using the supplied sort function.
         * @param {Function} [sortFn] A function which, when passed two Nodes, returns -1, 0 or 1 depending upon required sort order.
         *
         * It omitted, the node is sorted according to the existing sorters in the owning {@link Ext.data.TreeStore TreeStore}.
         * @param {Boolean} [recursive=false] True to apply this sort recursively
         * @param {Boolean} [suppressEvent=false] True to not fire a sort event.
         */
        sort(sortFn?: Function, recursive?: boolean, suppressEvent?: boolean);

        /**
         * Updates general data of this node like isFirst, isLast, depth. This
         * method is internally called after a node is moved. This shouldn't
         * have to be called by the developer unless they are creating custom
         * Tree plugins.
         * @param {Object} info The info to update. May contain any of the following
         *  @param {Object} info.isFirst
         *  @param {Object} info.isLast
         *  @param {Object} info.index
         *  @param {Object} info.depth
         *  @param {Object} info.parentId
         */
        protected updateInfo(commit: boolean, info: any);

        /**
         * Fires when a new child node is appended
         * @param {Ext.data.NodeInterface} this This node
         * @param {Ext.data.NodeInterface} node The newly appended node
         * @param {Number} index The index of the newly appended node
         */
        append(that: Ext.data.NodeInterface, node: Ext.data.NodeInterface, index: number);

        /**
         * Fires before a new child is appended, return false to cancel the append.
         * @param {Ext.data.NodeInterface} this This node
         * @param {Ext.data.NodeInterface} node The child node to be appended
         */
        beforeappend(that: Ext.data.NodeInterface, node: Ext.data.NodeInterface);

        /**
         * Fires before this node is collapsed.
         * @param {Ext.data.NodeInterface} this The collapsing node
         */
        beforecollapse(that: Ext.data.NodeInterface);

        /**
         * Fires before this node is expanded.
         * @param {Ext.data.NodeInterface} this The expanding node
         */
        beforeexpand(that: Ext.data.NodeInterface);

        /**
         * Fires before a new child is inserted, return false to cancel the insert.
         * @param {Ext.data.NodeInterface} this This node
         * @param {Ext.data.NodeInterface} node The child node to be inserted
         * @param {Ext.data.NodeInterface} refNode The child node the node is being inserted before
         */
        beforeinsert(that: Ext.data.NodeInterface, node: Ext.data.NodeInterface, refNode: Ext.data.NodeInterface);

        /**
         * Fires before this node is moved to a new location in the tree. Return false to cancel the move.
         * @param {Ext.data.NodeInterface} this This node
         * @param {Ext.data.NodeInterface} oldParent The parent of this node
         * @param {Ext.data.NodeInterface} newParent The new parent this node is moving to
         * @param {Number} index The index it is being moved to
         */
        beforemove(that: Ext.data.NodeInterface, oldParent: Ext.data.NodeInterface, newParent: Ext.data.NodeInterface, index: number);

        /**
         * Fires before a child is removed, return false to cancel the remove.
         * @param {Ext.data.NodeInterface} this This node
         * @param {Ext.data.NodeInterface} node The child node to be removed
         * @param {Boolean} isMove 'true' if the child node is being removed so it can be moved to another position in the tree.
         * (a side effect of calling {@link Ext.data.NodeInterface#appendChild appendChild} or
         * {@link Ext.data.NodeInterface#insertBefore insertBefore} with a node that already has a parentNode)
         */
        beforeremove(that: Ext.data.NodeInterface, node: Ext.data.NodeInterface, isMove: boolean);

        /**
         * Fires when a new child node is inserted.
         * @param {Ext.data.NodeInterface} this This node
         * @param {Ext.data.NodeInterface} node The child node inserted
         * @param {Ext.data.NodeInterface} refNode The child node the node was inserted before
         */
        insert(that: Ext.data.NodeInterface, node: Ext.data.NodeInterface, refNode: Ext.data.NodeInterface);

        /**
         * Fires when this node is moved to a new location in the tree
         * @param {Ext.data.NodeInterface} this This node
         * @param {Ext.data.NodeInterface} oldParent The old parent of this node
         * @param {Ext.data.NodeInterface} newParent The new parent of this node
         * @param {Number} index The index it was moved to
         */
        move(that: Ext.data.NodeInterface, oldParent: Ext.data.NodeInterface, newParent: Ext.data.NodeInterface, index: number);

        /**
         * This method allows you to decorate a Model's class to implement the NodeInterface.
         * This adds a set of methods, new events, new properties and new fields on every Record.
         * @param {Ext.Class/Ext.data.Model} model The Model class or an instance of the Model class you want to
         * decorate the prototype of.
         */
        static decorate(model: Ext.Class|Ext.data.Model);
    }

    interface NodeStoreConfig extends Ext.data.StoreConfig {
        /**
         * Set to 'true' to automatically prepend a leaf sorter.
         */
        folderSort?: boolean;

        /**
         * The Record you want to bind this Store to. Note that
         * this record will be decorated with the {@link Ext.data.NodeInterface} if this is not the
         * case yet.
         */
        node?: Ext.data.Model;

        /**
         * Set this to 'true' if you want this NodeStore to represent
         * all the descendants of the node in its flat data collection. This is useful for
         * rendering a tree structure to a DataView and is being used internally by
         * the TreeView. Any records that are moved, removed, inserted or appended to the
         * node at any depth below the node this store is bound to will be automatically
         * updated in this Store's internal flat data structure.
         */
        recursive?: boolean;

        /**
         * 'false' to not include the root node in this Stores collection.
         */
        rootVisible?: boolean;
    }

    /**
     * Node Store
     */
    export class NodeStore extends Ext.data.Store implements Ext.data.NodeStoreConfig {
        /**
         * 'true' in this class to identify an object as an instantiated NodeStore, or subclass thereof.
         */
        isNodeStore: boolean;

        /**
         * Set to 'true' to automatically prepend a leaf sorter.
         */
        folderSort: boolean;

        /**
         * The Record you want to bind this Store to. Note that
         * this record will be decorated with the {@link Ext.data.NodeInterface} if this is not the
         * case yet.
         */
        node: Ext.data.Model;

        /**
         * Set this to 'true' if you want this NodeStore to represent
         * all the descendants of the node in its flat data collection. This is useful for
         * rendering a tree structure to a DataView and is being used internally by
         * the TreeView. Any records that are moved, removed, inserted or appended to the
         * node at any depth below the node this store is bound to will be automatically
         * updated in this Store's internal flat data structure.
         */
        recursive: boolean;

        /**
         * 'false' to not include the root node in this Stores collection.
         */
        rootVisible: boolean;

        /**
         * Creates the store.
         * @param {Object} [config] Config object.
         */
        constructor(config?: Ext.data.ArrayStoreConfig);

        getFolderSort();

        getNode();

        getRecursive();

        getRootVisible();

        /**
         * @return {Boolean}
         */
        isVisible(node: any): boolean;

        setFolderSort();

        setNode();

        setRecursive();

        setRootVisible();
    }

    interface PageMapConfig extends Ext.util.LruCacheConfig {
        /**
         * The size of pages in this map.
         */
        pageSize?: number;

        /**
         * The root property to use for aggregation, filtering and sorting. By default
         * this is 'null' but when containing things like {@link Ext.data.Model records}
         * this config would likely be set to "data" so that property names are applied
         * to the fields of each record.
         */
        rootProperty?: string;
    }

    /**
     * @extends Ext.util.LruCache
     * Private class for use by only Store when configured 'buffered: true'.
     */
    export class PageMap extends Ext.util.LruCache implements Ext.data.PageMapConfig {
        /**
         * The size of pages in this map.
         */
        pageSize: number;

        /**
         * The root property to use for aggregation, filtering and sorting. By default
         * this is 'null' but when containing things like {@link Ext.data.Model records}
         * this config would likely be set to "data" so that property names are applied
         * to the fields of each record.
         */
        rootProperty: string;

        /**
         * Creates new HashMap.
         * @param {Object} config (optional) Config object.
         */
        constructor(config: Ext.data.PageMapConfig);

        destroy();

        /**
         * Returns the first record in this page map which elicits a true return value from the
         * passed selection function.
         *
         * **IMPORTANT
         * This can ONLY find records which happen to be cached in the page cache. This will be parts of the dataset around the currently
         * visible zone, or recently visited zones if the pages have not yet been purged from the cache.
         *
         * This CAN NOT find records which have not been loaded into the cache.**
         *
         * If full client side searching is required, do not use a buffered store, instead use a regular, fully loaded store and
         * use the {@link Ext.grid.plugin.BufferedRenderer BufferedRenderer} plugin to minimize DOM footprint.
         * @param {Function} fn The selection function to execute for each item.
         *  @param {Mixed} fn.rec The record.
         *  @param {Mixed} fn.index The index in the total dataset of the record.
         * @param {Object} [scope] The scope ('this' reference) in which the function is executed. Defaults to this PageMap.
         * @return {Object} The first record in this page map which returned true from the selection
         * function, or null if none was found.
         */
        findBy(fn: Function, scope?: any): any;

        /**
         * Returns the index *in the whole dataset* of the first record in this page map which elicits a true return value from the
         * passed selection function.
         *
         * **IMPORTANT
         * This can ONLY find records which happen to be cached in the page cache. This will be parts of the dataset around the currently
         * visible zone, or recently visited zones if the pages have not yet been purged from the cache.
         *
         * This CAN NOT find records which have not been loaded into the cache.**
         *
         * If full client side searching is required, do not use a buffered store, instead use a regular, fully loaded store and
         * use the {@link Ext.grid.plugin.BufferedRenderer BufferedRenderer} plugin to minimize DOM footprint.
         * @param {Function} fn The selection function to execute for each item.
         *  @param {Mixed} fn.rec The record.
         *  @param {Mixed} fn.index The index in the total dataset of the record.
         * @param {Object} [scope] The scope ('this' reference) in which the function is executed. Defaults to this PageMap.
         * @return {Number} The index first record in this page map which returned true from the selection
         * function, or -1 if none was found.
         */
        findIndexBy(fn: Function, scope?: any): number;

        getPageSize();

        getRootProperty();

        getStore();

        setPageSize();

        setRootProperty();

        setStore();
    }

    interface ProxyStoreConfig extends Ext.data.AbstractStoreConfig {
        /**
         * This defaults to 'true' when this store's {@link #cfg-proxy} is asynchronous, such as an
         * {@link Ext.data.proxy.Ajax Ajax proxy}.
         *
         * When the proxy is synchronous, such as a {@link Ext.data.proxy.Memory} memory proxy, this
         * defaults to 'false'.
         *
         * *NOTE:* This does not cause synchronous Ajax requests if configured 'false' when an Ajax proxy
         * is used. It causes immediate issuing of an Ajax request when {@link #method-load} is called
         * rather than issuing the request at the end of the current event handler run.
         *
         * What this means is that when using an Ajax proxy, calls to
         * {@link #method-load} do not fire the request to the remote resource
         * immediately, but schedule a request to be made. This is so that multiple
         * requests are not fired when mutating a store's remote filters and sorters (as
         * happens during state restoration). The request is made only once after all
         * relevant store state is fully set.
         *
         * @since 6.0.1
         *
         * Optional
         */
        asynchronousLoad?: boolean;

        /**
         * If data is not specified, and if autoLoad is true or an Object, this store's load method is automatically called
         * after creation. If the value of autoLoad is an Object, this Object will be passed to the store's load method.
         *
         * It's important to note that {@link Ext.data.TreeStore Tree Stores} will
         * load regardless of autoLoad's value if expand is set to true on the
         * {@link Ext.data.TreeStore#root root node}.
         *
         * @since 2.3.0
         */
        autoLoad?: boolean|any;

        /**
         * True to automatically sync the Store with its Proxy after every edit to one of its Records. Defaults to false.
         */
        autoSync?: boolean;

        /**
         * Sets the updating behavior based on batch synchronization. 'operation' (the default) will update the Store's
         * internal representation of the data after each operation of the batch has completed, 'complete' will wait until
         * the entire batch has been completed before updating the Store's data. 'complete' is a good choice for local
         * storage proxies, 'operation' is better for remote proxies, where there is a comparatively high latency.
         */
        batchUpdateMode?: string;

        /**
         * for simple stores like a two-field store of
         * {@link Ext.form.field.ComboBox ComboBox}. For anything more complicated, such
         * as specifying a particular id property or associations, a
         * {@link Ext.data.Model Model} should be defined and specified for the
         * {@link #model} config.
         *
         * @since 2.3.0
         */
        fields?: any|string;

        /**
         * Name of the {@link Ext.data.Model Model} associated with this store. See
         * {@link Ext.data.Model#entityName}.
         *
         * May also be the actual Model subclass.
         *
         * This config is required for the store to be able to read data unless you have defined
         * the {@link #fields} config which will create an anonymous 'Ext.data.Model'.
         */
        model?: string|Ext.data.Model;

        /**
         * The Proxy to use for this Store. This can be either a string, a config object or a Proxy instance -
         * see {@link #setProxy} for details.
         * @since 1.1.0
         */
        proxy?: string|Ext.data.proxy.Proxy|any;

        /**
         * If true, any sorters attached to this Store will be run after loading data, before the datachanged event is fired.
         * Defaults to true, ignored if {@link Ext.data.Store#remoteSort remoteSort} is true
         */
        sortOnLoad?: boolean;

        /**
         * This config controls whether removed records are remembered by this store for
         * later saving to the server.
         *
         * Optional, Defaults to: true
         */
        trackRemoved?: boolean;
    }

    /**
     * ProxyStore is a superclass of {@link Ext.data.Store} and {@link Ext.data.BufferedStore}. It's never used directly,
     * but offers a set of methods used by both of those subclasses.
     *
     * We've left it here in the docs for reference purposes, but unless you need to make a whole new type of Store, what
     * you're probably looking for is {@link Ext.data.Store}. If you're still interested, here's a brief description of what
     * ProxyStore is and is not.
     *
     * ProxyStore provides the basic configuration for anything that can be considered a Store. It expects to be
     * given a {@link Ext.data.Model Model} that represents the type of data in the Store. It also expects to be given a
     * {@link Ext.data.proxy.Proxy Proxy} that handles the loading of data into the Store.
     *
     * ProxyStore provides a few helpful methods such as {@link #method-load} and {@link #sync}, which load and save data
     * respectively, passing the requests through the configured {@link #proxy}.
     *
     * Built-in Store subclasses add extra behavior to each of these functions. Note also that each ProxyStore subclass
     * has its own way of storing data - in {@link Ext.data.Store} the data is saved as a flat {@link Ext.util.Collection Collection},
     * whereas in {@link Ext.data.BufferedStore BufferedStore} we use a {@link Ext.data.PageMap} to maintain a client side cache of pages of records.
     *
     * The store provides filtering and sorting support. This sorting/filtering can happen on the client side
     * or can be completed on the server. This is controlled by the {@link Ext.data.Store#remoteSort remoteSort} and
     * {@link Ext.data.Store#remoteFilter remoteFilter} config options. For more information see the {@link #method-sort} and
     * {@link Ext.data.Store#filter filter} methods.
     */
    export class ProxyStore extends Ext.data.AbstractStore implements Ext.data.ProxyStoreConfig {
        /**
         * Property to hold the last options from a {@link #method-load} method call. This object is used for the {@link #method-reload}
         * to reuse the same options. Please see {@link #method-reload} for a simple example on how to use the lastOptions property.
         */
        lastOptions: any;

        /**
         * Temporary cache in which removed model instances are kept until successfully
         * synchronised with a Proxy, at which point this is cleared.
         *
         * This cache is maintained unless you set 'trackRemoved' to 'false'.
         */
        protected removed: Ext.data.Model;

        /**
         * This defaults to 'true' when this store's {@link #cfg-proxy} is asynchronous, such as an
         * {@link Ext.data.proxy.Ajax Ajax proxy}.
         *
         * When the proxy is synchronous, such as a {@link Ext.data.proxy.Memory} memory proxy, this
         * defaults to 'false'.
         *
         * *NOTE:* This does not cause synchronous Ajax requests if configured 'false' when an Ajax proxy
         * is used. It causes immediate issuing of an Ajax request when {@link #method-load} is called
         * rather than issuing the request at the end of the current event handler run.
         *
         * What this means is that when using an Ajax proxy, calls to
         * {@link #method-load} do not fire the request to the remote resource
         * immediately, but schedule a request to be made. This is so that multiple
         * requests are not fired when mutating a store's remote filters and sorters (as
         * happens during state restoration). The request is made only once after all
         * relevant store state is fully set.
         *
         * @since 6.0.1
         *
         * Optional
         */
        asynchronousLoad: boolean;

        /**
         * If data is not specified, and if autoLoad is true or an Object, this store's load method is automatically called
         * after creation. If the value of autoLoad is an Object, this Object will be passed to the store's load method.
         *
         * It's important to note that {@link Ext.data.TreeStore Tree Stores} will
         * load regardless of autoLoad's value if expand is set to true on the
         * {@link Ext.data.TreeStore#root root node}.
         *
         * @since 2.3.0
         */
        autoLoad: boolean|any;

        /**
         * True to automatically sync the Store with its Proxy after every edit to one of its Records. Defaults to false.
         */
        autoSync: boolean;

        /**
         * Sets the updating behavior based on batch synchronization. 'operation' (the default) will update the Store's
         * internal representation of the data after each operation of the batch has completed, 'complete' will wait until
         * the entire batch has been completed before updating the Store's data. 'complete' is a good choice for local
         * storage proxies, 'operation' is better for remote proxies, where there is a comparatively high latency.
         */
        batchUpdateMode: string;

        /**
         * for simple stores like a two-field store of
         * {@link Ext.form.field.ComboBox ComboBox}. For anything more complicated, such
         * as specifying a particular id property or associations, a
         * {@link Ext.data.Model Model} should be defined and specified for the
         * {@link #model} config.
         *
         * @since 2.3.0
         */
        fields: any|string;

        /**
         * Name of the {@link Ext.data.Model Model} associated with this store. See
         * {@link Ext.data.Model#entityName}.
         *
         * May also be the actual Model subclass.
         *
         * This config is required for the store to be able to read data unless you have defined
         * the {@link #fields} config which will create an anonymous 'Ext.data.Model'.
         */
        model: string|Ext.data.Model;

        /**
         * The Proxy to use for this Store. This can be either a string, a config object or a Proxy instance -
         * see {@link #setProxy} for details.
         * @since 1.1.0
         */
        proxy: string|Ext.data.proxy.Proxy|any;

        /**
         * If true, any sorters attached to this Store will be run after loading data, before the datachanged event is fired.
         * Defaults to true, ignored if {@link Ext.data.Store#remoteSort remoteSort} is true
         */
        sortOnLoad: boolean;

        /**
         * This config controls whether removed records are remembered by this store for
         * later saving to the server.
         *
         * Optional, Defaults to: true
         */
        trackRemoved: boolean;

        constructor();

        /**
         * Called when the event handler which called the {@link #method-load} method exits.
         */
        flushLoad();

        getAsynchronousLoad();

        getAutoLoad();

        getAutoSync();

        getBatchUpdateMode();

        getFields();

        getModel();

        /**
         * Gets all {@link Ext.data.Model records} added or updated since the last commit. Note that the order of records
         * returned is not deterministic and does not indicate the order in which records were modified. Note also that
         * removed records are not included (use {@link #getRemovedRecords} for that).
         * @return {Ext.data.Model[]} The added and updated Model instances
         */
        getModifiedRecords(): Ext.data.Model;

        /**
         * Returns all '{@link Ext.data.Model#property-phantom phantom}' records in this store.
         * @return {Ext.data.Model[]} A possibly empty array of 'phantom' records.
         */
        getNewRecords(): Ext.data.Model;

        getProxy();

        /**
         * Returns any records that have been removed from the store but not yet destroyed on the proxy.
         * @return {Ext.data.Model[]} The removed Model instances. Note that this is a *copy* of the store's
         * array, so may be mutated.
         */
        getRemovedRecords(): Ext.data.Model;

        getSortOnLoad();

        /**
         * Returns the total number of {@link Ext.data.Model Model} instances that the {@link Ext.data.proxy.Proxy Proxy}
         * indicates exist. This will usually differ from {@link #getCount} when using paging - getCount returns the
         * number of records loaded into the Store at the moment, getTotalCount returns the number of records that
         * could be loaded into the Store if the Store contained all data
         * @return {Number} The total number of Model instances available via the Proxy. 0 returned if
         * no value has been set via the reader.
         */
        getTotalCount(): number;

        getTrackRemoved();

        /**
         * Returns all valid, non-phantom Model instances that have been updated in the Store but not yet synchronized with the Proxy.
         * @return {Ext.data.Model[]} The updated Model instances
         */
        getUpdatedRecords(): Ext.data.Model;

        /**
         * Returns 'true' if the Store has been loaded.
         * @return {Boolean} 'true' if the Store has been loaded.
         */
        isLoaded(): boolean;

        /**
         * Returns true if the Store is currently performing a load operation
         * @return {Boolean} 'true' if the Store is currently loading
         */
        isLoading(): boolean;

        /**
         * Marks this store as needing a load. When the current executing event handler exits,
         * this store will send a request to load using its configured {@link #proxy}.
         *
         * Upon return of the data from whatever data source the proxy connected to, the retrieved
         * {@link Ext.data.Model records} will be loaded into this store, and the optional callback will be called.
         * Example usage:
         *
         *     store.load({
         *         scope: this,
         *         callback: function(records, operation, success) {
         *             // the operation object
         *             // contains all of the details of the load operation
         *             console.log(records);
         *         }
         *     });
         *
         * If the callback scope does not need to be set, a function can simply be passed:
         *
         *     store.load(function(records, operation, success) {
         *         console.log('loaded records');
         *     });
         *
         * @param {Object} [options] This is passed into the {@link Ext.data.operation.Operation Operation}
         * object that is created and then sent to the proxy's {@link Ext.data.proxy.Proxy#read} function.
         * In addition to the options listed below, this object may contain properties to configure the
         * {@link Ext.data.operation.Operation Operation}.
         * @param {Function} [options.callback] A function which is called when the response arrives.
         * @param {Ext.data.Model[]} options.callback.records Array of records.
         * @param {Ext.data.operation.Operation} options.callback.operation The Operation itself.
         * @param {Boolean} options.callback.success 'true' when operation completed successfully.
         * @param {Boolean} [options.addRecords=false] Specify as 'true' to *add* the incoming records rather than the
         * default which is to have the incoming records *replace* the existing stoire contents.
         *
         * @return {Ext.data.Store} this
         * @since 1.1.0
         */
        load(options?: any, options_callback?: Function, options_callback_records?: Ext.data.Model, options_callback_operation?: Ext.data.operation.Operation, options_callback_success?: boolean, options_addRecords?: boolean): Ext.data.Store;

        /**
         * Reloads the store using the last options passed to the {@link #method-load} method. You can use the reload method to reload the
         * store using the parameters from the last load() call. For example:
         *
         *     store.load({
         *         params : {
         *             userid : 22216
         *         }
         *     });
         *
         *     //...
         *
         *     store.reload();
         *
         * The initial {@link #method-load} execution will pass the 'userid' parameter in the request. The {@link #reload} execution
         * will also send the same 'userid' parameter in its request as it will reuse the 'params' object from the last {@link #method-load} call.
         *
         * You can override a param by passing in the config object with the 'params' object:
         *
         *     store.load({
         *         params : {
         *             userid : 22216,
         *             foo    : 'bar'
         *         }
         *     });
         *
         *     //...
         *
         *     store.reload({
         *         params : {
         *             userid : 1234
         *         }
         *     });
         *
         * The initial {@link #method-load} execution sends the 'userid' and 'foo' parameters but in the {@link #reload} it only sends
         * the 'userid' paramter because you are overriding the 'params' config not just overriding the one param. To only change a single param
         * but keep other params, you will have to get the last params from the {@link #lastOptions} property:
         *
         *     var lastOptions = store.lastOptions,
         *         lastParams = Ext.clone(lastOptions.params); // make a copy of the last params so we don't affect future reload() calls
         *
         *     lastParams.userid = 1234;
         *
         *     store.reload({
         *         params : lastParams
         *     });
         *
         * This will now send the 'userid' parameter as '1234' and the 'foo' param as ''bar''.
         *
         * @param {Object} [options] A config object which contains options which may override the options passed to the previous load call. See the
         * {@link #method-load} method for valid configs.
         */
        reload(options?: any);

        /**
         * Removes all records from the store. This method does a "fast remove",
         * individual remove events are not called. The {@link #clear} event is
         * fired upon completion.
         * @since 1.1.0
         */
        removeAll();

        /**
         * Resumes automatically syncing the Store with its Proxy.  Only applicable if {@link #autoSync} is 'true'
         * @param {Boolean} syncNow Pass 'true' to synchronize now. Only synchronizes with the Proxy if the suspension
         * count has gone to zero (We are not under a higher level of suspension)
         */
        resumeAutoSync(syncNow: boolean);

        /**
         * Saves all pending changes via the configured {@link #proxy}. Use {@link #sync} instead.
         * @deprecated 4.0.0 Will be removed in the next major version
         */
        save();

        setAsynchronousLoad();

        setAutoLoad();

        setAutoSync();

        setBatchUpdateMode();

        setFields();

        setModel();

        setProxy();

        setSortOnLoad();

        setTrackRemoved();

        /**
         * Suspends automatically syncing the Store with its Proxy.  Only applicable if {@link #autoSync} is 'true'
         */
        suspendAutoSync();

        /**
         * Synchronizes the store with its {@link #proxy}. This asks the proxy to batch together any new, updated
         * and deleted records in the store, updating the store's internal representation of the records
         * as each operation completes.
         *
         * @param {Object} [options] Object containing one or more properties supported by the sync method (these get
         * passed along to the underlying proxy's {@link Ext.data.Proxy#batch batch} method):
         *
         * @param {Ext.data.Batch/Object} [options.batch] A {@link Ext.data.Batch} object (or batch config to apply
         * to the created batch). If unspecified a default batch will be auto-created as needed.
         *
         * @param {Function} [options.callback] The function to be called upon completion of the sync.
         * The callback is called regardless of success or failure and is passed the following parameters:
         * @param {Ext.data.Batch} options.callback.batch The {@link Ext.data.Batch batch} that was processed,
         * containing all operations in their current state after processing
         * @param {Object} options.callback.options The options argument that was originally passed into sync
         *
         * @param {Function} [options.success] The function to be called upon successful completion of the sync. The
         * success function is called only if no exceptions were reported in any operations. If one or more exceptions
         * occurred then the failure function will be called instead. The success function is called
         * with the following parameters:
         * @param {Ext.data.Batch} options.success.batch The {@link Ext.data.Batch batch} that was processed,
         * containing all operations in their current state after processing
         * @param {Object} options.success.options The options argument that was originally passed into sync
         *
         * @param {Function} [options.failure] The function to be called upon unsuccessful completion of the sync. The
         * failure function is called when one or more operations returns an exception during processing (even if some
         * operations were also successful). In this case you can check the batch's {@link Ext.data.Batch#exceptions
         * exceptions} array to see exactly which operations had exceptions. The failure function is called with the
         * following parameters:
         * @param {Ext.data.Batch} options.failure.batch The {@link Ext.data.Batch} that was processed, containing all
         * operations in their current state after processing
         * @param {Object} options.failure.options The options argument that was originally passed into sync
         *
         * @param {Object} [options.params] Additional params to send during the sync Operation(s).
         *
         * @param {Object} [options.scope] The scope in which to execute any callbacks (i.e. the 'this' object inside
         * the callback, success and/or failure functions). Defaults to the store's proxy.
         *
         * @return {Ext.data.Store} this
         */
        sync(options?: any, options_batch?: Ext.data.Batch|any, options_callback?: Function, options_callback_batch?: Ext.data.Batch, options_callback_options?: any, options_success?: Function, options_success_batch?: Ext.data.Batch, options_success_options?: any, options_failure?: Function, options_failure_batch?: Ext.data.Batch, options_failure_options?: any, options_params?: any, options_scope?: any): Ext.data.Store;

        /**
         * Fires before a request is made for a new data object. If the beforeload handler returns false the load
         * action will be canceled.
         * @param {Ext.data.Store} store This Store
         * @param {Ext.data.operation.Operation} operation The Ext.data.operation.Operation object that will be passed to the Proxy to
         * load the Store
         * @since 1.1.0
         */
        beforeload(store: Ext.data.Store, operation: Ext.data.operation.Operation);

        /**
         * Fired before a call to {@link #sync} is executed. Return false from any listener to cancel the sync
         * @param {Object} options Hash of all records to be synchronized, broken down into create, update and destroy
         */
        beforesync(options: any);

        /**
         * Fires when this store's underlying reader (available via the proxy) provides new metadata.
         * Metadata usually consists of new field definitions, but can include any configuration data
         * required by an application, and can be processed as needed in the event handler.
         * This event is currently only fired for JsonReaders.
         * @param {Object} meta The JSON metadata
         * @since 1.1.0
         */
        metachange(that: Ext.data.Store, meta: any);

        /**
         * Fires whenever a successful write has been made via the configured {@link #proxy Proxy}
         * @param {Ext.data.Store} store This Store
         * @param {Ext.data.operation.Operation} operation The {@link Ext.data.operation.Operation Operation} object that was used in
         * the write
         * @since 3.4.0
         */
        write(store: Ext.data.Store, operation: Ext.data.operation.Operation);
    }

    interface RequestConfig {
        /**
         * The name of the action this Request represents. Usually one of 'create', 'read', 'update' or 'destroy'.
         */
        action?: string;

        /**
         * True to request binary data from the server.  This feature requires
         * the use of a binary reader such as {@link Ext.data.amf.Reader AMF Reader}
         */
        binary?: boolean;

        /**
         * Some requests (like JsonP) want to send an additional key that contains
         * the name of the callback function.
         */
        callbackKey?: string;

        /**
         * Whether or not to disable caching for this request.
         */
        disableCaching?: boolean;

        /**
         * Some requests (like XMLHttpRequests) want to send additional server headers.
         * This configuration can be set for those types of requests.
         */
        headers?: any;

        /**
         * This is used by some write actions to attach data to the request without encoding it
         * as a parameter.
         */
        jsonData?: any;

        /**
         * The HTTP method to use on this Request. Should be one of 'GET', 'POST', 'PUT' or 'DELETE'.
         */
        method?: string;

        /**
         * The operation this request belongs to.
         */
        operation?: Ext.data.operation.Operation;

        /**
         * HTTP request params. The Proxy and its Writer have access to and can modify this object.
         */
        params?: any;

        /**
         * Most oData feeds require basic HTTP authentication. This configuration allows
         * you to specify the password.
         */
        password?: string;

        /**
         * The proxy this request belongs to.
         */
        proxy?: Ext.data.proxy.Proxy;

        /**
         * The url to access on this Request.
         */
        url?: string;

        /**
         * Most oData feeds require basic HTTP authentication. This configuration allows
         * you to specify the username.
         */
        username?: string;

        /**
         * This field is necessary when using cross-origin resource sharing.
         */
        withCredentials?: boolean;

        /**
         * This is used by some write actions to attach data to the request without encoding it
         * as a parameter, but instead sending it as XML.
         */
        xmlData?: any;
    }

    /**
     * Simple class that represents a Request that will be made by any {@link Ext.data.proxy.Server} subclass.
     * All this class does is standardize the representation of a Request as used by any ServerProxy subclass,
     * it does not contain any actual logic or perform the request itself.
     */
    export class Request extends Ext.Base implements Ext.data.RequestConfig {
        /**
         * The name of the action this Request represents. Usually one of 'create', 'read', 'update' or 'destroy'.
         */
        action: string;

        /**
         * True to request binary data from the server.  This feature requires
         * the use of a binary reader such as {@link Ext.data.amf.Reader AMF Reader}
         */
        binary: boolean;

        /**
         * Some requests (like JsonP) want to send an additional key that contains
         * the name of the callback function.
         */
        callbackKey: string;

        /**
         * Whether or not to disable caching for this request.
         */
        disableCaching: boolean;

        /**
         * Some requests (like XMLHttpRequests) want to send additional server headers.
         * This configuration can be set for those types of requests.
         */
        headers: any;

        /**
         * This is used by some write actions to attach data to the request without encoding it
         * as a parameter.
         */
        jsonData: any;

        /**
         * The HTTP method to use on this Request. Should be one of 'GET', 'POST', 'PUT' or 'DELETE'.
         */
        method: string;

        /**
         * The operation this request belongs to.
         */
        operation: Ext.data.operation.Operation;

        /**
         * HTTP request params. The Proxy and its Writer have access to and can modify this object.
         */
        params: any;

        /**
         * Most oData feeds require basic HTTP authentication. This configuration allows
         * you to specify the password.
         */
        password: string;

        /**
         * The proxy this request belongs to.
         */
        proxy: Ext.data.proxy.Proxy;

        /**
         * The url to access on this Request.
         */
        url: string;

        /**
         * Most oData feeds require basic HTTP authentication. This configuration allows
         * you to specify the username.
         */
        username: string;

        /**
         * This field is necessary when using cross-origin resource sharing.
         */
        withCredentials: boolean;

        /**
         * This is used by some write actions to attach data to the request without encoding it
         * as a parameter, but instead sending it as XML.
         */
        xmlData: any;

        /**
         * Creates the Request object.
         * @param {Object} [config] Config object.
         */
        constructor(config?: Ext.data.RequestConfig);

        getAction();

        getArgs();

        getBinary();

        getCallback();

        getCallbackKey();

        getDirectFn();

        getDisableCaching();

        getHeaders();

        getJsonData();

        getMethod();

        getOperation();

        /**
         * Gets a single param from the {@link #params}.
         * @param {String} key The key for the param.
         * @return {Object} The value for the param. 'undefined' if it does not exist.
         */
        getParam(key: string): any;

        getParams();

        getPassword();

        getProxy();

        getRecords();

        getScope();

        getTimeout();

        getUrl();

        getUseDefaultXhrHeader();

        getUsername();

        getWithCredentials();

        getXmlData();

        setAction();

        setArgs();

        setBinary();

        setCallback();

        setCallbackKey();

        setDirectFn();

        setDisableCaching();

        setHeaders();

        setJsonData();

        setMethod();

        setOperation();

        /**
         * Sets a single param value in the {@link #params}.
         * @param {String} key The key to set.
         * @param {Object} value The value to set.
         */
        setParam(key: string, value: any);

        setParams();

        setPassword();

        setProxy();

        setRecords();

        setScope();

        setTimeout();

        setUrl();

        setUseDefaultXhrHeader();

        setUsername();

        setWithCredentials();

        setXmlData();
    }

    interface ResultSetConfig {
        /**
         * The number of records in this ResultSet. Note that total may differ from this number.
         */
        count?: number;

        /**
         * True if the records have already been loaded. This is only meaningful when dealing with
         * SQL-backed proxies.
         */
        loaded?: boolean;

        /**
         * The message that was read in from the data
         */
        message?: string;

        /**
         * The metadata object from a server sourced JSON data packet.
         */
        metadata?: any;

        /**
         * (required)
         * The array of record instances or record config objects.
         */
        records?: Ext.data.Model|any;

        /**
         * True if the ResultSet loaded successfully, false if any errors were encountered.
         */
        success?: boolean;

        /**
         * The total number of records reported by the data source. This ResultSet may form a subset of
         * those records (see {@link #count}).
         */
        total?: number;
    }

    /**
     * Simple wrapper class that represents a set of records returned by a Proxy.
     */
    export class ResultSet extends Ext.Base implements Ext.data.ResultSetConfig {
        /**
         * Identifies this class as a result set.
         */
        isResultSet: boolean;

        /**
         * The number of records in this ResultSet. Note that total may differ from this number.
         */
        count: number;

        /**
         * True if the records have already been loaded. This is only meaningful when dealing with
         * SQL-backed proxies.
         */
        loaded: boolean;

        /**
         * The message that was read in from the data
         */
        message: string;

        /**
         * The metadata object from a server sourced JSON data packet.
         */
        metadata: any;

        /**
         * (required)
         * The array of record instances or record config objects.
         */
        records: Ext.data.Model|any;

        /**
         * True if the ResultSet loaded successfully, false if any errors were encountered.
         */
        success: boolean;

        /**
         * The total number of records reported by the data source. This ResultSet may form a subset of
         * those records (see {@link #count}).
         */
        total: number;

        /**
         * Creates the resultSet
         * @param {Object} [config] Config object.
         */
        constructor(config?: Ext.data.ResultSetConfig);

        getLoaded();

        getMessage();

        getMetadata();

        getRecords();

        getSuccess();

        getTotal();

        setCount();

        setLoaded();

        setMessage();

        setMetadata();

        setRecords();

        setSuccess();

        setTotal();
    }

    interface SessionConfig {
        /**
         * 'true' to automatically destroy this session when a component it is attached
         * to is destroyed. This should be set to false if the session is intended to be
         * used across multiple root level components.
         *
         * @since 5.0.1
         */
        autoDestroy?: boolean;

        /**
         * The parent session for this session.
         */
        parent?: Ext.data.Session;

        schema?: string|Ext.data.schema.Schema;
    }

    /**
     * This class manages models and their associations. Instances of 'Session' are typically
     * associated with some 'Component' (perhaps the Viewport or a Window) and then used by
     * their '{@link Ext.app.ViewModel view models}' to enable data binding.
     *
     * The primary job of a Session is to manage a collection of records of many different
     * types and their associations. This often starts by loading records when requested (via
     * bind - see below) and culminates when it is time to save to the server.
     *
     * Because the Session tracks all records it loads, it ensures that for any given type of
     * model, only one record exists with a given 'id'. This means that all edits of that
     * record are properly targeted at that one instance.
     *
     * Similarly, when associations are loaded, the 'Ext.data.Store' created to hold the
     * associated records is tracked by the Session. So all requests for the "OrderItems" of
     * a particular Order id will result in the same Store. Adding and removing items from
     * that Order then is sure to remain consistent.
     *
     * # Data
     *
     * Since the Session is managing all this data, there are several methods it provides
     * to give convenient access to that data. The most important of these is 'update' and
     * 'getChanges'.
     *
     * The 'update' and 'getChanges' methods both operate on object that contains a summary
     * of records and associations and different CRUD operations.
     *
     * ## Saving
     *
     * There are two basic ways to save the contents of a Session: 'getChanges' and
     * 'getSaveBatch'. We've already seen 'getChanges'. The data contained in the CRUD object
     * can be translated into whatever shape is needed by the server.
     *
     * To leverage the '{@link Ext.data.Model#proxy proxy}' facilities defined by each Model
     * class, there is the 'getSaveBatch' method. That method returns an 'Ext.data.Batch'
     * object populated with the necessary 'create', 'update' and 'destory' operations to
     * save all of the changes in the Session.
     *
     * @since 5.0.0
     */
    export class Session extends Ext.Base implements Ext.data.SessionConfig {
        protected destroyed: boolean;

        /**
         * 'true' to automatically destroy this session when a component it is attached
         * to is destroyed. This should be set to false if the session is intended to be
         * used across multiple root level components.
         *
         * @since 5.0.1
         */
        autoDestroy: boolean;

        /**
         * The parent session for this session.
         */
        parent: Ext.data.Session;

        schema: string|Ext.data.schema.Schema;

        /**
         * Adds an existing record instance to the session. The record
         * may not belong to another session. The record cannot be a phantom record, instead
         * use {@link #createRecord}.
         * @param {Ext.data.Model} record The record to adopt.
         */
        adopt(record: Ext.data.Model);

        /**
         * Marks the session as "clean" by calling {@link Ext.data.Model#commit} on each record
         * that is known to the session.
         *
         * - Phantom records will no longer be phantom.
         * - Modified records will no longer be dirty.
         * - Dropped records will be erased.
         *
         * @since 5.1.0
         */
        commit();

        constructor(config: Ext.data.SessionConfig);

        /**
         * Creates a new record and tracks it in this session.
         *
         * @param {String/Ext.Class} type The 'entityName' or the actual class of record to create.
         * @param {Object} [data] The data for the record.
         * @return {Ext.data.Model} The new record.
         */
        createRecord(type: string|Ext.Class, data?: any): Ext.data.Model;

        destroy();

        getAutoDestroy();

        /**
         * Returns an object describing all of the modified fields, created or dropped records
         * and many-to-many association changes maintained by this session.
         *
         * @return {Object} An object in the CRUD format (see the intro docs). 'null' if there are no changes.
         */
        getChanges(): any;

        /**
         * The same functionality as {@link #getChanges}, however we also take into account our
         * parent session.
         *
         * @return {Object} An object in the CRUD format (see the intro docs). 'null' if there are no changes.
         */
        protected getChangesForParent(): any;

        getCrudProperties();

        /**
         * Transforms a list of ids into a list of records for a particular type.
         * @param {Ext.Class} entityType The entity type.
         * @param {Object[]} ids The ids to transform.
         * @return {Ext.data.Model[]} The models corresponding to the ids.
         */
        getEntityList(entityType: Ext.Class, ids: any): Ext.data.Model;

        /**
         * Gets a user friendly identifier for a Model.
         * @param {Ext.Class} entityType The entity type.
         * @param {Object} id The id of the entity.
         * @return {String} The identifier.
         */
        getModelIdentifier(entityType: Ext.Class, id: any): string;

        getParent();

        /**
         * Get a cached record from the session. If the record does not exist, it will
         * be created. If the 'autoLoad' parameter is not set to 'false', the record will
         * be loaded via the {@link Ext.data.Model#proxy proxy} of the Model.
         *
         * If this session is configured with a '{@link #parent}' session, a *copy* of any existing record
         * in the 'parent' will be adopted into this session. If the 'parent' does not contain the record,
         * the record will be created and *not* inserted into the parent.
         *
         * See also {@link #peekRecord}.
         *
         * @param {String/Ext.Class/Ext.data.Model} type The 'entityName' or the actual class of record to create.
         * This may also be a record instance, where the type and id will be inferred from the record. If the record is
         * not attached to a session, it will be adopted. If it exists in a parent, an appropriate copy will be made as
         * described.
         * @param {Object} id The id of the record.
         * @param {Boolean/Object} [autoLoad=true] 'false' to prevent the record from being loaded if
         * it does not exist. If this parameter is an object, it will be passed to the {@link Ext.data.Model#load} call.
         * @return {Ext.data.Model} The record.
         */
        getRecord(type: string|Ext.Class|Ext.data.Model, id: any, autoLoad?: boolean|any): Ext.data.Model;

        /**
         * Returns an 'Ext.data.Batch' containing the 'Ext.data.operation.Operation' instances
         * that are needed to save all of the changes in this session. This sorting is based
         * on operation type, associations and foreign keys. Generally speaking the operations
         * in the batch can be committed to a server sequentially and the server will never be
         * sent a request with an invalid (client-generated) id in a foreign key field.
         *
         * @param {Boolean} [sort=true] Pass 'false' to disable the batch operation sort.
         * @return {Ext.data.Batch}
         */
        getSaveBatch(sort?: boolean): Ext.data.Batch;

        getSchema();

        /**
         * Triggered when an associated item from {@link #update} references a record
         * that does not exist in the session.
         * @param {Ext.Class} entityType The entity type.
         * @param {Object} id The id of the model.
         */
        protected onInvalidAssociationEntity(entityType: Ext.Class, id: any);

        /**
         * Triggered when an drop block from {@link #update} tries to create a record
         * that already exists.
         * @param {Ext.Class} entityType The entity type.
         * @param {Object} id The id of the model.
         */
        protected onInvalidEntityCreate(entityType: Ext.Class, id: any);

        /**
         * Triggered when an drop block from {@link #update} references a record
         * that does not exist in the session.
         * @param {Ext.Class} entityType The entity type.
         * @param {Object} id The id of the model.
         */
        protected onInvalidEntityDrop(entityType: Ext.Class, id: any);

        /**
         * Triggered when an drop block from {@link #update} tries to create a record
         * that already exists.
         * @param {Ext.Class} entityType The entity type.
         * @param {Object} id The id of the model.
         */
        protected onInvalidEntityRead(entityType: Ext.Class, id: any);

        /**
         * Triggered when an update block from {@link #update} references a record
         * that does not exist in the session.
         * @param {Ext.Class} entityType The entity type.
         * @param {Object} id The id of the model.
         * @param {Boolean} dropped 'true' if the record was dropped.
         */
        protected onInvalidEntityUpdate(entityType: Ext.Class, id: any, dropped: boolean);

        /**
         * Gets an existing record from the session. The record will *not* be created if it does
         * not exist.
         *
         * See also: {@link #getRecord}.
         *
         * @param {String/Ext.Class} type The 'entityName' or the actual class of record to create.
         * @param {Object} id The id of the record.
         * @param {Boolean} [deep=false] 'true' to consult
         * @return {Ext.data.Model} The record, 'null' if it does not exist.
         */
        peekRecord(type: string|Ext.Class, id: any, deep?: boolean): Ext.data.Model;

        /**
         * Save any changes in this session to a {@link #parent} session.
         */
        save();

        setAutoDestroy();

        setCrudProperties();

        setParent();

        setSchema();

        /**
         * Create a child session with this session as the {@link #parent}.
         * @return {Ext.data.Session} The copied session.
         */
        spawn(): Ext.data.Session;

        /**
         * Complete a bulk update for this session.
         * @param {Object} data Data in the CRUD format (see the intro docs).
         */
        update(data: any);

        /**
         * Walks the internal data tracked by this session and calls methods on the provided
         * 'visitor' object. The visitor can then accumulate whatever data it finds important.
         * The visitor object can provide a number of methods, but all are optional.
         *
         * This method does not enumerate associations since these can be traversed given the
         * records that are enumerated. For many-to-many associations, however, this method
         * does enumerate the changes because these changes are not "owned" by either side of
         * such associations.
         *
         * @param {Function} [visitor.onCleanRecord] This method is called to describe a record
         * that is known but unchanged.
         * @param {Ext.data.Model} visitor.onCleanRecord.record The unmodified record.
         * @param {Function} [visitor.onDirtyRecord] This method is called to describe a record
         * that has either been created, dropped or modified.
         * @param {Ext.data.Model} visitor.onDirtyRecord.record The modified record.
         * @param {Function} [visitor.onMatrixChange] This method is called to describe a
         * change in a many-to-many association (a "matrix").
         * @param {Ext.data.schema.Association} visitor.onMatrixChange.association The object
         * describing the many-to-many ("matrix") association.
         * @param {Mixed} visitor.onMatrixChange.leftId The 'idProperty' of the record on the
         * "left" of the association.
         * @param {Mixed} visitor.onMatrixChange.rightId The 'idProperty' of the record on the
         * "right" of the association.
         * @param {Number} visitor.onMatrixChange.state A negative number if the two records
         * are being disassociated or a positive number if they are being associated. For
         * example, when adding User 10 to Group 20, this would be 1. When removing the User
         * this argument would be -1.
         * @return {Object} The visitor instance
         */
        visitData(visitor: any, visitor_onCleanRecord?: Function, visitor_onCleanRecord_record?: Ext.data.Model, visitor_onDirtyRecord?: Function, visitor_onDirtyRecord_record?: Ext.data.Model, visitor_onMatrixChange?: Function, visitor_onMatrixChange_association?: Ext.data.schema.Association, visitor_onMatrixChange_leftId?: any, visitor_onMatrixChange_rightId?: any, visitor_onMatrixChange_state?: number): any;
    }

    /**
     * This class defines a series of static methods that are used on a
     * {@link Ext.data.Field} for performing sorting. The methods cast the
     * underlying values into a data type that is appropriate for sorting on
     * that particular field.  If a {@link Ext.data.Field#type} is specified,
     * the sortType will be set to a sane default if the sortType is not
     * explicitly defined on the field. The sortType will make any necessary
     * modifications to the value and return it.
     *
     *  - **'asText'** - Removes any tags and converts the value to a string
     *  - **'asUCText'** - Removes any tags and converts the value to an uppercase string
     *  - **'asUCText'** - Converts the value to an uppercase string
     *  - **'asDate'** - Converts the value into Unix epoch time
     *  - **'asFloat'** - Converts the value to a floating point number
     *  - **'asInt'** - Converts the value to an integer number
     *
     * It is also possible to create a custom sortType that can be used throughout
     * an application.
     *
     *      Ext.apply(Ext.data.SortTypes, {
     *          asPerson: function(person){
     *              // expects an object with a first and last name property
     *              return person.lastName.toUpperCase() + person.firstName.toLowerCase();
     *          }
     *      });
     *
     *      Ext.define('Employee', {
     *          extend: 'Ext.data.Model',
     *          fields: [{
     *              name: 'person',
     *              sortType: 'asPerson'
     *          }, {
     *              name: 'salary',
     *              type: 'float' // sortType set to asFloat
     *          }]
     *      });
     */
    export class SortTypes {
        /**
         * The regular expression used to strip commas
         */
        static stripCommasRe: any;

        /**
         * The regular expression used to strip tags
         */
        static stripTagsRE: any;

        /**
         * Date sorting
         * @param {Object} s The value being converted
         * @return {Number} The comparison value
         */
        static asDate(s: any): number;

        /**
         * Float sorting
         * @param {Object} s The value being converted
         * @return {Number} The comparison value
         */
        static asFloat(s: any): number;

        /**
         * Integer sorting
         * @param {Object} s The value being converted
         * @return {Number} The comparison value
         */
        static asInt(s: any): number;

        /**
         * Strips all HTML tags to sort on text only
         * @param {Object} s The value being converted
         * @return {String} The comparison value
         */
        static asText(s: any): string;

        /**
         * Case insensitive string
         * @param {Object} s The value being converted
         * @return {String} The comparison value
         */
        static asUCString(s: any): string;

        /**
         * Strips all HTML tags to sort on text only - Case insensitive
         * @param {Object} s The value being converted
         * @return {String} The comparison value
         */
        static asUCText(s: any): string;

        /**
         * Default sort that does nothing
         * @param {Object} s The value being converted
         * @return {Object} The comparison value
         */
        static none(s: any): any;
    }

    interface StoreConfig extends Ext.data.ProxyStoreConfig {
        /**
         * True to empty the store when loading another page via {@link #loadPage},
         * {@link #nextPage} or {@link #previousPage}. Setting to false keeps existing records, allowing
         * large data sets to be loaded one page at a time but rendered all together.
         *
         * Optional, Defaults to: true
         */
        clearOnPageLoad?: boolean;

        /**
         * 'true' to clear anything in the {@link #removed} record collection when the store loads.
         *
         * Optional, Defaults to: true
         */
        clearRemovedOnLoad?: boolean;

        /**
         * Array of Model instances or data objects to load locally. See "Inline data"
         * above for details.
         */
        data?: any|Ext.data.Model;

        /**
         * The session for this store. By specifying a session, it ensures any records that are
         * added to this store are also included in the session. This store does not become a member
         * of the session itself.
         *
         * @since  5.0.0
         */
        session?: Ext.data.Session;
    }

    /**
     * The Store class encapsulates a client side cache of {@link Ext.data.Model Model} objects. Stores load data via a
     * {@link Ext.data.proxy.Proxy Proxy}, and also provide functions for {@link #method-sort sorting}, {@link #filter filtering}
     * and querying the {@link Ext.data.Model model} instances contained within it.
     *
     * Creating a Store is easy - we just tell it the Model and the Proxy to use for loading and saving its data:
     *
     *      // Set up a model to use in our Store
     *      Ext.define('User', {
     *          extend: 'Ext.data.Model',
     *          fields: [
     *              {name: 'firstName', type: 'string'},
     *              {name: 'lastName',  type: 'string'},
     *              {name: 'age',       type: 'int'},
     *              {name: 'eyeColor',  type: 'string'}
     *          ]
     *      });
     *
     *      var myStore = Ext.create('Ext.data.Store', {
     *          model: 'User',
     *          proxy: {
     *              type: 'ajax',
     *              url: '/users.json',
     *              reader: {
     *                  type: 'json',
     *                  rootProperty: 'users'
     *              }
     *          },
     *          autoLoad: true
     *      });
     *
     * In the example above we configured an AJAX proxy to load data from the url '/users.json'. We told our Proxy to use a
     * {@link Ext.data.reader.Json JsonReader} to parse the response from the server into Model object - {@link
     * Ext.data.reader.Json see the docs on JsonReader} for details.
     *
     * ## Inline data
     *
     * Stores can also load data inline. Internally, Store converts each of the objects we pass in as {@link #cfg-data} into
     * Model instances:
     *
     *      Ext.create('Ext.data.Store', {
     *          model: 'User',
     *          data : [
     *              {firstName: 'Peter',   lastName: 'Venkman'},
     *              {firstName: 'Egon',    lastName: 'Spengler'},
     *              {firstName: 'Ray',     lastName: 'Stantz'},
     *              {firstName: 'Winston', lastName: 'Zeddemore'}
     *          ]
     *      });
     *
     * Loading inline data using the method above is great if the data is in the correct format already (e.g. it doesn't
     * need to be processed by a {@link Ext.data.reader.Reader reader}). If your inline data requires processing to decode
     * the data structure, use a {@link Ext.data.proxy.Memory MemoryProxy} instead (see the {@link Ext.data.proxy.Memory
     * MemoryProxy} docs for an example).
     *
     * Additional data can also be loaded locally using {@link #method-add}.
     *
     * ## Dynamic Loading
     *
     * Stores can be dynamically updated by calling the {@link #method-load} method:
     *
     *     store.load({
     *         params: {
     *             group: 3,
     *             type: 'user'
     *         },
     *         callback: function(records, operation, success) {
     *             // do something after the load finishes
     *         },
     *         scope: this
     *     });
     *
     * Here a bunch of arbitrary parameters is passed along with the load request and a callback function is set
     * up to do something after the loading is over.
     *
     * ## Loading Nested Data
     *
     * Applications often need to load sets of associated data - for example a CRM system might load a User and her Orders.
     * Instead of issuing an AJAX request for the User and a series of additional AJAX requests for each Order, we can load
     * a nested dataset and allow the Reader to automatically populate the associated models. Below is a brief example, see
     * the {@link Ext.data.reader.Reader} intro docs for a full explanation:
     *
     *      var store = Ext.create('Ext.data.Store', {
     *          autoLoad: true,
     *          model: "User",
     *          proxy: {
     *              type: 'ajax',
     *              url: 'users.json',
     *              reader: {
     *                  type: 'json',
     *                  rootProperty: 'users'
     *              }
     *          }
     *      });
     *
     * Which would consume a response like this:
     *
     *      {
     *          "users": [{
     *              "id": 1,
     *              "name": "Peter",
     *              "orders": [{
     *                  "id": 10,
     *                  "total": 10.76,
     *                  "status": "invoiced"
     *             },{
     *                  "id": 11,
     *                  "total": 13.45,
     *                  "status": "shipped"
     *             }]
     *          }]
     *      }
     *
     * See the {@link Ext.data.reader.Reader} intro docs for a full explanation.
     *
     * ## Filtering and Sorting
     *
     * Stores can be sorted and filtered - in both cases either remotely or locally. The {@link #cfg-sorters} and
     * {@link #cfg-filters} are held inside {@link Ext.util.Collection Collection} instances to make them easy to manage.
     * Usually it is sufficient to either just specify sorters and filters in the Store configuration or call {@link #method-sort}
     * or {@link #filter}:
     *
     *      var store = Ext.create('Ext.data.Store', {
     *          model: 'User',
     *          sorters: [{
     *              property: 'age',
     *              direction: 'DESC'
     *          }, {
     *              property: 'firstName',
     *              direction: 'ASC'
     *          }],
     *
     *          filters: [{
     *              property: 'firstName',
     *              value: /Peter/
     *          }]
     *      });
     *
     * The new Store will keep the configured sorters and filters in the Collection instances mentioned above. By
     * default, sorting and filtering are both performed locally by the Store - see {@link #remoteSort} and
     * {@link #remoteFilter} to allow the server to perform these operations instead.
     *
     * Filtering and sorting after the Store has been instantiated is also easy. Calling {@link #filter} adds another filter
     * to the Store and automatically filters the dataset (calling {@link #filter} with no arguments simply re-applies all
     * existing filters).
     *
     *     store.filter('eyeColor', 'Brown');
     *
     * Change the sorting at any time by calling {@link #method-sort}:
     *
     *     store.sort('height', 'ASC');
     *
     * Note that all existing sorters will be removed in favor of the new sorter data (if {@link #method-sort} is called with no
     * arguments, the existing sorters are just reapplied instead of being removed). To keep existing sorters and add new
     * ones, just add them to the Collection:
     *
     *     store.sorters.add(new Ext.util.Sorter({
     *         property : 'shoeSize',
     *         direction: 'ASC'
     *     }));
     *
     *     store.sort();
     *
     * ## Registering with StoreManager
     *
     * Any Store that is instantiated with a {@link #storeId} will automatically be registered with the {@link
     * Ext.data.StoreManager StoreManager}. This makes it easy to reuse the same store in multiple views:
     *
     *     //this store can be used several times
     *     Ext.create('Ext.data.Store', {
     *         model: 'User',
     *         storeId: 'usersStore'
     *     });
     *
     *     new Ext.List({
     *         store: 'usersStore',
     *         //other config goes here
     *     });
     *
     *     new Ext.view.View({
     *         store: 'usersStore',
     *         //other config goes here
     *     });
     *
     * ## Further Reading
     *
     * Stores are backed up by an ecosystem of classes that enables their operation. To gain a full understanding of these
     * pieces and how they fit together, see:
     *
     *   - {@link Ext.data.proxy.Proxy Proxy} - overview of what Proxies are and how they are used
     *   - {@link Ext.data.Model Model} - the core class in the data package
     *   - {@link Ext.data.reader.Reader Reader} - used by any subclass of {@link Ext.data.proxy.Server ServerProxy} to read a response
     */
    export class Store extends Ext.data.ProxyStore implements Ext.data.StoreConfig {
        /**
         * The number of times records have been loaded into the store. This includes loads via
         * {@link #loadData} & {@link #loadRecords}.
         * @readonly
         */
        loadCount: number;

        /**
         * True to empty the store when loading another page via {@link #loadPage},
         * {@link #nextPage} or {@link #previousPage}. Setting to false keeps existing records, allowing
         * large data sets to be loaded one page at a time but rendered all together.
         *
         * Optional, Defaults to: true
         */
        clearOnPageLoad: boolean;

        /**
         * 'true' to clear anything in the {@link #removed} record collection when the store loads.
         *
         * Optional, Defaults to: true
         */
        clearRemovedOnLoad: boolean;

        /**
         * Array of Model instances or data objects to load locally. See "Inline data"
         * above for details.
         */
        data: any|Ext.data.Model;

        /**
         * The session for this store. By specifying a session, it ensures any records that are
         * added to this store are also included in the session. This store does not become a member
         * of the session itself.
         *
         * @since  5.0.0
         */
        session: Ext.data.Session;

        /**
         * (Local sort only) Inserts the passed Record into the Store at the index where it
         * should go based on the current sort information.
         */
        addSorted(record: Ext.data.Model);

        aggregate();

        average();

        collect();

        /**
         * Commits all Records with {@link #getModifiedRecords outstanding changes}. To handle updates for changes,
         * subscribe to the Store's {@link #event-update update event}, and perform updating when the third parameter is
         * Ext.data.Record.COMMIT.
         */
        commitChanges();

        /**
         * Creates the store.
         * @param {Object} [config] Config object.
         */
        constructor(config?: Ext.data.ArrayStoreConfig);

        count();

        each();

        first();

        getByInternalId();

        getClearOnPageLoad();

        getClearRemovedOnLoad();

        /**
         * Returns the store's records.
         *
         * **Note:** If your store has been filtered, getData() will return a filtered
         * collection.  Use 'getData().{@link Ext.util.Collection#getSource getSource()}' to
         * fetch all unfiltered records.
         *
         * @return {Ext.util.Collection} An Ext.util.Collection of records
         * (an empty Collection if no records are held by the store).
         */
        getData(): Ext.util.Collection;

        getSession();

        indexOf();

        indexOfId();

        insert();

        last();

        /**
         * Loads an array of data straight into the Store.
         *
         * Using this method is great if the data is in the correct format already (e.g. it doesn't need to be
         * processed by a reader). If your data requires processing to decode the data structure, use a
         * {@link Ext.data.proxy.Memory MemoryProxy} or {@link #loadRawData}.
         *
         * @param {Ext.data.Model[]/Object[]} data Array of data to load. Any non-model instances will be cast
         * into model instances first.
         * @param {Boolean} [append=false] 'true' to add the records to the existing records in the store, 'false'
         * to remove the old ones first.
         */
        loadData(data: Ext.data.Model|any, append?: boolean);

        /**
         * Loads a given 'page' of data by setting the start and limit values appropriately. Internally this just causes a normal
         * load operation, passing in calculated 'start' and 'limit' params.
         * @param {Number} page The number of the page to load.
         * @param {Object} [options] See options for {@link #method-load}.
         */
        loadPage(page: number, options?: any);

        /**
         * Loads data via the bound Proxy's reader
         *
         * Use this method if you are attempting to load data and want to utilize the configured data reader.
         *
         * As of 4.2, this method will no longer fire the {@link #event-load} event.
         *
         * @param {Object[]} data The full JSON object you'd like to load into the Data store.
         * @param {Boolean} [append=false] 'true' to add the records to the existing records in the store, 'false'
         * to remove the old ones first.
         *
         * @return {Boolean} 'true' if the reader processed the records correctly. See {@link Ext.data.reader.Reader#successProperty}.
         * If the reader did not process the records, nothing will be added.
         */
        loadRawData(data: any, append?: boolean): boolean;

        /**
         * Loads an array of {@link Ext.data.Model model} instances into the store, fires the datachanged event. This should only usually
         * be called internally when loading from the {@link Ext.data.proxy.Proxy Proxy}, when adding records manually use {@link #method-add} instead
         * @param {Ext.data.Model[]} records The array of records to load
         * @param {Boolean} [options.addRecords=false] Pass 'true' to add these records to the existing records, 'false' to remove the Store's existing records first.
         */
        loadRecords(records: Ext.data.Model, options: any, options_addRecords?: boolean);

        max();

        min();

        /**
         * Loads the next 'page' in the current data set
         * @param {Object} options See options for {@link #method-load}
         */
        nextPage(options: any);

        /**
         * Called internally when a Proxy has completed a load request
         */
        protected onProxyLoad();

        /**
         * Loads the previous 'page' in the current data set
         * @param {Object} options See options for {@link #method-load}
         */
        previousPage(options: any);

        query();

        queryBy();

        /**
         * {@link Ext.data.Model#reject Rejects} outstanding changes on all {@link #getModifiedRecords modified records}
         * and re-insert any records that were removed locally. Any phantom records will be removed.
         */
        rejectChanges();

        /**
         * Removes the model instance(s) at the given index
         * @param {Number} index The record index
         * @param {Number} [count=1] The number of records to delete
         */
        removeAt(index: number, count?: number);

        setClearOnPageLoad();

        setClearRemovedOnLoad();

        /**
         * Loads an array of data directly into the Store.
         *
         * setData() is ideal if your data's format is already in its appropriate format (e.g. it doesn't need to be
         * processed by a reader). If your data's structure requires processing, use a
         * {@link Ext.data.proxy.Memory MemoryProxy} or {@link #loadRawData}.
         *
         * Use {@link #loadData}, {@link #method-add}, or {@link #insert} if records need to be
         * appended to the current recordset.
         *
         * @param {Ext.data.Model[]/Object[]} data Array of data to load. Any non-model instances will be cast
         * into model instances first.
         */
        setData(data: Ext.data.Model|any);

        setSession();

        sum();

        /**
         * Fires before a prefetch occurs. Return 'false' to cancel.
         * @param {Ext.data.operation.Operation} operation The associated operation.
         */
        beforeprefetch(that: Ext.data.Store, operation: Ext.data.operation.Operation);

        /**
         * Fired whenever the filter set changes.
         * @param {Ext.data.Store} store The store.
         * @param {Ext.util.Filter[]} filters The array of Filter objects.
         */
        filterchange(store: Ext.data.Store, filters: Ext.util.Filter);

        /**
         * Fired whenever the grouping in the grid changes.
         * @param {Ext.data.Store} store The store.
         * @param {Ext.util.Grouper} grouper The grouper object.
         */
        groupchange(store: Ext.data.Store, grouper: Ext.util.Grouper);

        /**
         * Fires whenever records have been prefetched.
         * @param {Ext.data.Model[]} records An array of records.
         * @param {Boolean} successful 'true' if the operation was successful.
         * @param {Ext.data.operation.Operation} operation The associated operation.
         */
        prefetch(that: Ext.data.Store, records: Ext.data.Model, successful: boolean, operation: Ext.data.operation.Operation);
    }

    /**
     * Contains a collection of all stores that are created that have an identifier. An identifier can be assigned by
     * setting the {@link Ext.data.AbstractStore#storeId storeId} property. When a store is in the StoreManager, it can be
     * referred to via it's identifier:
     *
     *     Ext.create('Ext.data.Store', {
     *         model: 'SomeModel',
     *         storeId: 'myStore'
     *     });
     *
     *     var store = Ext.data.StoreManager.lookup('myStore');
     *
     * Also note that the {@link #lookup} method is aliased to {@link Ext#getStore} for convenience.
     *
     * If a store is registered with the StoreManager, you can also refer to the store by it's identifier when registering
     * it with any Component that consumes data from a store:
     *
     *     Ext.create('Ext.data.Store', {
     *         model: 'SomeModel',
     *         storeId: 'myStore'
     *     });
     *
     *     Ext.create('Ext.view.View', {
     *         store: 'myStore',
     *         // other configuration here
     *     });
     */
    export class StoreManager {
        /**
         * Creates new MixedCollection.
         * @param {Object} config A configuration object.
         *  @param {Boolean} [config.allowFunctions=false] Specify 'true' if the {@link #addAll}
         * function should add function references to the collection.
         *  @param {Function} [config.getKey] A function that can accept an item of the type(s) stored in this MixedCollection
         * and return the key value for that item.  This is used when available to look up the key on items that
         * were passed without an explicit key parameter to a MixedCollection method.  Passing this parameter is
         * equivalent to overriding the {@link #method-getKey} method.
         */
        constructor(config: Ext.util.MixedCollectionConfig);

        /**
         * Gets a registered Store by id
         * @param {String/Object} store The id of the Store, or a Store instance, or a store configuration
         * @param {String} [defaultType] The store type to create when used with store configuration and there
         * is no type specified on the config.
         * @return {Ext.data.Store}
         */
        static lookup(store: string|any, defaultType?: string): Ext.data.Store;

        /**
         * Registers one or more Stores with the StoreManager. You do not normally need to register stores manually. Any
         * store initialized with a {@link Ext.data.Store#storeId} will be auto-registered.
         * @param {Ext.data.Store...} stores Any number of Store instances
         */
        static register(stores: Ext.data.Store);

        /**
         * Unregisters one or more Stores with the StoreManager
         * @param {String/Object...} stores Any number of Store instances or ID-s
         */
        static unregister(stores: string[]|any[]);
    }

    interface TreeModelConfig extends Ext.data.ModelConfig {
        /**
         * The class name of child nodes to create when reading child nodes from
         * raw data. By default the type configured into the TreeStore is used.
         *
         * This is one way of creating heterogeneous nodes in a tree.
         *
         * To do this through data types passed from the server, use the {@link Ext.data.reader.Reader#typeProperty}.
         *
         * for example in the case of a hidden root node, you'd use the default type at level zero. See {@link Ext.tree.Panel TreePanel}'s
         * documentation for an example.
         *
         * *Important*
         * If you are using this declaration on your tree models, and have a {@link Ext.tree.Panel#rootVisible hidden root node}, you
         * MUST create a special root model definition which declares the type of its children.
         *
         * If you allow the TreeStore to create a root node of the same type as the first level of *visible* nodes
         * then the reader will atempt to read the wrong type of child node for the root.
         *
         * Example:
         *
         *    Ext.define('myApp.World', {
         *        childType: 'Territory'
         *    });
         *
         *    ...
         *
         *    store: {
         *        id: 'myTreeStore',
         *        model: 'myApp.World' // The hidden root will know to create 'Territory' type children.
         *    }
         *
         * If the root is hidden, and the first level of visible nodes are going to be the 'myApp.Territory' class,
         * then the hidden root must not be of the 'myApp.Territory' class. Otherwise, it would try to read in the
         * territory data as its childType - most likely 'Country'.
         *
         * Optional
         */
        childType?: string;
    }

    /**
     * This class is used as a base class from which to derive Models used in Trees.
     */
    export class TreeModel extends Ext.data.Model implements Ext.data.TreeModelConfig {
        /**
         * The class name of child nodes to create when reading child nodes from
         * raw data. By default the type configured into the TreeStore is used.
         *
         * This is one way of creating heterogeneous nodes in a tree.
         *
         * To do this through data types passed from the server, use the {@link Ext.data.reader.Reader#typeProperty}.
         *
         * for example in the case of a hidden root node, you'd use the default type at level zero. See {@link Ext.tree.Panel TreePanel}'s
         * documentation for an example.
         *
         * *Important*
         * If you are using this declaration on your tree models, and have a {@link Ext.tree.Panel#rootVisible hidden root node}, you
         * MUST create a special root model definition which declares the type of its children.
         *
         * If you allow the TreeStore to create a root node of the same type as the first level of *visible* nodes
         * then the reader will atempt to read the wrong type of child node for the root.
         *
         * Example:
         *
         *    Ext.define('myApp.World', {
         *        childType: 'Territory'
         *    });
         *
         *    ...
         *
         *    store: {
         *        id: 'myTreeStore',
         *        model: 'myApp.World' // The hidden root will know to create 'Territory' type children.
         *    }
         *
         * If the root is hidden, and the first level of visible nodes are going to be the 'myApp.Territory' class,
         * then the hidden root must not be of the 'myApp.Territory' class. Otherwise, it would try to read in the
         * territory data as its childType - most likely 'Country'.
         *
         * Optional
         */
        childType: string;

        constructor(data: any, session: any);
    }

    interface TreeStoreConfig extends Ext.data.StoreConfig {
        /**
         * Remove previously existing child nodes before loading.
         *
         * Optional, Defaults to: true
         */
        clearOnLoad?: boolean;

        /**
         * If 'true', when a node is reloaded, any records in the {@link #removed} record collection that were previously descendants of the node being reloaded will be cleared from the {@link #removed} collection.
         * Only applicable if {@link #clearOnLoad} is 'true'.
         *
         * Optional, Defaults to: true
         */
        clearRemovedOnLoad?: boolean;

        /**
         * The default root id.
         *
         * Optional, Defaults to: "root"
         */
        defaultRootId?: string;

        /**
         * Optional, Defaults to: "children"
         */
        defaultRootProperty?: string;

        /**
         * The default root text (if not specified)
         *
         * Optional, Defaults to: "Root"
         */
        defaultRootText?: string;

        /**
         * {@link Ext.panel.Table#cfg-columns columns} configuration, it is possible to
         * define the set of fields you wish to use in the Store instead of configuring the
         * store with a {@link #cfg-model}.
         *
         * By default, the Store uses an {@link Ext.data.TreeModel}. If you configure
         * fields, it uses a subclass of {@link Ext.data.TreeModel} defined with the set of
         * fields that you specify (in addition to the fields which it uses for storing
         * internal state).
         */
        fields?: any|string;

        /**
         * The order in which to prioritize how filters are applied to nodes.
         *
         * The default, ''topdown'' means that if a parent node does *not* pass the filter, then the branch
         * ends there, and no descendant nodes are filtered in, even if they would pass the filter.
         *
         * By specifying ''bottomup'', if a leaf node passes the filter, then all its ancestor nodes are filtered
         * in to allow it to be visible.
         *
         * Optional, Defaults to: topdown
         */
        filterer?: string;

        /**
         * Set to true to automatically prepend a leaf sorter.
         *
         * Optional, Defaults to: false
         */
        folderSort?: boolean;

        /**
         * Set to true to prevent child nodes from being loaded until the the node is
         * expanded or loaded explicitly.
         *
         * Optional, Defaults to: false
         */
        lazyFill?: boolean;

        /**
         * The name of the parameter sent to the server which contains the identifier of the node.
         *
         * Optional, Defaults to: "node"
         */
        nodeParam?: string;

        /**
         * This config allows node data to be returned from the server in linear format without having to structure it into 'children'
         * arrays.
         *
         * This property specifies which property name in the raw node data yields the id of the parent node.
         *
         * For example the following data would be read into a geographic tree by configuring the TreeStore with 'parentIdProperty: 'parentId''.
         * The node data contains an upward link to a parent node.
         *
         *     data: [{
         *         name: 'North America',
         *         id: 'NA'
         *     }, {
         *         name: 'Unites States',
         *         id: 'USA',
         *         parentId: 'NA'
         *     }, {
         *         name: 'Redwood City',
         *         leaf: true,
         *         parentId: 'USA'
         *     }, {
         *         name: 'Frederick, MD',
         *         leaf: true,
         *         parentId: 'USA'
         *     }]
         *
         * Optional
         */
        parentIdProperty?: string;

        /**
         * The root node for this store. For example:
         *
         *     root: {
         *         expanded: true,
         *         text: "My Root",
         *         children: [
         *             { text: "Child 1", leaf: true },
         *             { text: "Child 2", expanded: true, children: [
         *                 { text: "GrandChild", leaf: true }
         *             ] }
         *         ]
         *     }
         *
         * Setting the 'root' config option is the same as calling {@link #setRootNode}.
         *
         * It's important to note that setting expanded to true on the root node will cause
         * the tree store to attempt to load.  This will occur regardless the value of
         * {@link Ext.data.ProxyStore#autoLoad autoLoad}. If you you do not want the store
         * to load on instantiation, ensure expanded is false and load the store when you're ready.
         */
        root?: Ext.data.TreeModel|Ext.data.NodeInterface|any;

        /**
         * 'false' to not include the root node in this Stores collection.
         */
        rootVisible?: boolean;
    }

    /**
     * The TreeStore is a store implementation that owns the {@link #cfg-root root node} of
     * a tree, and provides methods to load either local or remote data as child nodes of the root
     * and any descendant non-leaf node.
     *
     * The TreeStore must be used as the store of a {@link Ext.tree.Panel tree panel}.
     *
     * This class also relays many node events from the underlying node structure.
     *
     * # Using Models
     *
     * If no Model is specified, an implicit model will be created that extends {@link Ext.data.TreeModel}.
     * The standard Tree fields will also be copied onto the Model for maintaining their state. These fields are listed
     * in the {@link Ext.data.NodeInterface} documentation.
     *
     * # Reading Nested Data
     *
     * For the tree to read nested data, the {@link Ext.data.reader.Reader} must be configured with a root property,
     * so the reader can find nested data for each node (if a root is not specified, it will default to
     * 'children'). This will tell the tree to look for any nested tree nodes by the same keyword, i.e., 'children'.
     * If a root is specified in the config make sure that any nested nodes with children have the same name.
     *
     * **Note:** Setting {@link #defaultRootProperty} accomplishes the same thing.
     *
     * #rootProperty as a Function
     * You can pass a function as the data reader's rootProperty when the tree's dataset has
     * mixed root properties. Child nodes can then be programmatically determined at read time.
     *
     * For example, the child nodes may be passed via the 'children' property
     * name, though you may have a top-level root property of 'items'.
     *
     * See {@link Ext.data.reader.Reader#rootProperty rootProperty} for more information.
     *
     * Filtering of nodes in a TreeStore is hierarchically top down by default. This means that if a non-leaf node does not
     * pass the filter, then it, and all its descendants are filtered *out* of the store.
     *
     * To reverse this, so that any node which passes the filter causes all its ancestors to be visible, configure
     * the 'TreeStore' with '{@link #cfg-filterer filterer: 'bottomup'}'
     */
    export class TreeStore extends Ext.data.Store implements Ext.data.TreeStoreConfig {
        /**
         * 'true' in this class to identify an object as an instantiated TreeStore, or subclass thereof.
         */
        isTreeStore: boolean;

        /**
         * Remove previously existing child nodes before loading.
         *
         * Optional, Defaults to: true
         */
        clearOnLoad: boolean;

        /**
         * If 'true', when a node is reloaded, any records in the {@link #removed} record collection that were previously descendants of the node being reloaded will be cleared from the {@link #removed} collection.
         * Only applicable if {@link #clearOnLoad} is 'true'.
         *
         * Optional, Defaults to: true
         */
        clearRemovedOnLoad: boolean;

        /**
         * The default root id.
         *
         * Optional, Defaults to: "root"
         */
        defaultRootId: string;

        /**
         * Optional, Defaults to: "children"
         */
        defaultRootProperty: string;

        /**
         * The default root text (if not specified)
         *
         * Optional, Defaults to: "Root"
         */
        defaultRootText: string;

        /**
         * {@link Ext.panel.Table#cfg-columns columns} configuration, it is possible to
         * define the set of fields you wish to use in the Store instead of configuring the
         * store with a {@link #cfg-model}.
         *
         * By default, the Store uses an {@link Ext.data.TreeModel}. If you configure
         * fields, it uses a subclass of {@link Ext.data.TreeModel} defined with the set of
         * fields that you specify (in addition to the fields which it uses for storing
         * internal state).
         */
        fields: any|string;

        /**
         * The order in which to prioritize how filters are applied to nodes.
         *
         * The default, ''topdown'' means that if a parent node does *not* pass the filter, then the branch
         * ends there, and no descendant nodes are filtered in, even if they would pass the filter.
         *
         * By specifying ''bottomup'', if a leaf node passes the filter, then all its ancestor nodes are filtered
         * in to allow it to be visible.
         *
         * Optional, Defaults to: topdown
         */
        filterer: string;

        /**
         * Set to true to automatically prepend a leaf sorter.
         *
         * Optional, Defaults to: false
         */
        folderSort: boolean;

        /**
         * Set to true to prevent child nodes from being loaded until the the node is
         * expanded or loaded explicitly.
         *
         * Optional, Defaults to: false
         */
        lazyFill: boolean;

        /**
         * The name of the parameter sent to the server which contains the identifier of the node.
         *
         * Optional, Defaults to: "node"
         */
        nodeParam: string;

        /**
         * This config allows node data to be returned from the server in linear format without having to structure it into 'children'
         * arrays.
         *
         * This property specifies which property name in the raw node data yields the id of the parent node.
         *
         * For example the following data would be read into a geographic tree by configuring the TreeStore with 'parentIdProperty: 'parentId''.
         * The node data contains an upward link to a parent node.
         *
         *     data: [{
         *         name: 'North America',
         *         id: 'NA'
         *     }, {
         *         name: 'Unites States',
         *         id: 'USA',
         *         parentId: 'NA'
         *     }, {
         *         name: 'Redwood City',
         *         leaf: true,
         *         parentId: 'USA'
         *     }, {
         *         name: 'Frederick, MD',
         *         leaf: true,
         *         parentId: 'USA'
         *     }]
         *
         * Optional
         */
        parentIdProperty: string;

        /**
         * The root node for this store. For example:
         *
         *     root: {
         *         expanded: true,
         *         text: "My Root",
         *         children: [
         *             { text: "Child 1", leaf: true },
         *             { text: "Child 2", expanded: true, children: [
         *                 { text: "GrandChild", leaf: true }
         *             ] }
         *         ]
         *     }
         *
         * Setting the 'root' config option is the same as calling {@link #setRootNode}.
         *
         * It's important to note that setting expanded to true on the root node will cause
         * the tree store to attempt to load.  This will occur regardless the value of
         * {@link Ext.data.ProxyStore#autoLoad autoLoad}. If you you do not want the store
         * to load on instantiation, ensure expanded is false and load the store when you're ready.
         */
        root: Ext.data.TreeModel|Ext.data.NodeInterface|any;

        /**
         * 'false' to not include the root node in this Stores collection.
         */
        rootVisible: boolean;

        commitChanges();

        constructor(config: Ext.data.TreeStoreConfig);

        /**
         * Finds the first matching node in the tree by a specific field value regardless of visibility
         * due to collapsed states; all nodes present in the tree structure are searched.
         *
         * @param {String} fieldName The name of the Record field to test.
         * @param {String/RegExp} value Either a string that the field value
         * should begin with, or a RegExp to test against the field.
         * @param {Boolean} [anyMatch=true] False to match any part of the string, not just
         * the beginning.
         * @param {Boolean} [caseSensitive=false] True for case sensitive comparison
         * @param {Boolean} [exactMatch=false] True to force exact match (^ and $ characters
         * added to the regex). Ignored if 'anyMatch' is 'true'.
         * @return {Ext.data.NodeInterface} The matched node or null
         */
        findNode(fieldName: string, value: string|RegExp, anyMatch?: boolean, caseSensitive?: boolean, exactMatch?: boolean): Ext.data.NodeInterface;

        /**
         * Called when the event handler which called the {@link #method-load} method exits.
         */
        flushLoad();

        getClearOnLoad();

        getClearRemovedOnLoad();

        getDefaultRootId();

        getDefaultRootProperty();

        getDefaultRootText();

        getFolderSort();

        /**
         * Returns the record node by id regardless of visibility due to collapsed states;
         * all nodes present in the tree structure are available.
         * @param {String} id The id of the node to get.
         * @return {Ext.data.NodeInterface}
         */
        getNodeById(id: string): Ext.data.NodeInterface;

        getNodeParam();

        getParentIdProperty();

        getRoot();

        /**
         * Returns the root node for this tree.
         * @return {Ext.data.NodeInterface}
         * @deprecated 5.0 Use {@link #getRoot} instead
         */
        getRootNode(): Ext.data.NodeInterface;

        getRootVisible();

        isVisible();

        removeAll();

        setClearOnLoad();

        setClearRemovedOnLoad();

        setDefaultRootId();

        setDefaultRootProperty();

        setDefaultRootText();

        setFolderSort();

        setNodeParam();

        setParentIdProperty();

        setRoot();

        /**
         * Sets the root node for this store.  See also the {@link #root} config option.
         * @return {Ext.data.NodeInterface} The new root
         * @deprecated 5.0 Use {@link #setRoot} instead
         */
        setRootNode(root: Ext.data.TreeModel|Ext.data.NodeInterface|any): Ext.data.NodeInterface;

        setRootVisible();

        nodeappend();

        nodebeforeappend();

        nodebeforecollapse();

        nodebeforeexpand();

        nodebeforeinsert();

        nodebeforemove();

        nodebeforeremove();

        nodecollapse();

        nodeexpand();

        nodeinsert();

        nodemove();

        noderemove();

        nodesort();

        /**
         * Fires any time the tree's root node changes.
         * @param {Ext.data.TreeModel/Ext.data.NodeInterface} newRoot The new root
         * @param {Ext.data.TreeModel/Ext.data.NodeInterface} oldRoot The old root
         */
        rootchange(newRoot: Ext.data.TreeModel|Ext.data.NodeInterface, oldRoot: Ext.data.TreeModel|Ext.data.NodeInterface);
    }

    /**
     * @deprecated Please use {@link Ext.data.field.Field field types} instead.
     */
    export class Types {
        /**
         * This data type means that no conversion is applied to the raw data before it is placed into a Record.
         */
        static AUTO: any;

        /**
         * This data type means that the raw data is converted into a boolean before it is placed into
         * a Record. The string "true" and the number 1 are converted to boolean true.
         *
         * The synonym 'BOOLEAN' is equivalent.
         */
        static BOOL: any;

        /**
         * This data type means that the raw data is converted into a boolean before it is placed into
         * a Record. The string "true" and the number 1 are converted to boolean 'true'.
         *
         * The synonym 'BOOL' is equivalent.
         */
        static BOOLEAN: any;

        /**
         * This data type means that the raw data is converted into a Date before it is placed into a Record.
         * The date format is specified in the constructor of the {@link Ext.data.Field} to which this type is
         * being applied.
         */
        static DATE: any;

        /**
         * This data type means that the raw data is converted into a number before it is placed into a Record.
         *
         * The synonym 'NUMBER' is equivalent.
         */
        static FLOAT: any;

        /**
         * This data type means that the raw data is converted into an integer before it is placed into a Record.
         *
         * The synonym 'INTEGER' is equivalent.
         */
        static INT: any;

        /**
         * This data type means that the raw data is converted into an integer before it is placed into a Record.
         *
         * The synonym 'INT' is equivalent.
         */
        static INTEGER: any;

        /**
         * This data type means that the raw data is converted into a number before it is placed into a Record.
         *
         * The synonym 'FLOAT' is equivalent.
         */
        static NUMBER: any;

        /**
         * This data type means that the raw data is converted into a String before it is placed into a Record.
         */
        static STRING: any;

        /**
         * A regular expression for stripping non-numeric characters from a numeric value.
         * This should be overridden for localization.
         */
        static stripRe: RegExp;
    }

    /**
     * This class is used to hold validation errors for a record. The results of the record's
     * '{@link Ext.data.Model#validators validators}' are stored as the field values of this
     * record. The first failed validation is all that is stored per field unless the Model
     * class has defined a 'validationSeparator' config.
     *
     * Application code will not need to interact with this class specifically but rather just
     * view the validation as a record.
     * @since 5.0.0
     */
    export class Validation extends Ext.data.Model {
        /**
         * The associated record for this validation instance.
         * @readonly
         * @since 5.0.0
         */
        record: Ext.data.Model;

        constructor(data: any, session: any);

        /**
         * Returns true if the associated record (not this one) is valid.
         * @return {Boolean}
         */
        isValid(): boolean;
    }

    /**
     * <p>Small helper class to make creating {@link Ext.data.Store}s from XML data easier.
     * A XmlStore will be automatically configured with a {@link Ext.data.reader.Xml}.</p>
     * <p>A store configuration would be something like:<pre><code>
     var store = new Ext.data.XmlStore({
     // store configs
     storeId: 'myStore',
     url: 'sheldon.xml', // automatically configures a HttpProxy
     // reader configs
     record: 'Item', // records will have an "Item" tag
     idPath: 'ASIN',
     totalRecords: '@TotalResults'
     fields: [
     // set up the fields mapping into the xml doc
     // The first needs mapping, the others are very basic
     {name: 'Author', mapping: 'ItemAttributes > Author'},
     'Title', 'Manufacturer', 'ProductGroup'
     ]
     });
     * </code></pre></p>
     * <p>This store is configured to consume a returned object of the form:<pre><code>
     &#60?xml version="1.0" encoding="UTF-8"?>
     &#60ItemSearchResponse xmlns="http://webservices.amazon.com/AWSECommerceService/2009-05-15">
     &#60Items>
     &#60Request>
     &#60IsValid>True&#60/IsValid>
     &#60ItemSearchRequest>
     &#60Author>Sidney Sheldon&#60/Author>
     &#60SearchIndex>Books&#60/SearchIndex>
     &#60/ItemSearchRequest>
     &#60/Request>
     &#60TotalResults>203&#60/TotalResults>
     &#60TotalPages>21&#60/TotalPages>
     &#60Item>
     &#60ASIN>0446355453&#60/ASIN>
     &#60DetailPageURL>
     http://www.amazon.com/
     &#60/DetailPageURL>
     &#60ItemAttributes>
     &#60Author>Sidney Sheldon&#60/Author>
     &#60Manufacturer>Warner Books&#60/Manufacturer>
     &#60ProductGroup>Book&#60/ProductGroup>
     &#60Title>Master of the Game&#60/Title>
     &#60/ItemAttributes>
     &#60/Item>
     &#60/Items>
     &#60/ItemSearchResponse>
     * </code></pre>
     * An object literal of this form could also be used as the {@link #cfg-data} config option.</p>
     * <p><b>Note:</b> This class accepts all of the configuration options of
     * <b>{@link Ext.data.reader.Xml XmlReader}</b>.</p>
     */
    export class XmlStore extends Ext.data.Store {
        constructor(config: any);
    }
}

declare module Ext.data.amf {
    /**
     * This class serializes data in the Action Message Format (AMF) format.
     * It can write simple and complex objects, to be used in conjunction with an
     * AMF-compliant server.
     * To encode a byte array, first construct an Encoder, optionally setting the format:
     *
     *     var encoder = Ext.create('Ext.data.amf.Encoder', {
     *       format: 3
     *     });
     *
     * Then use the writer methods to out data to the :
     *
     *     encoder.writeObject(1);
     *
     * And access the data through the #bytes property:
     *     encoder.bytes;
     *
     * You can also reset the class to start a new byte array:
     *
     *     encoder.clear();
     *
     * Current limitations:
     * AMF3 format (format:3)
     * - writeObject will write out XML object, not legacy XMLDocument objects. A
     *   writeXmlDocument method is provided for explicitly writing XMLDocument
     *   objects.
     * - Each object is written out explicitly, not using the reference tables
     *   supported by the AMF format. This means the function does NOT support
     *   circular reference objects.
     * - Array objects: only the numbered indices and data will be written out.
     *   Associative values will be ignored.
     * - Objects that aren't Arrays, Dates, Strings, Document (XML) or primitive
     *   values will be written out as anonymous objects with dynamic data.
     * - There's no JavaScript equivalent to the ByteArray type in ActionScript,
     *   hence data will never be searialized as ByteArrays by the writeObject
     *   function. A writeByteArray method is provided for writing out ByteArray objects.
     *
     * AMF0 format (format:0)
     * - Each object is written out explicitly, not using the reference tables
     *   supported by the AMF format. This means the function does NOT support
     *   circular reference objects.
     * - Array objects: the function always writes an associative array (following
     *   the behavior of flex).
     * - Objects that aren't Arrays, Dates, Strings, Document (XML) or primitive
     *   values will be written out as anonymous objects.
     *
     * For more information on working with AMF data please refer to the
     * [AMF Guide](#/guide/amf).
     */
    export class Encoder extends Ext.Base {
        /**
         * @readonly
         * The constructed byte array.
         */
        bytes: any[];

        /**
         * Sets the functions that will correctly serialize for the relevant
         * protocol version.
         * @param {Number} protocol_version the protocol version to support
         */
        applyFormat(protocol_version: number);

        /**
         * Reset all class states and starts a new empty array for encoding data.
         * The method generates a new array for encoding, so it's safe to keep a
         * reference to the old one.
         */
        clear();

        /**
         * Creates new Encoder.
         * @param {Object} config Configuration options
         */
        constructor(config: any);

        /**
         * Convert a UTF 16 char to a UTF 8 char
         * @param {Number} c char 16-bit code to convert
         * @return {Array} byte array with the UTF 8 values
         */
        encodeUtf8Char(c: number): any[];

        /**
         * Encode 16- or 32-bit integers into big-endian (network order) bytes
         * @param {Number} value the number to encode.
         * @param {Number} byte_count 2 or 4 byte encoding
         * @return {Array} byte array with encoded number
         */
        encodeXInt(value: number, byte_count: number): any[];

        getFormat();

        /**
         * Tries to determine if an object is an XML document
         * @param {Object} item to identify
         * @return {Boolean} true if it's an XML document, false otherwise
         */
        isXmlDocument(item: any): boolean;

        setFormat();

        /**
         * Writes a key-value pair in AMF0 format.
         * @param {String} key the name of the property
         * @param {Object} value to write in AMF0 format
         */
        write0ObjectProperty(key: string, value: any);

        /**
         * Writes a short UTF8 string preceded with a 16-bit length.
         * @param {String} str the string to write
         */
        write0ShortUtf8String(str: string);

        /**
         * Writes a strict-array in AMF0 format. Unordered parts are ignored (e.g.
         * a["hello"] will not be encoded). This function is included for
         * completeness and will never be called by writeObject.
         * @param {Array} arr the array to serialize.
         */
        write0StrictArray(arr: any[]);

        /**
         * Write a byte array in AMF3 format. This function is never called directly
         * by writeObject since there's no way to distinguish a regular array from a
         * byte array.
         * @param {Array} arr the object to serialize.
         */
        write3ByteArray(arr: any[]);

        /**
         * Writes an Legacy XMLDocument (ActionScript Legacy XML object) in AMF3
         * format. Must be called explicitly.
         * The writeObject method will call writeXml and not writeXmlDocument.
         * @param {Object} xml XML document (type Document typically) to write
         */
        write3XmlDocument(xml: any);

        /**
         * Writes an AMF packet to the byte array
         * @param {Array} headers the headers to serialize. Each item in the array
         *                should be an object with three fields:
         *                name, mustUnderstand, value
         * @param {Array} messages the messages to serialize. Each item in the array
         *                should be an object with three fields:
         *                targetUri, responseUri, body
         */
        writeAmfPacket(headers: any[], messages: any[]);

        /**
         * Write the appropriate data items to the byte array. Supported types:
         * - undefined
         * - null
         * - boolean
         * - integer (if AMF3 - limited by 29-bit int, otherwise passed as double)
         * - double
         * - UTF-8 string
         * - XML Document (identified by being instaneof Document. Can be generated with: new DOMParser()).parseFromString(xml, "text/xml");
         * @param {Object} item A primitive or object to write to the stream
         */
        writeObject(item: any);
    }

    /**
     * This class represents an Action Message Format (AMF) Packet.  It contains all
     * the logic required to decode an AMF Packet from a byte array.
     * To decode a Packet, first construct a Packet:
     *
     *     var packet = Ext.create('Ext.data.amf.Packet');
     *
     * Then use the decode method to decode an AMF byte array:
     *
     *     packet.decode(bytes);
     *
     * where "bytes" is a Uint8Array or an array of numbers representing the binary
     * AMF data.
     *
     * To access the decoded data use the #version, #headers, and #messages properties:
     *
     *     console.log(packet.version, packet.headers, packet.messages);
     *
     * For more information on working with AMF data please refer to the
     * [AMF Guide](#/guide/amf).
     */
    export class Packet extends Ext.Base {
        /**
         * @readonly
         * The decoded headers. Each header has the following properties:
         *
         * - 'name': String
         * The header name. Typically identifies a remote operation or method to
         * be invoked by this context header.
         * - 'mustUnderstand': Boolean
         * If 'true' this flag instructs the endpoint to abort and generate an
         * error if the header is not understood.
         * - 'byteLength': Number
         * If the byte-length of a header is known it can be specified to optimize
         * memory allocation at the remote endpoint.
         * - 'value': Mixed
         * The header value
         */
        headers: any[];

        /**
         * @readonly
         * The decoded messages. Each message has the following properties:
         *
         * - 'targetURI': String
         * Describes which operation, function, or method is to be remotely
         * invoked.
         * - 'responseURI': String
         * A unique operation name
         * - 'byteLength': Number
         * Optional byte-length of the message body
         * - 'body': Mixed
         * The message body
         */
        messages: any[];

        /**
         * @readonly
         * The AMF version number (0 or 3)
         */
        version: number;

        /**
         * Decodes an AMF btye array and sets the decoded data as the
         * Packet's #version, #headers, and #messages properties
         * @param {Array} byteArray A byte array containing the encoded AMF data.
         * @return {Ext.data.amf.Packet} this AMF Packet
         */
        decode(byteArray: any[]): Ext.data.amf.Packet;

        /**
         * Decodes an AMF3 byte array and that has one value and returns it.
         * Note: Destroys previously stored data in this Packet.
         * @param {Array} byteArray A byte array containing the encoded AMF data.
         * @return {Object} the decoded object
         */
        decodeValue(byteArray: any[]): any;
    }

    interface ProxyConfig extends Ext.data.proxy.AjaxConfig {
        binary?: any;

        reader?: any;
    }

    /**
     * The AMF Proxy is an {@link Ext.data.proxy.Ajax Ajax Proxy} that requests
     * binary data from a remote server and parses it into records using an
     * {@link Ext.data.amf.Reader AMF Reader} for use in a
     * {@link Ext.data.Store Store}.
     *
     *     Ext.create('Ext.data.Store', {
     *         model: 'Foo',
     *         proxy: {
     *             type: 'amf',
     *             url: 'some/url'
     *         }
     *     });
     *
     * For a detailed tutorial on using AMF data see the [AMF Guide](#/guide/amf).
     *
     * **Note: **  _This functionality is only available with the purchase of
     * Sencha Complete.  For more information about using this class, please visit
     * our [Sencha Complete](https://www.sencha.com/products/complete/) product page._
     */
    export class Proxy extends Ext.data.proxy.Ajax implements Ext.data.amf.ProxyConfig {
        /**
         * True to request binary data from the server.  This feature requires
         * the use of a binary reader such as {@link Ext.data.amf.Reader AMF Reader}
         */
        binary: boolean;

        /**
         * The Ext.data.reader.Reader to use to decode the server's response or data read
         * from client. This can either be a Reader instance, a config object or just a
         * valid Reader type name (e.g. 'json', 'xml').
         */
        reader: any|string|Ext.data.reader.Reader;

        /**
         * AjaxProxy is one of the most widely-used ways of getting data into your application. It uses AJAX requests to load
         * data from the server, usually to be placed into a {@link Ext.data.Store Store}. Let's take a look at a typical setup.
         * Here we're going to set up a Store that has an AjaxProxy. To prepare, we'll also set up a {@link Ext.data.Model
         * Model}:
         *
         *     Ext.define('User', {
         *         extend: 'Ext.data.Model',
         *         fields: ['id', 'name', 'email']
         *     });
         *
         *     //The Store contains the AjaxProxy as an inline configuration
         *     var store = Ext.create('Ext.data.Store', {
         *         model: 'User',
         *         proxy: {
         *             type: 'ajax',
         *             url : 'users.json'
         *         }
         *     });
         *
         *     store.load();
         *
         * Our example is going to load user data into a Store, so we start off by defining a {@link Ext.data.Model Model} with
         * the fields that we expect the server to return. Next we set up the Store itself, along with a
         * {@link Ext.data.Store#proxy proxy} configuration. This configuration was automatically turned into an
         * Ext.data.proxy.Ajax instance, with the url we specified being passed into AjaxProxy's constructor.
         * It's as if we'd done this:
         *
         *     new Ext.data.proxy.Ajax({
         *         url: 'users.json',
         *         model: 'User',
         *         reader: 'json'
         *     });
         *
         * A couple of extra configurations appeared here - {@link #model} and {@link #reader}. These are set by default when we
         * create the proxy via the Store - the Store already knows about the Model, and Proxy's default {@link
         * Ext.data.reader.Reader Reader} is {@link Ext.data.reader.Json JsonReader}.
         *
         * Now when we call store.load(), the AjaxProxy springs into action, making a request to the url we configured
         * ('users.json' in this case). As we're performing a read, it sends a GET request to that url (see
         * {@link #actionMethods} to customize this - by default any kind of read will be sent as a GET request and any kind of write
         * will be sent as a POST request).
         *
         * # Limitations
         *
         * AjaxProxy cannot be used to retrieve data from other domains. If your application is running on http://domainA.com it
         * cannot load data from http://domainB.com because browsers have a built-in security policy that prohibits domains
         * talking to each other via AJAX.
         *
         * If you need to read data from another domain and can't set up a proxy server (some software that runs on your own
         * domain's web server and transparently forwards requests to http://domainB.com, making it look like they actually came
         * from http://domainA.com), you can use {@link Ext.data.proxy.JsonP} and a technique known as JSON-P (JSON with
         * Padding), which can help you get around the problem so long as the server on http://domainB.com is set up to support
         * JSON-P responses. See {@link Ext.data.proxy.JsonP JsonPProxy}'s introduction docs for more details.
         *
         * # Readers and Writers
         *
         * AjaxProxy can be configured to use any type of {@link Ext.data.reader.Reader Reader} to decode the server's response.
         * If no Reader is supplied, AjaxProxy will default to using a {@link Ext.data.reader.Json JsonReader}. Reader
         * configuration can be passed in as a simple object, which the Proxy automatically turns into a {@link
         * Ext.data.reader.Reader Reader} instance:
         *
         *     var proxy = new Ext.data.proxy.Ajax({
         *         model: 'User',
         *         reader: {
         *             type: 'xml',
         *             rootProperty: 'users'
         *         }
         *     });
         *
         *     proxy.getReader(); //returns an XmlReader instance based on the config we supplied
         *
         * # Url generation
         *
         * AjaxProxy automatically inserts any sorting, filtering, paging and grouping options into the url it generates for
         * each request. These are controlled with the following configuration options:
         *
         * - {@link #pageParam} - controls how the page number is sent to the server (see also {@link #startParam} and {@link #limitParam})
         * - {@link #sortParam} - controls how sort information is sent to the server
         * - {@link #groupParam} - controls how grouping information is sent to the server
         * - {@link #filterParam} - controls how filter information is sent to the server
         *
         * Each request sent by AjaxProxy is described by an {@link Ext.data.operation.Operation Operation}. To see how we can customize
         * the generated urls, let's say we're loading the Proxy with the following Operation:
         *
         *     var proxy = new Ext.data.proxy.Ajax({
         *         url: '/users'
         *     });
         *
         *     var operation = proxy.createOperation('read', {
         *         page  : 2
         *     });
         *
         * Now we'll issue the request for this Operation by calling {@link #read}:
         *
         *     proxy.read(operation); //GET /users?page=2
         *
         * Easy enough - the Proxy just copied the page property from the Operation. We can customize how this page data is sent
         * to the server:
         *
         *     var proxy = new Ext.data.proxy.Ajax({
         *         url: '/users',
         *         pageParam: 'pageNumber'
         *     });
         *
         *     proxy.read(operation); //GET /users?pageNumber=2
         *
         * Alternatively, our Operation could have been configured to send start and limit parameters instead of page:
         *
         *     var proxy = new Ext.data.proxy.Ajax({
         *         url: '/users'
         *     });
         *
         *     var operation = proxy.createOperation('read', {
         *         start : 50,
         *         limit : 25
         *     });
         *
         *     proxy.read(operation); //GET /users?start=50&limit;=25
         *
         * Again we can customize this url:
         *
         *     var proxy = new Ext.data.proxy.Ajax({
         *         url: '/users',
         *         startParam: 'startIndex',
         *         limitParam: 'limitIndex'
         *     });
         *
         *     proxy.read(operation); //GET /users?startIndex=50&limitIndex;=25
         *
         * AjaxProxy will also send sort and filter information to the server. Let's take a look at how this looks with a more
         * expressive Operation object:
         *
         *     var operation = proxy.createOperation('read', {
         *         sorters: [
         *             new Ext.util.Sorter({
         *                 property : 'name',
         *                 direction: 'ASC'
         *             }),
         *             new Ext.util.Sorter({
         *                 property : 'age',
         *                 direction: 'DESC'
         *             })
         *         ],
         *         filters: [
         *             new Ext.util.Filter({
         *                 property: 'eyeColor',
         *                 value   : 'brown'
         *             })
         *         ]
         *     });
         *
         * This is the type of object that is generated internally when loading a {@link Ext.data.Store Store} with sorters and
         * filters defined. By default the AjaxProxy will JSON encode the sorters and filters, resulting in something like this
         * (note that the url is escaped before sending the request, but is left unescaped here for clarity):
         *
         *     var proxy = new Ext.data.proxy.Ajax({
         *         url: '/users'
         *     });
         *
         *     proxy.read(operation); //GET /users?sort=[{"property":"name","direction":"ASC"},{"property":"age","direction":"DESC"}]&filter;=[{"property":"eyeColor","value":"brown"}]
         *
         * We can again customize how this is created by supplying a few configuration options. Let's say our server is set up
         * to receive sorting information is a format like "sortBy=name#ASC,age#DESC". We can configure AjaxProxy to provide
         * that format like this:
         *
         *      var proxy = new Ext.data.proxy.Ajax({
         *          url: '/users',
         *          sortParam: 'sortBy',
         *          filterParam: 'filterBy',
         *
         *          //our custom implementation of sorter encoding - turns our sorters into "name#ASC,age#DESC"
         *          encodeSorters: function(sorters) {
         *              var length   = sorters.length,
         *                  sortStrs = [],
         *                  sorter, i;
         *
         *              for (i = 0; i < length; i++) {
         *                  sorter = sorters[i];
         *
         *                  sortStrs[i] = sorter.property + '#' + sorter.direction
         *              }
         *
         *              return sortStrs.join(",");
         *          }
         *      });
         *
         *      proxy.read(operation); //GET /users?sortBy=name#ASC,age#DESC&filterBy;=[{"property":"eyeColor","value":"brown"}]
         *
         * We can also provide a custom {@link #encodeFilters} function to encode our filters.
         *
         * # Debugging your Ajax Proxy
         *
         * If the data is not being loaded into the store as expected, it could be due to a mismatch between the the way that the {@link #reader}
         * is configured, and the shape of the incoming data.
         *
         * To debug from the point that your data arrives back from the network, set a breakpoint inside the callback function
         * created in the 'createRequestCallback' method of the Ajax Proxy class, and follow the data to where the {@link #reader} attempts
         * to consume it.
         *
         * @constructor
         * Note that if this HttpProxy is being used by a {@link Ext.data.Store Store}, then the Store's call to
         * {@link Ext.data.Store#method-load load} will override any specified callback and params options. In this case, use the
         * {@link Ext.data.Store Store}'s events to modify parameters, or react to loading events.
         *
         * @param {Object} config (optional) Config object.
         * If an options parameter is passed, the singleton {@link Ext.Ajax} object will be used to make the request.
         */
        constructor(config: Ext.data.amf.ProxyConfig);
    }

    interface ReaderConfig extends Ext.data.reader.JsonConfig {
        /**
         * AMF Packets can contain multiple messages. This config specifies the
         * 0-based index of the message that contains the record data.
         */
        messageIndex?: number;
    }

    /**
     * The AMF Reader is used by an {@link Ext.data.amf.Proxy AMF Proxy} to read
     * records from a server response that contains binary data in either AMF0 or
     * AMF3 format. AMF Reader constructs an {@link Ext.data.amf.Packet AMF Packet}
     * and uses it to decode the binary data into javascript objects, then simply
     * allows its superclass ({@link Ext.data.reader.Json}) to handle converting the
     * raw javascript objects into {@link Ext.data.Model} instances.
     *
     * For a more detailed tutorial see the [AMF Guide](#/guide/amf).
     */
    export class Reader extends Ext.data.reader.Json implements Ext.data.amf.ReaderConfig {
        /**
         * AMF Packets can contain multiple messages. This config specifies the
         * 0-based index of the message that contains the record data.
         */
        messageIndex: number;

        /**
         * Creates new Reader.
         * @param {Object} [config] Config object.
         */
        constructor(config?: Ext.data.amf.ReaderConfig);
    }

    /**
     * Represents a remote call to be sent to the server.
     */
    export class RemotingMessage extends Ext.Base {
        /**
         * - typically an array of parameters to pass to a method call
         */
        body: any[];

        /**
         * - identifies the calling client.
         */
        clientID: string;

        /**
         * - the service destination on the server
         */
        destination: string;

        /**
         * - the headers to attach to the message.
         * Would typically contain the DSEndpoint and DSId fields.
         */
        headers: any;

        /**
         * - message identifier
         */
        messageId: string;

        /**
         * - the method name to call
         */
        operation: string;

        /**
         * - should be empty for security purposes
         */
        source: any[];

        /**
         * - when the message was created
         */
        timestamp: number;

        /**
         * - how long the message is still valid for passing
         */
        timeToLive: number;

        /**
         * Creates new message.
         * @param {Object} config Configuration options
         */
        constructor(config: any);

        /**
         * Returns an AMFX encoded version of the message.
         */
        encodeMessage();

        get$flexType();

        set$flexType();
    }

    /**
     * This class parses an XML-based AMFX message and returns the deserialized
     * objects. You should not need to use this class directly. It's mostly used by
     * the AMFX Direct implementation.
     * To decode a message, first construct a Decoder:
     *
     *      decoder = Ext.create('Ext.data.amf.XmlDecoder');
     *
     * Then ask it to read in the message :
     *
     *     resp = decoder.readAmfxMessage(str);
     *
     * For more information on working with AMF data please refer to the
     * [AMF Guide](#/guide/amf).
     */
    export class XmlDecoder extends Ext.Base {
        /**
         * Clears the accumulated data and reference tables
         */
        clear();

        /**
         * Creates new encoder.
         * @param {Object} config Configuration options
         */
        constructor(config: any);

        /**
         * Reads and returns a decoded AMFX packet.
         * @param {String} xml the xml of the message
         * @return {Object} the response object containing the message
         */
        readAmfxMessage(xml: string): any;

        /**
         * Parses and returns an AMFX array.
         * @param {HTMLElement/XMLElement} node the array node
         * @return {Array} the deserialized array
         */
        readArray(node: HTMLElement|any): any[];

        /**
         * Parses and returns an AMFX dictionary.
         * @param {HTMLElement/XMLElement} node the '<dictionary>' node
         * @return {Object} a javascript object with the dictionary value-pair elements
         */
        readDictionary(node: HTMLElement|any): any;

        /**
         * Parses and returns an AMFX object.
         * @param {HTMLElement/XMLElement} node the '<object>' node to parse
         * @return {Object} the deserialized object
         */
        readObject(node: HTMLElement|any): any;

        /**
         * Parses and return an object / array / dictionary / date from reference
         * @param {HTMLElement/XMLElement} node the ref node
         * @return {Object} the previously instantiated object referred to by the ref node
         */
        readObjectRef(node: HTMLElement|any): any;

        /**
         * Reads a string or string reference and return the value
         * @param {HTMLElement/XMLElement} node the node containing a string object
         * @return {String} the parsed string
         */
        readString(node: HTMLElement|any): string;

        /**
         * Parses and returns an ordered list of trait names
         * @param {HTMLElement/XMLElement} node the traits node from the XML doc
         * @return {Array} an array of ordered trait names or null if it's an externalizable object
         */
        readTraits(node: HTMLElement|any): any[];

        /**
         * Parses an HTML element returning the appropriate JavaScript value from the AMFX data.
         * @param {HTMLElement} node The node to parse
         * @return {Object} a JavaScript object or value
         */
        readValue(node: HTMLElement): any;

        /**
         * Accepts Flex-style UID and decodes the number in the first four bytes (8 hex digits) of data.
         * @param {String} messageId the message ID
         * @return {Number} the transaction ID
         */
        static decodeTidFromFlexUID(messageId: string): number;

        /**
         * Deserializes an AMF3 binary object from a byte array
         * @param {Array} bytes the byte array containing one AMF3-encoded value
         * @return {Object} the decoded value
         */
        static readAMF3Value(bytes: any[]): any;

        /**
         * parses a node containing a byte array in hexadecimal format, returning the reconstructed array.
         * @param {HTMLElement/XMLElement} node the node
         * @return {Array} a byte array
         */
        static readByteArray(node: HTMLElement|any): any[];
    }

    /**
     * This class serializes data in the Action Message Format XML (AMFX) format.
     * It can write simple and complex objects, to be used in conjunction with an
     * AMFX-compliant server.
     * To create an encoded XMl, first construct an Encoder:
     *
     *     var encoder = Ext.create('Ext.data.amf.XmlEncoder');
     *
     * Then use the writer methods to out data to the :
     *
     *     encoder.writeObject(1);
     *     encoder.writeObject({a: "b"});
     *
     * And access the data through the #bytes property:
     *     encoder.body;
     *
     * You can also reset the class to start a new body:
     *
     *     encoder.clear();
     *
     * Current limitations:
     * AMF3 format (format:3)
     * - Each object is written out explicitly, not using the reference tables
     *   supported by the AMFX format. This means the function does NOT support
     *   circular reference objects.
     * - Objects that aren't Arrays, Dates, Strings, Document (XML) or primitive
     *   values will be written out as anonymous objects with dynamic data.
     * - If the object has a $flexType field, that field will be used in signifying
     *   the object-type as an attribute, instead of being passed as data.
     * - There's no JavaScript equivalent to the ByteArray type in ActionScript,
     *   hence data will never be searialized as ByteArrays by the writeObject
     *   function. A writeByteArray method is provided for writing out ByteArray objects.
     *
     * For more information on working with AMF data please refer to the
     * [AMF Guide](#/guide/amf).
     */
    export class XmlEncoder extends Ext.Base {
        /**
         * - The output string
         */
        body: string;

        /**
         * Clears the accumulated data, starting with an empty string
         */
        clear();

        /**
         * Creates new encoder.
         * @param {Object} config Configuration options
         */
        constructor(config: any);

        /**
         * Encodes an AMFX remoting message with the AMFX envelope.
         * @param {Ext.data.amf.RemotingMessage} message the message to pass on to serialize.
         */
        encodeAmfxRemotingPacket(message: Ext.data.amf.RemotingMessage);

        /**
         * Encodes an array, marking it as an ECMA array if it has associative (non-ordinal) indices
         * @param {Array} array the array to encode
         */
        encodeArray(array: any[]);

        /**
         * Returns an encoded boolean
         * @param {Boolean} val a boolean value
         */
        encodeBoolean(val: boolean);

        /**
         * Encodes a byte arrat in AMFX format
         * @param {Array} array the byte array to encode
         */
        encodeByteArray(array: any[]);

        /**
         * Encode a date
         * @param {Date} date the date to encode
         */
        encodeDate(date: Date);

        /**
         * Returns an encoded double
         * @param {Number} num the double to encode
         */
        encodeDouble(num: number);

        /**
         * Encodes a generic object into AMFX format. If a <tt>$flexType</tt> member is defined, list that as the object type.
         * @param {Object} obj the object to encode
         * @return {String} the encoded text
         */
        encodeGenericObject(obj: any): string;

        /**
         * Returns an encoded int
         * @param {Number} num the integer to encode
         */
        encodeInt(num: number);

        /**
         * Returns the encoding for null
         */
        encodeNull();

        /**
         * Returns an encoded number. Decides wheter to use int or double encoding.
         * @param {Number} num the number to encode
         */
        encodeNumber(num: number);

        /**
         * encode the appropriate data item. Supported types:
         * - undefined
         * - null
         * - boolean
         * - integer
         * - double
         * - UTF-8 string
         * - XML Document (identified by being instaneof Document. Can be generated with: new DOMParser()).parseFromString(xml, "text/xml");
         * - Date
         * - Array
         * - Generic object
         * @param {Object} item A primitive or object to write to the stream
         * @return {String} the encoded object in AMFX format
         */
        encodeObject(item: any): string;

        /**
         * Returns an encoded string
         * @param {String} str the string to encode
         */
        encodeString(str: string);

        /**
         * Returns the encoding for undefined (which is the same as the encoding for null)
         */
        encodeUndefined();

        /**
         * Encodes an xml document into a CDATA section
         * @param {XMLElement/HTMLElement} xml an XML document or element (Document type in some browsers)
         */
        encodeXml(xml: any|HTMLElement);

        /**
         * Tries to determine if an object is an XML document
         * @param {Object} item to identify
         * @return {Boolean} true if it's an XML document, false otherwise
         */
        isXmlDocument(item: any): boolean;

        /**
         * Writes an AMFX remoting message with the AMFX envelope to the string.
         * @param {Ext.data.amf.RemotingMessage} message the message to pass on to serialize.
         */
        writeAmfxRemotingPacket(message: Ext.data.amf.RemotingMessage);

        /**
         * Writes an array to the string, marking it as an ECMA array if it has associative (non-ordinal) indices
         * @param {Array} array the array to encode
         */
        writeArray(array: any[]);

        /**
         * Writes a boolean value to the string
         * @param {Boolean} val a boolean value
         */
        writeBoolean(val: boolean);

        /**
         * Writes an AMFX byte array to the string. This is for convenience only and is not called automatically by writeObject.
         * @param {Array} array the byte array to encode
         */
        writeByteArray(array: any[]);

        /**
         * Write a date to the string
         * @param {Date} date the date to encode
         */
        writeDate(date: Date);

        /**
         * Writes a double tag with the content.
         * @param {Number} num the double to encode
         */
        writeDouble(num: number);

        /**
         * Writes a generic object to the string. If a <tt>$flexType</tt> member is defined, list that as the object type.
         * @param {Object} obj the object to encode
         */
        writeGenericObject(obj: any);

        /**
         * Writes a int tag with the content.
         * @param {Number} num the integer to encode
         */
        writeInt(num: number);

        /**
         * Writes the null value to the string
         */
        writeNull();

        /**
         * Writes a number, deciding if to use int or double as the tag
         * @param {Number} num the number to encode
         */
        writeNumber(num: number);

        /**
         * Writes the appropriate data item to the string. Supported types:
         * - undefined
         * - null
         * - boolean
         * - integer
         * - double
         * - UTF-8 string
         * - XML Document (identified by being instaneof Document. Can be generated with: new DOMParser()).parseFromString(xml, "text/xml");
         * - Date
         * - Array
         * - Generic object
         * @param {Object} item A primitive or object to write to the stream
         */
        writeObject(item: any);

        /**
         * Writes a string tag with the string content.
         * @param {String} str the string to encode
         */
        writeString(str: string);

        /**
         * Writes the undefined value to the string
         */
        writeUndefined();

        /**
         * Write an XML document to the string
         * @param {XMLElement/HTMLElement} xml an XML document or element (Document type in some browsers)
         */
        writeXml(xml: any|HTMLElement);

        /**
         * Utility function to generate a flex-friendly UID
         * @param {Number} id used in the first 8 chars of the id. If not provided, a random number will be used.
         * @return {String} a string-encoded opaque UID
         */
        static generateFlexUID(id: number): string;
    }
}

declare module Ext.data.field {
    export class Boolean extends Ext.data.field.Field {
        /**
         * Values matching this regular expression are considered 'true'.
         */
        trueRe: any;

        constructor(config: Ext.data.field.DateConfig);
    }

    interface DateConfig extends Ext.data.field.FieldConfig {
        /**
         * Serves as a default for the {@link #dateReadFormat} and {@link #dateWriteFormat} config options. This
         * will be used in place of those other configurations if not specified.
         *
         * A format string for the {@link Ext.Date#parse Ext.Date.parse} function, or "timestamp" if the value provided by
         * the Reader is a UNIX timestamp, or "time" if the value provided by the Reader is a javascript millisecond
         * timestamp. See {@link Ext.Date}.
         *
         * It is quite important to note that while this config is optional, it will default to using the base
         * JavaScript Date object's 'parse' function if not specified, rather than {@link Ext.Date#parse Ext.Date.parse}.
         * This can cause unexpected issues, especially when converting between timezones, or when converting dates that
         * do not have a timezone specified. The behavior of the native 'Date.parse' is implementation-specific, and
         * depending on the value of the date string, it might return the UTC date or the local date. __For this reason
         * it is strongly recommended that you always specify an explicit date format when parsing dates.__
         */
        dateFormat?: string;

        /**
         * Used when converting received data into a Date when the {@link #type} is specified as '"date"'.
         * This configuration takes precedence over {@link #dateFormat}.
         * See {@link #dateFormat} for more information.
         */
        dateReadFormat?: string;

        /**
         * Provides a custom format when serializing dates with a {@link Ext.data.writer.Writer}.
         * If this is not specified, the {@link #dateFormat} will be used. If no 'dateFormat'
         * is specified, 'timestamp' format is used.
         *
         * See the {@link Ext.data.writer.Writer} docs for more information on writing dates.
         *
         * **Note** It is not possible to use the standard date serialization pathway or {@link Ext#USE_NATIVE_JSON native browser JSON production}
         * to use a {@link Ext.data.JsonWriter JsonWriter} to send Microsoft formated
         * "JSON" dates.
         *
         * To use a {@link Ext.data.JsonWriter JsonWriter} to write dates in a JSON packet in
         * the form '"\/Date(1357372800000)\/"' configure the field like this:
         *
         *    {
         *        type: 'date',
         *        dateFormat: 'MS',     // To parse incoming dates from server correctly
         *        serialize: null       // Avoid formatting or conversion by the Writer
         *    }
         *
         * Then override the 'Ext.JSON' date serialize function:
         *
         *    Ext.JSON.encodeDate = function (d) {
         *        return '"' + Ext.Date.format(d, 'MS') + '"';
         *    };
         */
        dateWriteFormat?: string;

        sortType?: any;
    }

    /**
     * This class provides Date specific processing for fields.
     *
     * In previous releases this functionality was integral to the 'Field' base class.
     */
    export class Date extends Ext.data.field.Field implements Ext.data.field.DateConfig {
        /**
         * Serves as a default for the {@link #dateReadFormat} and {@link #dateWriteFormat} config options. This
         * will be used in place of those other configurations if not specified.
         *
         * A format string for the {@link Ext.Date#parse Ext.Date.parse} function, or "timestamp" if the value provided by
         * the Reader is a UNIX timestamp, or "time" if the value provided by the Reader is a javascript millisecond
         * timestamp. See {@link Ext.Date}.
         *
         * It is quite important to note that while this config is optional, it will default to using the base
         * JavaScript Date object's 'parse' function if not specified, rather than {@link Ext.Date#parse Ext.Date.parse}.
         * This can cause unexpected issues, especially when converting between timezones, or when converting dates that
         * do not have a timezone specified. The behavior of the native 'Date.parse' is implementation-specific, and
         * depending on the value of the date string, it might return the UTC date or the local date. __For this reason
         * it is strongly recommended that you always specify an explicit date format when parsing dates.__
         */
        dateFormat: string;

        /**
         * Used when converting received data into a Date when the {@link #type} is specified as '"date"'.
         * This configuration takes precedence over {@link #dateFormat}.
         * See {@link #dateFormat} for more information.
         */
        dateReadFormat: string;

        /**
         * Provides a custom format when serializing dates with a {@link Ext.data.writer.Writer}.
         * If this is not specified, the {@link #dateFormat} will be used. If no 'dateFormat'
         * is specified, 'timestamp' format is used.
         *
         * See the {@link Ext.data.writer.Writer} docs for more information on writing dates.
         *
         * **Note** It is not possible to use the standard date serialization pathway or {@link Ext#USE_NATIVE_JSON native browser JSON production}
         * to use a {@link Ext.data.JsonWriter JsonWriter} to send Microsoft formated
         * "JSON" dates.
         *
         * To use a {@link Ext.data.JsonWriter JsonWriter} to write dates in a JSON packet in
         * the form '"\/Date(1357372800000)\/"' configure the field like this:
         *
         *    {
         *        type: 'date',
         *        dateFormat: 'MS',     // To parse incoming dates from server correctly
         *        serialize: null       // Avoid formatting or conversion by the Writer
         *    }
         *
         * Then override the 'Ext.JSON' date serialize function:
         *
         *    Ext.JSON.encodeDate = function (d) {
         *        return '"' + Ext.Date.format(d, 'MS') + '"';
         *    };
         */
        dateWriteFormat: string;

        sortType: Function|string;

        constructor(config: Ext.data.field.DateConfig);

        /**
         * Gets the dateFormat for this field. See {@link #dateFormat}.
         * @return {String} dateFormat
         */
        getDateFormat(): string;

        /**
         * Gets the dateReadFormat for this field. See {@link #dateReadFormat}.
         * @return {String} dateReadFormat
         */
        getDateReadFormat(): string;

        /**
         * Gets the dateWriteFormat for this field. See {@link #dateWriteFormat}.
         * @return {String} dateWriteFormat
         */
        getDateWriteFormat(): string;
    }

    interface FieldConfig {
        /**
         * Use when converting received data into a {@link Ext.data.field.Integer 'int'},
         * {@link Ext.data.field.Number 'float'}, {@link Ext.data.field.Boolean 'bool'}
         * or {@link Ext.data.field.String 'string'} type. If the value cannot be
         * parsed, 'null' will be used if allowNull is true, otherwise a default value for that type will be used:
         *
         * - for 'int' and 'float' - '0'.
         * - for 'string' - '""'.
         * - for 'bool' - 'false'.
         *
         * Note that when parsing of {@link Ext.data.field.Date 'date'} type fails, the value will
         * be 'null' regardless of this setting.
         */
        allowNull?: boolean;

        /**
         * This config defines a simple field calculation function. A calculate method only
         * has access to the record data and should return the value of the calculated field.
         * When provided in this way, the 'depends' config is automatically determined by
         * parsing the 'calculate' function. For example:
         *
         *      fields: [{
         *          name: 'firstName',
         *          type: 'string'
         *      },{
         *          name: 'lastName',
         *          type: 'string'
         *      },{
         *          name: 'fullName',
         *          calculate: function (data) {
         *              return data.firstName + ' ' + data.lastName;
         *          }
         *      }]
         *
         * The above 'fullName' field is equivalent to:
         *
         *      {
         *          name: 'fullName',
         *          convert: function (v, rec) {
         *              return rec.get('firstName') + ' ' + rec.get('lastName');
         *          },
         *          depends: ['firstName', 'lastName']
         *      }
         *
         * The restrictions on form for a 'calculate' method are that the accesses to field
         * values must match the following regular expression (case insensitive):
         *
         *      data.([a-z_][a-z0-9_]*)
         *      // where 'data' is the param passed to the calculate method
         *
         * The only advantage of a 'calculate' method over a 'convert' method is automatic
         * determination of 'depends'.
         *
         * **Note:** The use of calculate and {@link #method-convert} are exclusive.  The
         * calculate method will override the convert method if both are configured.
         *
         * **Note:** Fields used by the calculate method must be explicitly defined in the
         * {@link Ext.data.Model#cfg-fields #fields} of the model.
         *
         * @param {Object} data An object with all values for each field in the parent
         * model.  See {@link Ext.data.Model#getData getData}.
         * @return {Mixed} value The value of the calculated field
         */
        calculate?: Function;

        /**
         * A critical field is a field that must always be sent to the server even if it has
         * not changed. The most common example of such a field is the "id" of a record (see
         * '{@link Ext.data.Model#idProperty}' but the '{@link Ext.data.Model#versionProperty}'
         * is similarly a 'critical' field.
         */
        critical?: boolean;

        /**
         * The default value used when the creating an instance from a raw data object,
         * and the property referenced by the '{@link Ext.data.field.Field#mapping mapping}'
         * does not exist in that data object.
         *
         * The value 'undefined' prevents defaulting in a value.
         *
         * Optional, Defaults to: undefined
         */
        defaultValue?: any;

        /**
         * The field name or names within the {@link Ext.data.Model Model} on which the value
         * of this field depends, and from which a new value may be calculated. These values
         * are the values used by the 'convert' method. If you do not have a 'convert' method
         * then this config should not be specified.
         *
         * Before using this config you should consider if using a 'calculate' method instead
         * of a 'convert' method would be simpler.
         *
         * Whenever any of the named fields are set using the {@link Ext.data.Model#set set}
         * method, this fields will have its 'convert' method called passing the
         * {@link Ext.data.Model record} so that the dependent value can be calculated from
         * all fields which it needs.
         *
         * For example, to display a person's full name, using two separate 'firstName' and
         * 'lastName' fields, configure the name field like this:
         *
         *     {
         *         name: 'name',
         *
         *         // Will be called whenever forename or surname fields are set
         *         convert: function (v, rec) {
         *             return rec.get('firstName') + ' ' + rec.get('lastName');
         *         },
         *
         *         depends: [ 'firstName', 'lastName' ],
         *
         *         // It should not be returned to the server - it's not a database field
         *         persist: false
         *     }
         *
         * Note that if you do not want the calculated field to be part of the field set sent
         * back to the server when the store is synchronized, you should configure the field
         * with 'persist' set to 'false'.
         *
         * Optional
         */
        depends?: string;

        /**
         * (Optional) A path expression for use by the {@link Ext.data.reader.Reader} implementation that is creating the
         * {@link Ext.data.Model Model} to extract the Field value from the data object. If the path expression is the same
         * as the field name, the mapping may be omitted. A function may be passed to do complex data extraction. The examples
         * below are simple just to demonstrate the capability, typically, a function would not be used to extract such
         * simple data.
         *
         * The form of the mapping expression depends on the Reader being used.
         *
         * - {@link Ext.data.reader.Json}
         *
         *   The mapping is a string containing the javascript expression to reference the data from an element of the data
         *   item's {@link Ext.data.reader.Json#cfg-rootProperty rootProperty} Array. Defaults to the field name. If a function is passed,
         *   a single argument is received which contains the raw json object:
         *
         *       // Server returns [{"name": "Foo", "age": 1}, {"name": "Bar", "age": 2}]
         *       mapping: function(data) {
         *           return data.name;
         *       }
         *
         * - {@link Ext.data.reader.Xml}
         *
         *   The mapping is an {@link Ext.DomQuery} path to the data item relative to the DOM element that represents the
         *   {@link Ext.data.reader.Xml#record record}. Defaults to the field name. If a function is passed, a single argument
         *   is received which contains the record node:
         *
         *       // Server returns <Root><Person><Name>Foo</Name><Age>1</Age></Person><Person><Name>Bar</Name><Age>2</Age></Person></Root>
         *       mapping: function(data) {
         *           return data.firstChild.textContent;
         *       }
         *
         * - {@link Ext.data.reader.Array}
         *
         *   The mapping is a number indicating the Array index of the field's value. Defaults to the field specification's
         *   Array position. If a function is passed, a single argument is received which contains the child array.
         *
         *       // Server returns [["Foo", 1], ["Bar", 2]]
         *       mapping: function(data) {
         *           return data[0];
         *       }
         *
         * If a more complex value extraction strategy is required, then configure the Field with a {@link #cfg-convert}
         * function. This is passed the whole row object, and may interrogate it in whatever way is necessary in order to
         * return the desired data.
         */
        mapping?: string|number|Function;

        /**
         * The name by which the field is referenced within the Model. This is referenced by,
         * for example, the 'dataIndex' property in column definition objects passed to
         * {@link Ext.grid.property.HeaderContainer}.
         *
         * Note: In the simplest case, if no properties other than 'name' are required, a
         * field definition may consist of just a String for the field name.
         */
        name?: string;

        /**
         * False to exclude this field from the {@link Ext.data.Model#modified} fields in a
         * record. This will also exclude the field from being written using a
         * {@link Ext.data.writer.Writer}. This option is useful when fields are used to keep
         * state on the client but do not need to be persisted to the server.
         *
         * Defaults to 'false' for 'calculated' fields and 'true' otherwise.
         *
         * Optional
         */
        persist?: boolean;

        /**
         * The {@link Ext.data.Model#entityName name} of the entity referenced by this field.
         * In most databases, this relationship is represented by a "foreign key". That is, a
         * value for such a field matches the value of the {@link Ext.data.Model#idProperty id}
         * for an entity of this type.
         *
         *      Ext.define('MyApp.models.Organization', {
         *          extend: 'Ext.data.Model',
         *          ...
         *      });
         *
         *      Ext.define('MyApp.models.User', {
         *          extend: 'Ext.data.Model',
         *
         *          fields: [
         *              { name: 'organizationId', reference: 'Organization' }
         *          ],
         *          ...
         *      });
         *
         * If a 'reference' is not nullable, set the {@link Ext.data.field.Field#allowBlank} property
         * to false.
         *
         *      Ext.define('MyApp.models.User', {
         *          extend: 'Ext.data.Model',
         *
         *          fields: [
         *              { name: 'organizationId', reference: 'Organization', allowBlank: false }
         *          ],
         *          ...
         *      });
         *
         * If the name of the generated {@link Ext.data.schema.Association association} or other aspects
         * need to be specified, the 'reference' can be an object. The following usage shows
         * what would be generated by default given the above examples using the string form.
         *
         *      Ext.define('MyApp.models.User', {
         *          extend: 'Ext.data.Model',
         *
         *          fields: [{
         *              name: 'organizationId',
         *              reference: {
         *                  type: 'Organization',
         *                  association: 'UsersByOrganization',
         *                  role: 'organization',
         *                  inverse: 'users'
         *              }
         *          }],
         *          ...
         *      });
         *
         * Finally, a 'reference' can also describe ownership between the entities. By default,
         * no ownership relationship is assumed. If, however, the User entities are owned by
         * their Organization, we could say this:
         *
         *      Ext.define('MyApp.models.User', {
         *          extend: 'Ext.data.Model',
         *
         *          fields: [{
         *              name: 'organizationId',
         *              reference: {
         *                  parent: 'Organization' // Organization is the parent of User
         *              }
         *          }],
         *          ...
         *      });
         *
         * The type which this field references. This is the value set by the string form of
         * 'reference'. If the referenced entity has an ownership relationship this field
         * should be omitted and 'reference.parent' or 'reference.child' should be specified
         * instead.
         *
         * The name of the association. By default, the name of the association is the
         * capitalized 'inverse' plus "By" plus the capitalized 'role'.
         *
         * Set this property instead of 'reference.type' to indicate that the referenced entity
         * is an owned child of this entity. That is, the 'reference' entity should be deleted
         * when this entity is deleted.
         *
         * Set this property instead of 'reference.type' to indicate that the referenced entity
         * is the owning parent of this entity. That is, this entity should be deleted when the
         * 'reference' entity is deleted.
         *
         * The name of the role played by the referenced entity. By default, this is the field
         * name (minus its "Id" suffix if present).
         *
         * The name of the inverse role (of this entity with respect to the 'reference'
         * entity). By default, this is the {@link Ext.util.Inflector#pluralize pluralized}
         * name of this entity, unless this 'reference' is 'unique', in which case the default
         * name is the {@link Ext.util.Inflector#singularize singularized} name of this entity.
         *
         * This config may also be an object containing a role, getter, or setter.
         *
         * Optional
         */
        reference?: string|any;

        /**
         * A function which converts a Field's value to a comparable value in order to ensure
         * correct sort ordering.
         *
         * Predefined functions are provided in {@link Ext.data.SortTypes}. A custom sort example:
         *
         *     // current sort     after sort we want
         *     // +-+------+          +-+------+
         *     // |1|First |          |1|First |
         *     // |2|Last  |          |3|Second|
         *     // |3|Second|          |2|Last  |
         *     // +-+------+          +-+------+
         *
         *     sortType: function(value) {
         *        switch (value.toLowerCase()) // native toLowerCase():
         *        {
         *           case 'first': return 1;
         *           case 'second': return 2;
         *           default: return 3;
         *        }
         *     }
         *
         * May also be set to a String value, corresponding to one of the named sort types in
         * {@link Ext.data.SortTypes}.
         */
        sortType?: Function|string;

        /**
         * 'true' if the value of this field is unique amongst all instances. When used with a
         * 'reference' this describes a "one-to-one" relationship. It is almost always the case
         * that a 'unique' field cannot also be {@link #allowBlank nullable}.
         *
         * Optional, Defaults to: false
         */
        unique?: boolean;

        /**
         * An array of {@link Ext.data.validator.Validator validators} for this field. These
         * 'validators' will only be passed a field value to validate.
         */
        validators?: any;
    }

    /**
     * Fields are used to define the members of a Model. They aren't instantiated directly;
     * instead, when we create a class that extends {@link Ext.data.Model}, it automatically
     * creates Field instances for each field configured in a {@link Ext.data.Model Model}.
     * For example, we might set up a model like this:
     *
     *     Ext.define('User', {
     *         extend: 'Ext.data.Model',
     *         fields: [
     *             'name', 'email',
     *             { name: 'age', type: 'int' },
     *             { name: 'gender', type: 'string', defaultValue: 'Unknown' }
     *         ]
     *     });
     *
     * Four fields will have been created for the User Model - name, email, age and gender.
     * Note that we specified a couple of different formats here; if we only pass in the string
     * name of the field (as with name and email), the field is set up with the 'auto' type.
     * It's as if we'd done this instead:
     *
     *     Ext.define('User', {
     *         extend: 'Ext.data.Model',
     *         fields: [
     *             { name: 'name', type: 'auto' },
     *             { name: 'email', type: 'auto' },
     *             { name: 'age', type: 'int' },
     *             { name: 'gender', type: 'string', defaultValue: 'Unknown' }
     *         ]
     *     });
     *
     * # Field Types
     *
     * Fields come in various types. When declaring a field, the 'type' property is used to
     * specify the type of 'Field' derived class used to manage values.
     *
     * The predefined set of types are:
     *
     *  - {@link Ext.data.field.Field auto} (Default, implies no conversion)
     *  - {@link Ext.data.field.String string}
     *  - {@link Ext.data.field.Integer int}
     *  - {@link Ext.data.field.Number number}
     *  - {@link Ext.data.field.Boolean boolean}
     *  - {@link Ext.data.field.Date date}
     *
     * # Conversion
     *
     * When reading fields it is often necessary to convert the values received before using
     * them or storing them in records. To handle these cases there is the
     * '{@link #method-convert convert}' method. This method is passed the received value (as
     * well as the current record instance, but see below) and it returns the value to carry
     * forward.
     *
     * For 'auto' fields there is no '{@link #method-convert convert}' method. This is for
     * efficiency. For other field types, there are often 'convert' methods. You can provide
     * a '{@link #cfg-convert convert}' config when the field is defined like this:
     *
     *      {
     *          name: 'timestamp',
     *
     *          convert: function (value) {
     *              return new Date(value);
     *          }
     *      }
     *
     * While this can be convenient, see below for details on defining Custom Types as that is
     * often a better practice and avoids repeating these functions.
     *
     * Note that when a 'defaultValue' is specified, it will also be passed through to
     * 'convert' (either to the '{@link #method-convert convert}' method or to the
     * '{@link #cfg-convert convert} config)'.
     *
     * ## Calculated Values
     *
     * In some cases fields are the result of a calculation from other fields. Historically
     * this was a second role for '{@link #method-convert convert}' but that has some short
     * comings. The simpler solution is the '{@link #cfg-calculate calculate}' config.
     *
     * Values produced by '{@link #cfg-calculate calculate}' and '{@link #method-convert convert}'
     * are stored in the record as with any other field. In fact, if we define a calculated
     * "firstName" field and log out all of the data, we'll see this:
     *
     *     var ed = Ext.create('User', { name: 'Ed Spencer' });
     *
     *     console.log(ed.data);
     *
     *     //outputs this:
     *     {
     *         age: 0,
     *         email: "",
     *         firstName: "Ed",  // calculated field
     *         gender: "Unknown",
     *         name: "Ed Spencer"
     *     }
     *
     * ### Using 'calculate'
     *
     *      {
     *          name: 'firstName',
     *
     *          calculate: function (data) {
     *              return data.name.split(' ')[0];
     *          }
     *      }
     *
     * Using '{@link #cfg-calculate calculate}' is the simplest and safest way to define a
     * calculated field. The most important part of this is that, internally, the code of the
     * supplied function is parsed to extract its dependencies. In this case, the "name" field
     * is the only dependency. This means that "firstName" will only need to be recalculated
     * when "name" is modified.
     *
     * **Note:** Fields used by the calculate method must be explicitly defined in the
     * {@link Ext.data.Model#cfg-fields #fields} of the model.
     *
     * ### Using 'convert'
     *
     * Following is the equivalent technique using '{@link #cfg-convert convert}'
     *
     *      {
     *          name: 'firstName',
     *
     *          convert: function (value, record) {
     *              return record.get('name').split(' ')[0];
     *          },
     *
     *          depends: [ 'name' ]
     *      }
     *
     * When a '{@link #method-convert convert}' function accepts a 2nd argument (a reference to
     * the record), it is considered a calculated field. If a '{@link #cfg-depends depends}'
     * config is not provided then this field's dependencies are unknown. In this case, the
     * '{@link #cfg-depends depends}' are provided as would be automatically determined with
     * the '{@link #cfg-calculate calculate}' config.
     *
     * ### Updating
     *
     * Fields modified with the {@link Ext.data.Model#set set} method will have their stored
     * value set using the convert / calculate method when present.
     *
     * For example:
     *
     *     Ext.define('MyApp.model.Employee', {
     *         extend: 'Ext.data.Model',
     *         fields: [{
     *             name: 'salary',
     *             convert: function (val) {
     *                 var startingBonus = val * .1;
     *                 return val + startingBonus;
     *             }
     *         }],
     *         convertOnSet: false
     *     });
     *
     *     var tina = Ext.create('MyApp.model.Employee', {
     *         salary: 50000
     *     });
     *
     *     console.log(tina.get('salary')); // logs 55000
     *
     *     tina.set('salary', 60000);
     *     console.log(tina.get('salary')); // logs 60000
     *
     * This default behavior can be disabled by setting the Model's
     * '{@link Ext.data.Model#cfg-convertOnSet}' config to 'false'.
     *
     * **Note:** convertOnSet 'false' only prevents the convert / calculate call when the
     * set 'fieldName' param matches the field's '{@link #name}'.  See
     * {@link Ext.data.Model#convertOnSet convertOnSet} for additional details.
     *
     * ### Dependencies
     *
     * When a field's '{@link #method-convert convert}' method processes values from the record
     * (vs. just the field's value), it is best to also provide a 'depends' config as shown
     * above. Fields that provide a '{@link #cfg-calculate calculate}' method must follow the
     * proper form for using fields so that dependencies can be extracted.
     *
     * Calculated fields are processed after other fields based on their dependencies. Fields
     * with '{@link #method-convert convert}' methods that use the provided record that do *not*
     * specify a '{@link #cfg-depends depends}' config are processed as a group after all other
     * fields since such converters can rely on anything in the record. The order of processing
     * these fields with respect to each other is unspecified and should not be relied upon.
     *
     * # Serialization
     *
     * To handle the inverse scenario of 'convert' there is the 'serialize' method. This
     * method is called to produce the value to send to a server based on the internal value
     * as would be returned from 'convert'. In most cases, these methods should "round trip"
     * a value:
     *
     *      assertEqual(value, field.serialize(field.convert(value)));
     *
     * By default, only '{@link Ext.data.field.Date date}' fields have a 'serialize' method.
     * Other types simply send their value unmodified.
     *
     * # Custom Types
     *
     * Developers may create their own application-specific data types by deriving from this
     * class. This is typically much better than applying multiple configuration values on
     * field instances as these often become repetitive.
     *
     * To illustrate, we define a "time" field type that stores a time-of-day represented as a
     * number of minutes since Midnight.
     *
     *      Ext.define('App.field.Time', {
     *          extend: 'Ext.data.field.Field',
     *
     *          alias: 'data.field.time',
     *
     *          timeFormat: 'g:i',
     *
     *          convert: function (value) {
     *              if (value && Ext.isString(value)) {
     *                  var date = Ext.Date.parse(value, this.timeFormat);
     *                  if (!date) {
     *                      return null;
     *                  }
     *                  return (date.getHours() - 1) * 60 + date.getMinutes();
     *              }
     *              return value;
     *          }
     *      });
     *
     * ## Validation
     *
     * Custom field types can override the '{@link #method-validate validate}' method or
     * provide a set of '{@link #cfg-validators validators}'.
     *
     *      Ext.define('App.field.PhoneNumber', {
     *          extend: 'Ext.data.field.Field',
     *
     *          alias: 'data.field.phonenumber',
     *
     *          // Match U.S. phone numbers for example purposes
     *          validators: {
     *              type: 'format',
     *              matcher: /\d{3}\-\d{3}\-\d{4}/
     *          }
     *      });
     *
     * Once the class is defined, fields can be declared using the new type (based on its
     * 'alias') like so:
     *
     *      Ext.define('App.model.PhoneCall', {
     *          fields: [
     *              { name: 'startTime', type: 'time' },
     *              { name: 'phoneNumber', type: 'phonenumber' }
     *          ]
     *      });
     */
    export class Field extends Ext.Base implements Ext.data.field.FieldConfig {
        /**
         * This property is 'true' if this field has a '{@link #cfg-calculate calculate}'
         * method or a '{@link #method-convert convert}' method that operates on the entire
         * record as opposed to just the data value. This property is determined from the
         * 'length' of the '{@link #method-convert convert}' function which means this is
         * *not* calculated:
         *
         *      convert: function (value) {
         *          return ...
         *      }
         *
         * While this *is* calculated:
         *
         *      convert: function (value, record) {
         *          return ...
         *      }
         *
         * **NOTE:** It is recommended for such fields to use '{@link #cfg-calculate calculate}'
         * or explicitly specify the fields used by '{@link #method-convert convert}' using
         * '{@link #cfg-depends depends}'.
         *
         * @readonly
         */
        calculated: boolean;

        /**
         * The default message to present for an invalid field.
         * @since 5.0.0
         */
        defaultInvalidMessage: string;

        /**
         * The class (derived from {@link Ext.data.Model}) that defined this field.
         *
         *      Ext.define('MyApp.models.Foo', {
         *          extend: 'Ext.data.Model',
         *
         *          fields: [
         *              { name: 'bar' }
         *          ],
         *          ...
         *      });
         *
         *      var barField = MyApp.models.Foo.getField('bar');
         *
         *      alert(barField.definedBy === MyApp.models.Foo); // alerts 'true'
         *
         * When a field is inherited, this value will reference the class that originally
         * defined the field.
         *
         *      Ext.define('MyApp.models.Base', {
         *          extend: 'Ext.data.Model',
         *
         *          fields: [
         *              { name: 'foo' }
         *          ],
         *          ...
         *      });
         *
         *      Ext.define('MyApp.models.Derived', {
         *          extend: 'MyApp.models.Base',
         *
         *          fields: [
         *              { name: 'bar' }
         *          ],
         *          ...
         *      });
         *
         *      var fooField = MyApp.models.Derived.getField('foo');
         *
         *      alert(fooField.definedBy === MyApp.models.Base); // alerts 'true'
         */
        definedBy: Ext.Class;

        factoryConfig: any;

        /**
         * This property is set to 'true' if this is an {@link Ext.data.Model#idProperty id}
         * field.
         * @readonly
         */
        identifier: boolean;

        /**
         * The position of this field in the {@link Ext.data.Model} in which it was defined.
         */
        ordinal: number;

        /**
         * A regular expression for stripping non-numeric characters from a numeric value.
         * This should be overridden for localization.
         * @readonly
         */
        protected stripRe: RegExp;

        /**
         * Use when converting received data into a {@link Ext.data.field.Integer 'int'},
         * {@link Ext.data.field.Number 'float'}, {@link Ext.data.field.Boolean 'bool'}
         * or {@link Ext.data.field.String 'string'} type. If the value cannot be
         * parsed, 'null' will be used if allowNull is true, otherwise a default value for that type will be used:
         *
         * - for 'int' and 'float' - '0'.
         * - for 'string' - '""'.
         * - for 'bool' - 'false'.
         *
         * Note that when parsing of {@link Ext.data.field.Date 'date'} type fails, the value will
         * be 'null' regardless of this setting.
         */
        allowNull: boolean;

        /**
         * This config defines a simple field calculation function. A calculate method only
         * has access to the record data and should return the value of the calculated field.
         * When provided in this way, the 'depends' config is automatically determined by
         * parsing the 'calculate' function. For example:
         *
         *      fields: [{
         *          name: 'firstName',
         *          type: 'string'
         *      },{
         *          name: 'lastName',
         *          type: 'string'
         *      },{
         *          name: 'fullName',
         *          calculate: function (data) {
         *              return data.firstName + ' ' + data.lastName;
         *          }
         *      }]
         *
         * The above 'fullName' field is equivalent to:
         *
         *      {
         *          name: 'fullName',
         *          convert: function (v, rec) {
         *              return rec.get('firstName') + ' ' + rec.get('lastName');
         *          },
         *          depends: ['firstName', 'lastName']
         *      }
         *
         * The restrictions on form for a 'calculate' method are that the accesses to field
         * values must match the following regular expression (case insensitive):
         *
         *      data.([a-z_][a-z0-9_]*)
         *      // where 'data' is the param passed to the calculate method
         *
         * The only advantage of a 'calculate' method over a 'convert' method is automatic
         * determination of 'depends'.
         *
         * **Note:** The use of calculate and {@link #method-convert} are exclusive.  The
         * calculate method will override the convert method if both are configured.
         *
         * **Note:** Fields used by the calculate method must be explicitly defined in the
         * {@link Ext.data.Model#cfg-fields #fields} of the model.
         *
         * @param {Object} data An object with all values for each field in the parent
         * model.  See {@link Ext.data.Model#getData getData}.
         * @return {Mixed} value The value of the calculated field
         */
        calculate: Function;

        /**
         * A critical field is a field that must always be sent to the server even if it has
         * not changed. The most common example of such a field is the "id" of a record (see
         * '{@link Ext.data.Model#idProperty}' but the '{@link Ext.data.Model#versionProperty}'
         * is similarly a 'critical' field.
         */
        critical: boolean;

        /**
         * The default value used when the creating an instance from a raw data object,
         * and the property referenced by the '{@link Ext.data.field.Field#mapping mapping}'
         * does not exist in that data object.
         *
         * The value 'undefined' prevents defaulting in a value.
         *
         * Optional, Defaults to: undefined
         */
        defaultValue: any;

        /**
         * The field name or names within the {@link Ext.data.Model Model} on which the value
         * of this field depends, and from which a new value may be calculated. These values
         * are the values used by the 'convert' method. If you do not have a 'convert' method
         * then this config should not be specified.
         *
         * Before using this config you should consider if using a 'calculate' method instead
         * of a 'convert' method would be simpler.
         *
         * Whenever any of the named fields are set using the {@link Ext.data.Model#set set}
         * method, this fields will have its 'convert' method called passing the
         * {@link Ext.data.Model record} so that the dependent value can be calculated from
         * all fields which it needs.
         *
         * For example, to display a person's full name, using two separate 'firstName' and
         * 'lastName' fields, configure the name field like this:
         *
         *     {
         *         name: 'name',
         *
         *         // Will be called whenever forename or surname fields are set
         *         convert: function (v, rec) {
         *             return rec.get('firstName') + ' ' + rec.get('lastName');
         *         },
         *
         *         depends: [ 'firstName', 'lastName' ],
         *
         *         // It should not be returned to the server - it's not a database field
         *         persist: false
         *     }
         *
         * Note that if you do not want the calculated field to be part of the field set sent
         * back to the server when the store is synchronized, you should configure the field
         * with 'persist' set to 'false'.
         *
         * Optional
         */
        depends: string;

        /**
         * (Optional) A path expression for use by the {@link Ext.data.reader.Reader} implementation that is creating the
         * {@link Ext.data.Model Model} to extract the Field value from the data object. If the path expression is the same
         * as the field name, the mapping may be omitted. A function may be passed to do complex data extraction. The examples
         * below are simple just to demonstrate the capability, typically, a function would not be used to extract such
         * simple data.
         *
         * The form of the mapping expression depends on the Reader being used.
         *
         * - {@link Ext.data.reader.Json}
         *
         *   The mapping is a string containing the javascript expression to reference the data from an element of the data
         *   item's {@link Ext.data.reader.Json#cfg-rootProperty rootProperty} Array. Defaults to the field name. If a function is passed,
         *   a single argument is received which contains the raw json object:
         *
         *       // Server returns [{"name": "Foo", "age": 1}, {"name": "Bar", "age": 2}]
         *       mapping: function(data) {
         *           return data.name;
         *       }
         *
         * - {@link Ext.data.reader.Xml}
         *
         *   The mapping is an {@link Ext.DomQuery} path to the data item relative to the DOM element that represents the
         *   {@link Ext.data.reader.Xml#record record}. Defaults to the field name. If a function is passed, a single argument
         *   is received which contains the record node:
         *
         *       // Server returns <Root><Person><Name>Foo</Name><Age>1</Age></Person><Person><Name>Bar</Name><Age>2</Age></Person></Root>
         *       mapping: function(data) {
         *           return data.firstChild.textContent;
         *       }
         *
         * - {@link Ext.data.reader.Array}
         *
         *   The mapping is a number indicating the Array index of the field's value. Defaults to the field specification's
         *   Array position. If a function is passed, a single argument is received which contains the child array.
         *
         *       // Server returns [["Foo", 1], ["Bar", 2]]
         *       mapping: function(data) {
         *           return data[0];
         *       }
         *
         * If a more complex value extraction strategy is required, then configure the Field with a {@link #cfg-convert}
         * function. This is passed the whole row object, and may interrogate it in whatever way is necessary in order to
         * return the desired data.
         */
        mapping: string|number|Function;

        /**
         * The name by which the field is referenced within the Model. This is referenced by,
         * for example, the 'dataIndex' property in column definition objects passed to
         * {@link Ext.grid.property.HeaderContainer}.
         *
         * Note: In the simplest case, if no properties other than 'name' are required, a
         * field definition may consist of just a String for the field name.
         */
        name: string;

        /**
         * False to exclude this field from the {@link Ext.data.Model#modified} fields in a
         * record. This will also exclude the field from being written using a
         * {@link Ext.data.writer.Writer}. This option is useful when fields are used to keep
         * state on the client but do not need to be persisted to the server.
         *
         * Defaults to 'false' for 'calculated' fields and 'true' otherwise.
         *
         * Optional
         */
        persist: boolean;

        /**
         * The {@link Ext.data.Model#entityName name} of the entity referenced by this field.
         * In most databases, this relationship is represented by a "foreign key". That is, a
         * value for such a field matches the value of the {@link Ext.data.Model#idProperty id}
         * for an entity of this type.
         *
         *      Ext.define('MyApp.models.Organization', {
         *          extend: 'Ext.data.Model',
         *          ...
         *      });
         *
         *      Ext.define('MyApp.models.User', {
         *          extend: 'Ext.data.Model',
         *
         *          fields: [
         *              { name: 'organizationId', reference: 'Organization' }
         *          ],
         *          ...
         *      });
         *
         * If a 'reference' is not nullable, set the {@link Ext.data.field.Field#allowBlank} property
         * to false.
         *
         *      Ext.define('MyApp.models.User', {
         *          extend: 'Ext.data.Model',
         *
         *          fields: [
         *              { name: 'organizationId', reference: 'Organization', allowBlank: false }
         *          ],
         *          ...
         *      });
         *
         * If the name of the generated {@link Ext.data.schema.Association association} or other aspects
         * need to be specified, the 'reference' can be an object. The following usage shows
         * what would be generated by default given the above examples using the string form.
         *
         *      Ext.define('MyApp.models.User', {
         *          extend: 'Ext.data.Model',
         *
         *          fields: [{
         *              name: 'organizationId',
         *              reference: {
         *                  type: 'Organization',
         *                  association: 'UsersByOrganization',
         *                  role: 'organization',
         *                  inverse: 'users'
         *              }
         *          }],
         *          ...
         *      });
         *
         * Finally, a 'reference' can also describe ownership between the entities. By default,
         * no ownership relationship is assumed. If, however, the User entities are owned by
         * their Organization, we could say this:
         *
         *      Ext.define('MyApp.models.User', {
         *          extend: 'Ext.data.Model',
         *
         *          fields: [{
         *              name: 'organizationId',
         *              reference: {
         *                  parent: 'Organization' // Organization is the parent of User
         *              }
         *          }],
         *          ...
         *      });
         *
         * The type which this field references. This is the value set by the string form of
         * 'reference'. If the referenced entity has an ownership relationship this field
         * should be omitted and 'reference.parent' or 'reference.child' should be specified
         * instead.
         *
         * The name of the association. By default, the name of the association is the
         * capitalized 'inverse' plus "By" plus the capitalized 'role'.
         *
         * Set this property instead of 'reference.type' to indicate that the referenced entity
         * is an owned child of this entity. That is, the 'reference' entity should be deleted
         * when this entity is deleted.
         *
         * Set this property instead of 'reference.type' to indicate that the referenced entity
         * is the owning parent of this entity. That is, this entity should be deleted when the
         * 'reference' entity is deleted.
         *
         * The name of the role played by the referenced entity. By default, this is the field
         * name (minus its "Id" suffix if present).
         *
         * The name of the inverse role (of this entity with respect to the 'reference'
         * entity). By default, this is the {@link Ext.util.Inflector#pluralize pluralized}
         * name of this entity, unless this 'reference' is 'unique', in which case the default
         * name is the {@link Ext.util.Inflector#singularize singularized} name of this entity.
         *
         * This config may also be an object containing a role, getter, or setter.
         *
         * Optional
         */
        reference: string|any;

        /**
         * A function which converts a Field's value to a comparable value in order to ensure
         * correct sort ordering.
         *
         * Predefined functions are provided in {@link Ext.data.SortTypes}. A custom sort example:
         *
         *     // current sort     after sort we want
         *     // +-+------+          +-+------+
         *     // |1|First |          |1|First |
         *     // |2|Last  |          |3|Second|
         *     // |3|Second|          |2|Last  |
         *     // +-+------+          +-+------+
         *
         *     sortType: function(value) {
         *        switch (value.toLowerCase()) // native toLowerCase():
         *        {
         *           case 'first': return 1;
         *           case 'second': return 2;
         *           default: return 3;
         *        }
         *     }
         *
         * May also be set to a String value, corresponding to one of the named sort types in
         * {@link Ext.data.SortTypes}.
         */
        sortType: Function|string;

        /**
         * 'true' if the value of this field is unique amongst all instances. When used with a
         * 'reference' this describes a "one-to-one" relationship. It is almost always the case
         * that a 'unique' field cannot also be {@link #allowBlank nullable}.
         *
         * Optional, Defaults to: false
         */
        unique: boolean;

        /**
         * An array of {@link Ext.data.validator.Validator validators} for this field. These
         * 'validators' will only be passed a field value to validate.
         */
        validators: any;

        /**
         * Compares two values to retrieve their relative position in sort order, taking into account
         * any {@link #sortType}. Also see {@link #compare}.
         * @param {Object} value1 The first value.
         * @param {Object} value2 The second value.
         * @return {Number} '-1' if 'value1' is less than 'value2'. '1' if 'value1' is greater than 'value2'.
         * '0' otherwise.
         */
        collate(value1: any, value2: any): number;

        /**
         * Compares two values to retrieve their relative position in sort order. Also see
         * {@link #collate}.
         * @param {Object} value1 The first value.
         * @param {Object} value2 The second value.
         * @return {Number} '-1' if 'value1' is less than 'value2'. '1' if 'value1' is greater than 'value2'.
         * '0' otherwise.
         */
        compare(value1: any, value2: any): number;

        constructor(config: Ext.data.field.DateConfig);

        /**
         * A function which converts the value provided by the Reader into the value that will
         * be stored in the record. This method can be overridden by a derived class or set as
         * a '{@link #cfg-convert convert}' config.
         *
         * If configured as 'null', then no conversion will be applied to the raw data property
         * when this Field is read. This will increase performance. but you must ensure that
         * the data is of the correct type and does not *need* converting.
         *
         * Example of convert functions:
         *
         *     function fullName(v, record){
         *         return record.data.last + ', ' + record.data.first;
         *     }
         *
         *     function location(v, record){
         *         return !record.data.city ? '' : (record.data.city + ', ' + record.data.state);
         *     }
         *
         *     Ext.define('Dude', {
         *         extend: 'Ext.data.Model',
         *         fields: [
         *             {name: 'fullname',  convert: fullName},
         *             {name: 'firstname', mapping: 'name.first'},
         *             {name: 'lastname',  mapping: 'name.last'},
         *             {name: 'city', defaultValue: 'unknown'},
         *             'state',
         *             {name: 'location',  convert: location}
         *         ]
         *     });
         *
         *     // create the data store
         *     var store = Ext.create('Ext.data.Store', {
         *         model: 'Dude',
         *         proxy: {
         *             type: 'memory',
         *             reader: {
         *                 type: 'json',
         *                 rootProperty: 'daRoot',
         *                 totalProperty: 'total'
         *             }
         *         }
         *     });
         *
         *     var myData = [
         *         { key: 1,
         *           name: { first: 'Fat',    last:  'Albert' }
         *           // notice no city, state provided in data object
         *         },
         *         { key: 2,
         *           name: { first: 'Barney', last:  'Rubble' },
         *           city: 'Bedrock', state: 'Stoneridge'
         *         },
         *         { key: 3,
         *           name: { first: 'Cliff',  last:  'Claven' },
         *           city: 'Boston',  state: 'MA'
         *         }
         *     ];
         *
         * @param {Mixed} value The data value as read by the Reader, if undefined will use
         * the configured 'defaultValue'.
         * @param {Ext.data.Model} record The data object containing the Model as read so far
         * by the Reader. Note that the Model may not be fully populated at this point as the
         * fields are read in the order that they are defined.
         * {@link Ext.data.Model#cfg-fields fields} array.
         * @return {Mixed} The converted value for storage in the record.
         */
        convert(value: any, record: Ext.data.Model): any;

        /**
         * Gets allowBlank for this field. See {@link #allowBlank}.
         * @return {Boolean} allowBlank
         */
        getAllowBlank(): boolean;

        /**
         * Gets allowNull for this field. See {@link #allowNull}.
         * @return {Boolean} allowNull
         */
        getAllowNull(): boolean;

        /**
         * Gets converter for this field. See {@link #method-convert}.
         * @return {Function} convert
         */
        getConvert(): Function;

        /**
         * Gets the defaultValue for this field. See {@link #defaultValue}.
         * @return {Object} defaultValue
         */
        getDefaultValue(): any;

        /**
         * Gets the depends for this field. See {@link #depends}.
         * @return {String[]} depends
         */
        getDepends(): string;

        /**
         * Get the mapping for this field. See {@link #mapping}.
         * @return {Object} mapping
         */
        getMapping(): any;

        /**
         * Gets the persist for this field. See {@link #persist}.
         * @return {Boolean} persist
         */
        getPersist(): boolean;

        /**
         * Gets the sortDir for this field.
         * @return {String} sortDir
         * @deprecated 5.1 Setting sortDir and calling getSortDir were never applied by the
         * the Sorter.  This functionality does not natively exist on field instances.
         */
        getSortDir(): string;

        /**
         * Gets the sortType for this field. See {@link #sortType}.
         * @return {Function} sortType
         */
        getSortType(): Function;

        /**
         * Gets a string representation of the type of this field.
         * @return {String} type
         */
        getType(): string;

        /**
         * Checks if this field has a mapping applied.
         * @return {Boolean} 'true' if this field has a mapping.
         */
        hasMapping(): boolean;

        /**
         * Tests whether two values are equal based on this field type.
         * This uses the {@link #compare} method to determine equality, so
         * this method should generally not be overridden.
         * @param {Object} value1 The first value.
         * @param {Object} value2 The second value.
         * @return {Boolean} 'true' if the values are equal.
         */
        isEqual(value1: any, value2: any): boolean;

        /**
         * A function which converts the Model's value for this Field into a form which can be used by whatever {@link Ext.data.writer.Writer Writer}
         * is being used to sync data with the server.
         *
         * @param {Mixed} value The Field's value - the value to be serialized.
         * @param {Ext.data.Model} record The record being serialized.
         * @return {String} The string that represents the Field's value.
         */
        serialize(value: any, record: Ext.data.Model): string;

        /**
         * Validates the passed value for this field.
         *
         * @param {Object} value The value to validate.
         *
         * @param {String} [separator] This string is passed if the caller wants all validation
         * messages concatenated with this string between each. This can be handled as a
         * "falsy" value because concatenating with no separator is seldom desirable.
         *
         * @param {Ext.data.ErrorCollection} [errors] This parameter is passed if the caller
         * wants all validation results individually added to the collection.
         *
         * @return {Boolean/String} 'true' if the value is valid. A string may be returned if
         * the value is not valid, to indicate an error message. Any other non 'true' value
         * indicates the value is not valid. This method is not implemented by default,
         * subclasses may override it to provide an implementation.
         *
         * @since 5.0.0
         */
        protected validate(value: any, separator?: string, errors?: Ext.data.ErrorCollection): boolean|string;
    }

    export class Integer extends Ext.data.field.Field {
        constructor(config: Ext.data.field.DateConfig);
    }

    export class Number extends Ext.data.field.Integer {
        constructor(config: Ext.data.field.DateConfig);
    }

    interface StringConfig extends Ext.data.field.FieldConfig {
        sortType?: any;
    }

    export class String extends Ext.data.field.Field implements Ext.data.field.StringConfig {
        sortType: Function|string;

        constructor(config: Ext.data.field.DateConfig);
    }
}

declare module Ext.data.flash {
    /**
     * Simulates an XMLHttpRequest object's methods and properties as returned
     * form the flash polyfill plugin. Used in submitting binary data in browsers that do
     * not support doing so from JavaScript.
     * NOTE: By default this will look for the flash object in the ext directory. When packaging and deploying the app, copy the <tt>ext/plugins</tt> directory and its contents to your root directory. For custom deployments where just the <tt>FlashPlugin.swf</tt> file gets copied (e.g. to <tt>/resources/FlashPlugin.swf</tt>), make sure to notify the framework of the location of the plugin before making the first attempt to post binary data, e.g. in the <tt>launch</tt> method of your app do:
     * <pre><code>
     Ext.flashPluginPath="/resources/FlashPlugin.swf";
     </code></pre>
     */
    export class BinaryXhr extends Ext.Base {
        /**
         * The connection's simulated readyState. Note that the only supported values are 0, 1 and 4. States 2 and 3 will never be reported.
         */
        readyState: number;

        /**
         * The binary bytes returned.
         */
        responseBytes: any[];

        /**
         * Connection status code returned by flash or the server.
         */
        status: number;

        /**
         * Status text (if any) returned by flash or the server.
         */
        statusText: any;

        /**
         * Abort this connection. Sets its readyState to 4.
         */
        abort();

        /**
         * Creates a new instance of BinaryXhr.
         */
        constructor();

        /**
         * As in XMLHttpRequest.
         */
        getAllResponseHeaders();

        /**
         * As in XMLHttpRequest.
         */
        getResponseHeader();

        /**
         * As in XMLHttpRequest.
         */
        onreadystatechange();

        /**
         * As in XMLHttpRequest.
         */
        open();

        /**
         * As in XMLHttpRequest.
         */
        overrideMimeType();

        /**
         * Initiate the request.
         * @param {Array} body an array of byte values to send.
         */
        send(body: any[]);

        /**
         * As in XMLHttpRequest.
         */
        setRequestHeader();
    }
}

declare module Ext.data.identifier {
    interface GeneratorConfig {
        /**
         * The id for this generator.
         */
        id?: string;
    }

    /**
     * This class is a base for all id generators. It also provides lookup of id generators by
     * their id.
     *
     * Generally, id generators are used to generate a primary key for new model instances. There
     * are different approaches to solving this problem, so this mechanism has both simple use
     * cases and is open to custom implementations. A {@link Ext.data.Model} requests id generation
     * using the {@link Ext.data.Model#identifier} property.
     *
     * The following types of 'identifiers' are provided:
     *
     *   * '{@link Ext.data.identifier.Sequential sequential}'
     *   * '{@link Ext.data.identifier.Negative negative}'
     *   * '{@link Ext.data.identifier.Uuid uuid}'
     *
     * In most cases (other than 'uuid'), the server is the only party that can generate
     * authoritative id values. This means that any id generated by an 'identifier' should be
     * consider "provisional" and must eventually be reconciled with the server. This makes a
     * 'uuid' very attractive as an 'identifier' because they are designed to be generated in
     * a distributed manner and therefore never require reconciliation.
     *
     * It is common for id values to be generated as increasing integer values (1, 2, etc.) by
     * the server when records are inserted. A '{@link Ext.data.identifier.Negative negative}'
     * 'identifier' may be useful as it generates client-side values of -1, -2, etc.. These
     * values are of the same data type (integer) and so can typically be read by servers
     * using typed languages (such as Java or C#) and easily recognized as provisional.
     *
     * In the end, the choice of 'identifier' strategy requires agreement between client and
     * server.
     *
     * # Identity, Type and Shared Generators
     *
     * It is often desirable to share Generators to ensure uniqueness or common configuration.
     * This is done by giving Generator instances an id property by which they can be looked
     * up using the {@link Ext.Factory#dataIdentifier dataIdentifier} method. To configure two {@link Ext.data.Model Model} classes
     * to share one {@link Ext.data.identifier.Sequential sequential} id generator, you simply
     * assign them the same id:
     *
     *     Ext.define('MyApp.data.MyModelA', {
     *         extend: 'Ext.data.Model',
     *         identifier: {
     *             type: 'sequential',
     *             id: 'foo'
     *         }
     *     });
     *
     *     Ext.define('MyApp.data.MyModelB', {
     *         extend: 'Ext.data.Model',
     *         identifier: {
     *             type: 'sequential',
     *             id: 'foo'
     *         }
     *     });
     *
     * To make this as simple as possible for generator types that are shared by many (or all)
     * Models, the Generator types (such as 'sequential' or 'uuid') are also reserved as
     * generator ids. This is used by the {@link Ext.data.identifier.Uuid} which has an id equal
     * to its type ('uuid'). In other words, the following Models share the same generator:
     *
     *     Ext.define('MyApp.data.MyModelX', {
     *         extend: 'Ext.data.Model',
     *         identifier: 'uuid'
     *     });
     *
     *     Ext.define('MyApp.data.MyModelY', {
     *         extend: 'Ext.data.Model',
     *         identifier: 'uuid'
     *     });
     *
     * This can be overridden (by specifying the id explicitly), but there is no particularly
     * good reason to do so for this generator type.
     *
     * # Creating Custom Generators
     *
     * An id generator should derive from this class and implement the {@link #generate} method.
     *
     * To register an id generator type, a derived class should provide an 'alias' like so:
     *
     *     Ext.define('MyApp.data.identifier.Custom', {
     *         extend: 'Ext.data.identifier.Generator',
     *         alias: 'data.identifier.custom',
     *         config: {
     *             configProp: 42 // some config property w/default value
     *         }
     *
     *         generate: function () {
     *             return ... // a new id
     *         }
     *     });
     *
     * Using the custom id generator is then straightforward:
     *
     *     Ext.define('MyApp.data.MyModel', {
     *         extend: 'Ext.data.Model',
     *         identifier: 'custom'
     *     });
     *     // or...
     *
     *     Ext.define('MyApp.data.MyModel', {
     *         extend: 'Ext.data.Model',
     *         identifier: {
     *             type: 'custom',
     *             configProp: value
     *         }
     *     });
     *
     * It is not recommended to mix shared generators with generator configuration. This leads
     * to unpredictable results unless all configurations match (which is also redundant). In
     * such cases, a custom generator with a default id is the best approach.
     *
     *     Ext.define('MyApp.data.identifier.Custom', {
     *         extend: 'Ext.data.identifier.Sequential',
     *         alias: 'data.identifier.custom',
     *
     *         config: {
     *             id: 'custom',
     *             prefix: 'ID_',
     *             seed: 1000
     *         }
     *     });
     *
     *     Ext.define('MyApp.data.MyModelX', {
     *         extend: 'Ext.data.Model',
     *         identifier: 'custom'
     *     });
     *
     *     Ext.define('MyApp.data.MyModelY', {
     *         extend: 'Ext.data.Model',
     *         identifier: 'custom'
     *     });
     *
     *     // the above models share a generator that produces ID_1000, ID_1001, etc..
     */
    export class Generator extends Ext.Base implements Ext.data.identifier.GeneratorConfig {
        factoryConfig: any;

        /**
         * 'true' in this class to identify an object as an instantiated IdGenerator, or subclass thereof.
         */
        isGenerator: boolean;

        /**
         * The id for this generator.
         */
        id: string;

        /**
         * Initializes a new instance.
         * @param {Object} config (optional) Configuration object to be applied to the new instance.
         */
        constructor(config: Ext.data.identifier.GeneratorConfig);

        /**
         * Generates and returns the next id. This method must be implemented by the derived
         * class.
         *
         * @return {Number/String} The next id.
         * @abstract
         */
        generate(): number|string;

        getId();

        setId();
    }

    interface NegativeConfig extends Ext.data.identifier.SequentialConfig {
        increment?: any;

        seed?: any;
    }

    /**
     * This class id generator produces successive negative numbers for id's. That is, -1, -2,
     * etc..
     *
     * The advantage of this type of 'identifier' is that these are seldom valid server-side
     * id values (which typically start at 1 and increase from there) but are of the same
     * data type (integer). This means that these values can typically be deserialized by a
     * server and then recognized as provisionally generated.
     */
    export class Negative extends Ext.data.identifier.Sequential implements Ext.data.identifier.NegativeConfig {
        increment: number;

        seed: number;

        /**
         * Initializes a new instance.
         * @param {Object} config (optional) Configuration object to be applied to the new instance.
         */
        constructor(config: Ext.data.identifier.GeneratorConfig);

        getIncrement();

        getSeed();

        setIncrement();

        setSeed();
    }

    interface SequentialConfig extends Ext.data.identifier.GeneratorConfig {
        /**
         * The number by which to adjust the 'seed' after for the next sequential id.
         */
        increment?: number;

        /**
         * The string to place in front of the sequential number for each generated id.
         */
        prefix?: string;

        /**
         * The number at which to start generating sequential id's.
         */
        seed?: number;
    }

    /**
     * This class is a sequential id generator. A simple use of this class would be like so:
     *
     *     Ext.define('MyApp.data.MyModel', {
     *         extend: 'Ext.data.Model',
     *         identifier: 'sequential'
     *     });
     *     // assign id's of 1, 2, 3, etc.
     *
     * An example of a configured generator would be:
     *
     *     Ext.define('MyApp.data.MyModel', {
     *         extend: 'Ext.data.Model',
     *         identifier: {
     *             type: 'sequential',
     *             prefix: 'ID_',
     *             seed: 1000,
     *             increment: 10
     *         }
     *     });
     *     // assign id's of ID_1000, ID_1010, ID_1020, etc.
     */
    export class Sequential extends Ext.data.identifier.Generator implements Ext.data.identifier.SequentialConfig {
        /**
         * The number by which to adjust the 'seed' after for the next sequential id.
         */
        increment: number;

        /**
         * The string to place in front of the sequential number for each generated id.
         */
        prefix: string;

        /**
         * The number at which to start generating sequential id's.
         */
        seed: number;

        /**
         * Initializes a new instance.
         * @param {Object} config (optional) Configuration object to be applied to the new instance.
         */
        constructor(config: Ext.data.identifier.GeneratorConfig);

        getIncrement();

        getPrefix();

        getSeed();

        setIncrement();

        setPrefix();

        setSeed();
    }

    interface UuidConfig extends Ext.data.identifier.GeneratorConfig {
        /**
         * A clock value to help avoid duplicates.
         *
         * Only applicable when 'version' is set to '1'.
         *
         * Optional
         */
        clockSeq?: number;

        /**
         * The id for this generator instance. By default all model instances share the same
         * UUID generator instance. By specifying an id other then 'uuid', a unique generator instance
         * will be created for the Model.
         */
        id?: any;

        /**
         * This value is a 48-bit number. This can be a number or an object with 'hi' and 'lo'
         * properties where 'lo' is the low 32-bits and 'hi' is the upper 16 bits.
         *
         * Only applicable when 'version' is set to '1'.
         *
         * Optional
         */
        salt?: number|any;

        /**
         * When created, this value is a 60-bit number. This can be a number or an object with
         * 'hi' and 'lo' properties where 'lo' is the low 32-bits and 'hi' is the upper 28 bits.
         *
         * Only applicable when 'version' is set to '1'.
         *
         * Optional
         */
        timestamp?: number|any;

        /**
         * The Version of UUID. Supported values are:
         *
         *  * 1 : Time-based, "sequential" UUID. To use this type of generator, you must also
         *  specify the 'salt', 'timestamp' and 'clock' properties. For details on the values
         *  and how a server should produce them, see RFC 4122. Use of this type of generator
         *  produces values that are easier to read since they are sequential, but requires
         *  some care to initialize properly and still ensure their uniqueness.
         *
         *  * 4 : Pseudo-random UUID. This is the simplest form and requires no configuration
         *  and hence is the default type.
         *
         * Optional, Defaults to: 4
         */
        version?: number;
    }

    /**
     * This class generates UUID's according to RFC 4122. This class has a default id property.
     * This means that a single instance is shared unless the id property is overridden. Thus,
     * two {@link Ext.data.Model} instances configured like the following share one generator:
     *
     *     Ext.define('MyApp.data.MyModelX', {
     *         extend: 'Ext.data.Model',
     *         identifier: 'uuid'
     *     });
     *
     *     Ext.define('MyApp.data.MyModelY', {
     *         extend: 'Ext.data.Model',
     *         identifier: 'uuid'
     *     });
     *
     * This allows all models using this class to share a commonly configured instance.
     *
     * # Using Version 1 ("Sequential") UUID's
     *
     * If a server can provide a proper timestamp and a "cryptographic quality random number"
     * (as described in RFC 4122), the shared instance can be configured as follows:
     *
     *     Ext.data.identifier.Uuid.Global.reconfigure({
     *         version: 1,
     *         clockSeq: clock, // 14 random bits
     *         salt: salt,      // 48 secure random bits (the Node field)
     *         timestamp: ts    // timestamp per Section 4.1.4
     *     });
     *
     *     // or these values can be split into 32-bit chunks:
     *
     *     Ext.data.identifier.Uuid.Global.reconfigure({
     *         version: 1,
     *         clockSeq: clock,
     *         salt: { lo: saltLow32, hi: saltHigh32 },
     *         timestamp: { lo: timestampLow32, hi: timestamptHigh32 }
     *     });
     *
     * This approach improves the generator's uniqueness by providing a valid timestamp and
     * higher quality random data. Version 1 UUID's should not be used unless this information
     * can be provided by a server and care should be taken to avoid caching of this data.
     *
     * See [http://www.ietf.org/rfc/rfc4122.txt](http://www.ietf.org/rfc/rfc4122.txt) for details.
     */
    export class Uuid extends Ext.data.identifier.Generator implements Ext.data.identifier.UuidConfig {
        /**
         * A clock value to help avoid duplicates.
         *
         * Only applicable when 'version' is set to '1'.
         *
         * Optional
         */
        clockSeq: number;

        /**
         * The id for this generator instance. By default all model instances share the same
         * UUID generator instance. By specifying an id other then 'uuid', a unique generator instance
         * will be created for the Model.
         */
        id: string;

        /**
         * This value is a 48-bit number. This can be a number or an object with 'hi' and 'lo'
         * properties where 'lo' is the low 32-bits and 'hi' is the upper 16 bits.
         *
         * Only applicable when 'version' is set to '1'.
         *
         * Optional
         */
        salt: number|any;

        /**
         * When created, this value is a 60-bit number. This can be a number or an object with
         * 'hi' and 'lo' properties where 'lo' is the low 32-bits and 'hi' is the upper 28 bits.
         *
         * Only applicable when 'version' is set to '1'.
         *
         * Optional
         */
        timestamp: number|any;

        /**
         * The Version of UUID. Supported values are:
         *
         *  * 1 : Time-based, "sequential" UUID. To use this type of generator, you must also
         *  specify the 'salt', 'timestamp' and 'clock' properties. For details on the values
         *  and how a server should produce them, see RFC 4122. Use of this type of generator
         *  produces values that are easier to read since they are sequential, but requires
         *  some care to initialize properly and still ensure their uniqueness.
         *
         *  * 4 : Pseudo-random UUID. This is the simplest form and requires no configuration
         *  and hence is the default type.
         *
         * Optional, Defaults to: 4
         */
        version: number;

        /**
         * Initializes a new instance.
         * @param {Object} config (optional) Configuration object to be applied to the new instance.
         */
        constructor(config: Ext.data.identifier.GeneratorConfig);

        getId();

        /**
         * Reconfigures this generator given new config properties. The only values that this
         * changes are 'version' and, if 'version' is 1, its related config properties.
         */
        reconfigure();

        setId();
    }
}

declare module Ext.data.matrix {
    /**
     * This class manages a many-to-many matrix for a 'Session'.
     */
    export class Matrix extends Ext.Base {
        /**
         * The 'ManyToMany' association for this matrix.
         * @readonly
         */
        association: Ext.data.schema.ManyToMany;

        /**
         * The 'Session' owning this matrix.
         * @readonly
         */
        session: Ext.data.Session;

        constructor();

        destroy();
    }

    /**
     * This class manages one side of a 'Matrix'.
     */
    export class Side extends Ext.Base {
        /**
         * Either 0 or 1 which is the index of our id value in an association entry.
         * @readonly
         */
        index: number;

        /**
         * Reference to the opposite side of the matrix.
         * @readonly
         */
        inverse: Ext.data.matrix.Side;

        /**
         * @readonly
         */
        matrix: Ext.data.matrix.Matrix;

        /**
         * The role for this side of the matrix.
         * @readonly
         */
        role: Ext.data.schema.Role;

        /**
         * Keyed by the id for this side of the matrix to yield a 'Slice'.
         * @readonly
         */
        slices: any;

        destroy();
    }

    /**
     * This class manages one side of a 'Matrix'.
     */
    export class Slice extends Ext.Base {
        /**
         * The id of the interested entity. Based on whether this slice is on the "left"
         * or "right" of the matrix, this id identities the respective entity.
         * @readonly
         */
        id: string|number;

        members: any;

        /**
         * The side of the matrix to which this slice belongs.
         */
        side: Ext.data.matrix.Side;

        constructor(side: any, id: any);

        destroy();
    }
}

declare module Ext.data.operation {
    /**
     * Enacpsulates a create operation as performed by a {@link Ext.data.proxy.Proxy proxy}.
     *
     * This class is instantiated by {@link Ext.data.Store stores} and {@link Ext.data.Model records} and should
     * not need to be instantiated in user code.
     */
    export class Create extends Ext.data.operation.Operation {
        /**
         * Creates new Operation object.
         * @param {Object} config (optional) Config object.
         */
        constructor(config: Ext.data.operation.OperationConfig);

        getRecordCreator();

        setRecordCreator();
    }

    /**
     * Enacapsulates a destroy operation as performed by a {@link Ext.data.proxy.Proxy proxy}.
     *
     * This class is instantiated by {@link Ext.data.Store stores} and {@link Ext.data.Model records} and should
     * not need to be instantiated in user code.
     */
    export class Destroy extends Ext.data.operation.Operation {
        /**
         * Creates new Operation object.
         * @param {Object} config (optional) Config object.
         */
        constructor(config: Ext.data.operation.OperationConfig);
    }

    interface OperationConfig {
        /**
         * The batch for this operation, if applicable
         */
        batch?: any;

        /**
         * Function to execute when operation completed.
         * Array of records.
         * The Operation itself.
         * True when operation completed successfully.
         */
        callback?: Function;

        /**
         * The id of the operation.
         */
        id?: any;

        /**
         * Parameters to pass along with the request when performing the operation.
         */
        params?: any;

        /**
         * The proxy for this operation
         */
        proxy?: Ext.data.proxy.Proxy;

        /**
         * The records associated with this operation. If this is a 'read' operation, this will be
         * 'null' until data is returned from the {@link Ext.data.proxy.Proxy}.
         */
        records?: Ext.data.Model;

        /**
         * The request for this operation.
         */
        request?: Ext.data.Request;

        /**
         * The ResultSet for this operation.
         */
        resultSet?: Ext.data.ResultSet;

        /**
         * Scope for the {@link #callback} function.
         */
        scope?: any;

        /**
         * True if this Operation is to be executed synchronously. This property is inspected by a
         * {@link Ext.data.Batch Batch} to see if a series of Operations can be executed in parallel or not.
         */
        synchronous?: boolean;

        /**
         * The url for this operation. Typically this will be provided by a proxy and not configured here.
         */
        url?: string;
    }

    /**
     * Represents a read or write operation performed by a {@link Ext.data.proxy.Proxy Proxy}.
     * Operation objects are used to enable communication between Stores and Proxies.
     * Application developers should rarely need to interact with Operation objects directly.
     *
     * Several Operations can be batched together in a {@link Ext.data.Batch batch}.
     */
    export class Operation extends Ext.Base implements Ext.data.operation.OperationConfig {
        /**
         * The batch for this operation, if applicable
         */
        batch: any;

        /**
         * Function to execute when operation completed.
         * Array of records.
         * The Operation itself.
         * True when operation completed successfully.
         */
        callback: Function;

        /**
         * The id of the operation.
         */
        id: any;

        /**
         * Parameters to pass along with the request when performing the operation.
         */
        params: any;

        /**
         * The proxy for this operation
         */
        proxy: Ext.data.proxy.Proxy;

        /**
         * The records associated with this operation. If this is a 'read' operation, this will be
         * 'null' until data is returned from the {@link Ext.data.proxy.Proxy}.
         */
        records: Ext.data.Model;

        /**
         * The request for this operation.
         */
        request: Ext.data.Request;

        /**
         * The ResultSet for this operation.
         */
        resultSet: Ext.data.ResultSet;

        /**
         * Scope for the {@link #callback} function.
         */
        scope: any;

        /**
         * True if this Operation is to be executed synchronously. This property is inspected by a
         * {@link Ext.data.Batch Batch} to see if a series of Operations can be executed in parallel or not.
         */
        synchronous: boolean;

        /**
         * The url for this operation. Typically this will be provided by a proxy and not configured here.
         */
        url: string;

        /**
         * Aborts the processing of this operation on the {@link #proxy}.
         * This is only valid for proxies that make asynchronous requests.
         */
        abort();

        /**
         * Checks whether this operation should cause writing to occur.
         * @return {Boolean} Whether the operation should cause a write to occur.
         */
        allowWrite(): boolean;

        /**
         * Creates new Operation object.
         * @param {Object} config (optional) Config object.
         */
        constructor(config: Ext.data.operation.OperationConfig);

        /**
         * Process records in the operation after the response is successful and the result
         * set is parsed correctly. The base class implementation of this method is used by
         * "create" and "update" operations to allow the server response to update the client
         * side records.
         *
         * @param {Ext.data.ResultSet} resultSet The result set
         * @param {Ext.data.Request} request The request
         * @param {Object} response The response
         */
        protected doProcess(resultSet: Ext.data.ResultSet, request: Ext.data.Request, response: any);

        getBatch();

        getCallback();

        /**
         * Returns the error string or object that was set using {@link #setException}
         * @return {String/Object} The error object
         */
        getError(): string|any;

        getId();

        getParams();

        getProxy();

        /**
         * Returns the {@link Ext.data.Model record}s associated with this operation. For read
         * operations the records as set by the {@link Ext.data.proxy.Proxy Proxy} will be
         * returned (returns 'null' if the proxy has not yet set the records).
         *
         * For create, update, and destroy operations the operation's initially configured
         * records will be returned, although the proxy may modify these records' data at some
         * point after the operation is initialized.
         *
         * @return {Ext.data.Model[]}
         */
        getRecords(): Ext.data.Model;

        getRequest();

        getResultSet();

        getScope();

        getSynchronous();

        getUrl();

        /**
         * Returns true if this Operation encountered an exception (see also {@link #getError})
         * @return {Boolean} True if there was an exception
         */
        hasException(): boolean;

        /**
         * Returns true if the Operation has been completed
         * @return {Boolean} True if the Operation is complete
         */
        isComplete(): boolean;

        /**
         * Returns true if the Operation has been started but has not yet completed.
         * @return {Boolean} True if the Operation is currently running
         */
        isRunning(): boolean;

        /**
         * Returns true if the Operation has been started. Note that the Operation may have started AND completed, see
         * {@link #isRunning} to test if the Operation is currently running.
         * @return {Boolean} True if the Operation has started
         */
        isStarted(): boolean;

        setBatch();

        setCallback();

        /**
         * Marks the Operation as completed.
         */
        setCompleted();

        /**
         * Marks the Operation as having experienced an exception. Can be supplied with an option error message/object.
         * @param {String/Object} error (optional) error string/object
         */
        setException(error: string|any);

        setId();

        setParams();

        setProxy();

        setRecords();

        setRequest();

        setResultSet();

        setScope();

        /**
         * Marks the Operation as started.
         */
        setStarted();

        /**
         * Marks the Operation as successful.
         * @param {Boolean} [complete] 'true' to also mark this operation
         * as being complete See {@link #setCompleted}.
         */
        setSuccessful(complete?: boolean);

        setSynchronous();

        setUrl();

        /**
         * Returns true if the Operation has completed and was successful
         * @return {Boolean} True if successful
         */
        wasSuccessful(): boolean;
    }

    interface ReadConfig extends Ext.data.operation.OperationConfig {
        /**
         * Optional array of filter objects. Only applies to 'read' actions.
         */
        filters?: Ext.util.Filter;

        /**
         * Optional grouping configuration. Only applies to 'read' actions where grouping is desired.
         */
        grouper?: Ext.util.Grouper;

        /**
         * The number of records to load. Used on 'read' actions when paging is being used.
         */
        limit?: number;

        /**
         * The page for this operation.
         */
        page?: number;

        /**
         * Optional array of sorter objects. Only applies to 'read' actions.
         */
        sorters?: Ext.util.Sorter;

        /**
         * The start index (offset), used in paging when running a 'read' action.
         */
        start?: number;
    }

    /**
     * Enacpsulates a read operation as performed by a {@link Ext.data.proxy.Proxy proxy}.
     *
     * This class is instantiated by {@link Ext.data.Store stores} and {@link Ext.data.Model records} and should
     * not need to be instantiated in user code.
     */
    export class Read extends Ext.data.operation.Operation implements Ext.data.operation.ReadConfig {
        /**
         * Optional array of filter objects. Only applies to 'read' actions.
         */
        filters: Ext.util.Filter;

        /**
         * Optional grouping configuration. Only applies to 'read' actions where grouping is desired.
         */
        grouper: Ext.util.Grouper;

        /**
         * The number of records to load. Used on 'read' actions when paging is being used.
         */
        limit: number;

        /**
         * The page for this operation.
         */
        page: number;

        /**
         * Optional array of sorter objects. Only applies to 'read' actions.
         */
        sorters: Ext.util.Sorter;

        /**
         * The start index (offset), used in paging when running a 'read' action.
         */
        start: number;

        /**
         * Creates new Operation object.
         * @param {Object} config (optional) Config object.
         */
        constructor(config: Ext.data.operation.OperationConfig);

        getFilters();

        getGrouper();

        getLimit();

        getPage();

        getSorters();

        getStart();

        setFilters();

        setGrouper();

        setLimit();

        setPage();

        setSorters();

        setStart();
    }

    /**
     * Enacpsulates a update operation as performed by a {@link Ext.data.proxy.Proxy proxy}.
     *
     * This class is instantiated by {@link Ext.data.Store stores} and {@link Ext.data.Model records} and should
     * not need to be instantiated in user code.
     */
    export class Update extends Ext.data.operation.Operation {
        /**
         * Creates new Operation object.
         * @param {Object} config (optional) Config object.
         */
        constructor(config: Ext.data.operation.OperationConfig);

        getRecordCreator();

        setRecordCreator();
    }
}

declare module Ext.data.proxy {
    interface AjaxConfig extends Ext.data.proxy.ServerConfig {
        /**
         * Mapping of action name to HTTP request method. In the basic AjaxProxy these are set to 'GET' for 'read' actions
         * and 'POST' for 'create', 'update' and 'destroy' actions. The {@link Ext.data.proxy.Rest} maps these to the
         * correct RESTful methods.
         */
        actionMethods?: any;

        /**
         * True to request binary data from the server.  This feature requires
         * the use of a binary reader such as {@link Ext.data.amf.Reader AMF Reader}
         */
        binary?: boolean;

        /**
         * Any headers to add to the Ajax request.
         *
         * example:
         *
         *     proxy: {
         *         headers: {'Content-Type': "text/plain" }
         *         ...
         *     }
         *
         * Optional
         */
        headers?: any;

        /**
         * 'true' to have any request parameters sent as {@link Ext.data.Connection#method-request jsonData}
         * where they can be parsed from the raw request. By default, parameters are sent via the
         * {@link Ext.data.Connection#method-request params} property. **Note**: This setting does not apply when the
         * request is sent as a 'GET' request. See {@link #actionMethods} for controlling the HTTP verb
         * that is used when sending requests.
         */
        paramsAsJson?: boolean;

        /**
         * Most oData feeds require basic HTTP authentication. This configuration allows
         * you to specify the password.
         */
        password?: string;

        /**
         * Set this to false to not send the default Xhr header (X-Requested-With) with every request.
         * This should be set to false when making CORS (cross-domain) requests.
         */
        useDefaultXhrHeader?: boolean;

        /**
         * Most oData feeds require basic HTTP authentication. This configuration allows
         * you to specify the username.
         */
        username?: string;

        /**
         * This configuration is sometimes necessary when using cross-origin resource sharing.
         */
        withCredentials?: boolean;
    }

    export class Ajax extends Ext.data.proxy.Server implements Ext.data.proxy.AjaxConfig {
        /**
         * Mapping of action name to HTTP request method. In the basic AjaxProxy these are set to 'GET' for 'read' actions
         * and 'POST' for 'create', 'update' and 'destroy' actions. The {@link Ext.data.proxy.Rest} maps these to the
         * correct RESTful methods.
         */
        actionMethods: any;

        /**
         * True to request binary data from the server.  This feature requires
         * the use of a binary reader such as {@link Ext.data.amf.Reader AMF Reader}
         */
        binary: boolean;

        /**
         * Any headers to add to the Ajax request.
         *
         * example:
         *
         *     proxy: {
         *         headers: {'Content-Type': "text/plain" }
         *         ...
         *     }
         *
         * Optional
         */
        headers: any;

        /**
         * 'true' to have any request parameters sent as {@link Ext.data.Connection#method-request jsonData}
         * where they can be parsed from the raw request. By default, parameters are sent via the
         * {@link Ext.data.Connection#method-request params} property. **Note**: This setting does not apply when the
         * request is sent as a 'GET' request. See {@link #actionMethods} for controlling the HTTP verb
         * that is used when sending requests.
         */
        paramsAsJson: boolean;

        /**
         * Most oData feeds require basic HTTP authentication. This configuration allows
         * you to specify the password.
         */
        password: string;

        /**
         * Set this to false to not send the default Xhr header (X-Requested-With) with every request.
         * This should be set to false when making CORS (cross-domain) requests.
         */
        useDefaultXhrHeader: boolean;

        /**
         * Most oData feeds require basic HTTP authentication. This configuration allows
         * you to specify the username.
         */
        username: string;

        /**
         * This configuration is sometimes necessary when using cross-origin resource sharing.
         */
        withCredentials: boolean;

        /**
         * Aborts a running request.
         * @param {Ext.data.Request} [request] The request to abort. If not passed, the most recent active
         * request will be aborted.
         */
        abort(request?: Ext.data.Request);

        /**
         * AjaxProxy is one of the most widely-used ways of getting data into your application. It uses AJAX requests to load
         * data from the server, usually to be placed into a {@link Ext.data.Store Store}. Let's take a look at a typical setup.
         * Here we're going to set up a Store that has an AjaxProxy. To prepare, we'll also set up a {@link Ext.data.Model
         * Model}:
         *
         *     Ext.define('User', {
         *         extend: 'Ext.data.Model',
         *         fields: ['id', 'name', 'email']
         *     });
         *
         *     //The Store contains the AjaxProxy as an inline configuration
         *     var store = Ext.create('Ext.data.Store', {
         *         model: 'User',
         *         proxy: {
         *             type: 'ajax',
         *             url : 'users.json'
         *         }
         *     });
         *
         *     store.load();
         *
         * Our example is going to load user data into a Store, so we start off by defining a {@link Ext.data.Model Model} with
         * the fields that we expect the server to return. Next we set up the Store itself, along with a
         * {@link Ext.data.Store#proxy proxy} configuration. This configuration was automatically turned into an
         * Ext.data.proxy.Ajax instance, with the url we specified being passed into AjaxProxy's constructor.
         * It's as if we'd done this:
         *
         *     new Ext.data.proxy.Ajax({
         *         url: 'users.json',
         *         model: 'User',
         *         reader: 'json'
         *     });
         *
         * A couple of extra configurations appeared here - {@link #model} and {@link #reader}. These are set by default when we
         * create the proxy via the Store - the Store already knows about the Model, and Proxy's default {@link
         * Ext.data.reader.Reader Reader} is {@link Ext.data.reader.Json JsonReader}.
         *
         * Now when we call store.load(), the AjaxProxy springs into action, making a request to the url we configured
         * ('users.json' in this case). As we're performing a read, it sends a GET request to that url (see
         * {@link #actionMethods} to customize this - by default any kind of read will be sent as a GET request and any kind of write
         * will be sent as a POST request).
         *
         * # Limitations
         *
         * AjaxProxy cannot be used to retrieve data from other domains. If your application is running on http://domainA.com it
         * cannot load data from http://domainB.com because browsers have a built-in security policy that prohibits domains
         * talking to each other via AJAX.
         *
         * If you need to read data from another domain and can't set up a proxy server (some software that runs on your own
         * domain's web server and transparently forwards requests to http://domainB.com, making it look like they actually came
         * from http://domainA.com), you can use {@link Ext.data.proxy.JsonP} and a technique known as JSON-P (JSON with
         * Padding), which can help you get around the problem so long as the server on http://domainB.com is set up to support
         * JSON-P responses. See {@link Ext.data.proxy.JsonP JsonPProxy}'s introduction docs for more details.
         *
         * # Readers and Writers
         *
         * AjaxProxy can be configured to use any type of {@link Ext.data.reader.Reader Reader} to decode the server's response.
         * If no Reader is supplied, AjaxProxy will default to using a {@link Ext.data.reader.Json JsonReader}. Reader
         * configuration can be passed in as a simple object, which the Proxy automatically turns into a {@link
         * Ext.data.reader.Reader Reader} instance:
         *
         *     var proxy = new Ext.data.proxy.Ajax({
         *         model: 'User',
         *         reader: {
         *             type: 'xml',
         *             rootProperty: 'users'
         *         }
         *     });
         *
         *     proxy.getReader(); //returns an XmlReader instance based on the config we supplied
         *
         * # Url generation
         *
         * AjaxProxy automatically inserts any sorting, filtering, paging and grouping options into the url it generates for
         * each request. These are controlled with the following configuration options:
         *
         * - {@link #pageParam} - controls how the page number is sent to the server (see also {@link #startParam} and {@link #limitParam})
         * - {@link #sortParam} - controls how sort information is sent to the server
         * - {@link #groupParam} - controls how grouping information is sent to the server
         * - {@link #filterParam} - controls how filter information is sent to the server
         *
         * Each request sent by AjaxProxy is described by an {@link Ext.data.operation.Operation Operation}. To see how we can customize
         * the generated urls, let's say we're loading the Proxy with the following Operation:
         *
         *     var proxy = new Ext.data.proxy.Ajax({
         *         url: '/users'
         *     });
         *
         *     var operation = proxy.createOperation('read', {
         *         page  : 2
         *     });
         *
         * Now we'll issue the request for this Operation by calling {@link #read}:
         *
         *     proxy.read(operation); //GET /users?page=2
         *
         * Easy enough - the Proxy just copied the page property from the Operation. We can customize how this page data is sent
         * to the server:
         *
         *     var proxy = new Ext.data.proxy.Ajax({
         *         url: '/users',
         *         pageParam: 'pageNumber'
         *     });
         *
         *     proxy.read(operation); //GET /users?pageNumber=2
         *
         * Alternatively, our Operation could have been configured to send start and limit parameters instead of page:
         *
         *     var proxy = new Ext.data.proxy.Ajax({
         *         url: '/users'
         *     });
         *
         *     var operation = proxy.createOperation('read', {
         *         start : 50,
         *         limit : 25
         *     });
         *
         *     proxy.read(operation); //GET /users?start=50&limit;=25
         *
         * Again we can customize this url:
         *
         *     var proxy = new Ext.data.proxy.Ajax({
         *         url: '/users',
         *         startParam: 'startIndex',
         *         limitParam: 'limitIndex'
         *     });
         *
         *     proxy.read(operation); //GET /users?startIndex=50&limitIndex;=25
         *
         * AjaxProxy will also send sort and filter information to the server. Let's take a look at how this looks with a more
         * expressive Operation object:
         *
         *     var operation = proxy.createOperation('read', {
         *         sorters: [
         *             new Ext.util.Sorter({
         *                 property : 'name',
         *                 direction: 'ASC'
         *             }),
         *             new Ext.util.Sorter({
         *                 property : 'age',
         *                 direction: 'DESC'
         *             })
         *         ],
         *         filters: [
         *             new Ext.util.Filter({
         *                 property: 'eyeColor',
         *                 value   : 'brown'
         *             })
         *         ]
         *     });
         *
         * This is the type of object that is generated internally when loading a {@link Ext.data.Store Store} with sorters and
         * filters defined. By default the AjaxProxy will JSON encode the sorters and filters, resulting in something like this
         * (note that the url is escaped before sending the request, but is left unescaped here for clarity):
         *
         *     var proxy = new Ext.data.proxy.Ajax({
         *         url: '/users'
         *     });
         *
         *     proxy.read(operation); //GET /users?sort=[{"property":"name","direction":"ASC"},{"property":"age","direction":"DESC"}]&filter;=[{"property":"eyeColor","value":"brown"}]
         *
         * We can again customize how this is created by supplying a few configuration options. Let's say our server is set up
         * to receive sorting information is a format like "sortBy=name#ASC,age#DESC". We can configure AjaxProxy to provide
         * that format like this:
         *
         *      var proxy = new Ext.data.proxy.Ajax({
         *          url: '/users',
         *          sortParam: 'sortBy',
         *          filterParam: 'filterBy',
         *
         *          //our custom implementation of sorter encoding - turns our sorters into "name#ASC,age#DESC"
         *          encodeSorters: function(sorters) {
         *              var length   = sorters.length,
         *                  sortStrs = [],
         *                  sorter, i;
         *
         *              for (i = 0; i < length; i++) {
         *                  sorter = sorters[i];
         *
         *                  sortStrs[i] = sorter.property + '#' + sorter.direction
         *              }
         *
         *              return sortStrs.join(",");
         *          }
         *      });
         *
         *      proxy.read(operation); //GET /users?sortBy=name#ASC,age#DESC&filterBy;=[{"property":"eyeColor","value":"brown"}]
         *
         * We can also provide a custom {@link #encodeFilters} function to encode our filters.
         *
         * # Debugging your Ajax Proxy
         *
         * If the data is not being loaded into the store as expected, it could be due to a mismatch between the the way that the {@link #reader}
         * is configured, and the shape of the incoming data.
         *
         * To debug from the point that your data arrives back from the network, set a breakpoint inside the callback function
         * created in the 'createRequestCallback' method of the Ajax Proxy class, and follow the data to where the {@link #reader} attempts
         * to consume it.
         *
         * @constructor
         * Note that if this HttpProxy is being used by a {@link Ext.data.Store Store}, then the Store's call to
         * {@link Ext.data.Store#method-load load} will override any specified callback and params options. In this case, use the
         * {@link Ext.data.Store Store}'s events to modify parameters, or react to loading events.
         *
         * @param {Object} config (optional) Config object.
         * If an options parameter is passed, the singleton {@link Ext.Ajax} object will be used to make the request.
         */
        constructor(config: Ext.data.amf.ProxyConfig);

        destroy();

        getActionMethods();

        getBinary();

        getHeaders();

        /**
         * Returns the HTTP method name for a given request. By default this returns based on a lookup on
         * {@link #actionMethods}.
         * @param {Ext.data.Request} request The request object
         * @return {String} The HTTP method to use (should be one of 'GET', 'POST', 'PUT' or 'DELETE')
         */
        getMethod(request: Ext.data.Request): string;

        getParamsAsJson();

        getPassword();

        getUseDefaultXhrHeader();

        getUsername();

        getWithCredentials();

        setActionMethods();

        setBinary();

        setHeaders();

        setParamsAsJson();

        setPassword();

        setUseDefaultXhrHeader();

        setUsername();

        setWithCredentials();
    }

    /**
     * Base class for any client-side storage. Used as a superclass for {@link Ext.data.proxy.Memory Memory} and
     * {@link Ext.data.proxy.WebStorage Web Storage} proxies. Do not use directly, use one of the subclasses instead.
     */
    export class Client extends Ext.data.proxy.Proxy {
        /**
         * 'true' in this class to identify that requests made on this proxy are
         * performed synchronously
         */
        isSynchronous: boolean;

        /**
         * Abstract function that must be implemented by each ClientProxy subclass. This should purge all record data
         * from the client side storage, as well as removing any supporting data (such as lists of record IDs)
         */
        clear();

        /**
         * Creates the Proxy
         * @param {Object} [config] Config object.
         */
        constructor(config?: Ext.data.proxy.JsonPConfig);
    }

    interface DirectConfig extends Ext.data.proxy.ServerConfig {
        /**
         * The same as {@link Ext.data.proxy.Server#api}, however instead of providing urls
         * you should provide a Direct function for each CRUD method. See also {@link #directFn}.
         */
        api?: any;

        /**
         * Function to call when executing a request. 'directFn' is a simple alternative to defining
         * the api configuration-parameter for Stores which will not implement a full CRUD api.
         * The 'directFn' may also be a string reference to the fully qualified name of the function,
         * for example: ''MyApp.company.GetProfile''. This can be useful when using dynamic loading.
         * The string will be resolved before calling the function for the first time.
         */
        directFn?: Function|string;

        /**
         * Optional set of fixed parameters to send with every Proxy request, similar to
         * {@link #extraParams} but available with all CRUD requests. Also unlike
         * {@link #extraParams}, metadata is not mixed with the ordinary data but sent
         * separately in the data packet.
         * You may need to update your server side Ext Direct stack to use this feature.
         *
         * Optional
         */
        metadata?: any|any[];

        /**
         * A list of params to be passed to server side Read function. Specify the params
         * in the order in which they must be executed on the server-side as either (1) an Array
         * of String values, or (2) a String of params delimited by either whitespace, comma,
         * or pipe. For example, any of the following would be acceptable:
         *
         *     paramOrder: ['param1','param2','param3']
         *     paramOrder: 'param1 param2 param3'
         *     paramOrder: 'param1,param2,param3'
         *     paramOrder: 'param1|param2|param'
         */
        paramOrder?: string;

        /**
         * Send Read function parameters as a collection of named arguments. Providing a
         * {@link #paramOrder} nullifies this configuration.
         */
        paramsAsHash?: boolean;
    }

    /**
     * This class is used to send requests to the server using {@link Ext.direct.Manager Ext Direct}.
     * When a request is made, the transport mechanism is handed off to the appropriate
     * {@link Ext.direct.RemotingProvider Provider} to complete the call.
     *
     * # Specifying the functions
     *
     * This proxy expects Direct remoting method to be passed in order to be able to complete requests,
     * one Direct function per CRUD method. This is done via {@link #api} configuration:
     *
     *      api: {
     *          read: 'MyApp.readRecords',
     *          create: 'MyApp.createRecords',
     *          update: 'MyApp.updateRecords',
     *          destroy: 'MyApp.destroyRecords'
     *      }
     *
     * The preferred way is to specify function names to allow late resolution, however you can
     * pass function references instead if desired:
     *
     *      api: {
     *          read: MyApp.readRecords, // Functions should be already defined
     *          create: MyApp.createRecords,
     *          update: MyApp.updateRecords,
     *          destroy: MyApp.destroyRecords
     *      }
     *
     * You can also use the {@link #directFn} configuration instead of {@link #api}. This will use
     * the same Direct function for all types of requests.
     *
     * # Server API
     *
     * The server side methods are expected to conform to the following calling conventions:
     *
     * ## 'read'
     *
     * Accept one argument which is either named arguments in an object (default), or an array
     * of values depending on the {@link #paramsAsHash} configuration. Return an array of records
     * or an object with format recognizable by the configured {@link Ext.data.reader.Reader}
     * instance.
     *
     * Example {@link Ext.directRemotingProvider#actions Direct API declaration}:
     *
     *      actions: {
     *          MyApp: [{
     *              name: 'readRecords',
     *              params: [],
     *              strict: false
     *          }]
     *      }
     *
     * Example function invocation:
     *
     *      MyApp.readRecords(
     *          {
     *              start: 0,
     *              limit: 10
     *          },
     *          // Results are passed to the callback function
     *          function(records) {
     *              console.log(records);
     *              // Logs:  [{ id: 'r0', text: 'foo' }, { id: 'r1', text: 'bar' }]
     *          }
     *      );
     *
     * ## 'create'
     *
     * Accept one ordered argument which is either an object with data for the new record,
     * or an array of objects for multiple records. Return an array of identifiers for actually
     * created records. See {@link Ext.data.Model#clientIdProperty} for more information.
     *
     * Example {@link Ext.directRemotingProvider#actions Direct API declaration}:
     *
     *      actions: [
     *          MyApp: [{
     *              name: 'createRecords',
     *              len: 1
     *          }]
     *      }
     *
     * Example function invocation:
     *
     *      MyApp.createRecords(
     *          [
     *              { id: 0, text: 'foo' },
     *              { id: 1, text: 'bar' }
     *          ],
     *          // Results are passed to the callback function
     *          function(records) {
     *              console.log(records);
     *              // Logs: [{ clientId: 0, id: 'r0' }, { clientId: 1, id: 'r1' }]
     *          }
     *      );
     *
     * ## 'update'
     *
     * Accept one ordered argument which is either an object with updated data and valid
     * record identifier, or an array of objects for multiple records. Return an array of
     * objects with updated record data.
     *
     * Example {@link Ext.directRemotingProvider#actions Direct API declaration}:
     *
     *      actions: [
     *          MyApp: [{
     *              name: 'updateRecords',
     *              len: 1
     *          }]
     *      }
     *
     * Example function invocation:
     *
     *      MyApp.updateRecords(
     *          [
     *              { id: 'r0', text: 'blerg' },
     *              { id: 'r1', text: 'throbbe' }
     *          ],
     *          // Results are passed to the callback function
     *          function(records) {
     *              console.log(records);
     *              // Logs: [{ id: 'r0', text: 'blerg' }, { id: 'r1', text: 'throbbe }]
     *          }
     *      );
     *
     * ## 'destroy'
     *
     * Accept one ordered argument which is an array of record identifiers to be deleted.
     * Return an object with at least one {@link Ext.data.reader.Json#successProperty}
     * property set to 'true' or 'false', with more optional properties recognizable by configured
     * {@link Ext.data.reader.Reader} instance.
     *
     * Example {@link Ext.directRemotingProvider#actions Direct API declaration}:
     *
     *      actions: [
     *          MyApp: [{
     *              name: 'destroyRecords',
     *              len: 1
     *          }]
     *      }
     *
     * Example function invocation:
     *
     *      MyApp.destroyRecords(
     *          [
     *              { id: 'r0' },
     *              { id: 'r1' }
     *          ],
     *          // Results are passed to the callback function
     *          function(result) {
     *              // Default successProperty is 'success'
     *              if (!result.success) {
     *                  // Handle the error
     *              }
     *          }
     *      );
     *
     * ## Read method parameters
     *
     * Direct proxy provides options to help configure which parameters will be sent to the server
     * for Read operations. By setting the {@link #paramsAsHash} option to 'true', the proxy will
     * send an object literal containing each of the passed parameters. This is the default. When
     * {@link #paramsAsHash} is set to 'false', Proxy will pass the Read function an array of values
     * instead of an object, with the order determined by {@link #paramOrder} value.
     *
     * Setting {@link #paramOrder} to any value other than 'undefined' will automatically reset
     * {@link #paramsAsHash} to 'false'.
     *
     * # Example Usage
     *
     *      Ext.define('User', {
     *          extend: 'Ext.data.Model',
     *          fields: ['firstName', 'lastName']
     *      });
     *
     *      Ext.define('Users', {
     *          extend: 'Ext.data.Store',
     *          model: 'User',
     *          proxy: {
     *              type: 'direct',
     *              directFn: 'MyApp.getUsers',
     *              // Tells the proxy to pass 'start' and 'limit' as two by-position arguments:
     *              paramOrder: 'start,limit'
     *          }
     *      });
     *
     *      var store = new Users();
     *      store.load();
     */
    export class Direct extends Ext.data.proxy.Server implements Ext.data.proxy.DirectConfig {
        /**
         * The same as {@link Ext.data.proxy.Server#api}, however instead of providing urls
         * you should provide a Direct function for each CRUD method. See also {@link #directFn}.
         */
        api: any;

        /**
         * Function to call when executing a request. 'directFn' is a simple alternative to defining
         * the api configuration-parameter for Stores which will not implement a full CRUD api.
         * The 'directFn' may also be a string reference to the fully qualified name of the function,
         * for example: ''MyApp.company.GetProfile''. This can be useful when using dynamic loading.
         * The string will be resolved before calling the function for the first time.
         */
        directFn: Function|string;

        /**
         * Optional set of fixed parameters to send with every Proxy request, similar to
         * {@link #extraParams} but available with all CRUD requests. Also unlike
         * {@link #extraParams}, metadata is not mixed with the ordinary data but sent
         * separately in the data packet.
         * You may need to update your server side Ext Direct stack to use this feature.
         *
         * Optional
         */
        metadata: any|any[];

        /**
         * A list of params to be passed to server side Read function. Specify the params
         * in the order in which they must be executed on the server-side as either (1) an Array
         * of String values, or (2) a String of params delimited by either whitespace, comma,
         * or pipe. For example, any of the following would be acceptable:
         *
         *     paramOrder: ['param1','param2','param3']
         *     paramOrder: 'param1 param2 param3'
         *     paramOrder: 'param1,param2,param3'
         *     paramOrder: 'param1|param2|param'
         */
        paramOrder: string;

        /**
         * Send Read function parameters as a collection of named arguments. Providing a
         * {@link #paramOrder} nullifies this configuration.
         */
        paramsAsHash: boolean;

        /**
         * Aborts a running request by operation.
         *
         * @param {Ext.data.Operation} operation The operation to abort. This parameter
         * is mandatory.
         */
        abort(operation: Ext.data.operation.Operation);

        constructor(config: Ext.data.proxy.DirectConfig);

        extractResponseData();

        getApi();

        getDirectFn();

        getMetadata();

        getParamOrder();

        getParamsAsHash();

        setApi();

        setDirectFn();

        setException();

        setMetadata();

        setParamOrder();

        setParamsAsHash();
    }

    interface JsonPConfig extends Ext.data.proxy.ServerConfig {
        /**
         * True to automatically append the request's params to the generated url. Defaults to true
         */
        autoAppendParams?: boolean;

        /**
         * See {@link Ext.data.JsonP#callbackKey}.
         */
        callbackKey?: string;

        /**
         * The HTTP parameter name to use when passing records to the server and the {@link #writer Json writer} is not configured
         * to {@link Ext.data.writer.Json#encode encode} records into a parameter.
         *
         * The {@link #encodeRecords} method is used to encode the records to create this parameter's value.
         *
         * Optional
         */
        recordParam?: string;
    }

    /**
     * The JsonP proxy is useful when you need to load data from a domain other than the one your application is running on. If
     * your application is running on http://domainA.com it cannot use {@link Ext.data.proxy.Ajax Ajax} to load its data
     * from http://domainB.com because cross-domain ajax requests are prohibited by the browser.
     *
     * We can get around this using a JsonP proxy. JsonP proxy injects a '<script>' tag into the DOM whenever an AJAX request
     * would usually be made. Let's say we want to load data from http://domainB.com/users - the script tag that would be
     * injected might look like this:
     *
     *     <script src="http://domainB.com/users?callback=someCallback"></script>
     *
     * When we inject the tag above, the browser makes a request to that url and includes the response as if it was any
     * other type of JavaScript include. By passing a callback in the url above, we're telling domainB's server that we want
     * to be notified when the result comes in and that it should call our callback function with the data it sends back. So
     * long as the server formats the response to look like this, everything will work:
     *
     *     someCallback({
     *         users: [
     *             {
     *                 id: 1,
     *                 name: "Ed Spencer",
     *                 email: "ed@sencha.com"
     *             }
     *         ]
     *     });
     *
     * As soon as the script finishes loading, the 'someCallback' function that we passed in the url is called with the JSON
     * object that the server returned.
     *
     * JsonP proxy takes care of all of this automatically. It formats the url you pass, adding the callback parameter
     * automatically. It even creates a temporary callback function, waits for it to be called and then puts the data into
     * the Proxy making it look just like you loaded it through a normal {@link Ext.data.proxy.Ajax AjaxProxy}. Here's how
     * we might set that up:
     *
     *     Ext.define('User', {
     *         extend: 'Ext.data.Model',
     *         fields: ['id', 'name', 'email']
     *     });
     *
     *     var store = Ext.create('Ext.data.Store', {
     *         model: 'User',
     *         proxy: {
     *             type: 'jsonp',
     *             url : 'http://domainB.com/users'
     *         }
     *     });
     *
     *     store.load();
     *
     * That's all we need to do - JsonP proxy takes care of the rest. In this case the Proxy will have injected a script tag
     * like this:
     *
     *     <script src="http://domainB.com/users?callback=callback1"></script>
     *
     * # Customization
     *
     * This script tag can be customized using the {@link #callbackKey} configuration. For example:
     *
     *     var store = Ext.create('Ext.data.Store', {
     *         model: 'User',
     *         proxy: {
     *             type: 'jsonp',
     *             url : 'http://domainB.com/users',
     *             callbackKey: 'theCallbackFunction'
     *         }
     *     });
     *
     *     store.load();
     *
     * Would inject a script tag like this:
     *
     *     <script src="http://domainB.com/users?theCallbackFunction=callback1"></script>
     *
     * # Implementing on the server side
     *
     * The remote server side needs to be configured to return data in this format. Here are suggestions for how you might
     * achieve this using Java, PHP and ASP.net:
     *
     * Java:
     *
     *     boolean jsonP = false;
     *     String cb = request.getParameter("callback");
     *     if (cb != null) {
     *         jsonP = true;
     *         response.setContentType("text/javascript");
     *     } else {
     *         response.setContentType("application/x-json");
     *     }
     *     Writer out = response.getWriter();
     *     if (jsonP) {
     *         out.write(cb + "(");
     *     }
     *     out.print(dataBlock.toJsonString());
     *     if (jsonP) {
     *         out.write(");");
     *     }
     *
     * PHP:
     *
     *     $callback = $_REQUEST['callback'];
     *
     *     // Create the output object.
     *     $output = array('a' => 'Apple', 'b' => 'Banana');
     *
     *     //start output
     *     if ($callback) {
     *         header('Content-Type: text/javascript');
     *         echo $callback . '(' . json_encode($output) . ');';
     *     } else {
     *         header('Content-Type: application/x-json');
     *         echo json_encode($output);
     *     }
     *
     * ASP.net:
     *
     *     String jsonString = "{success: true}";
     *     String cb = Request.Params.Get("callback");
     *     String responseString = "";
     *     if (!String.IsNullOrEmpty(cb)) {
     *         responseString = cb + "(" + jsonString + ")";
     *     } else {
     *         responseString = jsonString;
     *     }
     *     Response.Write(responseString);
     */
    export class JsonP extends Ext.data.proxy.Server implements Ext.data.proxy.JsonPConfig {
        /**
         * True to automatically append the request's params to the generated url. Defaults to true
         */
        autoAppendParams: boolean;

        /**
         * See {@link Ext.data.JsonP#callbackKey}.
         */
        callbackKey: string;

        /**
         * The HTTP parameter name to use when passing records to the server and the {@link #writer Json writer} is not configured
         * to {@link Ext.data.writer.Json#encode encode} records into a parameter.
         *
         * The {@link #encodeRecords} method is used to encode the records to create this parameter's value.
         *
         * Optional
         */
        recordParam: string;

        /**
         * Aborts a server request. If no request is passed, the most recent request
         * will be aborted.
         * @param {Ext.data.Request} [request] The request to abort.
         */
        abort(request?: Ext.data.Request);

        /**
         * Generates a url based on a given Ext.data.Request object. Adds the params and callback function name to the url
         * @param {Ext.data.Request} request The request object
         * @return {String} The url
         */
        buildUrl(request: Ext.data.Request): string;

        /**
         * Creates the Proxy
         * @param {Object} [config] Config object.
         */
        constructor(config?: Ext.data.proxy.JsonPConfig);

        /**
         * Encodes an array of records into a value suitable to be added to the request 'params' as the {@link #recordParam} parameter.
         * This is broken out into its own function so that it can be easily overridden.
         *
         * The default implementation
         * @param {Ext.data.Model[]} records The records array
         * @return {Array} An array of record data objects
         */
        encodeRecords(records: Ext.data.Model): any[];

        getAutoAppendParams();

        getCallbackKey();

        getRecordParam();

        setAutoAppendParams();

        setCallbackKey();

        setRecordParam();
    }

    /**
     * The LocalStorageProxy uses the new HTML5 localStorage API to save {@link Ext.data.Model Model} data locally on the
     * client browser. HTML5 localStorage is a key-value store (e.g. cannot save complex objects like JSON), so
     * LocalStorageProxy automatically serializes and deserializes data when saving and retrieving it.
     *
     * localStorage is extremely useful for saving user-specific information without needing to build server-side
     * infrastructure to support it. Let's imagine we're writing a Twitter search application and want to save the user's
     * searches locally so they can easily perform a saved search again later. We'd start by creating a Search model:
     *
     *     Ext.define('Search', {
     *         fields: ['id', 'query'],
     *         extend: 'Ext.data.Model',
     *         proxy: {
     *             type: 'localstorage',
     *             id  : 'twitter-Searches'
     *         }
     *     });
     *
     * Our Search model contains just two fields - id and query - plus a Proxy definition. The only configuration we need to
     * pass to the LocalStorage proxy is an {@link #id}. This is important as it separates the Model data in this Proxy from
     * all others. The localStorage API puts all data into a single shared namespace, so by setting an id we enable
     * LocalStorageProxy to manage the saved Search data.
     *
     * Saving our data into localStorage is easy and would usually be done with a {@link Ext.data.Store Store}:
     *
     *     //our Store automatically picks up the LocalStorageProxy defined on the Search model
     *     var store = Ext.create('Ext.data.Store', {
     *         model: "Search"
     *     });
     *
     *     //loads any existing Search data from localStorage
     *     store.load();
     *
     *     //now add some Searches
     *     store.add({query: 'Sencha Touch'});
     *     store.add({query: 'Ext JS'});
     *
     *     //finally, save our Search data to localStorage
     *     store.sync();
     *
     * The LocalStorageProxy automatically gives our new Searches an id when we call store.sync(). It encodes the Model data
     * and places it into localStorage. We can also save directly to localStorage, bypassing the Store altogether:
     *
     *     var search = Ext.create('Search', {query: 'Sencha Animator'});
     *
     *     //uses the configured LocalStorageProxy to save the new Search to localStorage
     *     search.save();
     *
     * # Limitations
     *
     * If this proxy is used in a browser where local storage is not supported, the constructor will throw an error. A local
     * storage proxy requires a unique ID which is used as a key in which all record data are stored in the local storage
     * object.
     *
     * It's important to supply this unique ID as it cannot be reliably determined otherwise. If no id is provided but the
     * attached store has a storeId, the storeId will be used. If neither option is presented the proxy will throw an error.
     */
    export class LocalStorage extends Ext.data.proxy.WebStorage {
        /**
         * Creates the proxy, throws an error if local storage is not supported in the current browser.
         * @param {Object} config (optional) Config object.
         */
        constructor(config: Ext.data.proxy.WebStorageConfig);
    }

    interface MemoryConfig extends Ext.data.proxy.ProxyConfig {
        /**
         * Optional data to pass to configured Reader.
         */
        data?: any;

        /**
         * Configure as 'true' to enable this MemoryProxy to honour a read operation's 'start' and 'limit' options.
         *
         * When 'true', read operations will be able to read *pages* of records from the data object.
         *
         * Optional
         */
        enablePaging?: boolean;
    }

    /**
     * In-memory proxy. This proxy simply uses a local variable for data storage/retrieval, so its contents are lost on
     * every page refresh.
     *
     * Usually this Proxy isn't used directly, serving instead as a helper to a {@link Ext.data.Store Store} where a reader
     * is required to load data. For example, say we have a Store for a User model and have some inline data we want to
     * load, but this data isn't in quite the right format: we can use a MemoryProxy with a JsonReader to read it into our
     * Store:
     *
     *     //this is the model we will be using in the store
     *     Ext.define('User', {
     *         extend: 'Ext.data.Model',
     *         fields: [
     *             {name: 'id',    type: 'int'},
     *             {name: 'name',  type: 'string'},
     *             {name: 'phone', type: 'string', mapping: 'phoneNumber'}
     *         ]
     *     });
     *
     *     //this data does not line up to our model fields - the phone field is called phoneNumber
     *     var data = {
     *         users: [
     *             {
     *                 id: 1,
     *                 name: 'Ed Spencer',
     *                 phoneNumber: '555 1234'
     *             },
     *             {
     *                 id: 2,
     *                 name: 'Abe Elias',
     *                 phoneNumber: '666 1234'
     *             }
     *         ]
     *     };
     *
     *     //note how we set the 'root' in the reader to match the data structure above
     *     var store = Ext.create('Ext.data.Store', {
     *         autoLoad: true,
     *         model: 'User',
     *         data : data,
     *         proxy: {
     *             type: 'memory',
     *             reader: {
     *                 type: 'json',
     *                 rootProperty: 'users'
     *             }
     *         }
     *     });
     */
    export class Memory extends Ext.data.proxy.Client implements Ext.data.proxy.MemoryConfig {
        /**
         * Optional data to pass to configured Reader.
         */
        data: any;

        /**
         * Configure as 'true' to enable this MemoryProxy to honour a read operation's 'start' and 'limit' options.
         *
         * When 'true', read operations will be able to read *pages* of records from the data object.
         *
         * Optional
         */
        enablePaging: boolean;

        clear();

        /**
         * Creates the Proxy
         * @param {Object} [config] Config object.
         */
        constructor(config?: Ext.data.proxy.JsonPConfig);

        /**
         * Currently this is a hard-coded method that simply commits any records and sets the operation to successful,
         * then calls the callback function, if provided. It is essentially mocking a server call in memory, but since
         * there is no real back end in this case there's not much else to do. This method can be easily overridden to
         * implement more complex logic if needed.
         * @param {Ext.data.operation.Operation} operation The Operation to perform
         */
        erase(operation: Ext.data.operation.Operation);

        getData();

        getEnablePaging();

        /**
         * Reads data from the configured {@link #data} object. Uses the Proxy's {@link #reader}, if present.
         * @param {Ext.data.operation.Operation} operation The read Operation
         */
        read(operation: Ext.data.operation.Operation);

        setData();

        setEnablePaging();

        /**
         * Currently this is a hard-coded method that simply commits any records and sets the operation to successful,
         * then calls the callback function, if provided. It is essentially mocking a server call in memory, but since
         * there is no real back end in this case there's not much else to do. This method can be easily overridden to
         * implement more complex logic if needed.
         * @param {Ext.data.operation.Operation} operation The Operation to perform
         */
        update(operation: Ext.data.operation.Operation);
    }

    interface ProxyConfig {
        /**
         * True to batch actions of a particular type when synchronizing the store. Defaults to true.
         */
        batchActions?: boolean;

        /**
         * Comma-separated ordering 'create', 'update' and 'destroy' actions when batching. Override this to set a different
         * order for the batched CRUD actions to be executed in. Defaults to 'create,update,destroy'.
         */
        batchOrder?: string;

        /**
         * The name of the Model to tie to this Proxy. Can be either the string name of the Model, or a reference to the
         * Model constructor. Required.
         */
        model?: string|Ext.data.Model;

        /**
         * The Ext.data.reader.Reader to use to decode the server's response or data read
         * from client. This can either be a Reader instance, a config object or just a
         * valid Reader type name (e.g. 'json', 'xml').
         */
        reader?: any|string|Ext.data.reader.Reader;

        /**
         * The Ext.data.writer.Writer to use to encode any request sent to the server or
         * saved to client. This can either be a Writer instance, a config object or just
         * a valid Writer type name (e.g. 'json', 'xml').
         */
        writer?: any|string|Ext.data.writer.Writer;
    }

    /**
     * Proxies are used by {@link Ext.data.Store Stores} to handle the loading and saving of {@link Ext.data.Model Model}
     * data. Usually developers will not need to create or interact with proxies directly.
     *
     * # Types of Proxy
     *
     * There are two main types of Proxy - {@link Ext.data.proxy.Client Client} and {@link Ext.data.proxy.Server Server}.
     * The Client proxies save their data locally and include the following subclasses:
     *
     * - {@link Ext.data.proxy.LocalStorage LocalStorageProxy} - saves its data to localStorage if the browser supports it
     * - {@link Ext.data.proxy.SessionStorage SessionStorageProxy} - saves its data to sessionStorage if the browsers supports it
     * - {@link Ext.data.proxy.Memory MemoryProxy} - holds data in memory only, any data is lost when the page is refreshed
     *
     * The Server proxies save their data by sending requests to some remote server. These proxies include:
     *
     * - {@link Ext.data.proxy.Ajax Ajax} - sends requests to a server on the same domain
     * - {@link Ext.data.proxy.JsonP JsonP} - uses JSON-P to send requests to a server on a different domain
     * - {@link Ext.data.proxy.Rest Rest} - uses RESTful HTTP methods (GET/PUT/POST/DELETE) to communicate with server
     * - {@link Ext.data.proxy.Direct Direct} - uses {@link Ext.direct.Manager} to send requests
     *
     * Proxies operate on the principle that all operations performed are either Create, Read, Update or Delete. These four
     * operations are mapped to the methods {@link #create}, {@link #read}, {@link #update} and {@link #erase}
     * respectively. Each Proxy subclass implements these functions.
     *
     * The CRUD methods each expect an {@link Ext.data.operation.Operation Operation} object as the sole argument. The Operation
     * encapsulates information about the action the Store wishes to perform, the {@link Ext.data.Model model} instances
     * that are to be modified, etc. See the {@link Ext.data.operation.Operation Operation} documentation for more details. Each CRUD
     * method also accepts a callback function to be called asynchronously on completion.
     *
     * Proxies also support batching of Operations via a {@link Ext.data.Batch batch} object, invoked by the {@link #batch}
     * method.
     */
    export class Proxy extends Ext.Base implements Ext.data.proxy.ProxyConfig {
        /**
         * 'true' in this class to identify an object as an instantiated Proxy, or subclass thereof.
         */
        isProxy: boolean;

        /**
         * Identifies the proxy as (a)synchronous.
         *
         * Optional, Defaults to: false
         */
        isSynchronous: boolean;

        /**
         * True to batch actions of a particular type when synchronizing the store. Defaults to true.
         */
        batchActions: boolean;

        /**
         * Comma-separated ordering 'create', 'update' and 'destroy' actions when batching. Override this to set a different
         * order for the batched CRUD actions to be executed in. Defaults to 'create,update,destroy'.
         */
        batchOrder: string;

        /**
         * The name of the Model to tie to this Proxy. Can be either the string name of the Model, or a reference to the
         * Model constructor. Required.
         */
        model: string|Ext.data.Model;

        /**
         * The Ext.data.reader.Reader to use to decode the server's response or data read
         * from client. This can either be a Reader instance, a config object or just a
         * valid Reader type name (e.g. 'json', 'xml').
         */
        reader: any|string|Ext.data.reader.Reader;

        /**
         * The Ext.data.writer.Writer to use to encode any request sent to the server or
         * saved to client. This can either be a Writer instance, a config object or just
         * a valid Writer type name (e.g. 'json', 'xml').
         */
        writer: any|string|Ext.data.writer.Writer;

        /**
         * Performs a batch of {@link Ext.data.operation.Operation Operations}, in the order specified by {@link #batchOrder}. Used
         * internally by {@link Ext.data.Store}'s {@link Ext.data.Store#sync sync} method. Example usage:
         *
         *     myProxy.batch({
         *         create : [myModel1, myModel2],
         *         update : [myModel3],
         *         destroy: [myModel4, myModel5]
         *     });
         *
         * Where the myModel* above are {@link Ext.data.Model Model} instances - in this case 1 and 2 are new instances and
         * have not been saved before, 3 has been saved previously but needs to be updated, and 4 and 5 have already been
         * saved but should now be destroyed.
         *
         * Note that the previous version of this method took 2 arguments (operations and listeners). While this is still
         * supported for now, the current signature is now a single 'options' argument that can contain both operations and
         * listeners, in addition to other options. The multi-argument signature will likely be deprecated in a future release.
         *
         * @param {Object} options Object containing one or more properties supported by the batch method:
         *
         * @param {Object} options.operations Object containing the Model instances to act upon, keyed by action name
         *
         * @param {Object} [options.listeners] Event listeners object passed straight through to the Batch -
         * see {@link Ext.data.Batch} for details
         *
         * @param {Ext.data.Batch/Object} [options.batch] A {@link Ext.data.Batch} object (or batch config to apply
         * to the created batch). If unspecified a default batch will be auto-created.
         *
         * @param {Function} [options.callback] The function to be called upon completion of processing the batch.
         * The callback is called regardless of success or failure and is passed the following parameters:
         * @param {Ext.data.Batch} options.callback.batch The {@link Ext.data.Batch batch} that was processed,
         * containing all operations in their current state after processing
         * @param {Object} options.callback.options The options argument that was originally passed into batch
         *
         * @param {Function} [options.success] The function to be called upon successful completion of the batch. The
         * success function is called only if no exceptions were reported in any operations. If one or more exceptions
         * occurred then the 'failure' function will be called instead. The success function is called
         * with the following parameters:
         * @param {Ext.data.Batch} options.success.batch The {@link Ext.data.Batch batch} that was processed,
         * containing all operations in their current state after processing
         * @param {Object} options.success.options The options argument that was originally passed into batch
         *
         * @param {Function} [options.failure] The function to be called upon unsuccessful completion of the batch. The
         * failure function is called when one or more operations returns an exception during processing (even if some
         * operations were also successful). In this case you can check the batch's {@link Ext.data.Batch#exceptions
         * exceptions} array to see exactly which operations had exceptions. The failure function is called with the
         * following parameters:
         * @param {Ext.data.Batch} options.failure.batch The {@link Ext.data.Batch batch} that was processed,
         * containing all operations in their current state after processing
         * @param {Object} options.failure.options The options argument that was originally passed into batch
         *
         * @param {Object} [options.scope] The scope in which to execute any callbacks (i.e. the 'this' object inside
         * the callback, success and/or failure functions). Defaults to the proxy.
         *
         * @return {Ext.data.Batch} The newly created Batch
         */
        batch(options: any, options_operations: any, options_listeners?: any, options_batch?: Ext.data.Batch|any, options_callback?: Function, options_callback_batch?: Ext.data.Batch, options_callback_options?: any, options_success?: Function, options_success_batch?: Ext.data.Batch, options_success_options?: any, options_failure?: Function, options_failure_batch?: Ext.data.Batch, options_failure_options?: any, options_scope?: any): Ext.data.Batch;

        /**
         * Creates the Proxy
         * @param {Object} [config] Config object.
         */
        constructor(config?: Ext.data.proxy.JsonPConfig);

        destroy();

        /**
         * Performs the given destroy operation.
         * @param {Ext.data.operation.Operation} operation The Operation to perform
         */
        erase(operation: Ext.data.operation.Operation);

        getBatchActions();

        getBatchOrder();

        getModel();

        getReader();

        getWriter();

        /**
         * Performs the given read operation.
         * @param {Ext.data.operation.Operation} operation The Operation to perform
         */
        read(operation: Ext.data.operation.Operation);

        setBatchActions();

        setBatchOrder();

        setModel();

        setReader();

        setWriter();

        /**
         * Performs the given update operation.
         * @param {Ext.data.operation.Operation} operation The Operation to perform
         */
        update(operation: Ext.data.operation.Operation);

        /**
         * Fires when this proxy's reader provides new metadata. Metadata usually consists
         * of new field definitions, but can include any configuration data required by an
         * application, and can be processed as needed in the event handler.
         * This event is currently only fired for JsonReaders. Note that this event is also
         * propagated by {@link Ext.data.Store}, which is typically where it would be handled.
         * @param {Object} meta The JSON metadata
         */
        metachange(that: Ext.data.proxy.Proxy, meta: any);
    }

    interface RestConfig extends Ext.data.proxy.AjaxConfig {
        /**
         * True to automatically append the ID of a Model instance when performing a request based on that single instance.
         * See Rest proxy intro docs for more details. Defaults to true.
         */
        appendId?: boolean;

        /**
         * True to batch actions of a particular type when synchronizing the store. Defaults to false.
         */
        batchActions?: boolean;

        /**
         * Optional data format to send to the server when making any request (e.g. 'json'). See the Rest proxy intro docs
         * for full details. Defaults to undefined.
         */
        format?: string;
    }

    /**
     * The Rest proxy is a specialization of the {@link Ext.data.proxy.Ajax AjaxProxy} which simply maps the four actions
     * (create, read, update and destroy) to RESTful HTTP verbs. For example, let's set up a {@link Ext.data.Model Model}
     * with an inline Rest proxy
     *
     *     Ext.define('User', {
     *         extend: 'Ext.data.Model',
     *         fields: ['id', 'name', 'email'],
     *
     *         proxy: {
     *             type: 'rest',
     *             url : '/users'
     *         }
     *     });
     *
     * Now we can create a new User instance and save it via the Rest proxy. Doing this will cause the Proxy to send a POST
     * request to '/users':
     *
     *     var user = Ext.create('User', {name: 'Ed Spencer', email: 'ed@sencha.com'});
     *
     *     user.save(); //POST /users
     *
     * Let's expand this a little and provide a callback for the {@link Ext.data.Model#save} call to update the Model once
     * it has been created. We'll assume the creation went successfully and that the server gave this user an ID of 123:
     *
     *     user.save({
     *         success: function(user) {
     *             user.set('name', 'Khan Noonien Singh');
     *
     *             user.save(); //PUT /users/123
     *         }
     *     });
     *
     * Now that we're no longer creating a new Model instance, the request method is changed to an HTTP PUT, targeting the
     * relevant url for that user. Now let's delete this user, which will use the DELETE method:
     *
     *         user.erase(); //DELETE /users/123
     *
     * Finally, when we perform a load of a Model or Store, Rest proxy will use the GET method:
     *
     *     //1. Load via Store
     *
     *     //the Store automatically picks up the Proxy from the User model
     *     var store = Ext.create('Ext.data.Store', {
     *         model: 'User'
     *     });
     *
     *     store.load(); //GET /users
     *
     *     //2. Load directly from the Model
     *
     *     //GET /users/123
     *     User.load(123, {
     *         success: function(user) {
     *             console.log(user.getId()); //outputs 123
     *         }
     *     });
     *
     * # Url generation
     *
     * The Rest proxy is able to automatically generate the urls above based on two configuration options - {@link #appendId} and
     * {@link #format}. If appendId is true (it is by default) then Rest proxy will automatically append the ID of the Model
     * instance in question to the configured url, resulting in the '/users/123' that we saw above.
     *
     * If the request is not for a specific Model instance (e.g. loading a Store), the url is not appended with an id.
     * The Rest proxy will automatically insert a '/' before the ID if one is not already present.
     *
     *     new Ext.data.proxy.Rest({
     *         url: '/users',
     *         appendId: true //default
     *     });
     *
     *     // Collection url: /users
     *     // Instance url  : /users/123
     *
     * The Rest proxy can also optionally append a format string to the end of any generated url:
     *
     *     new Ext.data.proxy.Rest({
     *         url: '/users',
     *         format: 'json'
     *     });
     *
     *     // Collection url: /users.json
     *     // Instance url  : /users/123.json
     *
     * If further customization is needed, simply implement the {@link #buildUrl} method and add your custom generated url
     * onto the {@link Ext.data.Request Request} object that is passed to buildUrl. See [Rest proxy's implementation][1] for
     * an example of how to achieve this.
     *
     * Note that Rest proxy inherits from {@link Ext.data.proxy.Ajax AjaxProxy}, which already injects all of the sorter,
     * filter, group and paging options into the generated url. See the {@link Ext.data.proxy.Ajax AjaxProxy docs} for more
     * details.
     *
     * [1]: source/Rest.html#Ext-data-proxy-Rest-method-buildUrl
     */
    export class Rest extends Ext.data.proxy.Ajax implements Ext.data.proxy.RestConfig {
        /**
         * Mapping of action name to HTTP request method. These default to RESTful conventions for the 'create', 'read',
         * 'update' and 'destroy' actions (which map to 'POST', 'GET', 'PUT' and 'DELETE' respectively). This object
         * should not be changed except globally via {@link Ext#override Ext.override} - the {@link #getMethod} function
         * can be overridden instead.
         */
        actionMethods: any;

        /**
         * True to automatically append the ID of a Model instance when performing a request based on that single instance.
         * See Rest proxy intro docs for more details. Defaults to true.
         */
        appendId: boolean;

        /**
         * True to batch actions of a particular type when synchronizing the store. Defaults to false.
         */
        batchActions: boolean;

        /**
         * Optional data format to send to the server when making any request (e.g. 'json'). See the Rest proxy intro docs
         * for full details. Defaults to undefined.
         */
        format: string;

        /**
         * AjaxProxy is one of the most widely-used ways of getting data into your application. It uses AJAX requests to load
         * data from the server, usually to be placed into a {@link Ext.data.Store Store}. Let's take a look at a typical setup.
         * Here we're going to set up a Store that has an AjaxProxy. To prepare, we'll also set up a {@link Ext.data.Model
         * Model}:
         *
         *     Ext.define('User', {
         *         extend: 'Ext.data.Model',
         *         fields: ['id', 'name', 'email']
         *     });
         *
         *     //The Store contains the AjaxProxy as an inline configuration
         *     var store = Ext.create('Ext.data.Store', {
         *         model: 'User',
         *         proxy: {
         *             type: 'ajax',
         *             url : 'users.json'
         *         }
         *     });
         *
         *     store.load();
         *
         * Our example is going to load user data into a Store, so we start off by defining a {@link Ext.data.Model Model} with
         * the fields that we expect the server to return. Next we set up the Store itself, along with a
         * {@link Ext.data.Store#proxy proxy} configuration. This configuration was automatically turned into an
         * Ext.data.proxy.Ajax instance, with the url we specified being passed into AjaxProxy's constructor.
         * It's as if we'd done this:
         *
         *     new Ext.data.proxy.Ajax({
         *         url: 'users.json',
         *         model: 'User',
         *         reader: 'json'
         *     });
         *
         * A couple of extra configurations appeared here - {@link #model} and {@link #reader}. These are set by default when we
         * create the proxy via the Store - the Store already knows about the Model, and Proxy's default {@link
         * Ext.data.reader.Reader Reader} is {@link Ext.data.reader.Json JsonReader}.
         *
         * Now when we call store.load(), the AjaxProxy springs into action, making a request to the url we configured
         * ('users.json' in this case). As we're performing a read, it sends a GET request to that url (see
         * {@link #actionMethods} to customize this - by default any kind of read will be sent as a GET request and any kind of write
         * will be sent as a POST request).
         *
         * # Limitations
         *
         * AjaxProxy cannot be used to retrieve data from other domains. If your application is running on http://domainA.com it
         * cannot load data from http://domainB.com because browsers have a built-in security policy that prohibits domains
         * talking to each other via AJAX.
         *
         * If you need to read data from another domain and can't set up a proxy server (some software that runs on your own
         * domain's web server and transparently forwards requests to http://domainB.com, making it look like they actually came
         * from http://domainA.com), you can use {@link Ext.data.proxy.JsonP} and a technique known as JSON-P (JSON with
         * Padding), which can help you get around the problem so long as the server on http://domainB.com is set up to support
         * JSON-P responses. See {@link Ext.data.proxy.JsonP JsonPProxy}'s introduction docs for more details.
         *
         * # Readers and Writers
         *
         * AjaxProxy can be configured to use any type of {@link Ext.data.reader.Reader Reader} to decode the server's response.
         * If no Reader is supplied, AjaxProxy will default to using a {@link Ext.data.reader.Json JsonReader}. Reader
         * configuration can be passed in as a simple object, which the Proxy automatically turns into a {@link
         * Ext.data.reader.Reader Reader} instance:
         *
         *     var proxy = new Ext.data.proxy.Ajax({
         *         model: 'User',
         *         reader: {
         *             type: 'xml',
         *             rootProperty: 'users'
         *         }
         *     });
         *
         *     proxy.getReader(); //returns an XmlReader instance based on the config we supplied
         *
         * # Url generation
         *
         * AjaxProxy automatically inserts any sorting, filtering, paging and grouping options into the url it generates for
         * each request. These are controlled with the following configuration options:
         *
         * - {@link #pageParam} - controls how the page number is sent to the server (see also {@link #startParam} and {@link #limitParam})
         * - {@link #sortParam} - controls how sort information is sent to the server
         * - {@link #groupParam} - controls how grouping information is sent to the server
         * - {@link #filterParam} - controls how filter information is sent to the server
         *
         * Each request sent by AjaxProxy is described by an {@link Ext.data.operation.Operation Operation}. To see how we can customize
         * the generated urls, let's say we're loading the Proxy with the following Operation:
         *
         *     var proxy = new Ext.data.proxy.Ajax({
         *         url: '/users'
         *     });
         *
         *     var operation = proxy.createOperation('read', {
         *         page  : 2
         *     });
         *
         * Now we'll issue the request for this Operation by calling {@link #read}:
         *
         *     proxy.read(operation); //GET /users?page=2
         *
         * Easy enough - the Proxy just copied the page property from the Operation. We can customize how this page data is sent
         * to the server:
         *
         *     var proxy = new Ext.data.proxy.Ajax({
         *         url: '/users',
         *         pageParam: 'pageNumber'
         *     });
         *
         *     proxy.read(operation); //GET /users?pageNumber=2
         *
         * Alternatively, our Operation could have been configured to send start and limit parameters instead of page:
         *
         *     var proxy = new Ext.data.proxy.Ajax({
         *         url: '/users'
         *     });
         *
         *     var operation = proxy.createOperation('read', {
         *         start : 50,
         *         limit : 25
         *     });
         *
         *     proxy.read(operation); //GET /users?start=50&limit;=25
         *
         * Again we can customize this url:
         *
         *     var proxy = new Ext.data.proxy.Ajax({
         *         url: '/users',
         *         startParam: 'startIndex',
         *         limitParam: 'limitIndex'
         *     });
         *
         *     proxy.read(operation); //GET /users?startIndex=50&limitIndex;=25
         *
         * AjaxProxy will also send sort and filter information to the server. Let's take a look at how this looks with a more
         * expressive Operation object:
         *
         *     var operation = proxy.createOperation('read', {
         *         sorters: [
         *             new Ext.util.Sorter({
         *                 property : 'name',
         *                 direction: 'ASC'
         *             }),
         *             new Ext.util.Sorter({
         *                 property : 'age',
         *                 direction: 'DESC'
         *             })
         *         ],
         *         filters: [
         *             new Ext.util.Filter({
         *                 property: 'eyeColor',
         *                 value   : 'brown'
         *             })
         *         ]
         *     });
         *
         * This is the type of object that is generated internally when loading a {@link Ext.data.Store Store} with sorters and
         * filters defined. By default the AjaxProxy will JSON encode the sorters and filters, resulting in something like this
         * (note that the url is escaped before sending the request, but is left unescaped here for clarity):
         *
         *     var proxy = new Ext.data.proxy.Ajax({
         *         url: '/users'
         *     });
         *
         *     proxy.read(operation); //GET /users?sort=[{"property":"name","direction":"ASC"},{"property":"age","direction":"DESC"}]&filter;=[{"property":"eyeColor","value":"brown"}]
         *
         * We can again customize how this is created by supplying a few configuration options. Let's say our server is set up
         * to receive sorting information is a format like "sortBy=name#ASC,age#DESC". We can configure AjaxProxy to provide
         * that format like this:
         *
         *      var proxy = new Ext.data.proxy.Ajax({
         *          url: '/users',
         *          sortParam: 'sortBy',
         *          filterParam: 'filterBy',
         *
         *          //our custom implementation of sorter encoding - turns our sorters into "name#ASC,age#DESC"
         *          encodeSorters: function(sorters) {
         *              var length   = sorters.length,
         *                  sortStrs = [],
         *                  sorter, i;
         *
         *              for (i = 0; i < length; i++) {
         *                  sorter = sorters[i];
         *
         *                  sortStrs[i] = sorter.property + '#' + sorter.direction
         *              }
         *
         *              return sortStrs.join(",");
         *          }
         *      });
         *
         *      proxy.read(operation); //GET /users?sortBy=name#ASC,age#DESC&filterBy;=[{"property":"eyeColor","value":"brown"}]
         *
         * We can also provide a custom {@link #encodeFilters} function to encode our filters.
         *
         * # Debugging your Ajax Proxy
         *
         * If the data is not being loaded into the store as expected, it could be due to a mismatch between the the way that the {@link #reader}
         * is configured, and the shape of the incoming data.
         *
         * To debug from the point that your data arrives back from the network, set a breakpoint inside the callback function
         * created in the 'createRequestCallback' method of the Ajax Proxy class, and follow the data to where the {@link #reader} attempts
         * to consume it.
         *
         * @constructor
         * Note that if this HttpProxy is being used by a {@link Ext.data.Store Store}, then the Store's call to
         * {@link Ext.data.Store#method-load load} will override any specified callback and params options. In this case, use the
         * {@link Ext.data.Store Store}'s events to modify parameters, or react to loading events.
         *
         * @param {Object} config (optional) Config object.
         * If an options parameter is passed, the singleton {@link Ext.Ajax} object will be used to make the request.
         */
        constructor(config: Ext.data.amf.ProxyConfig);

        getActionMethods();

        getAppendId();

        getBatchActions();

        getFormat();

        setActionMethods();

        setAppendId();

        setBatchActions();

        setFormat();
    }

    interface ServerConfig extends Ext.data.proxy.ProxyConfig {
        /**
         * Specific urls to call on CRUD action methods "create", "read", "update" and "destroy". Defaults to:
         *
         *     api: {
         *         create  : undefined,
         *         read    : undefined,
         *         update  : undefined,
         *         destroy : undefined
         *     }
         *
         * The url is built based upon the action being executed [create|read|update|destroy] using the commensurate
         * {@link #api} property, or if undefined default to the configured
         * {@link Ext.data.Store}.{@link Ext.data.proxy.Server#url url}.
         *
         * For example:
         *
         *     api: {
         *         create  : '/controller/new',
         *         read    : '/controller/load',
         *         update  : '/controller/update',
         *         destroy : '/controller/destroy_action'
         *     }
         *
         * If the specific URL for a given CRUD action is undefined, the CRUD action request will be directed to the
         * configured {@link Ext.data.proxy.Server#url url}.
         */
        api?: any;

        /**
         * The name of the cache param added to the url when using noCache. Defaults to "_dc".
         *
         * Optional, Defaults to: "_dc"
         */
        cacheString?: string;

        /**
         * The name of the direction parameter to send in a request. **This is only used when simpleSortMode is set to
         * true.**
         *
         * Optional, Defaults to: "dir"
         */
        directionParam?: string;

        /**
         * Extra parameters that will be included on every request. Individual requests with params of the same name
         * will override these params when they are in conflict.
         */
        extraParams?: any;

        /**
         * The name of the 'filter' parameter to send in a request. Defaults to 'filter'. Set this to '''' if you don't
         * want to send a filter parameter.
         *
         * Optional, Defaults to: "filter"
         */
        filterParam?: string;

        /**
         * The name of the direction parameter to send in a request. **This is only used when simpleGroupMode is set to
         * true.**
         *
         * Optional, Defaults to: "groupDir"
         */
        groupDirectionParam?: string;

        /**
         * The name of the 'group' parameter to send in a request. Defaults to 'group'. Set this to '''' if you don't
         * want to send a group parameter.
         *
         * Optional, Defaults to: "group"
         */
        groupParam?: string;

        /**
         * The name of the parameter which carries the id of the entity being operated upon.
         *
         * Optional, Defaults to: "id"
         */
        idParam?: string;

        /**
         * The name of the 'limit' parameter to send in a request. Defaults to 'limit'. Set this to '''' if you don't
         * want to send a limit parameter.
         *
         * Optional, Defaults to: "limit"
         */
        limitParam?: string;

        /**
         * Disable caching by adding a unique parameter name to the request. Set to false to allow caching. Defaults to true.
         *
         * Optional, Defaults to: true
         */
        noCache?: boolean;

        /**
         * The name of the 'page' parameter to send in a request. Defaults to 'page'. Set this to '''' if you don't
         * want to send a page parameter.
         *
         * Optional, Defaults to: "page"
         */
        pageParam?: string;

        /**
         * Enabling simpleGroupMode in conjunction with remoteGroup will only send one group property and a direction when a
         * remote group is requested. The {@link #groupDirectionParam} and {@link #groupParam} will be sent with the property name and either 'ASC'
         * or 'DESC'.
         *
         * Optional, Defaults to: false
         */
        simpleGroupMode?: boolean;

        /**
         * Enabling simpleSortMode in conjunction with remoteSort will only send one sort property and a direction when a
         * remote sort is requested. The {@link #directionParam} and {@link #sortParam} will be sent with the property name
         * and either 'ASC' or 'DESC'.
         *
         * Optional, Defaults to: false
         */
        simpleSortMode?: boolean;

        /**
         * The name of the 'sort' parameter to send in a request. Defaults to 'sort'. Set this to '''' if you don't
         * want to send a sort parameter.
         *
         * Optional, Defaults to: "sort"
         */
        sortParam?: string;

        /**
         * The name of the 'start' parameter to send in a request. Defaults to 'start'. Set this to '''' if you don't
         * want to send a start parameter.
         *
         * Optional, Defaults to: "start"
         */
        startParam?: string;

        /**
         * The number of milliseconds to wait for a response. Defaults to 30000 milliseconds (30 seconds).
         */
        timeout?: number;

        /**
         * The URL from which to request the data object.
         */
        url?: string;
    }

    /**
     * ServerProxy is a superclass of {@link Ext.data.proxy.JsonP JsonPProxy} and {@link Ext.data.proxy.Ajax AjaxProxy}, and
     * would not usually be used directly.
     */
    export class Server extends Ext.data.proxy.Proxy implements Ext.data.proxy.ServerConfig {
        /**
         * Specific urls to call on CRUD action methods "create", "read", "update" and "destroy". Defaults to:
         *
         *     api: {
         *         create  : undefined,
         *         read    : undefined,
         *         update  : undefined,
         *         destroy : undefined
         *     }
         *
         * The url is built based upon the action being executed [create|read|update|destroy] using the commensurate
         * {@link #api} property, or if undefined default to the configured
         * {@link Ext.data.Store}.{@link Ext.data.proxy.Server#url url}.
         *
         * For example:
         *
         *     api: {
         *         create  : '/controller/new',
         *         read    : '/controller/load',
         *         update  : '/controller/update',
         *         destroy : '/controller/destroy_action'
         *     }
         *
         * If the specific URL for a given CRUD action is undefined, the CRUD action request will be directed to the
         * configured {@link Ext.data.proxy.Server#url url}.
         */
        api: any;

        /**
         * The name of the cache param added to the url when using noCache. Defaults to "_dc".
         *
         * Optional, Defaults to: "_dc"
         */
        cacheString: string;

        /**
         * The name of the direction parameter to send in a request. **This is only used when simpleSortMode is set to
         * true.**
         *
         * Optional, Defaults to: "dir"
         */
        directionParam: string;

        /**
         * Extra parameters that will be included on every request. Individual requests with params of the same name
         * will override these params when they are in conflict.
         */
        extraParams: any;

        /**
         * The name of the 'filter' parameter to send in a request. Defaults to 'filter'. Set this to '''' if you don't
         * want to send a filter parameter.
         *
         * Optional, Defaults to: "filter"
         */
        filterParam: string;

        /**
         * The name of the direction parameter to send in a request. **This is only used when simpleGroupMode is set to
         * true.**
         *
         * Optional, Defaults to: "groupDir"
         */
        groupDirectionParam: string;

        /**
         * The name of the 'group' parameter to send in a request. Defaults to 'group'. Set this to '''' if you don't
         * want to send a group parameter.
         *
         * Optional, Defaults to: "group"
         */
        groupParam: string;

        /**
         * The name of the parameter which carries the id of the entity being operated upon.
         *
         * Optional, Defaults to: "id"
         */
        idParam: string;

        /**
         * The name of the 'limit' parameter to send in a request. Defaults to 'limit'. Set this to '''' if you don't
         * want to send a limit parameter.
         *
         * Optional, Defaults to: "limit"
         */
        limitParam: string;

        /**
         * Disable caching by adding a unique parameter name to the request. Set to false to allow caching. Defaults to true.
         *
         * Optional, Defaults to: true
         */
        noCache: boolean;

        /**
         * The name of the 'page' parameter to send in a request. Defaults to 'page'. Set this to '''' if you don't
         * want to send a page parameter.
         *
         * Optional, Defaults to: "page"
         */
        pageParam: string;

        /**
         * Enabling simpleGroupMode in conjunction with remoteGroup will only send one group property and a direction when a
         * remote group is requested. The {@link #groupDirectionParam} and {@link #groupParam} will be sent with the property name and either 'ASC'
         * or 'DESC'.
         *
         * Optional, Defaults to: false
         */
        simpleGroupMode: boolean;

        /**
         * Enabling simpleSortMode in conjunction with remoteSort will only send one sort property and a direction when a
         * remote sort is requested. The {@link #directionParam} and {@link #sortParam} will be sent with the property name
         * and either 'ASC' or 'DESC'.
         *
         * Optional, Defaults to: false
         */
        simpleSortMode: boolean;

        /**
         * The name of the 'sort' parameter to send in a request. Defaults to 'sort'. Set this to '''' if you don't
         * want to send a sort parameter.
         *
         * Optional, Defaults to: "sort"
         */
        sortParam: string;

        /**
         * The name of the 'start' parameter to send in a request. Defaults to 'start'. Set this to '''' if you don't
         * want to send a start parameter.
         *
         * Optional, Defaults to: "start"
         */
        startParam: string;

        /**
         * The number of milliseconds to wait for a response. Defaults to 30000 milliseconds (30 seconds).
         */
        timeout: number;

        /**
         * The URL from which to request the data object.
         */
        url: string;

        /**
         * Optional callback function which can be used to clean up after a request has been completed.
         * @param {Ext.data.Request} request The Request object
         * @param {Boolean} success True if the request was successful
         */
        protected afterRequest(request: Ext.data.Request, success: boolean);

        /**
         * Encode any values being sent to the server. Can be overridden in subclasses.
         * @param {Array} value An array of sorters/filters.
         * @return {Object} The encoded value
         */
        protected applyEncoding(value: any[]): any;

        /**
         * Creates an {@link Ext.data.Request Request} object from {@link Ext.data.operation.Operation Operation}.
         *
         * This gets called from doRequest methods in subclasses of Server proxy.
         *
         * @param {Ext.data.operation.Operation} operation The operation to execute
         * @return {Ext.data.Request} The request object
         */
        buildRequest(operation: Ext.data.operation.Operation): Ext.data.Request;

        /**
         * Generates a url based on a given Ext.data.Request object. By default, ServerProxy's buildUrl will add the
         * cache-buster param to the end of the url. Subclasses may need to perform additional modifications to the url.
         * @param {Ext.data.Request} request The request object
         * @return {String} The url
         */
        buildUrl(request: Ext.data.Request): string;

        /**
         * Creates the Proxy
         * @param {Object} [config] Config object.
         */
        constructor(config?: Ext.data.proxy.JsonPConfig);

        destroy();

        /**
         * In ServerProxy subclasses, the {@link #create}, {@link #read}, {@link #update} and {@link #erase} methods all
         * pass through to doRequest. Each ServerProxy subclass must implement the doRequest method - see {@link
         * Ext.data.proxy.JsonP} and {@link Ext.data.proxy.Ajax} for examples. This method carries the same signature as
         * each of the methods that delegate to it.
         *
         * @param {Ext.data.operation.Operation} operation The Ext.data.operation.Operation object
         * @param {Function} callback The callback function to call when the Operation has completed
         * @param {Object} scope The scope in which to execute the callback
         */
        doRequest(operation: Ext.data.operation.Operation, callback: Function, scope: any);

        /**
         * Encodes the array of {@link Ext.util.Filter} objects into a string to be sent in the request url. By default,
         * this simply JSON-encodes the filter data
         * @param {Ext.util.Filter[]} filters The array of {@link Ext.util.Filter Filter} objects
         * @return {String} The encoded filters
         */
        encodeFilters(filters: Ext.util.Filter): string;

        /**
         * Encodes the array of {@link Ext.util.Sorter} objects into a string to be sent in the request url. By default,
         * this simply JSON-encodes the sorter data
         * @param {Ext.util.Sorter[]} sorters The array of {@link Ext.util.Sorter Sorter} objects
         * @param {Boolean} [preventArray=false] Prevents the items from being output as an array.
         * @return {String} The encoded sorters
         */
        encodeSorters(sorters: Ext.util.Sorter, preventArray?: boolean): string;

        getApi();

        getCacheString();

        getDirectionParam();

        getExtraParams();

        getFilterParam();

        getGroupDirectionParam();

        getGroupParam();

        getIdParam();

        getLimitParam();

        getNoCache();

        getPageParam();

        getSimpleGroupMode();

        getSimpleSortMode();

        getSortParam();

        getStartParam();

        getTimeout();

        /**
         * Processes response, which may involve updating or committing records, each of which
         * will inform the owning stores and their interested views. Finally, we may perform
         * an additional layout if the data shape has changed.
         */
        protected processResponse();

        setApi();

        setCacheString();

        setDirectionParam();

        /**
         * Sets a value in the underlying {@link #extraParams}.
         * @param {String} name The key for the new value
         * @param {Object} value The value
         */
        setExtraParam(name: string, value: any);

        setExtraParams();

        setFilterParam();

        setGroupDirectionParam();

        setGroupParam();

        setIdParam();

        setLimitParam();

        setNoCache();

        setPageParam();

        setSimpleGroupMode();

        setSimpleSortMode();

        setSortParam();

        setStartParam();

        setTimeout();

        setUrl();

        /**
         * Fires when the server returns an exception. This event may also be listened
         * to in the event that a request has timed out or has been aborted.
         * @param {Ext.data.Request} request The request that was sent
         * @param {Ext.data.operation.Operation} operation The operation that triggered the request
         */
        exception(that: Ext.data.proxy.Proxy, request: Ext.data.Request, operation: Ext.data.operation.Operation);
    }

    /**
     * Proxy which uses HTML5 session storage as its data storage/retrieval mechanism. If this proxy is used in a browser
     * where session storage is not supported, the constructor will throw an error. A session storage proxy requires a
     * unique ID which is used as a key in which all record data are stored in the session storage object.
     *
     * It's important to supply this unique ID as it cannot be reliably determined otherwise. If no id is provided but the
     * attached store has a storeId, the storeId will be used. If neither option is presented the proxy will throw an error.
     *
     * Proxies are almost always used with a {@link Ext.data.Store store}:
     *
     *     new Ext.data.Store({
     *         proxy: {
     *             type: 'sessionstorage',
     *             id  : 'myProxyKey'
     *         }
     *     });
     *
     * Alternatively you can instantiate the Proxy directly:
     *
     *     new Ext.data.proxy.SessionStorage({
     *         id  : 'myOtherProxyKey'
     *     });
     *
     * Note that session storage is different to local storage (see {@link Ext.data.proxy.LocalStorage}) - if a browser
     * session is ended (e.g. by closing the browser) then all data in a SessionStorageProxy are lost. Browser restarts
     * don't affect the {@link Ext.data.proxy.LocalStorage} - the data are preserved.
     */
    export class SessionStorage extends Ext.data.proxy.WebStorage {
        /**
         * Creates the proxy, throws an error if local storage is not supported in the current browser.
         * @param {Object} config (optional) Config object.
         */
        constructor(config: Ext.data.proxy.WebStorageConfig);
    }

    interface WebStorageConfig extends Ext.data.proxy.ProxyConfig {
        /**
         * The unique ID used as the key in which all record data are stored in the local storage object.
         */
        id?: string;
    }

    /**
     * WebStorageProxy is simply a superclass for the {@link Ext.data.proxy.LocalStorage LocalStorage} and {@link
     * Ext.data.proxy.SessionStorage SessionStorage} proxies. It uses the new HTML5 key/value client-side storage objects to
     * save {@link Ext.data.Model model instances} for offline use.
     */
    export class WebStorage extends Ext.data.proxy.Client implements Ext.data.proxy.WebStorageConfig {
        /**
         * Cached map of records already retrieved by this Proxy. Ensures that the same instance is always retrieved.
         */
        cache: any;

        /**
         * The unique ID used as the key in which all record data are stored in the local storage object.
         */
        id: string;

        /**
         * Destroys all records stored in the proxy and removes all keys and values used to support the proxy from the
         * storage object.
         */
        clear();

        /**
         * Creates the proxy, throws an error if local storage is not supported in the current browser.
         * @param {Object} config (optional) Config object.
         */
        constructor(config: Ext.data.proxy.WebStorageConfig);

        getId();

        setId();

        /**
         * Saves the given record in the Proxy.
         * @param {Ext.data.Model} record The model instance
         * @param {String} [id] The id to save the record under (defaults to the value of the record's getId() function)
         */
        setRecord(record: Ext.data.Model, id?: string);
    }
}

declare module Ext.data.reader {
    interface ArrayConfig extends Ext.data.reader.JsonConfig {
        successProperty?: any;

        totalProperty?: any;
    }

    export class Array extends Ext.data.reader.Json implements Ext.data.reader.ArrayConfig {
        /**
         * Name of the property from which to retrieve the 'success' attribute, the value of which indicates
         * whether a given request succeeded or failed (typically a boolean or 'true'|'false'). See
         * {@link Ext.data.proxy.Server}.{@link Ext.data.proxy.Server#exception exception} for additional information.
         *
         * Optional
         */
        successProperty: string;

        /**
         * Name of the property from which to retrieve the total number of records in the dataset. This is only needed if
         * the whole dataset is not passed in one go, but is being paged from the remote server.
         *
         * Optional
         */
        totalProperty: string;

        /**
         * <p>Data reader class to create an Array of {@link Ext.data.Model} objects from an Array.
         * Each element of that Array represents a row of data fields. The
         * fields are pulled into a Record object using as a subscript, the <code>mapping</code> property
         * of the field definition if it exists, or the field's ordinal position in the definition.</p>
         *
         * <p><u>Example code:</u></p>
         *
         <pre><code>
         Employee = Ext.define('Employee', {
         extend: 'Ext.data.Model',
         fields: [
         'id',
         {name: 'name', mapping: 1},         // "mapping" only needed if an "id" field is present which
         {name: 'occupation', mapping: 2}    // precludes using the ordinal position as the index.
         ]
         });
         var myReader = new Ext.data.reader.Array({
         model: 'Employee'
         }, Employee);
         </code></pre>
         *
         * <p>This would consume an Array like this:</p>
         *
         <pre><code>
         [ [1, 'Bill', 'Gardener'], [2, 'Ben', 'Horticulturalist'] ]
         </code></pre>
         *
         * @constructor
         * Create a new ArrayReader
         * @param {Object} meta Metadata configuration options.
         */
        constructor(meta: any);

        getSuccessProperty();

        getTotalProperty();

        setSuccessProperty();

        setTotalProperty();
    }

    interface JsonConfig extends Ext.data.reader.ReaderConfig {
        /**
         * Name of the property from which to retrieve the 'metaData' attribute. See {@link #metaData}.
         *
         * Optional
         */
        metaProperty?: string;

        /**
         * The reader will keep a copy of the most recent request in the {@link #rawData} property. For performance reasons,
         * the data object for each record is used directly as the model data. This means that these objects may be modified and
         * thus modify the raw data. To ensure the objects are copied, set this option to 'true'. NB: This only applies to items
         * that are read as part of the data array, any other metadata will not be modified:
         *
         *     {
         *         "someOtherData": 1, // Won't be modified
         *         "root": [{}, {}, {}] // The objects here will be modified
         *     }
         */
        preserveRawData?: boolean;

        /**
         * The optional location within the JSON response that the record data itself can be found at.
         * See the JsonReader intro docs for more details. This is not often needed.
         */
        record?: string;

        /**
         * True to ensure that field names/mappings are treated as literals when
         * reading values.
         *
         * For example, by default, using the mapping "foo.bar.baz" will try and read a property foo from the root, then a property bar
         * from foo, then a property baz from bar. Setting the simple accessors to true will read the property with the name
         * "foo.bar.baz" direct from the root object.
         */
        useSimpleAccessors?: boolean;
    }

    /**
     * The JSON Reader is used by a Proxy to read a server response that is sent back in JSON format. This usually
     * happens as a result of loading a Store - for example we might create something like this:
     *
     *     Ext.define('User', {
     *         extend: 'Ext.data.Model',
     *         fields: ['id', 'name', 'email']
     *     });
     *
     *     var store = Ext.create('Ext.data.Store', {
     *         model: 'User',
     *         proxy: {
     *             type: 'ajax',
     *             url : 'users.json',
     *             reader: {
     *                 type: 'json'
     *             }
     *         }
     *     });
     *
     * The example above creates a 'User' model. Models are explained in the {@link Ext.data.Model Model} docs if you're
     * not already familiar with them.
     *
     * We created the simplest type of JSON Reader possible by simply telling our {@link Ext.data.Store Store}'s
     * {@link Ext.data.proxy.Proxy Proxy} that we want a JSON Reader. The Store automatically passes the configured model to the
     * Store, so it is as if we passed this instead:
     *
     *     reader: {
     *         type : 'json',
     *         model: 'User'
     *     }
     *
     * The reader we set up is ready to read data from our server - at the moment it will accept a response like this:
     *
     *     [
     *         {
     *             "id": 1,
     *             "name": "Ed Spencer",
     *             "email": "ed@sencha.com"
     *         },
     *         {
     *             "id": 2,
     *             "name": "Abe Elias",
     *             "email": "abe@sencha.com"
     *         }
     *     ]
     *
     * ## Reading other JSON formats
     *
     * If you already have your JSON format defined and it doesn't look quite like what we have above, you can usually
     * pass JsonReader a couple of configuration options to make it parse your format. For example, we can use the
     * {@link #cfg-rootProperty} configuration to parse data that comes back like this:
     *
     *     {
     *         "users": [
     *            {
     *                "id": 1,
     *                "name": "Ed Spencer",
     *                "email": "ed@sencha.com"
     *            },
     *            {
     *                "id": 2,
     *                "name": "Abe Elias",
     *                "email": "abe@sencha.com"
     *            }
     *         ]
     *     }
     *
     * To parse this we just pass in a {@link #rootProperty} configuration that matches the 'users' above:
     *
     *     reader: {
     *         type: 'json',
     *         rootProperty: 'users'
     *     }
     *
     * Sometimes the JSON structure is even more complicated. Document databases like CouchDB often provide metadata
     * around each record inside a nested structure like this:
     *
     *     {
     *         "total": 122,
     *         "offset": 0,
     *         "users": [
     *             {
     *                 "id": "ed-spencer-1",
     *                 "value": 1,
     *                 "user": {
     *                     "id": 1,
     *                     "name": "Ed Spencer",
     *                     "email": "ed@sencha.com"
     *                 }
     *             }
     *         ]
     *     }
     *
     * In the case above the record data is nested an additional level inside the "users" array as each "user" item has
     * additional metadata surrounding it ('id' and 'value' in this case). To parse data out of each "user" item in the
     * JSON above we need to specify the {@link #record} configuration like this:
     *
     *     reader: {
     *         type  : 'json',
     *         rootProperty  : 'users',
     *         record: 'user'
     *     }
     *
     * ## Response MetaData
     *
     * The server can return metadata in its response, in addition to the record data, that describe attributes
     * of the data set itself or are used to reconfigure the Reader. To pass metadata in the response you simply
     * add a 'metaData' attribute to the root of the response data. The metaData attribute can contain anything,
     * but supports a specific set of properties that are handled by the Reader if they are present:
     *
     * - {@link #rootProperty}: the property name of the root response node containing the record data
     * - {@link #totalProperty}: property name for the total number of records in the data
     * - {@link #successProperty}: property name for the success status of the response
     * - {@link #messageProperty}: property name for an optional response message
     * - {@link Ext.data.Model#cfg-fields fields}: Config used to reconfigure the Model's fields before converting the
     * response data into records
     *
     * An initial Reader configuration containing all of these properties might look like this ("fields" would be
     * included in the Model definition, not shown):
     *
     *     reader: {
     *         type : 'json',
     *         rootProperty : 'root',
     *         totalProperty  : 'total',
     *         successProperty: 'success',
     *         messageProperty: 'message'
     *     }
     *
     * If you were to pass a response object containing attributes different from those initially defined above, you could
     * use the 'metaData' attribute to reconfigure the Reader on the fly. For example:
     *
     *     {
     *         "count": 1,
     *         "ok": true,
     *         "msg": "Users found",
     *         "users": [{
     *             "userId": 123,
     *             "name": "Ed Spencer",
     *             "email": "ed@sencha.com"
     *         }],
     *         "metaData": {
     *             "rootProperty": "users",
     *             "totalProperty": 'count',
     *             "successProperty": 'ok',
     *             "messageProperty": 'msg'
     *         }
     *     }
     *
     * You can also place any other arbitrary data you need into the 'metaData' attribute which will be ignored by the Reader,
     * but will be accessible via the Reader's {@link #metaData} property (which is also passed to listeners via the Proxy's
     * {@link Ext.data.proxy.Proxy#metachange metachange} event (also relayed by the store). Application code can then
     * process the passed metadata in any way it chooses.
     *
     * A simple example for how this can be used would be customizing the fields for a Model that is bound to a grid. By passing
     * the 'fields' property the Model will be automatically updated by the Reader internally, but that change will not be
     * reflected automatically in the grid unless you also update the column configuration. You could do this manually, or you
     * could simply pass a standard grid {@link Ext.panel.Table#columns column} config object as part of the 'metaData' attribute
     * and then pass that along to the grid. Here's a very simple example for how that could be accomplished:
     *
     *     // response format:
     *     {
     *         ...
     *         "metaData": {
     *             "fields": [
     *                 { "name": "userId", "type": "int" },
     *                 { "name": "name", "type": "string" },
     *                 { "name": "birthday", "type": "date", "dateFormat": "Y-j-m" },
     *             ],
     *             "columns": [
     *                 { "text": "User ID", "dataIndex": "userId", "width": 40 },
     *                 { "text": "User Name", "dataIndex": "name", "flex": 1 },
     *                 { "text": "Birthday", "dataIndex": "birthday", "flex": 1, "format": 'Y-j-m', "xtype": "datecolumn" }
     *             ]
     *         }
     *     }
     *
     * The Reader will automatically read the meta fields config and rebuild the Model based on the new fields, but to handle
     * the new column configuration you would need to handle the metadata within the application code. This is done simply enough
     * by handling the metachange event on either the store or the proxy, e.g.:
     *
     *     var store = Ext.create('Ext.data.Store', {
     *         ...
     *         listeners: {
     *             'metachange': function(store, meta) {
     *                 myGrid.reconfigure(store, meta.columns);
     *             }
     *         }
     *     });
     */
    export class Json extends Ext.data.reader.Reader implements Ext.data.reader.JsonConfig {
        /**
         * Name of the property from which to retrieve the 'metaData' attribute. See {@link #metaData}.
         *
         * Optional
         */
        metaProperty: string;

        /**
         * The reader will keep a copy of the most recent request in the {@link #rawData} property. For performance reasons,
         * the data object for each record is used directly as the model data. This means that these objects may be modified and
         * thus modify the raw data. To ensure the objects are copied, set this option to 'true'. NB: This only applies to items
         * that are read as part of the data array, any other metadata will not be modified:
         *
         *     {
         *         "someOtherData": 1, // Won't be modified
         *         "root": [{}, {}, {}] // The objects here will be modified
         *     }
         */
        preserveRawData: boolean;

        /**
         * The optional location within the JSON response that the record data itself can be found at.
         * See the JsonReader intro docs for more details. This is not often needed.
         */
        record: string;

        /**
         * True to ensure that field names/mappings are treated as literals when
         * reading values.
         *
         * For example, by default, using the mapping "foo.bar.baz" will try and read a property foo from the root, then a property bar
         * from foo, then a property baz from bar. Setting the simple accessors to true will read the property with the name
         * "foo.bar.baz" direct from the root object.
         */
        useSimpleAccessors: boolean;

        /**
         * Creates new Reader.
         * @param {Object} [config] Config object.
         */
        constructor(config?: Ext.data.amf.ReaderConfig);

        getMetaProperty();

        getPreserveRawData();

        getRecord();

        getUseSimpleAccessors();

        /**
         * Reads a JSON object and returns a ResultSet. Uses the internal getTotal and getSuccess extractors to
         * retrieve meta data from the response, and extractData to turn the JSON data into model instances.
         * @param {Object} data The raw JSON data
         * @param {Object} [readOptions] See {@link #read} for details.
         * @return {Ext.data.ResultSet} A ResultSet containing model instances and meta data about the results
         */
        readRecords(data: any, readOptions?: any): Ext.data.ResultSet;

        setMetaProperty();

        setPreserveRawData();

        setRecord();

        setUseSimpleAccessors();
    }

    interface ReaderConfig {
        /**
         * True to automatically parse models nested within other models in a response object. See the
         * Ext.data.reader.Reader intro docs for full explanation.
         *
         * Optional
         */
        implicitIncludes?: boolean;

        /**
         * Determines if the Reader will keep raw data
         * received from the server in the {@link #rawData} property.
         *
         * While this might seem useful to do additional data processing, keeping raw data
         * might cause adverse effects such as memory leaks. It is recommended to set
         * 'keepRawData' to 'false' if you do not need the raw data.
         *
         * If you need to process data packet to extract additional data such as row summaries,
         * it is recommended to use {@link #transform} function for that purpose.
         *
         * Note that starting with Ext JS 6.0 the default behavior has been changed to
         * **not** keep the raw data because of the high potential for memory leaks.
         * @since 5.1.1
         *
         * Optional
         */
        keepRawData?: boolean;

        /**
         * The name of the property which contains a response message for exception handling. If you want to return a false success
         * response from the server, maybe due to some server-side validation, the messageProperty can hold the error message. For
         * example:
         *
         *     {
         *         "success": false,
         *         "error": "There was an error with your request"
         *     }
         *
         * You can retrieve this error message in a callback when loading a {@link Ext.data.Store Store} or {@link Ext.data.Model Model} like:
         *
         *     var store = new Ext.data.Store({
         *         fields : ['foo'],
         *         proxy  : {
         *             type   : 'ajax',
         *             url    : 'data.json',
         *             reader : {
         *                 type            : 'json',
         *                 rootProperty    : 'data',
         *                 messageProperty : 'error'
         *             }
         *         }
         *     });
         *
         *     store.load({
         *         callback: function(records, operation, success) {
         *             if (success) {
         *                 // ...
         *             } else {
         *                 var error = operation.getError();
         *
         *                 Ext.Msg.alert('Error', error);
         *             }
         *         }
         *     });
         *
         * In this example, the callback will execute with 'success' being 'false' and will therefore show the {@link Ext.MessageBox#alert Ext.Msg.alert} with
         * the error string returned in the response.
         */
        messageProperty?: string;

        /**
         * The model to use for this reader. This config is only required if the reader is being used
         * without a proxy, otherwise the proxy will automatically set the model.
         *
         * Optional
         */
        model?: string|Ext.data.Model;

        /**
         * True to extract the records from a data packet even if the {@link #successProperty} returns false.
         *
         * Optional
         */
        readRecordsOnFailure?: boolean;

        /**
         * The property that contains data items corresponding to the
         * Model(s) of the configured Reader. 'rootProperty' varies by Reader type.
         *
         * ##JSON Reader
         * 'rootProperty' is a property name. It may also be a dot-separated
         * list of property names if the root is nested. The root JSON array will be
         * used by default.
         *
         *     // rootPropety config
         *     rootProperty: 'embedded.myresults'
         *
         *     // server response
         *     {
         *         embedded: {
         *             myresults: [{
         *                 name: 'Scott',
         *                 age: 22
         *             }, {
         *                 name: 'Ramona',
         *                 age: 24
         *             }]
         *         },
         *         success: true
         *     }
         *
         * ##XML Reader
         * 'rootProperty' is a CSS selector. The root XML element will be used
         * by default.
         *
         *     // rootProperty config (plus record config)
         *     rootProperty: 'myresults',
         *     record: 'user'
         *
         *     // server response
         *     <?xml version="1.0" encoding="UTF-8"?>
         *     <embedded>
         *         <myresults>
         *             <user>
         *                 <name>Scott</name>
         *                 <age>22</age>
         *             </user>
         *             <user>
         *                 <name>Ramona</name>
         *                 <age>24</age>
         *             </user>
         *         </myresults>
         *     </embedded>
         *
         * ##Array Reader
         * 'rootProperty' is not typically applicable since the data is assumed to be a
         * single-level array of arrays.  However, if the array of records is returned
         * within a JSON response a 'rootProperty' config may be used:
         *
         *     // rootProperty config
         *     rootProperty: 'embedded.myresults'
         *
         *     // server response
         *     {
         *         embedded: {
         *             myresults: [['Scott', 22], ['Ramona', 24]]
         *         },
         *         success: true
         *     }
         *
         * ##rootProperty as a function
         * The 'rootProperty' may also be a function that returns the root node from
         * the dataset. For example:
         *
         *     var store = Ext.create('Ext.data.TreeStore', {
         *         proxy: {
         *             type: 'memory',
         *             reader: {
         *                 type: 'json',
         *                 rootProperty: function(data){
         *                     // Extract child nodes from the items or children property in the dataset
         *                     return data.items || data.children;
         *                 }
         *             }
         *         },
         *         data: {
         *             items: [{
         *                 text: 'item 1',
         *                 children: [{
         *                     text: 'child A',
         *                     leaf: true
         *                 }]
         *             }]
         *         }
         *     });
         *
         *     Ext.create('Ext.tree.Panel', {
         *         title: 'rootProperty as a function',
         *         width: 200,
         *         height:150,
         *         store: store,
         *         rootVisible: false,
         *         renderTo: Ext.getBody()
         *     });
         */
        rootProperty?: string|Function;

        /**
         * Name of the property from which to retrieve the 'success' attribute, the value of which indicates
         * whether a given request succeeded or failed (typically a boolean or 'true'|'false'). See
         * {@link Ext.data.proxy.Server}.{@link Ext.data.proxy.Server#exception exception} for additional information.
         *
         * Optional
         */
        successProperty?: string;

        /**
         * Name of the property from which to retrieve the total number of records in the dataset. This is only needed if
         * the whole dataset is not passed in one go, but is being paged from the remote server.
         *
         * Optional
         */
        totalProperty?: string;

        /**
         * If a transform function is set, it will be invoked just before {@link #readRecords} executes.
         * It is passed the raw (deserialized) data object. The transform function returns a data object, which can be
         * a modified version of the original data object, or a completely new data object. The transform can
         * be a function, or a method name on the Reader instance, or an object with a 'fn' key
         * and an optional 'scope' key.
         *
         * Example usage:
         *
         *     Ext.create('Ext.data.Store', {
         *         model: 'User',
         *         proxy: {
         *             type: 'ajax',
         *             url : 'users.json',
         *             reader: {
         *                 type: 'json',
         *                 transform: {
         *                     fn: function(data) {
         *                         // do some manipulation of the raw data object
         *                         return data;
         *                     },
         *                     scope: this
         *                 }
         *             }
         *         },
         *     });
         *
         * Optional
         */
        transform?: Function|string|any;

        /**
         * The name of the property in a node raw data block which indicates the type of the model to be created from that raw data. Useful for heterogeneous trees.
         *
         * For example, hierarchical geographical data may look like this:
         *
         *     {
         *         nodeType: 'Territory',
         *         name: 'EMEA',
         *         children: [{
         *             nodeType: 'Country',
         *             name: 'United Kingdon',
         *             children: [{
         *                 nodeType: 'City',
         *                 name: 'London'
         *             }]
         *         }]
         *     }
         *
         * You would configure the typeProperty in this case to be '"nodeType"' which would cause the models named "Territory", "Country" and "City" to
         * be used.
         *
         * Optional
         */
        typeProperty?: string;
    }

    /**
     * Readers are used to interpret data to be loaded into a {@link Ext.data.Model Model} instance or a {@link
     * Ext.data.Store Store} - often in response to an AJAX request. In general there is usually no need to create
     * a Reader instance directly, since a Reader is almost always used together with a {@link Ext.data.proxy.Proxy Proxy},
     * and is configured using the Proxy's {@link Ext.data.proxy.Proxy#cfg-reader reader} configuration property:
     *
     *     Ext.create('Ext.data.Store', {
     *         model: 'User',
     *         proxy: {
     *             type: 'ajax',
     *             url : 'users.json',
     *             reader: {
     *                 type: 'json',
     *                 rootProperty: 'users'
     *             }
     *         },
     *     });
     *
     * The above reader is configured to consume a JSON string that looks something like this:
     *
     *     {
     *         "success": true,
     *         "users": [
     *             { "name": "User 1" },
     *             { "name": "User 2" }
     *         ]
     *     }
     *
     *
     * # Loading Nested Data
     *
     * Readers have the ability to automatically load deeply-nested data objects based on the {@link Ext.data.schema.Association associations}
     * configured on each Model. Below is an example demonstrating the flexibility of these associations in a
     * fictional CRM system which manages a User, their Orders, OrderItems and Products. First we'll define the models:
     *
     *     Ext.define("User", {
     *         extend: 'Ext.data.Model',
     *         fields: [
     *             'id', 'name'
     *         ],
     *
     *         hasMany: {model: 'Order', name: 'orders'},
     *
     *         proxy: {
     *             type: 'rest',
     *             url : 'users.json',
     *             reader: {
     *                 type: 'json',
     *                 rootProperty: 'users'
     *             }
     *         }
     *     });
     *
     *     Ext.define("Order", {
     *         extend: 'Ext.data.Model',
     *         fields: [
     *             'id', 'total'
     *         ],
     *
     *         hasMany  : {model: 'OrderItem', name: 'orderItems', associationKey: 'order_items'},
     *         belongsTo: 'User'
     *     });
     *
     *     Ext.define("OrderItem", {
     *         extend: 'Ext.data.Model',
     *         fields: [
     *             'id', 'price', 'quantity', 'order_id', 'product_id'
     *         ],
     *
     *         belongsTo: ['Order', {model: 'Product', associationKey: 'product'}]
     *     });
     *
     *     Ext.define("Product", {
     *         extend: 'Ext.data.Model',
     *         fields: [
     *             'id', 'name'
     *         ],
     *
     *         hasMany: 'OrderItem'
     *     });
     *
     * This may be a lot to take in - basically a User has many Orders, each of which is composed of several OrderItems.
     * Finally, each OrderItem has a single Product. This allows us to consume data like this:
     *
     *     {
     *         "users": [
     *             {
     *                 "id": 123,
     *                 "name": "Ed",
     *                 "orders": [
     *                     {
     *                         "id": 50,
     *                         "total": 100,
     *                         "order_items": [
     *                             {
     *                                 "id"      : 20,
     *                                 "price"   : 40,
     *                                 "quantity": 2,
     *                                 "product" : {
     *                                     "id": 1000,
     *                                     "name": "MacBook Pro"
     *                                 }
     *                             },
     *                             {
     *                                 "id"      : 21,
     *                                 "price"   : 20,
     *                                 "quantity": 3,
     *                                 "product" : {
     *                                     "id": 1001,
     *                                     "name": "iPhone"
     *                                 }
     *                             }
     *                         ]
     *                     }
     *                 ]
     *             }
     *         ]
     *     }
     *
     * The JSON response is deeply nested - it returns all Users (in this case just 1 for simplicity's sake), all of the
     * Orders for each User (again just 1 in this case), all of the OrderItems for each Order (2 order items in this case),
     * and finally the Product associated with each OrderItem. Now we can read the data and use it as follows:
     *
     *     var store = Ext.create('Ext.data.Store', {
     *         model: "User"
     *     });
     *
     *     store.load({
     *         callback: function() {
     *             //the user that was loaded
     *             var user = store.first();
     *
     *             console.log("Orders for " + user.get('name') + ":")
     *
     *             //iterate over the Orders for each User
     *             user.orders().each(function(order) {
     *                 console.log("Order ID: " + order.getId() + ", which contains items:");
     *
     *                 //iterate over the OrderItems for each Order
     *                 order.orderItems().each(function(orderItem) {
     *                     //we know that the Product data is already loaded, so we can use the synchronous getProduct
     *                     //usually, we would use the asynchronous version (see #belongsTo)
     *                     var product = orderItem.getProduct();
     *
     *                     console.log(orderItem.get('quantity') + ' orders of ' + product.get('name'));
     *                 });
     *             });
     *         }
     *     });
     *
     * Running the code above results in the following:
     *
     *     Orders for Ed:
     *     Order ID: 50, which contains items:
     *     2 orders of MacBook Pro
     *     3 orders of iPhone
     */
    export class Reader extends Ext.Base implements Ext.data.reader.ReaderConfig {
        factoryConfig: any;

        /**
         * 'true' in this class to identify an object as an instantiated Reader, or subclass thereof.
         **/
        isReader: boolean;

        /**
         * The raw meta data that was most recently read, if any. Meta data can include existing
         * Reader config options like {@link #totalProperty}, etc. that get
         * automatically applied to the Reader, and those can still be accessed directly from the Reader
         * if needed. However, meta data is also often used to pass other custom data to be processed
         * by application code. For example, it is common when reconfiguring the data model of a grid to
         * also pass a corresponding column model config to be applied to the grid. Any such data will
         * not get applied to the Reader directly (it just gets passed through and is ignored by Ext).
         * This metaData property gives you access to all meta data that was passed, including any such
         * custom data ignored by the reader.
         *
         * This is a read-only property, and it will get replaced each time a new meta data object is
         * passed to the reader. Note that typically you would handle proxy's
         * {@link Ext.data.proxy.Proxy#metachange metachange} event which passes this exact same meta
         * object to listeners. However this property is available if it's more convenient to access it
         * via the reader directly in certain cases.
         * @readonly
         */
        metaData: any;

        /**
         * The raw data object that was last passed to {@link #readRecords}. rawData is populated
         * based on the results of {@link Ext.data.proxy.Server#processResponse}. rawData will
         * maintain a cached copy of the last successfully returned records. In other words,
         * if processResponse is unsuccessful, the records from the last successful response
         * will remain cached in rawData.
         *
         * Since Ext JS 5.1.1 you can use the {@link #keepRawData} config option to
         * control this behavior.
         */
        rawData: any;

        /**
         * True to automatically parse models nested within other models in a response object. See the
         * Ext.data.reader.Reader intro docs for full explanation.
         *
         * Optional
         */
        implicitIncludes: boolean;

        /**
         * Determines if the Reader will keep raw data
         * received from the server in the {@link #rawData} property.
         *
         * While this might seem useful to do additional data processing, keeping raw data
         * might cause adverse effects such as memory leaks. It is recommended to set
         * 'keepRawData' to 'false' if you do not need the raw data.
         *
         * If you need to process data packet to extract additional data such as row summaries,
         * it is recommended to use {@link #transform} function for that purpose.
         *
         * Note that starting with Ext JS 6.0 the default behavior has been changed to
         * **not** keep the raw data because of the high potential for memory leaks.
         * @since 5.1.1
         *
         * Optional
         */
        keepRawData: boolean;

        /**
         * The name of the property which contains a response message for exception handling. If you want to return a false success
         * response from the server, maybe due to some server-side validation, the messageProperty can hold the error message. For
         * example:
         *
         *     {
         *         "success": false,
         *         "error": "There was an error with your request"
         *     }
         *
         * You can retrieve this error message in a callback when loading a {@link Ext.data.Store Store} or {@link Ext.data.Model Model} like:
         *
         *     var store = new Ext.data.Store({
         *         fields : ['foo'],
         *         proxy  : {
         *             type   : 'ajax',
         *             url    : 'data.json',
         *             reader : {
         *                 type            : 'json',
         *                 rootProperty    : 'data',
         *                 messageProperty : 'error'
         *             }
         *         }
         *     });
         *
         *     store.load({
         *         callback: function(records, operation, success) {
         *             if (success) {
         *                 // ...
         *             } else {
         *                 var error = operation.getError();
         *
         *                 Ext.Msg.alert('Error', error);
         *             }
         *         }
         *     });
         *
         * In this example, the callback will execute with 'success' being 'false' and will therefore show the {@link Ext.MessageBox#alert Ext.Msg.alert} with
         * the error string returned in the response.
         */
        messageProperty: string;

        /**
         * The model to use for this reader. This config is only required if the reader is being used
         * without a proxy, otherwise the proxy will automatically set the model.
         *
         * Optional
         */
        model: string|Ext.data.Model;

        /**
         * True to extract the records from a data packet even if the {@link #successProperty} returns false.
         *
         * Optional
         */
        readRecordsOnFailure: boolean;

        /**
         * The property that contains data items corresponding to the
         * Model(s) of the configured Reader. 'rootProperty' varies by Reader type.
         *
         * ##JSON Reader
         * 'rootProperty' is a property name. It may also be a dot-separated
         * list of property names if the root is nested. The root JSON array will be
         * used by default.
         *
         *     // rootPropety config
         *     rootProperty: 'embedded.myresults'
         *
         *     // server response
         *     {
         *         embedded: {
         *             myresults: [{
         *                 name: 'Scott',
         *                 age: 22
         *             }, {
         *                 name: 'Ramona',
         *                 age: 24
         *             }]
         *         },
         *         success: true
         *     }
         *
         * ##XML Reader
         * 'rootProperty' is a CSS selector. The root XML element will be used
         * by default.
         *
         *     // rootProperty config (plus record config)
         *     rootProperty: 'myresults',
         *     record: 'user'
         *
         *     // server response
         *     <?xml version="1.0" encoding="UTF-8"?>
         *     <embedded>
         *         <myresults>
         *             <user>
         *                 <name>Scott</name>
         *                 <age>22</age>
         *             </user>
         *             <user>
         *                 <name>Ramona</name>
         *                 <age>24</age>
         *             </user>
         *         </myresults>
         *     </embedded>
         *
         * ##Array Reader
         * 'rootProperty' is not typically applicable since the data is assumed to be a
         * single-level array of arrays.  However, if the array of records is returned
         * within a JSON response a 'rootProperty' config may be used:
         *
         *     // rootProperty config
         *     rootProperty: 'embedded.myresults'
         *
         *     // server response
         *     {
         *         embedded: {
         *             myresults: [['Scott', 22], ['Ramona', 24]]
         *         },
         *         success: true
         *     }
         *
         * ##rootProperty as a function
         * The 'rootProperty' may also be a function that returns the root node from
         * the dataset. For example:
         *
         *     var store = Ext.create('Ext.data.TreeStore', {
         *         proxy: {
         *             type: 'memory',
         *             reader: {
         *                 type: 'json',
         *                 rootProperty: function(data){
         *                     // Extract child nodes from the items or children property in the dataset
         *                     return data.items || data.children;
         *                 }
         *             }
         *         },
         *         data: {
         *             items: [{
         *                 text: 'item 1',
         *                 children: [{
         *                     text: 'child A',
         *                     leaf: true
         *                 }]
         *             }]
         *         }
         *     });
         *
         *     Ext.create('Ext.tree.Panel', {
         *         title: 'rootProperty as a function',
         *         width: 200,
         *         height:150,
         *         store: store,
         *         rootVisible: false,
         *         renderTo: Ext.getBody()
         *     });
         */
        rootProperty: string|Function;

        /**
         * Name of the property from which to retrieve the 'success' attribute, the value of which indicates
         * whether a given request succeeded or failed (typically a boolean or 'true'|'false'). See
         * {@link Ext.data.proxy.Server}.{@link Ext.data.proxy.Server#exception exception} for additional information.
         *
         * Optional
         */
        successProperty: string;

        /**
         * Name of the property from which to retrieve the total number of records in the dataset. This is only needed if
         * the whole dataset is not passed in one go, but is being paged from the remote server.
         *
         * Optional
         */
        totalProperty: string;

        /**
         * If a transform function is set, it will be invoked just before {@link #readRecords} executes.
         * It is passed the raw (deserialized) data object. The transform function returns a data object, which can be
         * a modified version of the original data object, or a completely new data object. The transform can
         * be a function, or a method name on the Reader instance, or an object with a 'fn' key
         * and an optional 'scope' key.
         *
         * Example usage:
         *
         *     Ext.create('Ext.data.Store', {
         *         model: 'User',
         *         proxy: {
         *             type: 'ajax',
         *             url : 'users.json',
         *             reader: {
         *                 type: 'json',
         *                 transform: {
         *                     fn: function(data) {
         *                         // do some manipulation of the raw data object
         *                         return data;
         *                     },
         *                     scope: this
         *                 }
         *             }
         *         },
         *     });
         *
         * Optional
         */
        transform: Function|string|any;

        /**
         * The name of the property in a node raw data block which indicates the type of the model to be created from that raw data. Useful for heterogeneous trees.
         *
         * For example, hierarchical geographical data may look like this:
         *
         *     {
         *         nodeType: 'Territory',
         *         name: 'EMEA',
         *         children: [{
         *             nodeType: 'Country',
         *             name: 'United Kingdon',
         *             children: [{
         *                 nodeType: 'City',
         *                 name: 'London'
         *             }]
         *         }]
         *     }
         *
         * You would configure the typeProperty in this case to be '"nodeType"' which would cause the models named "Territory", "Country" and "City" to
         * be used.
         *
         * Optional
         */
        typeProperty: string;

        /**
         * Creates new Reader.
         * @param {Object} [config] Config object.
         */
        constructor(config?: Ext.data.amf.ReaderConfig);

        destroy();

        /**
         * This method provides a hook to do any data transformation before the reading process
         * begins. By default this function just returns what is passed to it. It can be
         * overridden in a subclass to return something else.
         * See {@link Ext.data.reader.Xml XmlReader} for an example.
         *
         * @param {Object} data The data object
         * @return {Object} The normalized data object
         */
        protected getData(data: any): any;

        getImplicitIncludes();

        getKeepRawData();

        getMessageProperty();

        getModel();

        getReadRecordsOnFailure();

        /**
         * Takes a raw response object (as passed to the {@link #read} method) and returns the useful data
         * segment from it. This must be implemented by each subclass.
         * @param {Object} response The response object
         * @return {Object} The extracted data from the response. For example, a JSON object or an XML document.
         */
        getResponseData(response: any): any;

        getRootProperty();

        getSuccessProperty();

        getTotalProperty();

        getTransform();

        getTypeProperty();

        /**
         * Reads the given response object. This method normalizes the different types of response object that may be passed to it.
         * If it's an XMLHttpRequest object, hand off to the subclass' {@link #getResponseData} method.
         * Else, hand off the reading of records to the {@link #readRecords} method.
         * @param {Object} response The response object. This may be either an XMLHttpRequest object or a plain JS object
         * @param {Object} [readOptions] Various options that instruct the reader on how to read the data
         * @param {Function} [readOptions.recordCreator] A function to construct the model based on the processed data. By default,
         * this just calls the model constructor and passes the raw data.
         * @return {Ext.data.ResultSet} The parsed or default ResultSet object
         */
        read(response: any, readOptions?: any, readOptions_recordCreator?: Function): Ext.data.ResultSet;

        /**
         * Abstracts common functionality used by all Reader subclasses. Each subclass is expected to call this function
         * before running its own logic and returning the Ext.data.ResultSet instance. For most Readers additional
         * processing should not be needed.
         * @param {Object} data The raw data object
         * @param {Object} [readOptions] See {@link #read} for details.
         * @return {Ext.data.ResultSet} A ResultSet object
         */
        readRecords(data: any, readOptions?: any): Ext.data.ResultSet;

        setImplicitIncludes();

        setKeepRawData();

        setMessageProperty();

        setModel();

        setReadRecordsOnFailure();

        setRootProperty();

        setSuccessProperty();

        setTotalProperty();

        setTransform();

        setTypeProperty();

        /**
         * Fires when the reader receives improperly encoded data from the server
         * @param {Ext.data.reader.Reader} reader A reference to this reader
         * @param {XMLHttpRequest} response The XMLHttpRequest response object
         * @param {Ext.data.ResultSet} error The error object
         */
        exception(reader: Ext.data.reader.Reader, response: any, error: Ext.data.ResultSet);
    }

    interface XmlConfig extends Ext.data.reader.ReaderConfig {
        /**
         * A namespace prefix that will be prepended to the field name when reading a
         * field from an XML node.  Take, for example, the following Model:
         *
         *     Ext.define('Foo', {
         *         extend: 'Ext.data.Model',
         *         fields: ['bar', 'baz']
         *     });
         *
         * The reader would need to be configured with a namespace of 'n' in order to read XML
         * data in the following format:
         *
         *     <foo>
         *         <n:bar>bar</n:bar>
         *         <n:baz>baz</n:baz>
         *     </foo>
         */
        namespace?: string;

        /**
         * (required)
         * The DomQuery path to the repeated element which contains record information.
         *
         * By default, the elements which match the selector may be nested at any level
         * below the {@link #rootProperty}
         *
         * If this Reader is being used by a {@link Ext.data.TreeStore TreeStore} to read tree-structured data,
         * then only first generation child nodes of the root element must be selected, so the record selector must be
         * specified with a more specific selector which will not select all descendants. For example:
         *
         *    record: '>node'
         */
        record?: string;
    }

    /**
     * The XML Reader is used by a Proxy to read a server response that is sent back in XML format. This usually happens as
     * a result of loading a Store - for example we might create something like this:
     *
     *     Ext.define('User', {
     *         extend: 'Ext.data.Model',
     *         fields: ['id', 'name', 'email']
     *     });
     *
     *     var store = Ext.create('Ext.data.Store', {
     *         model: 'User',
     *         proxy: {
     *             type: 'ajax',
     *             url : 'users.xml',
     *             reader: {
     *                 type: 'xml',
     *                 record: 'user',
     *                 rootProperty: 'users'
     *             }
     *         }
     *     });
     *
     * The example above creates a 'User' model. Models are explained in the {@link Ext.data.Model Model} docs if you're not
     * already familiar with them.
     *
     * We created the simplest type of XML Reader possible by simply telling our {@link Ext.data.Store Store}'s {@link
     * Ext.data.proxy.Proxy Proxy} that we want a XML Reader. The Store automatically passes the configured model to the
     * Store, so it is as if we passed this instead:
     *
     *     reader: {
     *         type : 'xml',
     *         model: 'User',
     *         record: 'user',
     *         rootProperty: 'users'
     *     }
     *
     * The reader we set up is ready to read data from our server - at the moment it will accept a response like this:
     *
     *     <?xml version="1.0" encoding="UTF-8"?>
     *     <users>
     *         <user>
     *             <id>1</id>
     *             <name>Ed Spencer</name>
     *             <email>ed@sencha.com</email>
     *         </user>
     *         <user>
     *             <id>2</id>
     *             <name>Abe Elias</name>
     *             <email>abe@sencha.com</email>
     *         </user>
     *     </users>
     *
     * First off there's {@link #rootProperty} option to define the root node '<users>' (there should be only one in a well-formed
     * XML document). Then the XML Reader uses the configured {@link #record} option to pull out the data for each record -
     * in this case we set record to 'user', so each '<user>' above will be converted into a User model.
     *
     * Note that XmlReader doesn't care whether your {@link #rootProperty} and {@link #record} elements are nested deep inside a
     * larger structure, so a response like this will still work:
     *
     *     <?xml version="1.0" encoding="UTF-8"?>
     *     <deeply>
     *         <nested>
     *             <xml>
     *                 <users>
     *                     <user>
     *                         <id>1</id>
     *                         <name>Ed Spencer</name>
     *                         <email>ed@sencha.com</email>
     *                     </user>
     *                     <user>
     *                         <id>2</id>
     *                         <name>Abe Elias</name>
     *                         <email>abe@sencha.com</email>
     *                     </user>
     *                 </users>
     *             </xml>
     *         </nested>
     *     </deeply>
     *
     * If this Reader is being used by a {@link Ext.data.TreeStore TreeStore} to read tree-structured data in which records
     * are nested as descendant nodes of other records, then this lenient behaviour must be overridden by using a more specific
     * child node selector as your {@link #record} selector which will not select all descendants, such as:
     *
     *    record: '>user'
     *
     * # Response metadata
     *
     * The server can return additional data in its response, such as the {@link #totalProperty total number of records} and
     * the {@link #successProperty success status of the response}. These are typically included in the XML response like
     * this:
     *
     *     <?xml version="1.0" encoding="UTF-8"?>
     *     <users>
     *         <total>100</total>
     *         <success>true</success>
     *         <user>
     *             <id>1</id>
     *             <name>Ed Spencer</name>
     *             <email>ed@sencha.com</email>
     *         </user>
     *         <user>
     *             <id>2</id>
     *             <name>Abe Elias</name>
     *             <email>abe@sencha.com</email>
     *         </user>
     *     </users>
     *
     * If these properties are present in the XML response they can be parsed out by the XmlReader and used by the Store
     * that loaded it. We can set up the names of these properties by specifying a final pair of configuration options:
     *
     *     reader: {
     *         type: 'xml',
     *         rootProperty: 'users',
     *         totalProperty  : 'total',
     *         successProperty: 'success'
     *     }
     *
     * These final options are not necessary to make the Reader work, but can be useful when the server needs to report an
     * error or if it needs to indicate that there is a lot of data available of which only a subset is currently being
     * returned.
     *
     * # Response format
     *
     * **Note:** in order for the browser to parse a returned XML document, the Content-Type header in the HTTP response
     * must be set to "text/xml" or "application/xml". This is very important - the XmlReader will not work correctly
     * otherwise.
     */
    export class Xml extends Ext.data.reader.Reader implements Ext.data.reader.XmlConfig {
        /**
         * Copy of {@link #rawData}.
         * @deprecated 5.1.1 Removed in Ext JS 5.0. Use {@link #rawData} instead.
         */
        xmlData: any;

        /**
         * A namespace prefix that will be prepended to the field name when reading a
         * field from an XML node.  Take, for example, the following Model:
         *
         *     Ext.define('Foo', {
         *         extend: 'Ext.data.Model',
         *         fields: ['bar', 'baz']
         *     });
         *
         * The reader would need to be configured with a namespace of 'n' in order to read XML
         * data in the following format:
         *
         *     <foo>
         *         <n:bar>bar</n:bar>
         *         <n:baz>baz</n:baz>
         *     </foo>
         */
        namespace: string;

        /**
         * (required)
         * The DomQuery path to the repeated element which contains record information.
         *
         * By default, the elements which match the selector may be nested at any level
         * below the {@link #rootProperty}
         *
         * If this Reader is being used by a {@link Ext.data.TreeStore TreeStore} to read tree-structured data,
         * then only first generation child nodes of the root element must be selected, so the record selector must be
         * specified with a more specific selector which will not select all descendants. For example:
         *
         *    record: '>node'
         */
        record: string;

        /**
         * Creates new Reader.
         * @param {Object} [config] Config object.
         */
        constructor(config?: Ext.data.amf.ReaderConfig);

        getNamespace();

        getRecord();

        setNamespace();

        setRecord();
    }
}

declare module Ext.data.request {
    /**
     * This class manages a pending Ajax request. Instances of this type are created by the
     * '{@link Ext.data.Connection#request}' method.
     * @since 6.0.0
     */
    export class Ajax extends Ext.data.request.Base {
        /**
         * Aborts an active request.
         */
        abort();

        /**
         * Cleans up any left over information from the request
         */
        cleanup();

        constructor(config: any);

        destroy();
    }

    /**
     * This class manages a pending Ajax request. Instances of this type are created by the
     * '{@link Ext.data.Connection#request}' method.
     * @since 6.0.0
     */
    export class Base extends Ext.Base {
        factoryConfig: any;

        constructor(config: any);

        destroy();

        /**
         * Determines whether this request is in progress.
         *
         * @return {Boolean} 'true' if this request is in progress, 'false' if complete.
         */
        isLoading(): boolean;

        /**
         * Start the request.
         */
        start();
    }

    /**
     * This class manages a pending form submit. Instances of this type are created by the
     * '{@link Ext.data.Connection#request}' method.
     * @since 6.0.0
     */
    export class Form extends Ext.data.request.Base {
        constructor(config: any);

        destroy();
    }
}

declare module Ext.data.schema {
    interface AssociationConfig {
        /**
         * The name of this association.
         */
        name?: string;
    }

    /**
     * This class and its derivatives describe how two entities are related to each other.
     * Associations have the following forms:
     *
     *   * *{@link Ext.data.schema.ManyToOne many-to-one}*
     *   * *{@link Ext.data.schema.ManyToMany many-to-many}*
     *   * *{@link Ext.data.schema.OneToOne one-to-one}*
     *
     * Associations are first-class objects in a '{@link Ext.data.schema.Schema schema}' but
     * are not created directly. They are created based on {@link Ext.data.field.Field#reference}
     * properties but also on {@link Ext.data.schema.ManyToMany} declarations.
     *
     * Associations have unique names within the 'schema' as do {@link Ext.data.Model entities}.
     * In many cases, the association names can be generated. These names have uses beyond the
     * basic needs of tracking such as when communicating with the server. If the generated
     * names are not satisfactory, they can be given explicitly or the default naming can be
     * replaced by implementing a custom 'Ext.data.schema.Schema' class.
     *
     * # Life Cycle
     *
     * Intimately connected with many associations is the concept of life-cycle. It is often
     * the case that one entity is "owned" by another so that if the owner is to be deleted,
     * the owned entity must also be deleted.
     *
     * There are also associations that work in the reverse direction. That is, the presence of
     * an associated entity prevents the other entity from being deleted.
     *
     * Finally, some associations just need to be dissolved if one of the related entities is
     * deleted. This is the case in a {@link Ext.data.schema.ManyToMany many-to-many}
     * association, but can also be for others if the 'reference' field can be set to 'null'.
     *
     * # Left and Right
     *
     * Because associations are data that span entity types, they are not rightly viewed as
     * "belonging" to either entity. Instead, associations are owned by the 'Schema'. Even so,
     * because belonging to an association effects both entities, associations are often
     * viewed from two perspectives or "sides". To distinguish them we call one "left" and the
     * other "right".
     *
     * The reason for this choice derives from {@link Ext.data.schema.ManyToMany many-to-many}
     * associations and their typical underlying "matrix" table. If you were to view the matrix
     * table in a grid, you would see one id on the left and the other id on the right. There
     * is no further significance to these labels.
     *
     * While the concept of left and right might makes sense in a matrix relationship, the
     * labels also apply to the other relationships. In those cases, the "left" entity is the
     * entity that contains the {@link Ext.data.Field#reference} (or foreign key).
     *
     * # Example
     *
     * To help illustrate the various associations, consider a data model with Users, Groups
     * and Organizations. The Users are owned by an Organization. Deleting an Organization,
     * should delete all of the Users it contains. The Users can also be added to one or more
     * Groups, for example, the "moderator" or "admin" Group. Further, a a Level is assigned
     * to each User. Levels represent the subscriber's or customer's rank, such as "premium"
     * or "basic".
     *
     * To summarize:
     *
     *  * Users are *{@link Ext.data.schema.ManyToOne many-to-one}* to Organizations
     *  * Users are *{@link Ext.data.schema.ManyToOne many-to-one}* to Levels
     *  * Users are *{@link Ext.data.schema.ManyToMany many-to-many}* to Groups
     */
    export class Association extends Ext.Base implements Ext.data.schema.AssociationConfig {
        /**
         * @readonly
         */
        definedBy: Ext.Class;

        /**
         * @readonly
         */
        field: Ext.data.field.Field;

        /**
         * @readonly
         */
        left: Ext.data.schema.Role;

        /**
         * @readonly
         */
        nullable: boolean;

        /**
         * Points at either 'left' or 'right' objects if one is the owning party in this
         * association or is 'null' if there is no owner.
         * @readonly
         */
        owner: any;

        /**
         * @readonly
         */
        right: Ext.data.schema.Role;

        /**
         * @readonly
         */
        schema: Ext.data.schema.Schema;

        /**
         * The name of this association.
         */
        name: string;
    }

    /**
     * This relationship describes the case where any one entity of one type may relate to any
     * number of entities of another type, and also in the reverse.
     *
     * This form of association cannot store id's in the related entities since that would
     * limit the number of related entities to one for the entity with the foreign key. Instead,
     * these relationships are typically implemented using a so-called "matrix" table. This
     * table typically has two columns to hold the id's of a pair of related entities. This
     * pair of id's is unique in the matrix table.
     *
     * # Declaration Forms
     *
     *      // Fully spelled out - all properties are their defaults:
     *
     *      Ext.define('App.models.Group', {
     *          extend: 'Ext.data.Model',
     *
     *          manyToMany: {
     *              UserGroups: {
     *                  type: 'User',
     *                  role: 'users',
     *                  field: 'userId',
     *                  right: {
     *                      field: 'groupId',
     *                      role: 'groups'
     *                  }
     *              }
     *          }
     *      });
     *
     *      // Eliminate "right" object and use boolean to indicate Group is on the
     *      // right. By default, left/right is determined by alphabetic order.
     *
     *      Ext.define('App.models.Group', {
     *          extend: 'Ext.data.Model',
     *
     *          manyToMany: {
     *              UserGroups: {
     *                  type: 'User',
     *                  role: 'users',
     *                  field: 'userId',
     *                  right: true
     *              }
     *          }
     *      });
     *
     *      // Eliminate object completely and rely on string to name the other type. Still
     *      // keep Group on the "right".
     *
     *      Ext.define('App.models.Group', {
     *          extend: 'Ext.data.Model',
     *
     *          manyToMany: {
     *              UserGroups: 'User#'   // '#' is on the side (left or right) of Group
     *          }
     *      });
     *
     *      // Remove explicit matrix name and keep Group on the "right". Generated matrixName
     *      // remains "UserGroups".
     *
     *      Ext.define('App.models.Group', {
     *          extend: 'Ext.data.Model',
     *
     *          manyToMany: [
     *              'User#'
     *          ]
     *      });
     *
     *      // Minimal definition but now Group is on the "left" since "Group" sorts before
     *      // "User". Generated matrixName is now "GroupUsers".
     *
     *      Ext.define('App.models.Group', {
     *          extend: 'Ext.data.Model',
     *
     *          manyToMany: [
     *              'User'
     *          ]
     *      });
     */
    export class ManyToMany extends Ext.data.schema.Association {
    }

    /**
     * This type of association describes the case where one entity is referenced by zero or
     * more other entities typically using a "foreign key" field.
     *
     * The way this is defined is for one entity to have a field that holds the unique id (also
     * known as "Primary Key" or, more specifically, as the {@link Ext.data.Model#idProperty}
     * field) of the related entity. These fields have a {@link Ext.data.field.Field#reference}
     * in their definition. The value in the 'reference' field of an entity instance holds the
     * value of the id of the related entity instance. Since many entities can hold the same
     * value in a 'reference' field, this allows many entities to reference one entity.
     * OrderItem has a foreign key to Order.
     *
     *      OrderItem -> Order
     *
     * OrderItem is on the "left" and Order is on the "right". This is because the owner of
     * the foreign key is always on the "left". Many OrderItems refer to one Order. The
     * default name of this association would be "Order_OrderItems".
     *
     *      var Order_OrderItems = {
     *          name: 'Order_OrderItems',
     *          owner: Order_OrderItems.right,
     *          left: {
     *              cls: OrderItem,
     *              type: 'OrderItem',
     *              association: Order_OrderItems,
     *              left: true,
     *              owner: false,
     *              autoLoad: true,
     *              isMany: true,
     *              inverse: Order_OrderItems.right,
     *              role: 'orderItems'
     *          },
     *          right: {
     *              cls: Order,
     *              type: 'Order',
     *              association: Order_OrderItems,
     *              left: false,
     *              owner: true,
     *              autoLoad: true,
     *              isMany: false,
     *              inverse: Order_OrderItems.left,
     *              role: 'order'
     *          }
     *      };
     *
     *      OrderItem.associations.order = Order_OrderItems.left;
     *      Order.associations.orderItems = Order_OrderItems.right;
     */
    export class ManyToOne extends Ext.data.schema.Association {
    }

    /**
     * This class provides name derivation methods for use by a 'Schema'.
     *
     * # Caching
     *
     * Because most name derivations are only textual manipulations of input strings, the
     * results can be cached. This is handled by the 'apply' method by giving it the name of
     * the method to call. For example:
     *
     *      var str = namer.capitalize('foo'); //  = "Foo"
     *
     *      var str = namer.apply('capitalize', 'foo');
     *
     * The return value of the second call (using 'apply') is the same as the first, however,
     * the results of 'capitalize' are cached. This allows repeated calls to 'apply' given the
     * same operation and string to avoid the extra string manipulation.
     *
     * # Usage
     *
     * This class is not intended to be created by application code. It is created by 'Schema'
     * instances as directed by the 'namer' config. Application code can derive from this
     * class and set the 'namer' config to customize naming conventions used by the 'Schema'.
     */
    export class Namer extends Ext.Base {
        /**
         * Given the name of a foreign key field, return the role of the related entity. For
         * example, fields like "fooId" or "foo_id" this implementation returns "foo".
         */
        fieldRole();

        /**
         * Returns the name for a one-to-many association given the left and right type and
         * the associating 'role'.
         *
         * In many cases the 'role' matches the target type. For example, an OrderItem might
         * have an "orderId" field which would have a 'role' of "order". If this is a reference
         * to an Order entity then the association name will be "OrderOrderItems".
         *
         * When the 'role' does not match, it is included in the association name. For example,
         * consider a Ticket entity with a "creatorId" field that references a User entity.
         * The 'role' of that field will (by default) be "creator". The returned association
         * name will be "UserCreatorTickets".
         */
        manyToOne();
    }

    /**
     * This type of association is similar to {@link Ext.data.schema.ManyToOne many-to-one},
     * except that the {@link Ext.data.field.Field#cfg-reference reference} field also has set
     * {@link Ext.data.field.Field#cfg-unique unique} to 'true'.
     *
     * While this type of association helps handle both sides of the association properly, it
     * is problematic to enforce the uniqueness aspect. If the database were to enforce this
     * uniqueness constraint, it would limit the field to be non-nullable. Even if this were
     * acceptable, this also creates challenges for a "soft-delete" strategy where records are
     * kept in the table, but only marked as "deleted" in a field.
     *
     * Ensuring uniqueness on the client-side is also difficult. So, at the present time, this
     * is not enforced.
     */
    export class OneToOne extends Ext.data.schema.Association {
    }

    export class Role extends Ext.Base {
        /**
         * @readonly
         */
        association: Ext.data.schema.Association;

        /**
         * The 'Ext.data.Model' derived class.
         * @readonly
         */
        cls: Ext.Class;

        /**
         * @readonly
         */
        inverse: Ext.data.schema.Role;

        /**
         * @readonly
         */
        isMany: boolean;

        /**
         * @readonly
         */
        left: boolean;

        /**
         * @readonly
         */
        owner: boolean;

        /**
         * @readonly
         */
        role: string;

        /**
         * @readonly
         */
        side: string;

        /**
         * The '{@link Ext.data.Model#entityName}' derived class.
         * @readonly
         */
        type: string;

        constructor(association: any, config: any);
    }

    interface SchemaConfig {
        /**
         * This config is used to initialize the '{@link Ext.data.Model#identifier}' config
         * for classes that do not define one.
         */
        defaultIdentifier?: any;

        /**
         * Specifies or configures the name generator for the schema.
         */
        namer?: string|any|Ext.data.schema.Namer;

        /**
         * The namespace for entity classes in this schema.
         */
        namespace?: string;

        /**
         * This is a template used to produce 'Ext.data.proxy.Proxy' configurations for
         * Models that do not define an explicit '{@link Ext.data.Model#cfg-proxy proxy}'.
         *
         * This template is processed with the Model class as the data object which means
         * any static properties of the Model are available. The most useful of these are
         *
         *  * 'prefix' - The 'urlPrefix' property of this instance.
         *  * 'entityName' - The {@link Ext.data.Model#entityName name} of the Model
         *      (for example, "User").
         *  * 'schema' - This instance.
         */
        proxy?: any|Ext.util.ObjectTemplate;

        /**
         * This is the URL prefix used for all requests to the server. It could be something
         * like "/~api". This value is included in the 'proxy' template data as "prefix".
         *
         * Optional, Defaults to: ""
         */
        urlPrefix?: string;
    }

    /**
     * A Schema is a collection of related {@link Ext.data.Model entities} and their respective
     * {@link Ext.data.schema.Association associations}.
     *
     * # Schema Instances
     *
     * By default a single instance of this class is created which serves as the schema for all
     * entities that do not have an explicit '{@link Ext.data.Model#cfg-schema schema}' config
     * either specified or inherited. This is sufficient in most cases.
     *
     * When an entity does specify a '{@link Ext.data.Model#cfg-schema schema}', however, that
     * looks up (or creates) an instance for that entity class which is then inherited.
     *
     * **Important:** All related entities *must* belong to a single schema instance in order
     * to properly link up their associations.
     *
     * ## Configuring Schemas
     *
     * The best way to control the configuration of your 'schema' is to define a base class for
     * all of your entities and use the '{@link Ext.data.Model#cfg-schema schema}' config like
     * this:
     *
     *      Ext.define('MyApp.model.Base', {
     *          extend: 'Ext.data.Model',
     *
     *          // This configures the default schema because we don't assign an "id":
     *          schema: {
     *              // configs go here
     *          }
     *      });
     *
     * **Note:** Only one explicit configuration can be applied to the default schema. In most
     * applications this will not be an issue.
     *
     * By using a base class for your entities you can ensure that the default schema is fully
     * configured before declaration of your classes proceeds. This is especially helpful if
     * you need to set the 'namespace' for your schema (see below).
     *
     * ## Relative Naming
     *
     * When describing associations between entities, it is desirable to use shorthand names
     * that do not contain the common namespace portion. This is called the 'entityName' as
     * opposed to its class name. By default, the 'entityName' is the full class name. However,
     * if a namespace is used, the common portion can be discarded and we can derive a shorter name.
     * In the following code, '"MyApp.model.Foo"' has an 'entityName' of '"Foo"' and the schema has
     * a 'namespace' of "MyApp.model".
     *
     * If you use deeper nesting for entities, you may need to set the 'namespace' config to
     * account for this. For example:
     *
     *      Ext.define('MyApp.model.Base', {
     *          extend: 'Ext.data.Model',
     *
     *          schema: {
     *              namespace: 'MyApp.model'
     *          }
     *      });
     *
     * Your derived classes now will generate proper default 'entityName' values even if they
     * have further namespaces. For example, "MyApp.model.foo.Thing" will produce "foo.Thing"
     * as the 'entityName' given the above as a base class.
     *
     * # Association Naming
     *
     * There are various terms involved when describing associations. Perhaps the simplest
     * example that will clarify these terms is that of the common many-to-many association
     * of User and Group.
     *
     *   * 'entityName' - The names "User" and "Group" are the 'entityName' values associated
     *   with these two classes. These are derived from their full classnames (perhaps
     *   something like "App.model.User" and "App.model.Group").
     *
     *   * 'associationName' - When talking about associations, especially the many-to-many
     *   variety, it is important to give them names. Associations are not owned by either of
     *   the entities involved, so this name is similar to an 'entityName'. In the case of
     *   "User" and "Group", the default 'associationName' would be "GroupUsers".
     *
     *   * 'left' and 'right' - Associations describe a relationship between two entities. To
     *   talk about specific associations we would use the 'entityName' of the parties (such
     *   as "User" or "Group"). When discussing associations in the abstract, however, it is
     *   very helpful to be able to talk about the entities in an association in a general way.
     *   In the case of the "GroupUsers" association, "User" is said to be the 'left' while
     *   "Group" is said to be the 'right'. In a many-to-many association the selection of
     *   'left' and 'right' is arbitrary. When a foreign-key is involved, the 'left' entity
     *   is the one containing the foreign-key.
     *
     * ## Custom Naming Conventions
     *
     * One of the jobs the the 'Schema' is to manage name generation (such as 'entityName').
     * This job is delegated to a class called the 'namer'. If you need to generate names in
     * other ways, you can provide a custom 'namer' for your classes:
     *
     *      Ext.define('MyApp.model.Base', {
     *          extend: 'Ext.data.Model',
     *
     *          schema: {
     *              namespace: 'MyApp.model',
     *              namer: 'custom'
     *          }
     *      });
     *
     * This will create a class using the alias "namer.custom". For example:
     *
     *      Ext.define('MyApp.model.CustomNamer', {
     *          extend: 'Ext.data.schema.Namer',
     *
     *          alias: 'namer.custom',
     *          ...
     *      });
     *
     * For details see the documentation for {@link Ext.data.schema.Namer Namer}.
     */
    export class Schema extends Ext.Base implements Ext.data.schema.SchemaConfig {
        /**
         * The number of {@link Ext.data.schema.Association associations}
         * in this 'schema'.
         * @readonly
         */
        assocCount: number;

        /**
         * The number of {@link Ext.data.Model entities} in this
         * 'schema'.
         * @readonly
         */
        entityCount: number;

        /**
         * The name of the schema's type. This should be the suffix of the 'alias' for this
         * class following the "schema." prefix. For example, if the 'alias' for a schema is
         * "schema.foo" then 'type' should "foo". If an 'alias' is specified on the derived
         * class, this property is set automatically.
         * @readonly
         */
        type: string;

        /**
         * This config is used to initialize the '{@link Ext.data.Model#identifier}' config
         * for classes that do not define one.
         */
        defaultIdentifier: any;

        /**
         * Specifies or configures the name generator for the schema.
         */
        namer: string|any|Ext.data.schema.Namer;

        /**
         * The namespace for entity classes in this schema.
         */
        namespace: string;

        /**
         * This is a template used to produce 'Ext.data.proxy.Proxy' configurations for
         * Models that do not define an explicit '{@link Ext.data.Model#cfg-proxy proxy}'.
         *
         * This template is processed with the Model class as the data object which means
         * any static properties of the Model are available. The most useful of these are
         *
         *  * 'prefix' - The 'urlPrefix' property of this instance.
         *  * 'entityName' - The {@link Ext.data.Model#entityName name} of the Model
         *      (for example, "User").
         *  * 'schema' - This instance.
         */
        proxy: any|Ext.util.ObjectTemplate;

        /**
         * This is the URL prefix used for all requests to the server. It could be something
         * like "/~api". This value is included in the 'proxy' template data as "prefix".
         *
         * Optional, Defaults to: ""
         */
        urlPrefix: string;

        /**
         * Adds an entry from a {@link Ext.data.schema.ManyToMany matrix config} declared by an
         * entity.
         *
         * This is the ideal method to override in a derived class if the standard, default
         * naming conventions need to be adjusted. In the override, apply whatever logic is
         * appropriate to determine the missing values and pass along the proper results to
         * this method in the 'callParent'.
         *
         * @param {Ext.Class} entityType A class derived from 'Ext.data.Model'.
         *
         * @param {String} matrixName The name of the matrix association.
         *
         * @param {String} [relation] A base name for the matrix. For information about the
         * meaning of this see {@link Ext.data.Schema#ManyToMany}.
         *
         * @param {Object} left The descriptor for the "left" of the matrix.
         * @param {String} left.type The type of the entity on the "left" of the matrix.
         *
         * @param {String} [left.field] The name of the field in the matrix table for the "left"
         * side entity. If not provided, this defaults to the 'left.type' name
         * {@link Ext.util.Inflector#singularize singularized} and uncapitalized followed by
         * "Id". For example, "userId" for a 'left.type' of "Users".
         *
         * @param {String} [left.role] The name of the relationship from the 'left.type' to the
         * 'right.type'. If not provided, this defaults to the 'left.type' name
         * {@link Ext.util.Inflector#pluralize pluralized} and uncapitalized. For example,
         * "users" for a 'left.type' of "User".
         *
         * @param {Object} right The descriptor for the "right" of the matrix.
         * @param {String} right.type The type of the entity on the "right" of the matrix.
         *
         * @param {String} [right.field] The name of the field in the matrix table for the
         * "right" side entity. If not provided, this defaults in the same way as 'left.field'
         * except this is based on 'right.type'.
         *
         * @param {String} [right.role] The name of the relationship from the 'right.type' to
         * the 'left.type'. If not provided, this defaults in the same way as 'left.role'
         * except this is based on 'right.type'.
         */
        protected addMatrix(entityType: Ext.Class, matrixName: string, relation?: string, left?: any, left_type?: string, left_field?: string, left_role?: string, right?: any, right_type?: string, right_field?: string, right_role?: string);

        /**
         * Adds a {@link Ext.data.Field#reference reference} field association for an entity
         * to this 'schema'.
         *
         * This is the ideal method to override in a derived class if the standard, default
         * naming conventions need to be adjusted. In the override, apply whatever logic is
         * appropriate to determine the missing values and pass along the proper results to
         * this method in the 'callParent'.
         *
         * @param {Ext.Class} entityType A class derived from 'Ext.data.Model'.
         *
         * @param {Ext.data.field.Field} referenceField The 'field' with the 'reference' config.
         *
         * @param {String} [association] The name of the association. If empty or null, this
         * will be derived from 'entityType', 'role', 'inverse' and
         * 'referenceField.unique'.
         *
         * @param {String} [role] The name of the relationship from 'entityType' to the target
         * 'type'. If not specified, the default is the 'referenceField.name' (minus any "Id"
         * suffix if present).
         *
         * @param {String} [inverse] The name of the relationship from the target 'type'
         * to the 'entityType'. If not specified, this is derived from the
         * {@link Ext.data.Model#entityName entityName} of the 'entityType'
         * ({@link Ext.util.Inflector#singularize singularized} or
         * {@link Ext.util.Inflector#pluralize pluralized} based on 'referenceField.unique').
         *
         * @param {String} type The {@link Ext.data.Model#entityName entityName} of the target
         * of the reference.
         *
         * @param {Object} [descr] The 'reference' descriptor from the 'referenceField' if one
         * was given in the field definition.
         *
         * @param {Boolean} [unique=false] Indicates if the reference is one-to-one.
         */
        protected addReference(entityType: Ext.Class, referenceField: Ext.data.field.Field, association?: string, role?: string, inverse?: string, type?: string, descr?: any, unique?: boolean);

        constructor(config: Ext.data.schema.SchemaConfig);

        /**
         * Returns an 'Association' by name.
         * @param {String} name The name of the association.
         * @return {Ext.data.schema.Association} The association instance.
         */
        getAssociation(name: string): Ext.data.schema.Association;

        getDefaultIdentifier();

        /**
         * Returns an entity by name.
         * @param {String} name The name of the entity
         * @return {Ext.data.Model} The entity class.
         */
        getEntity(name: string): Ext.data.Model;

        /**
         * Get the entity name taking into account the {@link #namespace}.
         * @param {String/Ext.data.Model} cls The model class or name of the class.
         * @return {String} The entity name
         */
        getEntityName(cls: string|Ext.data.Model): string;

        getNamer();

        getNamespace();

        getProxy();

        getUrlPrefix();

        /**
         * Checks if the passed entity has attached associations that need to be read when
         * using nested loading.
         *
         * @param {String/Ext.Class/Ext.data.Model} name The name, instance, or Model class.
         * @return {Boolean} 'true' if there are associations attached to the entity.
         */
        hasAssociations(name: string|Ext.Class|Ext.data.Model): boolean;

        /**
         * Checks if an entity is defined
         * @param {String/Ext.data.Model} entity The name or model
         * @return {Boolean} True if this entity is defined
         */
        hasEntity(entity: string|Ext.data.Model): boolean;

        setDefaultIdentifier();

        setNamer();

        setNamespace();

        setProxy();

        setUrlPrefix();

        /**
         * Returns the 'Schema' instance given its 'id' or config object. If only the 'id'
         * is specified, that 'Schema' instance is looked up and returned. If there is no
         * instance already created, the 'id' is assumed to be the 'type'. For example:
         *
         *      schema: 'foo'
         *
         * Would be created from the alias '"schema.foo"' and assigned the 'id' of "foo"
         * as well.
         *
         * @param {String/Object} config The id, type or config object of the schema.
         * @param {String} [config.type] The type alias of the schema. A "schema." prefix
         * is added to this string, if provided, to complete the alias. This should match
         * match the "alias" of some class derived from 'Ext.data.schema.Schema'.
         * @return {Ext.data.schema.Schema} The previously existing or newly created
         * instance.
         */
        static get(config: string|Ext.data.schema.SchemaConfig, config_type?: string): Ext.data.schema.Schema;
    }
}

declare module Ext.data.session {
    /**
     * This class is used internally by '{@link Ext.data.Session#getSaveBatch}' and is
     * not intended for direct use. It can be studied as an example of implementing a visitor
     * to pass to '{@link Ext.data.Session#visitData}'.
     * @since 5.0.0
     */
    export class BatchVisitor extends Ext.Base {
        constructor(batch: any);
    }

    /**
     * This class is used internally by '{@link Ext.data.Session#getChanges}' to build
     * up an object describing changes in the session. It is not intended for public use but
     * can be used as an example of the visitor '{@link Ext.data.Session#visitData}'
     * requires.
     * @since 5.0.0
     */
    export class ChangesVisitor extends Ext.Base {
        constructor(session: any);
    }

    /**
     * This visitor class adds extra capability to consider changes as
     * they would be considered for a parent session.
     * @since 5.0.0
     */
    export class ChildChangesVisitor extends Ext.data.session.ChangesVisitor {
        constructor();
    }
}

declare module Ext.data.soap {
    interface ProxyConfig extends Ext.data.proxy.AjaxConfig {
        /**
         * An object containing "create", "read", "update" and "destroy" properties that define
         * SOAP operations for each CRUD action method. These operations will be appended to
         * the {@link #url} as the {@link #operationParam} for each request type.
         *
         *     api: {
         *         create: undefined,
         *         read: undefined,
         *         update: undefined,
         *         destroy: undefined
         *     }
         *
         * At least one operation is required, but additional operations do not need to be configured
         * if they will not be used.  For example, if this proxy is only used for read operations
         * the following configuration will be sufficient:
         *
         *     api: {
         *         read: 'Foo'
         *     }
         */
        api?: any;

        /**
         * The template used to create the SOAP body for the "create" action. If not specified
         * {@link #writeBodyTpl} will be used for the "create" action.
         */
        createBodyTpl?: Ext.XTemplate|any[];

        /**
         * The template used to create the SOAP body for the "destroy" action. If not specified
         * {@link #writeBodyTpl} will be used for the "destroy" action.
         */
        destroyBodyTpl?: Ext.XTemplate|any[];

        /**
         * The template used to create the SOAP envelope.  Defaults to:
         *
         *     [
         *         '<?xml version="1.0" encoding="utf-8" ?>',
         *         '<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">',
         *             '{[values.bodyTpl.apply(values)]}',
         *         '</soap:Envelope>'
         *     ]
         */
        envelopeTpl?: any;

        /**
         * The name of the operation parameter to be appened to the SOAP endpoint url
         *
         * Optional, Defaults to: 'op'
         */
        operationParam?: string;

        /**
         * The template used to create the SOAP body for the "read" action.  Defaults to:
         *
         *     [
         *         '<soap:Body>',
         *             '<{operation} xmlns="{targetNamespace}">',
         *                 '<tpl foreach="params">',
         *                     '<{$}>{.}</{$}>',
         *                 '</tpl>',
         *             '</{operation}>',
         *         '</soap:Body>'
         *     ]
         *
         * Optional, Defaults to: undefined
         */
        readBodyTpl?: Ext.XTemplate|any[];

        /**
         * An object containing "create", "read", "update" and "destroy" properties that define
         * the [SOAPAction](http://www.w3.org/TR/2000/NOTE-SOAP-20000508/#_Toc478383528) header
         * for each CRUD action method. A soapAction must be specified for each operation
         * configured in {@link #api}  Defaults to:
         *
         *     soapAction: {
         *         create: undefined,
         *         read: undefined,
         *         update: undefined,
         *         destroy: undefined
         *     }
         */
        soapAction?: any;

        /**
         * namespace URI used by {@link #createBodyTpl}, {@link #readBodyTpl}, {@link #updateBodyTpl},
         * and {@link #destroyBodyTpl} as the "xmlns" attribute for the operation element.
         */
        targetNamespace?: string;

        /**
         * The template used to create the SOAP body for the "update" action. If not specified
         * {@link #writeBodyTpl} will be used for the "update" action.
         */
        updateBodyTpl?: Ext.XTemplate|any[];

        /**
         * The SOAP endpoint url that this proxy will use to request the SOAP data. This can
         * be a proxied url to work around same-origin policy if the SOAP endpoint url is on
         * a different domain from your application.
         */
        url?: string;

        /**
         * The default template used to create the SOAP body for write actions (create, update,
         * and destroy). The individual body templates for each write action can be configured
         * using {@link #createBodyTpl}, {@link #updateBodyTpl}, and {@link #destroyBodyTpl}.
         * Defaults to:
         *
         *     [
         *          '<soap:Body>',
         *              '<{operation} xmlns="{targetNamespace}">',
         *                  '<tpl for="records">',
         *                      '{% var recordName=values.modelName.split(".").pop(); %}',
         *                      '<{[recordName]}>',
         *                          '<tpl for="fields">',
         *                              '<{name}>{[parent.get(values.name)]}</{name}>',
         *                          '</tpl>',
         *                      '</{[recordName]}>',
         *                  '</tpl>',
         *              '</{operation}>',
         *          '</soap:Body>'
         *      ]
         *
         * Optional, Defaults to: undefined
         */
        writeBodyTpl?: Ext.XTemplate|any[];
    }

    /**
     * The SOAP Proxy class is an {@link Ext.data.proxy.Ajax Ajax Proxy} to access v1.1 SOAP
     * (Simple Object Access Protocol) services.  SOAP Proxy constructs a SOAP Envelope and
     * submits an AJAX request to load a SOAP response from the server.
     *
     * For help getting started please refer to the [Soap Guide](../../../enterprise/soap.html).
     *
     * **Note: **  _This functionality is only available with the purchase of
     * Sencha Complete.  For more information about using this class, please visit
     * our [Sencha Complete](https://www.sencha.com/products/complete/) product page._
     */
    export class Proxy extends Ext.data.proxy.Ajax implements Ext.data.soap.ProxyConfig {
        /**
         * @readonly
         * Mapping of action name to HTTP request method.  All SOAP actions are mapped to 'POST'
         */
        actionMethods: any;

        /**
         * An object containing "create", "read", "update" and "destroy" properties that define
         * SOAP operations for each CRUD action method. These operations will be appended to
         * the {@link #url} as the {@link #operationParam} for each request type.
         *
         *     api: {
         *         create: undefined,
         *         read: undefined,
         *         update: undefined,
         *         destroy: undefined
         *     }
         *
         * At least one operation is required, but additional operations do not need to be configured
         * if they will not be used.  For example, if this proxy is only used for read operations
         * the following configuration will be sufficient:
         *
         *     api: {
         *         read: 'Foo'
         *     }
         */
        api: any;

        /**
         * The template used to create the SOAP body for the "create" action. If not specified
         * {@link #writeBodyTpl} will be used for the "create" action.
         */
        createBodyTpl: Ext.XTemplate|any[];

        /**
         * The template used to create the SOAP body for the "destroy" action. If not specified
         * {@link #writeBodyTpl} will be used for the "destroy" action.
         */
        destroyBodyTpl: Ext.XTemplate|any[];

        /**
         * The template used to create the SOAP envelope.  Defaults to:
         *
         *     [
         *         '<?xml version="1.0" encoding="utf-8" ?>',
         *         '<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">',
         *             '{[values.bodyTpl.apply(values)]}',
         *         '</soap:Envelope>'
         *     ]
         */
        envelopeTpl: any;

        /**
         * The name of the operation parameter to be appened to the SOAP endpoint url
         *
         * Optional, Defaults to: 'op'
         */
        operationParam: string;

        /**
         * The template used to create the SOAP body for the "read" action.  Defaults to:
         *
         *     [
         *         '<soap:Body>',
         *             '<{operation} xmlns="{targetNamespace}">',
         *                 '<tpl foreach="params">',
         *                     '<{$}>{.}</{$}>',
         *                 '</tpl>',
         *             '</{operation}>',
         *         '</soap:Body>'
         *     ]
         *
         * Optional, Defaults to: undefined
         */
        readBodyTpl: Ext.XTemplate|any[];

        /**
         * An object containing "create", "read", "update" and "destroy" properties that define
         * the [SOAPAction](http://www.w3.org/TR/2000/NOTE-SOAP-20000508/#_Toc478383528) header
         * for each CRUD action method. A soapAction must be specified for each operation
         * configured in {@link #api}  Defaults to:
         *
         *     soapAction: {
         *         create: undefined,
         *         read: undefined,
         *         update: undefined,
         *         destroy: undefined
         *     }
         */
        soapAction: any;

        /**
         * namespace URI used by {@link #createBodyTpl}, {@link #readBodyTpl}, {@link #updateBodyTpl},
         * and {@link #destroyBodyTpl} as the "xmlns" attribute for the operation element.
         */
        targetNamespace: string;

        /**
         * The template used to create the SOAP body for the "update" action. If not specified
         * {@link #writeBodyTpl} will be used for the "update" action.
         */
        updateBodyTpl: Ext.XTemplate|any[];

        /**
         * The SOAP endpoint url that this proxy will use to request the SOAP data. This can
         * be a proxied url to work around same-origin policy if the SOAP endpoint url is on
         * a different domain from your application.
         */
        url: string;

        /**
         * The default template used to create the SOAP body for write actions (create, update,
         * and destroy). The individual body templates for each write action can be configured
         * using {@link #createBodyTpl}, {@link #updateBodyTpl}, and {@link #destroyBodyTpl}.
         * Defaults to:
         *
         *     [
         *          '<soap:Body>',
         *              '<{operation} xmlns="{targetNamespace}">',
         *                  '<tpl for="records">',
         *                      '{% var recordName=values.modelName.split(".").pop(); %}',
         *                      '<{[recordName]}>',
         *                          '<tpl for="fields">',
         *                              '<{name}>{[parent.get(values.name)]}</{name}>',
         *                          '</tpl>',
         *                      '</{[recordName]}>',
         *                  '</tpl>',
         *              '</{operation}>',
         *          '</soap:Body>'
         *      ]
         *
         * Optional, Defaults to: undefined
         */
        writeBodyTpl: Ext.XTemplate|any[];

        /**
         * AjaxProxy is one of the most widely-used ways of getting data into your application. It uses AJAX requests to load
         * data from the server, usually to be placed into a {@link Ext.data.Store Store}. Let's take a look at a typical setup.
         * Here we're going to set up a Store that has an AjaxProxy. To prepare, we'll also set up a {@link Ext.data.Model
         * Model}:
         *
         *     Ext.define('User', {
         *         extend: 'Ext.data.Model',
         *         fields: ['id', 'name', 'email']
         *     });
         *
         *     //The Store contains the AjaxProxy as an inline configuration
         *     var store = Ext.create('Ext.data.Store', {
         *         model: 'User',
         *         proxy: {
         *             type: 'ajax',
         *             url : 'users.json'
         *         }
         *     });
         *
         *     store.load();
         *
         * Our example is going to load user data into a Store, so we start off by defining a {@link Ext.data.Model Model} with
         * the fields that we expect the server to return. Next we set up the Store itself, along with a
         * {@link Ext.data.Store#proxy proxy} configuration. This configuration was automatically turned into an
         * Ext.data.proxy.Ajax instance, with the url we specified being passed into AjaxProxy's constructor.
         * It's as if we'd done this:
         *
         *     new Ext.data.proxy.Ajax({
         *         url: 'users.json',
         *         model: 'User',
         *         reader: 'json'
         *     });
         *
         * A couple of extra configurations appeared here - {@link #model} and {@link #reader}. These are set by default when we
         * create the proxy via the Store - the Store already knows about the Model, and Proxy's default {@link
         * Ext.data.reader.Reader Reader} is {@link Ext.data.reader.Json JsonReader}.
         *
         * Now when we call store.load(), the AjaxProxy springs into action, making a request to the url we configured
         * ('users.json' in this case). As we're performing a read, it sends a GET request to that url (see
         * {@link #actionMethods} to customize this - by default any kind of read will be sent as a GET request and any kind of write
         * will be sent as a POST request).
         *
         * # Limitations
         *
         * AjaxProxy cannot be used to retrieve data from other domains. If your application is running on http://domainA.com it
         * cannot load data from http://domainB.com because browsers have a built-in security policy that prohibits domains
         * talking to each other via AJAX.
         *
         * If you need to read data from another domain and can't set up a proxy server (some software that runs on your own
         * domain's web server and transparently forwards requests to http://domainB.com, making it look like they actually came
         * from http://domainA.com), you can use {@link Ext.data.proxy.JsonP} and a technique known as JSON-P (JSON with
         * Padding), which can help you get around the problem so long as the server on http://domainB.com is set up to support
         * JSON-P responses. See {@link Ext.data.proxy.JsonP JsonPProxy}'s introduction docs for more details.
         *
         * # Readers and Writers
         *
         * AjaxProxy can be configured to use any type of {@link Ext.data.reader.Reader Reader} to decode the server's response.
         * If no Reader is supplied, AjaxProxy will default to using a {@link Ext.data.reader.Json JsonReader}. Reader
         * configuration can be passed in as a simple object, which the Proxy automatically turns into a {@link
         * Ext.data.reader.Reader Reader} instance:
         *
         *     var proxy = new Ext.data.proxy.Ajax({
         *         model: 'User',
         *         reader: {
         *             type: 'xml',
         *             rootProperty: 'users'
         *         }
         *     });
         *
         *     proxy.getReader(); //returns an XmlReader instance based on the config we supplied
         *
         * # Url generation
         *
         * AjaxProxy automatically inserts any sorting, filtering, paging and grouping options into the url it generates for
         * each request. These are controlled with the following configuration options:
         *
         * - {@link #pageParam} - controls how the page number is sent to the server (see also {@link #startParam} and {@link #limitParam})
         * - {@link #sortParam} - controls how sort information is sent to the server
         * - {@link #groupParam} - controls how grouping information is sent to the server
         * - {@link #filterParam} - controls how filter information is sent to the server
         *
         * Each request sent by AjaxProxy is described by an {@link Ext.data.operation.Operation Operation}. To see how we can customize
         * the generated urls, let's say we're loading the Proxy with the following Operation:
         *
         *     var proxy = new Ext.data.proxy.Ajax({
         *         url: '/users'
         *     });
         *
         *     var operation = proxy.createOperation('read', {
         *         page  : 2
         *     });
         *
         * Now we'll issue the request for this Operation by calling {@link #read}:
         *
         *     proxy.read(operation); //GET /users?page=2
         *
         * Easy enough - the Proxy just copied the page property from the Operation. We can customize how this page data is sent
         * to the server:
         *
         *     var proxy = new Ext.data.proxy.Ajax({
         *         url: '/users',
         *         pageParam: 'pageNumber'
         *     });
         *
         *     proxy.read(operation); //GET /users?pageNumber=2
         *
         * Alternatively, our Operation could have been configured to send start and limit parameters instead of page:
         *
         *     var proxy = new Ext.data.proxy.Ajax({
         *         url: '/users'
         *     });
         *
         *     var operation = proxy.createOperation('read', {
         *         start : 50,
         *         limit : 25
         *     });
         *
         *     proxy.read(operation); //GET /users?start=50&limit;=25
         *
         * Again we can customize this url:
         *
         *     var proxy = new Ext.data.proxy.Ajax({
         *         url: '/users',
         *         startParam: 'startIndex',
         *         limitParam: 'limitIndex'
         *     });
         *
         *     proxy.read(operation); //GET /users?startIndex=50&limitIndex;=25
         *
         * AjaxProxy will also send sort and filter information to the server. Let's take a look at how this looks with a more
         * expressive Operation object:
         *
         *     var operation = proxy.createOperation('read', {
         *         sorters: [
         *             new Ext.util.Sorter({
         *                 property : 'name',
         *                 direction: 'ASC'
         *             }),
         *             new Ext.util.Sorter({
         *                 property : 'age',
         *                 direction: 'DESC'
         *             })
         *         ],
         *         filters: [
         *             new Ext.util.Filter({
         *                 property: 'eyeColor',
         *                 value   : 'brown'
         *             })
         *         ]
         *     });
         *
         * This is the type of object that is generated internally when loading a {@link Ext.data.Store Store} with sorters and
         * filters defined. By default the AjaxProxy will JSON encode the sorters and filters, resulting in something like this
         * (note that the url is escaped before sending the request, but is left unescaped here for clarity):
         *
         *     var proxy = new Ext.data.proxy.Ajax({
         *         url: '/users'
         *     });
         *
         *     proxy.read(operation); //GET /users?sort=[{"property":"name","direction":"ASC"},{"property":"age","direction":"DESC"}]&filter;=[{"property":"eyeColor","value":"brown"}]
         *
         * We can again customize how this is created by supplying a few configuration options. Let's say our server is set up
         * to receive sorting information is a format like "sortBy=name#ASC,age#DESC". We can configure AjaxProxy to provide
         * that format like this:
         *
         *      var proxy = new Ext.data.proxy.Ajax({
         *          url: '/users',
         *          sortParam: 'sortBy',
         *          filterParam: 'filterBy',
         *
         *          //our custom implementation of sorter encoding - turns our sorters into "name#ASC,age#DESC"
         *          encodeSorters: function(sorters) {
         *              var length   = sorters.length,
         *                  sortStrs = [],
         *                  sorter, i;
         *
         *              for (i = 0; i < length; i++) {
         *                  sorter = sorters[i];
         *
         *                  sortStrs[i] = sorter.property + '#' + sorter.direction
         *              }
         *
         *              return sortStrs.join(",");
         *          }
         *      });
         *
         *      proxy.read(operation); //GET /users?sortBy=name#ASC,age#DESC&filterBy;=[{"property":"eyeColor","value":"brown"}]
         *
         * We can also provide a custom {@link #encodeFilters} function to encode our filters.
         *
         * # Debugging your Ajax Proxy
         *
         * If the data is not being loaded into the store as expected, it could be due to a mismatch between the the way that the {@link #reader}
         * is configured, and the shape of the incoming data.
         *
         * To debug from the point that your data arrives back from the network, set a breakpoint inside the callback function
         * created in the 'createRequestCallback' method of the Ajax Proxy class, and follow the data to where the {@link #reader} attempts
         * to consume it.
         *
         * @constructor
         * Note that if this HttpProxy is being used by a {@link Ext.data.Store Store}, then the Store's call to
         * {@link Ext.data.Store#method-load load} will override any specified callback and params options. In this case, use the
         * {@link Ext.data.Store Store}'s events to modify parameters, or react to loading events.
         *
         * @param {Object} config (optional) Config object.
         * If an options parameter is passed, the singleton {@link Ext.Ajax} object will be used to make the request.
         */
        constructor(config: Ext.data.amf.ProxyConfig);

        getCreateBodyTpl();

        getDestroyBodyTpl();

        getEnvelopeTpl();

        getOperationParam();

        getReadBodyTpl();

        getReader();

        getSoapAction();

        getTargetNamespace();

        getUpdateBodyTpl();

        getUrl();

        getWriteBodyTpl();

        setCreateBodyTpl();

        setDestroyBodyTpl();

        setEnvelopeTpl();

        setOperationParam();

        setReadBodyTpl();

        setReader();

        setSoapAction();

        setTargetNamespace();

        setUpdateBodyTpl();

        setUrl();

        setWriteBodyTpl();
    }

    /**
     * Reader class to access v1.1 SOAP (Simple Object Access Protocol) services.
     */
    export class Reader extends Ext.data.reader.Xml {
        /**
         * Creates new Reader.
         * @param {Object} [config] Config object.
         */
        constructor(config?: Ext.data.amf.ReaderConfig);
    }
}

declare module Ext.data.validator {
    interface BoundConfig {
        /**
         * The error message to return when the value is not in the specified range
         * and both the minimum and maximum are specified.
         */
        bothMessage?: string;

        /**
         * The error message to return when the value is empty.
         */
        emptyMessage?: string;

        /**
         * The maximum length value.
         */
        max?: number;

        /**
         * The error message to return when the value is more than the maximum
         * and only a maximum is specified.
         */
        maxOnlyMessage?: string;

        /**
         * The minimum length value.
         */
        min?: number;

        /**
         * The error message to return when the value is less than the minimum
         * and only a minimum is specified.
         */
        minOnlyMessage?: string;
    }

    /**
     * @abstract
     * A superclass for a validator that checks if a value is within a certain range.
     */
    export class Bound extends Ext.data.validator.Validator implements Ext.data.validator.BoundConfig {
        type: string;

        /**
         * The error message to return when the value is not in the specified range
         * and both the minimum and maximum are specified.
         */
        bothMessage: string;

        /**
         * The error message to return when the value is empty.
         */
        emptyMessage: string;

        /**
         * The maximum length value.
         */
        max: number;

        /**
         * The error message to return when the value is more than the maximum
         * and only a maximum is specified.
         */
        maxOnlyMessage: string;

        /**
         * The minimum length value.
         */
        min: number;

        /**
         * The error message to return when the value is less than the minimum
         * and only a minimum is specified.
         */
        minOnlyMessage: string;

        constructor();

        getEmptyMessage();

        getMax();

        getMaxOnlyMessage();

        getMin();

        getMinOnlyMessage();

        setEmptyMessage();

        setMax();

        setMaxOnlyMessage();

        setMin();

        setMinOnlyMessage();
    }

    interface EmailConfig extends Ext.data.validator.FormatConfig {
        /**
         * A matcher to check for simple emails. This may be overridden.
         */
        matcher?: RegExp;

        /**
         * The error message to return when the value is not a valid email
         */
        message?: string;
    }

    /**
     * Validates that the value is a valid email.
     */
    export class Email extends Ext.data.validator.Format implements Ext.data.validator.EmailConfig {
        type: string;

        /**
         * A matcher to check for simple emails. This may be overridden.
         */
        matcher: RegExp;

        /**
         * The error message to return when the value is not a valid email
         */
        message: string;

        constructor();

        getMatcher();

        getMessage();

        setMatcher();

        setMessage();
    }

    interface ExclusionConfig extends Ext.data.validator.ListConfig {
        /**
         * The error message to return when the passed value exists in the
         * specified {@link #list}.
         */
        message?: string;
    }

    /**
     * Validates that the value does not exist in a {@link #list} of values.
     */
    export class Exclusion extends Ext.data.validator.List implements Ext.data.validator.ExclusionConfig {
        type: string;

        /**
         * The error message to return when the passed value exists in the
         * specified {@link #list}.
         */
        message: string;

        constructor();

        getMessage();

        setMessage();
    }

    interface FormatConfig {
        /**
         * (required) The matcher regex to test against the value.
         */
        matcher?: RegExp;

        /**
         * The error message to return when the value does not match the format.
         */
        message?: string;
    }

    /**
     * Validates that the passed value matches a specific format specified by a regex.
     * The format is provided by the {@link #matcher} config.
     */
    export class Format extends Ext.data.validator.Validator implements Ext.data.validator.FormatConfig {
        type: string;

        /**
         * (required) The matcher regex to test against the value.
         */
        matcher: RegExp;

        /**
         * The error message to return when the value does not match the format.
         */
        message: string;

        constructor();

        getMatcher();

        getMessage();

        setMatcher();

        setMessage();
    }

    interface InclusionConfig extends Ext.data.validator.ListConfig {
        /**
         * The error message to return when the passed value does not exist
         * in the specified {@link #list}.
         */
        message?: string;
    }

    /**
     * Validates that the value exists in a {@link #list} of values.
     */
    export class Inclusion extends Ext.data.validator.List implements Ext.data.validator.InclusionConfig {
        type: string;

        /**
         * The error message to return when the passed value does not exist
         * in the specified {@link #list}.
         */
        message: string;

        constructor();

        getMessage();

        setMessage();
    }

    interface LengthConfig extends Ext.data.validator.BoundConfig {
        /**
         * The error message to return when the value length is not in the specified
         * range and both the minimum and maximum are specified.
         */
        bothMessage?: string;

        /**
         * The maximum length value.
         */
        max?: number;

        /**
         * The error message to return when the value is more than the maximum
         * length and only a maximum is specified.
         */
        maxOnlyMessage?: string;

        /**
         * The minimum length value.
         */
        min?: number;

        /**
         * The error message to return when the value is less than the minimum
         * length and only a minimum is specified.
         */
        minOnlyMessage?: string;
    }

    /**
     * Validates that the length of the value is between a {@link #min} and {@link #max}.
     */
    export class Length extends Ext.data.validator.Bound implements Ext.data.validator.LengthConfig {
        type: string;

        /**
         * The error message to return when the value length is not in the specified
         * range and both the minimum and maximum are specified.
         */
        bothMessage: string;

        /**
         * The maximum length value.
         */
        max: number;

        /**
         * The error message to return when the value is more than the maximum
         * length and only a maximum is specified.
         */
        maxOnlyMessage: string;

        /**
         * The minimum length value.
         */
        min: number;

        /**
         * The error message to return when the value is less than the minimum
         * length and only a minimum is specified.
         */
        minOnlyMessage: string;

        constructor();

        getBothMessage();

        getMaxOnlyMessage();

        getMinOnlyMessage();

        setBothMessage();

        setMaxOnlyMessage();

        setMinOnlyMessage();
    }

    interface ListConfig {
        /**
         * (required)
         * The list to check the passed value against.
         */
        list?: any[];
    }

    /**
     * A superclass for inclusion/exclusion validators.
     */
    export class List extends Ext.data.validator.Validator implements Ext.data.validator.ListConfig {
        type: string;

        /**
         * (required)
         * The list to check the passed value against.
         */
        list: any[];

        /**
         * Creates new Validator.
         * @param {Object/Function} config A config object. A function may also be passed,
         * which will be used as the {@link #validate} method for this validator.
         */
        constructor(config: Function|Ext.data.validator.ListConfig);

        getList();

        setList();
    }

    interface PresenceConfig {
        /**
         * 'true' to allow '''' as a valid value.
         */
        allowEmpty?: boolean;

        /**
         * The error message to return when the value is not specified.
         */
        message?: string;
    }

    /**
     * Validates that the passed value is not 'null' or 'undefined' or ''''.
     */
    export class Presence extends Ext.data.validator.Validator implements Ext.data.validator.PresenceConfig {
        type: string;

        /**
         * 'true' to allow '''' as a valid value.
         */
        allowEmpty: boolean;

        /**
         * The error message to return when the value is not specified.
         */
        message: string;

        /**
         * Creates new Validator.
         * @param {Object/Function} config A config object. A function may also be passed,
         * which will be used as the {@link #validate} method for this validator.
         */
        constructor(config: Function|Ext.data.validator.ListConfig);

        getAllowEmpty();

        getMessage();

        setAllowEmpty();

        setMessage();
    }

    interface RangeConfig extends Ext.data.validator.BoundConfig {
        bothMessage?: any;

        /**
         * The maximum value.
         */
        max?: number;

        maxOnlyMessage?: any;

        /**
         * The minimum value.
         */
        min?: number;

        minOnlyMessage?: any;

        /**
         * The error message to return when the value is not numeric.
         */
        nanMessage?: string;
    }

    /**
     * Validates that the the value is between a {@link #min} and {@link #max}.
     */
    export class Range extends Ext.data.validator.Bound implements Ext.data.validator.RangeConfig {
        type: string;

        /**
         * The error message to return when the value is not in the specified range
         * and both the minimum and maximum are specified.
         */
        bothMessage: string;

        /**
         * The maximum value.
         */
        max: number;

        /**
         * The error message to return when the value is more than the maximum
         * and only a maximum is specified.
         */
        maxOnlyMessage: string;

        /**
         * The minimum value.
         */
        min: number;

        /**
         * The error message to return when the value is less than the minimum
         * and only a minimum is specified.
         */
        minOnlyMessage: string;

        /**
         * The error message to return when the value is not numeric.
         */
        nanMessage: string;

        constructor();

        getBothMessage();

        getMaxOnlyMessage();

        getMinOnlyMessage();

        getNanMessage();

        setBothMessage();

        setMaxOnlyMessage();

        setMinOnlyMessage();

        setNanMessage();
    }

    /**
     * The base class for validators to be used to validate {@link Ext.data.Field fields} in
     * a {@link Ext.data.Model model}.
     *
     * The model will call the {@link #validate} method, which may be overridden by subclasses.
     */
    export class Validator extends Ext.Base {
        /**
         * A string representation of this format.
         */
        type: string;

        /**
         * Creates new Validator.
         * @param {Object/Function} config A config object. A function may also be passed,
         * which will be used as the {@link #validate} method for this validator.
         */
        constructor(config: Function|Ext.data.validator.ListConfig);

        /**
         * Validates the passed value.
         * @param {Object} value The value
         * @param {Ext.data.Model} record The record
         * @return {Boolean/String} 'true' if the value is valid. A string may be returned if the value
         * is not valid, to indicate an error message. Any other non 'true' value indicates the value
         * is not valid.
         */
        validate(value: any, record: Ext.data.Model): boolean|string;
    }
}

declare module Ext.data.writer {
    interface JsonConfig extends Ext.data.writer.WriterConfig {
        /**
         * Configure with 'false' to ensure that records are always wrapped in an array, even if there is only
         * one record being sent. When there is more than one record, they will always be encoded into an array.
         *
         * Optional, Defaults to: true
         */
        allowSingle?: boolean;

        /**
         * Configure 'true' to send record data (all record fields if {@link #writeAllFields} is 'true')
         * as a JSON encoded HTTP parameter named by the {@link #rootProperty} configuration.
         *
         * The encode option should only be set to true when a {@link #rootProperty} is defined, because the values will be
         * sent as part of the request parameters as opposed to a raw post. The root will be the name of the parameter
         * sent to the server.
         *
         * Optional, Defaults to: false
         */
        encode?: boolean;

        /**
         * By default, when dot-delimited field {@link #nameProperty mappings} are
         * used (e.g. 'name: 'myProperty', mapping: 'my.nested.property'') the writer will simply output a flat data
         * object containing the mapping string literal as the property name (e.g. '{ 'my.nested.property': 'foo' }').
         *
         * Mappings are used to map incoming nested JSON to flat Ext models. In many case, the data output by the
         * writer should preferrably match the original nested data format. Setting this config to 'true' will ensure
         * that the output will instead look like '{ my: { nested: { property: 'foo' }}}'. The output is generated
         * by {@link #getExpandedData}, which can optionally be overridden to apply more customized logic.
         *
         * Optional, Defaults to: false
         */
        expandData?: boolean;

        /**
         * The HTTP parameter name by which JSON encoded records will be passed to the server if the
         * {@link #encode} option is 'true'.
         */
        rootProperty?: string;
    }

    /**
     * This class is used to write {@link Ext.data.Model} data to the server in a JSON format.
     * The {@link #allowSingle} configuration can be set to false to force the records to always
     * be encoded in an array, even if there is only a single record being sent.
     */
    export class Json extends Ext.data.writer.Writer implements Ext.data.writer.JsonConfig {
        /**
         * Configure with 'false' to ensure that records are always wrapped in an array, even if there is only
         * one record being sent. When there is more than one record, they will always be encoded into an array.
         *
         * Optional, Defaults to: true
         */
        allowSingle: boolean;

        /**
         * Configure 'true' to send record data (all record fields if {@link #writeAllFields} is 'true')
         * as a JSON encoded HTTP parameter named by the {@link #rootProperty} configuration.
         *
         * The encode option should only be set to true when a {@link #rootProperty} is defined, because the values will be
         * sent as part of the request parameters as opposed to a raw post. The root will be the name of the parameter
         * sent to the server.
         *
         * Optional, Defaults to: false
         */
        encode: boolean;

        /**
         * By default, when dot-delimited field {@link #nameProperty mappings} are
         * used (e.g. 'name: 'myProperty', mapping: 'my.nested.property'') the writer will simply output a flat data
         * object containing the mapping string literal as the property name (e.g. '{ 'my.nested.property': 'foo' }').
         *
         * Mappings are used to map incoming nested JSON to flat Ext models. In many case, the data output by the
         * writer should preferrably match the original nested data format. Setting this config to 'true' will ensure
         * that the output will instead look like '{ my: { nested: { property: 'foo' }}}'. The output is generated
         * by {@link #getExpandedData}, which can optionally be overridden to apply more customized logic.
         *
         * Optional, Defaults to: false
         */
        expandData: boolean;

        /**
         * The HTTP parameter name by which JSON encoded records will be passed to the server if the
         * {@link #encode} option is 'true'.
         */
        rootProperty: string;

        constructor();

        getAllowSingle();

        getEncode();

        getExpandData();

        /**
         * The Reader classes support dot-delimited data mappings for extracting nested raw data into fields, so the
         * writer must support converting the flat {@link Ext.data.Model} structure back into the original nested data
         * format. Using the same mappings when available, the Writer will simply split each delimiter into a nested
         * object in the output, which should exactly match the input format. For example, record data like this:
         *
         *     my.nested.property: 'foo',
         *     my.nested.another: 'bar',
         *     my.somethingElse: 123
         *
         * should write out as...
         *
         *     my: {
         *         nested: {
         *             property: 'foo',
         *             another: 'bar
         *         },
         *         somethingElse: 123
         *     }
         *
         * This behavior is governed by the {@link #expandData} config. By default, this option is 'false' for
         * compatibility reasons, and will output a flat structure matching the flat record format. Setting this config
         * to 'true' will enable the expanded mapping behavior as shown here. This method could also be overridden
         * to provide an even more customized output data structure.
         */
        protected getExpandedData();

        getRootProperty();

        setAllowSingle();

        setEncode();

        setExpandData();

        setRootProperty();
    }

    interface WriterConfig {
        /**
         * This object contains the options passed to '{@link Ext.data.Model#getData}' when
         * writing '{@link Ext.data.Model#phantom}' records or when 'writeAllFields' is set
         * to 'true'.
         *
         * *NOTE:* The 'serialize' option cannot be used here.
         */
        allDataOptions?: any;

        /**
         * When specified this property causes the '{@link Ext.data.Model#idProperty}' of
         * newly created records to be sent to the server as this name instead of the
         * value of the 'idProperty'.
         *
         * For example, by default, the following code:
         *
         *      Ext.define('Person', {
         *          idProperty: 'id',  // this is the default value (for clarity)
         *
         *          fields: [ 'name' ]
         *      });
         *
         *      var person = new Person({
         *          // no id provided, so one is generated
         *          name: 'Clark Kent'
         *      });
         *
         * Will send this to the server:
         *
         *      {
         *          id: 'Person-1',
         *          name: 'Clark Kent'
         *      }
         *
         * This can be an issue if the server expects an integer for the "id" property.
         * You can use '{@link Ext.data.Model#identifier}' to produce identifiers that
         * the server would recognize or use this config to send the client's id in a
         * different property.
         *
         *      Ext.define('Person', {
         *          idProperty: 'id',  // this is the default value (for clarity)
         *
         *          proxy: {
         *              writer: {
         *                  clientIdProperty: 'clientId'
         *              }
         *          },
         *
         *          fields: [ 'name' ]
         *      });
         *
         * Given the above, the server is sent this data now:
         *
         *      {
         *          clientId: 'Person-1',
         *          name: 'Clark Kent'
         *      }
         *
         * While this config provides the behavior of '{@link Ext.data.Model#clientIdProperty}'
         * from previous releases, this property is not as useful as a suitable
         * '{@link Ext.data.Model#identifier}' due to id's appearing in foreign-key fields
         * and in '{@link Ext.data.Model#manyToMany}' associations.
         *
         * See '{@link Ext.data.Model#identifier}' for more on id generation.
         */
        clientIdProperty?: string;

        /**
         * This is used for each field of type date in the model to format the value before
         * it is sent to the server.
         */
        dateFormat?: string;

        /**
         * This property is used to read the key for each value that will be sent to the
         * server.
         *
         * For example:
         *
         *     Ext.define('Person', {
         *         extend: 'Ext.data.Model',
         *         fields: [{
         *             name: 'first',
         *             mapping: 'firstName'
         *         }, {
         *             name: 'last',
         *             mapping: 'lastName'
         *         }, {
         *             name: 'age'
         *         }]
         *     });
         *
         *     new Ext.data.writer.Writer({
         *         nameProperty: 'mapping'
         *     });
         *
         *     // This will be sent to the server
         *     {
         *         firstName: 'first name value',
         *         lastName: 'last name value',
         *         age: 1
         *     }
         *
         * If the value is not present, the field name will always be used.
         */
        nameProperty?: string;

        /**
         * This object contains the options passed to '{@link Ext.data.Model#getData}' when
         * writing non '{@link Ext.data.Model#phantom}' records or when 'writeAllFields' is
         * set to 'false'.
         *
         * *NOTE:* The 'serialize' option cannot be used here.
         */
        partialDataOptions?: any;

        /**
         * If a transform function is set, it will be invoked just before {@link #writeRecords}
         * executes. It is passed the unserialized data object and the {@link Ext.data.Request request}
         * object. The transform function returns a data object, which can be a modified version of the original
         * data object, or a completely new data object. The transform can be a function, or an object
         * with a 'fn' key and an optional 'scope' key. Example usage:
         *
         *     Ext.create('Ext.data.Store', {
         *         model: 'User',
         *         proxy: {
         *             type: 'ajax',
         *             url : 'users.json',
         *             writer: {
         *                 type: 'json',
         *                 transform: {
         *                     fn: function(data, request) {
         *                         // do some manipulation of the unserialized data object
         *                         return data;
         *                     },
         *                     scope: this
         *                 }
         *             }
         *         },
         *     });
         *
         * Optional
         */
        transform?: Function|any;

        /**
         * 'true' to write all fields from the record to the
         * server. If set to 'false' it will only send the fields that were modified. Note
         * that any fields that have '{@link Ext.data.field.Field#persist}' set to 'false'
         * will still be ignored while those with '{@link Ext.data.field.Field#critical}'
         * set to 'true' will be included.
         *
         * The exact set of fields written is determined by 'allDataOptions' (when 'true')
         * or 'partialDataOptions' (when 'false'). This option is ignored and treated as
         * 'true' when writing '{@link Ext.data.Model#phantom}' records.
         *
         * It is seldom a good idea to use this config. Rather use 'allDataOptions' or
         * 'partialDataOptions' to control what fields are sent for records based on their
         * '{@link Ext.data.Model#phantom}' state.
         *
         * In the previous release, this was default 'true'.
         */
        writeAllFields?: boolean;

        /**
         * By default, each record's id is always included in the output for non-phantom
         * records since in most cases the id will be required on the server to process
         * the record action. This is helpful since the id will normally not be modified,
         * and so would not be sent to the server unless {@link #writeAllFields} was
         * explicitly enabled.
         *
         * However, there are cases where it is not desirable for the record id to be passed
         * in the data directly. For example, when using a RESTful API the record id would
         * typically be appended to the url instead.
         *
         * Optional
         */
        writeRecordId?: boolean;
    }

    /**
     * Base Writer class used by most subclasses of {@link Ext.data.proxy.Server}. This class
     * is responsible for taking a set of {@link Ext.data.operation.Operation} objects and a
     * {@link Ext.data.Request} object and modifying that request based on the Operations.
     *
     * For example a Ext.data.writer.Json would format the Operations and their
     * {@link Ext.data.Model} instances based on the config options passed to the JsonWriter's
     * constructor.
     *
     * Writers are not needed for any kind of local storage - whether via a
     * {@link Ext.data.proxy.WebStorage Web Storage proxy} (see
     * {@link Ext.data.proxy.LocalStorage localStorage} and
     * {@link Ext.data.proxy.SessionStorage sessionStorage})
     * or just in memory via a {@link Ext.data.proxy.Memory MemoryProxy}.
     *
     * # Dates
     *
     * Before sending dates to the server, they can be formatted using an {@link Ext.Date}
     * format. These formats can be specified both on the field and the writer itself. In terms
     * of precedence, from highest to lowest:
     *
     * - {@link #dateFormat Writer.dateFormat} The writer 'dateFormat' will always have the
     *   highest precedence.
     * - {@link Ext.data.field.Date#dateWriteFormat} The 'dateWriteFormat' given to the field
     *   instance. This is handled by {@link Ext.data.field.Date#method-serialize}.
     * - {@link Ext.data.field.Date#dateFormat Field.dateFormat} This is handled by the field's
     *   'serialize' method.
     * - {@link Ext.data.field.Date#dateReadFormat Field.dateReadFormat} Also handled by the
     *   field's 'serialize' method.
     */
    export class Writer extends Ext.Base implements Ext.data.writer.WriterConfig {
        factoryConfig: any;

        /**
         * 'true' in this class to identify an object as an instantiated Writer, or subclass thereof.
         **/
        isWriter: boolean;

        /**
         * This object contains the options passed to '{@link Ext.data.Model#getData}' when
         * writing '{@link Ext.data.Model#phantom}' records or when 'writeAllFields' is set
         * to 'true'.
         *
         * *NOTE:* The 'serialize' option cannot be used here.
         */
        allDataOptions: any;

        /**
         * When specified this property causes the '{@link Ext.data.Model#idProperty}' of
         * newly created records to be sent to the server as this name instead of the
         * value of the 'idProperty'.
         *
         * For example, by default, the following code:
         *
         *      Ext.define('Person', {
         *          idProperty: 'id',  // this is the default value (for clarity)
         *
         *          fields: [ 'name' ]
         *      });
         *
         *      var person = new Person({
         *          // no id provided, so one is generated
         *          name: 'Clark Kent'
         *      });
         *
         * Will send this to the server:
         *
         *      {
         *          id: 'Person-1',
         *          name: 'Clark Kent'
         *      }
         *
         * This can be an issue if the server expects an integer for the "id" property.
         * You can use '{@link Ext.data.Model#identifier}' to produce identifiers that
         * the server would recognize or use this config to send the client's id in a
         * different property.
         *
         *      Ext.define('Person', {
         *          idProperty: 'id',  // this is the default value (for clarity)
         *
         *          proxy: {
         *              writer: {
         *                  clientIdProperty: 'clientId'
         *              }
         *          },
         *
         *          fields: [ 'name' ]
         *      });
         *
         * Given the above, the server is sent this data now:
         *
         *      {
         *          clientId: 'Person-1',
         *          name: 'Clark Kent'
         *      }
         *
         * While this config provides the behavior of '{@link Ext.data.Model#clientIdProperty}'
         * from previous releases, this property is not as useful as a suitable
         * '{@link Ext.data.Model#identifier}' due to id's appearing in foreign-key fields
         * and in '{@link Ext.data.Model#manyToMany}' associations.
         *
         * See '{@link Ext.data.Model#identifier}' for more on id generation.
         */
        clientIdProperty: string;

        /**
         * This is used for each field of type date in the model to format the value before
         * it is sent to the server.
         */
        dateFormat: string;

        /**
         * This property is used to read the key for each value that will be sent to the
         * server.
         *
         * For example:
         *
         *     Ext.define('Person', {
         *         extend: 'Ext.data.Model',
         *         fields: [{
         *             name: 'first',
         *             mapping: 'firstName'
         *         }, {
         *             name: 'last',
         *             mapping: 'lastName'
         *         }, {
         *             name: 'age'
         *         }]
         *     });
         *
         *     new Ext.data.writer.Writer({
         *         nameProperty: 'mapping'
         *     });
         *
         *     // This will be sent to the server
         *     {
         *         firstName: 'first name value',
         *         lastName: 'last name value',
         *         age: 1
         *     }
         *
         * If the value is not present, the field name will always be used.
         */
        nameProperty: string;

        /**
         * This object contains the options passed to '{@link Ext.data.Model#getData}' when
         * writing non '{@link Ext.data.Model#phantom}' records or when 'writeAllFields' is
         * set to 'false'.
         *
         * *NOTE:* The 'serialize' option cannot be used here.
         */
        partialDataOptions: any;

        /**
         * If a transform function is set, it will be invoked just before {@link #writeRecords}
         * executes. It is passed the unserialized data object and the {@link Ext.data.Request request}
         * object. The transform function returns a data object, which can be a modified version of the original
         * data object, or a completely new data object. The transform can be a function, or an object
         * with a 'fn' key and an optional 'scope' key. Example usage:
         *
         *     Ext.create('Ext.data.Store', {
         *         model: 'User',
         *         proxy: {
         *             type: 'ajax',
         *             url : 'users.json',
         *             writer: {
         *                 type: 'json',
         *                 transform: {
         *                     fn: function(data, request) {
         *                         // do some manipulation of the unserialized data object
         *                         return data;
         *                     },
         *                     scope: this
         *                 }
         *             }
         *         },
         *     });
         *
         * Optional
         */
        transform: Function|any;

        /**
         * 'true' to write all fields from the record to the
         * server. If set to 'false' it will only send the fields that were modified. Note
         * that any fields that have '{@link Ext.data.field.Field#persist}' set to 'false'
         * will still be ignored while those with '{@link Ext.data.field.Field#critical}'
         * set to 'true' will be included.
         *
         * The exact set of fields written is determined by 'allDataOptions' (when 'true')
         * or 'partialDataOptions' (when 'false'). This option is ignored and treated as
         * 'true' when writing '{@link Ext.data.Model#phantom}' records.
         *
         * It is seldom a good idea to use this config. Rather use 'allDataOptions' or
         * 'partialDataOptions' to control what fields are sent for records based on their
         * '{@link Ext.data.Model#phantom}' state.
         *
         * In the previous release, this was default 'true'.
         */
        writeAllFields: boolean;

        /**
         * By default, each record's id is always included in the output for non-phantom
         * records since in most cases the id will be required on the server to process
         * the record action. This is helpful since the id will normally not be modified,
         * and so would not be sent to the server unless {@link #writeAllFields} was
         * explicitly enabled.
         *
         * However, there are cases where it is not desirable for the record id to be passed
         * in the data directly. For example, when using a RESTful API the record id would
         * typically be appended to the url instead.
         *
         * Optional
         */
        writeRecordId: boolean;

        /**
         * Creates new Writer.
         * @param {Object} [config] Config object.
         */
        constructor(config?: Ext.data.writer.WriterConfig);

        getAllDataOptions();

        getClientIdProperty();

        getDateFormat();

        getNameProperty();

        getPartialDataOptions();

        /**
         * Formats the data for each record before sending it to the server. This method should
         * be overridden to format the data in a way that differs from the default.
         *
         * @param {Ext.data.Model} record The record that we are writing to the server.
         * @param {Ext.data.operation.Operation} [operation] An operation object.
         * @return {Object} An object literal of name/value keys to be written to the server.
         * By default this method returns the data property on the record.
         */
        getRecordData(record: Ext.data.Model, operation?: Ext.data.operation.Operation): any;

        getTransform();

        getWriteAllFields();

        getWriteRecordId();

        setAllDataOptions();

        setClientIdProperty();

        setDateFormat();

        setNameProperty();

        setPartialDataOptions();

        setTransform();

        setWriteAllFields();

        setWriteRecordId();

        /**
         * Prepares a Proxy's Ext.data.Request object.
         * @param {Ext.data.Request} request The request object.
         * @return {Ext.data.Request} The modified request object.
         */
        write(request: Ext.data.Request): Ext.data.Request;

        /**
         * Write the record data to the request in the appropriate format.
         * @param {Ext.data.Request} request The request.
         * @param {Array} data An array of objects containing data.
         * @return {Ext.data.Request} The request.
         */
        protected writeRecords(request: Ext.data.Request, data: any[]): Ext.data.Request;
    }

    interface XmlConfig extends Ext.data.writer.WriterConfig {
        /**
         * The root to be used if {@link #documentRoot} is empty and a root is required
         * to form a valid XML document.
         */
        defaultDocumentRoot?: string;

        /**
         * The name of the root element of the document. Defaults to <tt>'xmlData'</tt>.
         * If there is more than 1 record and the root is not specified, the default document root will still be used
         * to ensure a valid XML document is created.
         *
         * If the {@link #record} mapping includes a root element name, eg: "SystemInfo>Operation", and
         * the selector includes the root element name, then you must configure this as 'false'
         */
        documentRoot?: string;

        /**
         * A header to use in the XML document (such as setting the encoding or version).
         * Defaults to <tt>''</tt>.
         */
        header?: string;

        /**
         * The name of the node to use for each record. Defaults to
         * the owning {@link Ext.data.proxy.Proxy Proxy}'s {@link Ext.data.reader.Xml Reader}'s
         * {@link Ext.data.reader.Xml#record} setting, or ''record''.
         */
        record?: string;
    }

    /**
     * This class is used to write {@link Ext.data.Model} data to the server in an XML format.
     * The {@link #documentRoot} property is used to specify the root element in the XML document.
     * The {@link #record} option is used to specify the element name for each record that will make up the XML document.
     */
    export class Xml extends Ext.data.writer.Writer implements Ext.data.writer.XmlConfig {
        /**
         * The root to be used if {@link #documentRoot} is empty and a root is required
         * to form a valid XML document.
         */
        defaultDocumentRoot: string;

        /**
         * The name of the root element of the document. Defaults to <tt>'xmlData'</tt>.
         * If there is more than 1 record and the root is not specified, the default document root will still be used
         * to ensure a valid XML document is created.
         *
         * If the {@link #record} mapping includes a root element name, eg: "SystemInfo>Operation", and
         * the selector includes the root element name, then you must configure this as 'false'
         */
        documentRoot: string;

        /**
         * A header to use in the XML document (such as setting the encoding or version).
         * Defaults to <tt>''</tt>.
         */
        header: string;

        /**
         * The name of the node to use for each record. Defaults to
         * the owning {@link Ext.data.proxy.Proxy Proxy}'s {@link Ext.data.reader.Xml Reader}'s
         * {@link Ext.data.reader.Xml#record} setting, or ''record''.
         */
        record: string;

        /**
         * Creates new Writer.
         * @param {Object} [config] Config object.
         */
        constructor(config?: Ext.data.writer.WriterConfig);

        getDefaultDocumentRoot();

        getDocumentRoot();

        getHeader();

        getRecord();

        /**
         * Serializes an object to XML.
         * Properties will be serialized as child elements unless their first character is ''@''
         *
         * For example:
         *
         *    myWriter.objectToElement('SystemComponent', {
         *        "@SystemNumber": '10118795',
         *        "SystemInfo>SystemName": 'Phase Noise Measurement System',
         *        AssetId: 'DE3208',
         *        AgilentModel: 'E5505A',
         *        SerialNumber: 'US44101357',
         *    }, []).join('');
         *
         * becomes
         *
         *    <SystemComponent SystemNumber="10118795">
         *      <SystemInfo>
         *          <SystemName>Phase Noise Measurement System</SystemName>
         *      </SystemInfo>
         *      <AssetId>DE3208</AssetId>
         *      <AgilentModel>E5505A</AgilentModel>
         *      <SerialNumber>US44101357</SerialNumber>
         *    </SystemComponent>
         *
         * @param {String} name The element name for the object.
         * @param {Object} o The object to serialize.
         * @param {Array} [output] The array into which to serialize the object.
         * @return {undefined}
         */
        objectToElement(name: string, o: any, output?: any[]): any;

        setDefaultDocumentRoot();

        setDocumentRoot();

        setHeader();

        setRecord();
    }
}

declare module Ext.dataview {
    interface DataViewConfig extends Ext.ContainerConfig {
        baseCls?: any;

        data?: any;

        /**
         * 'true' to defer 'emptyText' being applied until the store's first load.
         */
        deferEmptyText?: boolean;

        /**
         * When set to true, tapping on the DataView's background (i.e. not on
         * an item in the DataView) will deselect any currently selected items.
         */
        deselectOnContainerClick?: boolean;

        /**
         * The text to display in the view when there is no data to display
         */
        emptyText?: string;

        /**
         * When set to 'true' the items within the DataView will have their display set to inline-block
         * and be arranged horizontally. By default the items will wrap to the width of the DataView.
         * Passing an object with '{ wrap: false }' will turn off this wrapping behavior and overflowed
         * items will need to be scrolled to horizontally.
         */
        inline?: boolean|any;

        /**
         * An additional CSS class to apply to items within the DataView.
         */
        itemCls?: string;

        /**
         * A configuration object that is passed to every item created by a component based DataView. Because each
         * item that a DataView renders is a Component, we can pass configuration options to each component to
         * easily customize how each child component behaves.
         *
         * __Note:__ this is only used when '{@link #useComponents}' is 'true'.
         */
        itemConfig?: any;

        /**
         * The 'tpl' to use for each of the items displayed in this DataView.
         */
        itemTpl?: string|Ext.XTemplate;

        /**
         * A string to display during data load operations.  If specified, this text will be
         * displayed in a loading div and the view's contents will be cleared while loading, otherwise the view's
         * contents will continue to display normally until the new data is loaded and the contents are replaced.
         */
        loadingText?: string|boolean;

        /**
         * Maintains a cache of reusable components when using a component based DataView.  Improving performance at
         * the cost of memory.
         *
         * __Note:__ this is currently only used when '{@link #useComponents}' is 'true'.
         */
        maxItemCache?: number;

        /**
         * The CSS class to apply to an item on the view while it is being pressed.
         */
        pressedCls?: string;

        /**
         * The amount of delay between the 'tapstart' and the moment we add the 'pressedCls'.
         *
         * Settings this to 'true' defaults to 100ms.
         */
        pressedDelay?: number;

        /**
         * Scroll the DataView to the top when the DataView is refreshed.
         */
        scrollToTopOnRefresh?: boolean;

        scrollable?: any;

        /**
         * The CSS class to apply to an item on the view while it is selected.
         */
        selectedCls?: string;

        /**
         * Can be either a Store instance or a configuration object that will be turned into a Store. The Store is used
         * to populate the set of items that will be rendered in the DataView. See the DataView intro documentation for
         * more information about the relationship between Store and DataView.
         */
        store?: Ext.data.Store|any;

        /**
         * Determines what type of touch event is recognized as a touch on the container.
         * Valid options are 'tap' and 'singletap'.
         */
        triggerCtEvent?: string;

        /**
         * Determines what type of touch event causes an item to be selected.
         * Valid options are: 'itemtap', 'itemsingletap', 'itemdoubletap', 'itemswipe', 'itemtaphold'.
         */
        triggerEvent?: string;

        /**
         * Flag the use a component based DataView implementation.  This allows the full use of components in the
         * DataView at the cost of some performance.
         */
        useComponents?: boolean;
    }

    /**
     * DataView makes it easy to create lots of components dynamically, usually based off a {@link Ext.data.Store Store}.
     * It's great for rendering lots of data from your server backend or any other data source and is what powers
     * components like {@link Ext.List}.
     *
     * Use DataView whenever you want to show sets of the same component many times, for examples in apps like these:
     *
     * - List of messages in an email app
     * - Showing latest news/tweets
     * - Tiled set of albums in an HTML5 music player
     *
     * # Creating a Simple DataView
     *
     * At its simplest, a DataView is just a Store full of data and a simple template that we use to render each item:
     *
     *     @example miniphone preview
     *     var gbTeam = Ext.create('Ext.DataView', {
     *         fullscreen: true,
     *         store: {
     *             fields: ['name', 'age'],
     *             data: [
     *                 {name: 'Peter',  age: 26},
     *                 {name: 'Ray',   age: 21},
     *                 {name: 'Egon', age: 24},
     *                 {name: 'Winston', age: 24}
     *             ]
     *         },
     *
     *         itemTpl: '<div>{name} is {age} years old</div>'
     *     });
     *
     * Here we just defined everything inline so it's all local with nothing being loaded from a server. For each of the 5
     * data items defined in our Store, DataView will render a {@link Ext.Component Component} and pass in the name and age
     * data. The component will use the tpl we provided above, rendering the data in the curly bracket placeholders we
     * provided.
     *
     * Because DataView is integrated with Store, any changes to the Store are immediately reflected on the screen. For
     * example, if we add a new record to the Store it will be rendered into our DataView:
     *
     *     gbTeam.getStore().add({
     *         name: 'Gozer',
     *         age: 567
     *     });
     *
     * We didn't have to manually update the DataView, it's just automatically updated. The same happens if we modify one
     * of the existing records in the Store:
     *
     *     gbTeam.getStore().getAt(0).set('age', 42);
     *
     * This will get the first record in the Store (Peter), change the age to 42 and automatically update what's on the
     * screen.
     *
     *     @example miniphone
     *     var gbTeam = Ext.create('Ext.DataView', {
     *         fullscreen: true,
     *         store: {
     *             fields: ['name', 'age'],
     *             data: [
     *                 {name: 'Peter',  age: 26},
     *                 {name: 'Ray',   age: 21},
     *                 {name: 'Egon', age: 24},
     *                 {name: 'Winston', age: 24}
     *             ]
     *         },
     *
     *         itemTpl: '<div>{name} is {age} years old</div>'
     *     });
     *
     *     gbTeam.getStore().add({
     *         name: 'Gozer',
     *         age: 21
     *     });
     *
     *     gbTeam.getStore().getAt(0).set('age', 42);
     *
     * # Loading data from a server
     *
     * We often want to load data from our server or some other web service so that we don't have to hard code it all
     * locally. Let's say we want to load some horror movies from Rotten Tomatoes into a DataView, and for each one
     * render the cover image and title. To do this all we have to do is grab an api key from rotten tomatoes (http://developer.rottentomatoes.com/)
     * and modify the {@link #store} and {@link #itemTpl} a little:
     *
     *     @example portrait
     *     Ext.create('Ext.DataView', {
     *         fullscreen: true,
     *         store: {
     *             autoLoad: true,
     *             fields: ['id', 'title',
     *              {
     *                  name:'thumbnail_image',
     *                  convert: function(v, record) {return record.raw.posters.thumbnail; }
     *              }],
     *
     *             proxy: {
     *                 type: 'jsonp',
     *                 // Modify this line with your API key, pretty please...
     *                 url: 'http://api.rottentomatoes.com/api/public/v1.0/movies.json?apikey=hbjgfgryw8tygxztr5wtag3u&q=Horror',
     *
     *                 reader: {
     *                     type: 'json',
     *                     rootProperty: 'results'
     *                 }
     *             }
     *         },
     *
     *         itemTpl: '<img src="{thumbnail_image}" /><p>{title}</p><div style="clear: both"></div>'
     *     });
     *
     * The Store no longer has hard coded data, instead we've provided a {@link Ext.data.proxy.Proxy Proxy}, which fetches
     * the data for us. In this case we used a JSON-P proxy so that we can load from Twitter's JSON-P search API. We also
     * specified the fields present for each tweet, and used Store's {@link Ext.data.Store#autoLoad autoLoad} configuration
     * to load automatically. Finally, we configured a Reader to decode the response from Twitter, telling it to expect
     * JSON and that the tweets can be found in the 'results' part of the JSON response.
     *
     * The last thing we did is update our template to render the image, Twitter username and message. All we need to do
     * now is add a little CSS to style the list the way we want it and we end up with a very basic Twitter viewer. Click
     * the preview button on the example above to see it in action.
     */
    export class DataView extends Ext.Container implements Ext.dataview.DataViewConfig {
        defaultBindProperty: any;

        /**
         * The base CSS class to apply to this component's element. This will also be prepended to
         * other elements within this component. To add specific styling for sub-classes, use the {@link #cls} config.
         */
        baseCls: string;

        /**
         * The initial set of data to apply to the '{@link #tpl}' to
         * update the content area of the Component.
         */
        data: any;

        /**
         * 'true' to defer 'emptyText' being applied until the store's first load.
         */
        deferEmptyText: boolean;

        /**
         * When set to true, tapping on the DataView's background (i.e. not on
         * an item in the DataView) will deselect any currently selected items.
         */
        deselectOnContainerClick: boolean;

        /**
         * The text to display in the view when there is no data to display
         */
        emptyText: string;

        /**
         * When set to 'true' the items within the DataView will have their display set to inline-block
         * and be arranged horizontally. By default the items will wrap to the width of the DataView.
         * Passing an object with '{ wrap: false }' will turn off this wrapping behavior and overflowed
         * items will need to be scrolled to horizontally.
         */
        inline: boolean|any;

        /**
         * An additional CSS class to apply to items within the DataView.
         */
        itemCls: string;

        /**
         * A configuration object that is passed to every item created by a component based DataView. Because each
         * item that a DataView renders is a Component, we can pass configuration options to each component to
         * easily customize how each child component behaves.
         *
         * __Note:__ this is only used when '{@link #useComponents}' is 'true'.
         */
        itemConfig: any;

        /**
         * The 'tpl' to use for each of the items displayed in this DataView.
         */
        itemTpl: string|Ext.XTemplate;

        /**
         * A string to display during data load operations.  If specified, this text will be
         * displayed in a loading div and the view's contents will be cleared while loading, otherwise the view's
         * contents will continue to display normally until the new data is loaded and the contents are replaced.
         */
        loadingText: string|boolean;

        /**
         * Maintains a cache of reusable components when using a component based DataView.  Improving performance at
         * the cost of memory.
         *
         * __Note:__ this is currently only used when '{@link #useComponents}' is 'true'.
         */
        maxItemCache: number;

        /**
         * The CSS class to apply to an item on the view while it is being pressed.
         */
        pressedCls: string;

        /**
         * The amount of delay between the 'tapstart' and the moment we add the 'pressedCls'.
         *
         * Settings this to 'true' defaults to 100ms.
         */
        pressedDelay: number;

        /**
         * Configuration options to make this Component scrollable. Acceptable values are:
         *
         * - 'true' to enable auto scrolling.
         * - 'false' (or 'null') to disable scrolling - this is the default.
         * - 'x' or 'horizontal' to enable horizontal scrolling only
         * - 'y' or 'vertical' to enable vertical scrolling only
         *
         * Also accepts a configuration object for a '{@link Ext.scroll.Scroller}' if
         * if advanced configuration is needed.
         *
         * The getter for this config returns the {@link Ext.scroll.Scroller Scroller}
         * instance.  You can use the Scroller API to read or manipulate the scroll position:
         *
         *     // scrolls the component to 5 on the x axis and 10 on the y axis
         *     component.getScrollable().scrollTo(5, 10);
         */
        scrollable: boolean|string|any;

        /**
         * Scroll the DataView to the top when the DataView is refreshed.
         */
        scrollToTopOnRefresh: boolean;

        /**
         * The CSS class to apply to an item on the view while it is selected.
         */
        selectedCls: string;

        /**
         * Can be either a Store instance or a configuration object that will be turned into a Store. The Store is used
         * to populate the set of items that will be rendered in the DataView. See the DataView intro documentation for
         * more information about the relationship between Store and DataView.
         */
        store: Ext.data.Store|any;

        /**
         * Determines what type of touch event is recognized as a touch on the container.
         * Valid options are 'tap' and 'singletap'.
         */
        triggerCtEvent: string;

        /**
         * Determines what type of touch event causes an item to be selected.
         * Valid options are: 'itemtap', 'itemsingletap', 'itemdoubletap', 'itemswipe', 'itemtaphold'.
         */
        triggerEvent: string;

        /**
         * Flag the use a component based DataView implementation.  This allows the full use of components in the
         * DataView at the cost of some performance.
         */
        useComponents: boolean;

        constructor(config: Ext.dataview.DataViewConfig);

        destroy();

        getBaseCls();

        getData();

        getDefaultType();

        getDeferEmptyText();

        getDeselectOnContainerClick();

        getEmptyText();

        getInline();

        /**
         * Returns an item at the specified index.
         * @param {Number} index Index of the item.
         * @return {Ext.dom.Element/Ext.dataview.component.DataItem} item Item at the specified index.
         */
        getItemAt(index: number): Ext.dom.Element|Ext.dataview.component.DataItem;

        getItemCls();

        getItemConfig();

        /**
         * Returns an index for the specified item.
         * @param {Number} item The item to locate.
         * @return {Number} Index for the specified item.
         */
        getItemIndex(item: number): number;

        getItemTpl();

        getLoadingText();

        getMaxItemCache();

        getPressedCls();

        getPressedDelay();

        getScrollable();

        getScrollToTopOnRefresh();

        getSelectedCls();

        getStore();

        getTriggerCtEvent();

        getTriggerEvent();

        getUseComponents();

        /**
         * Returns an array of the current items in the DataView.
         * @return {Ext.dom.Element[]/Ext.dataview.component.DataItem[]} Array of Items.
         */
        getViewItems(): Ext.dom.Element|Ext.dataview.component.DataItem;

        /**
         * Method called when the Store's Reader throws an exception
         */
        handleException();

        protected initialize();

        /**
         * Function which can be overridden to provide custom formatting for each Record that is used by this
         * DataView's {@link #tpl template} to render each node.
         * @param {Object/Object[]} data The raw data object that was used to create the Record.
         * @param {Number} index the index number of the Record being prepared for rendering.
         * @param {Ext.data.Model} record The Record being prepared for rendering.
         * @return {Array/Object} The formatted data in a format expected by the internal {@link #tpl template}'s 'overwrite()' method.
         * (either an array if your params are numeric (i.e. '{0}') or an object (i.e. '{foo: 'bar'}'))
         */
        prepareData(data: any, index: number, record: Ext.data.Model): any[]|any;

        /**
         * Refreshes the view by reloading the data from the store and re-rendering the template.
         */
        refresh();

        setBaseCls();

        setData();

        setDefaultType();

        setDeferEmptyText();

        setDeselectOnContainerClick();

        setEmptyText();

        setInline();

        setItemCls();

        setItemConfig();

        setItemTpl();

        setLoadingText();

        setMaxItemCache();

        setPressedCls();

        setPressedDelay();

        setScrollable();

        setScrollToTopOnRefresh();

        setSelectedCls();

        setStore();

        setTriggerCtEvent();

        setTriggerEvent();

        setUseComponents();

        /**
         * Fires when a tap occurs and it is not on a template node.
         * @removed 2.0.0
         */
        containertap();

        /**
         * Fires whenever an item is deselected
         * @param {Ext.data.Model} record The record associated to the item
         * @param {Boolean} supressed Flag to suppress the event
         */
        deselect(that: Ext.dataview.DataView, record: Ext.data.Model, supressed: boolean);

        /**
         * Fires whenever an item is doubletapped
         * @param {Number} index The index of the item doubletapped
         * @param {Ext.Element/Ext.dataview.component.DataItem} target The element or DataItem doubletapped
         * @param {Ext.data.Model} record The record associated to the item
         * @param {Ext.event.Event} e The event object
         */
        itemdoubletap(that: Ext.dataview.DataView, index: number, target: Ext.dom.Element|Ext.dataview.component.DataItem, record: Ext.data.Model, e: Ext.event.Event);

        /**
         * Fires whenever an item is singletapped
         * @param {Number} index The index of the item singletapped
         * @param {Ext.Element/Ext.dataview.component.DataItem} target The element or DataItem singletapped
         * @param {Ext.data.Model} record The record associated to the item
         * @param {Ext.event.Event} e The event object
         */
        itemsingletap(that: Ext.dataview.DataView, index: number, target: Ext.dom.Element|Ext.dataview.component.DataItem, record: Ext.data.Model, e: Ext.event.Event);

        /**
         * Fires whenever an item is swiped
         * @param {Number} index The index of the item swiped
         * @param {Ext.Element/Ext.dataview.component.DataItem} target The element or DataItem swiped
         * @param {Ext.data.Model} record The record associated to the item
         * @param {Ext.event.Event} e The event object
         */
        itemswipe(that: Ext.dataview.DataView, index: number, target: Ext.dom.Element|Ext.dataview.component.DataItem, record: Ext.data.Model, e: Ext.event.Event);

        /**
         * Fires whenever an item is tapped
         * @param {Number} index The index of the item tapped
         * @param {Ext.Element/Ext.dataview.component.DataItem} target The element or DataItem tapped
         * @param {Ext.data.Model} record The record associated to the item
         * @param {Ext.event.Event} e The event object
         */
        itemtap(that: Ext.dataview.DataView, index: number, target: Ext.dom.Element|Ext.dataview.component.DataItem, record: Ext.data.Model, e: Ext.event.Event);

        /**
         * Fires whenever an item's taphold event fires
         * @param {Number} index The index of the item touched
         * @param {Ext.Element/Ext.dataview.component.DataItem} target The element or DataItem touched
         * @param {Ext.data.Model} record The record associated to the item
         * @param {Ext.event.Event} e The event object
         */
        itemtaphold(that: Ext.dataview.DataView, index: number, target: Ext.dom.Element|Ext.dataview.component.DataItem, record: Ext.data.Model, e: Ext.event.Event);

        /**
         * Fires whenever an item is touched
         * @param {Number} index The index of the item touched
         * @param {Ext.Element/Ext.dataview.component.DataItem} target The element or DataItem touched
         * @param {Ext.data.Model} record The record associated to the item
         * @param {Ext.event.Event} e The event object
         */
        itemtouchend(that: Ext.dataview.DataView, index: number, target: Ext.dom.Element|Ext.dataview.component.DataItem, record: Ext.data.Model, e: Ext.event.Event);

        /**
         * Fires whenever an item is moved
         * @param {Number} index The index of the item moved
         * @param {Ext.Element/Ext.dataview.component.DataItem} target The element or DataItem moved
         * @param {Ext.data.Model} record The record associated to the item
         * @param {Ext.event.Event} e The event object
         */
        itemtouchmove(that: Ext.dataview.DataView, index: number, target: Ext.dom.Element|Ext.dataview.component.DataItem, record: Ext.data.Model, e: Ext.event.Event);

        /**
         * Fires whenever an item is touched
         * @param {Number} index The index of the item touched
         * @param {Ext.Element/Ext.dataview.component.DataItem} target The element or DataItem touched
         * @param {Ext.data.Model} record The record associated to the item
         * @param {Ext.event.Event} e The event object
         */
        itemtouchstart(that: Ext.dataview.DataView, index: number, target: Ext.dom.Element|Ext.dataview.component.DataItem, record: Ext.data.Model, e: Ext.event.Event);

        /**
         * Fires whenever an item is selected
         * @param {Ext.data.Model} record The record associated to the item
         */
        select(that: Ext.dataview.DataView, record: Ext.data.Model);
    }

    interface IndexBarConfig extends Ext.ComponentConfig {
        baseCls?: any;

        /**
         * Layout direction, can be either 'vertical' or 'horizontal'
         */
        direction?: string;

        /**
         * The letters to show on the index bar.
         */
        letters?: any[];

        /**
         * The prefix string to be used at the beginning of the list.
         * E.g: useful to add a "#" prefix before numbers.
         */
        listPrefix?: string;

        ui?: any;
    }

    /**
     * IndexBar is a component used to display a list of data (primarily an alphabet) which can then be used to quickly
     * navigate through a list (see {@link Ext.List}) of data. When a user taps on an item in the {@link Ext.IndexBar},
     * it will fire the {@link #index} event.
     *
     * Here is an example of the usage in a {@link Ext.List}:
     *
     *     @example phone portrait preview
     *     Ext.define('Contact', {
     *         extend: 'Ext.data.Model',
     *         config: {
     *             fields: ['firstName', 'lastName']
     *         }
     *     });
     *
     *     var store = new Ext.data.JsonStore({
     *        model: 'Contact',
     *        sorters: 'lastName',
     *
     *        grouper: {
     *            groupFn: function(record) {
     *                return record.get('lastName')[0];
     *            }
     *        },
     *
     *        data: [
     *            {firstName: 'Screech', lastName: 'Powers'},
     *            {firstName: 'Kelly',   lastName: 'Kapowski'},
     *            {firstName: 'Zach',    lastName: 'Morris'},
     *            {firstName: 'Jessie',  lastName: 'Spano'},
     *            {firstName: 'Lisa',    lastName: 'Turtle'},
     *            {firstName: 'A.C.',    lastName: 'Slater'},
     *            {firstName: 'Richard', lastName: 'Belding'}
     *        ]
     *     });
     *
     *     var list = new Ext.List({
     *        fullscreen: true,
     *        itemTpl: '<div class="contact">{firstName} <strong>{lastName}</strong></div>',
     *
     *        grouped     : true,
     *        indexBar    : true,
     *        store: store,
     *        hideOnMaskTap: false
     *     });
     */
    export class IndexBar extends Ext.Component implements Ext.dataview.IndexBarConfig {
        baseCls: string;

        /**
         * Layout direction, can be either 'vertical' or 'horizontal'
         */
        direction: string;

        /**
         * The letters to show on the index bar.
         */
        letters: any[];

        /**
         * The prefix string to be used at the beginning of the list.
         * E.g: useful to add a "#" prefix before numbers.
         */
        listPrefix: string;

        ui: string;

        /**
         * Creates new Component.
         * @param {Object} config The standard configuration object.
         */
        constructor(config: Ext.ButtonConfig);

        getBaseCls();

        getDirection();

        getLetters();

        getListPrefix();

        getUi();

        setBaseCls();

        setDirection();

        setLetters();

        setListPrefix();

        setUi();

        directionchange();

        /**
         * Fires when an item in the index bar display has been tapped.
         * @param {Ext.dataview.IndexBar} this The IndexBar instance
         * @param {String} html The HTML inside the tapped node.
         * @param {Ext.dom.Element} target The node on the indexbar that has been tapped.
         */
        index(that: Ext.dataview.IndexBar, html: string, target: Ext.dom.Element);
    }

    interface ListConfig extends Ext.dataview.DataViewConfig {
        baseCls?: any;

        /**
         * The amount of items we render additionally besides the ones currently visible.
         * We try to prevent the rendering of items while scrolling until the next time you stop scrolling.
         * If you scroll close to the end of the buffer, we start rendering individual items to always
         * have the {@link #minimumBufferSize} prepared.
         */
        bufferSize?: number;

        /**
         * This config is used to control the internal {@link Ext.Container} created to
         * manage this list's items. One common use for this is to apply a {@link #userCls}
         * to the item container.
         *
         *      {
         *          xtype: 'list',
         *          container: {
         *              userCls: 'mylist-cls'
         *          },
         *          ...
         *      }
         *
         * @since 6.0.1
         */
        container?: any;

        /**
         * A property to check on each record to display the disclosure on a per record basis.  This
         * property must be false to prevent the disclosure from being displayed on the item.
         */
        disclosureProperty?: string;

        /**
         * Whether or not to group items in the provided Store with a header for each item.
         */
        grouped?: boolean;

        /**
         * 'true' to render an alphabet IndexBar docked on the right.
         * This can also be a config object that will be passed to {@link Ext.IndexBar}.
         */
        indexBar?: boolean|any;

        /**
         * Set this to false to render all items in this list, and render them relatively.
         * Note that this configuration can not be dynamically changed after the list has instantiated.
         */
        infinite?: boolean;

        /**
         * This allows you to set the default item height and is used to roughly calculate the amount
         * of items needed to fill the list. By default items are around 50px high.
         */
        itemHeight?: number;

        /**
         * 'true' to display a disclosure icon on each list item.
         * The list will still fire the disclose event, and the event can be stopped before itemtap.
         * By setting this config to a function, the function passed will be called when the disclosure
         * is tapped.
         * Finally you can specify an object with a 'scope' and 'handler'
         * property defined. This will also be bound to the tap event listener
         * and is useful when you want to change the scope of the handler.
         */
        onItemDisclosure?: boolean|Function|any;

        /**
         * Whether or not to pin headers on top of item groups while scrolling for an iPhone native list experience.
         */
        pinHeaders?: boolean;

        /**
         * 'true' to prevent the item selection when the user
         * taps a disclose icon.
         */
        preventSelectionOnDisclose?: boolean;

        /**
         * Set this to false if you make many updates to your list (like in an interval), but updates
         * won't affect the item's height. Doing this will increase the performance of these updates.
         */
        refreshHeightOnUpdate?: boolean;

        /**
         * Set this to true if you want the items in the list to be zebra striped, alternating their
         * background color.
         */
        striped?: boolean;

        /**
         * Set this to true if you just want to have the list create simple items that use the itemTpl.
         * These simple items still support headers, grouping and disclosure functionality but avoid
         * container layouts and deeply nested markup. For many Lists using this configuration will
         * drastically increase the scrolling and render performance.
         */
        useSimpleItems?: boolean;
    }

    /**
     * List is a custom styled DataView which allows Grouping, Indexing, Icons, and a Disclosure.
     *
     *     @example miniphone preview
     *     Ext.create('Ext.List', {
     *         fullscreen: true,
     *         itemTpl: '{title}',
     *         data: [
     *             { title: 'Item 1' },
     *             { title: 'Item 2' },
     *             { title: 'Item 3' },
     *             { title: 'Item 4' }
     *         ]
     *     });
     *
     * A more advanced example showing a list of people grouped by last name:
     *
     *     @example miniphone preview
     *     Ext.define('Contact', {
     *         extend: 'Ext.data.Model',
     *         config: {
     *             fields: ['firstName', 'lastName']
     *         }
     *     });
     *
     *     var store = Ext.create('Ext.data.Store', {
     *        model: 'Contact',
     *        sorters: 'lastName',
     *
     *        grouper: {
     *            groupFn: function(record) {
     *                return record.get('lastName')[0];
     *            }
     *        },
     *
     *        data: [
     *            { firstName: 'Peter',   lastName: 'Venkman'  },
     *            { firstName: 'Raymond', lastName: 'Stantz'   },
     *            { firstName: 'Egon',    lastName: 'Spengler' },
     *            { firstName: 'Winston', lastName: 'Zeddemore'}
     *        ]
     *     });
     *
     *     Ext.create('Ext.List', {
     *        fullscreen: true,
     *        itemTpl: '<div class="contact">{firstName} <strong>{lastName}</strong></div>',
     *        store: store,
     *        grouped: true
     *     });
     *
     * If you want to dock items to the bottom or top of a List, you can use the scrollDock configuration on child items in this List. The following example adds a button to the bottom of the List.
     *
     *     @example phone preview
     *     Ext.define('Contact', {
     *         extend: 'Ext.data.Model',
     *         config: {
     *             fields: ['firstName', 'lastName']
     *         }
     *     });
     *
     *     var store = Ext.create('Ext.data.Store', {
     *        model: 'Contact',
     *        sorters: 'lastName',
     *
     *        grouper: {
     *            groupFn: function(record) {
     *                return record.get('lastName')[0];
     *            }
     *        },
     *
     *        data: [
     *            { firstName: 'Peter',   lastName: 'Venkman'  },
     *            { firstName: 'Raymond', lastName: 'Stantz'   },
     *            { firstName: 'Egon',    lastName: 'Spengler' },
     *            { firstName: 'Winston', lastName: 'Zeddemore'}
     *        ]
     *     });
     *
     *     Ext.create('Ext.List', {
     *         fullscreen: true,
     *         itemTpl: '<div class="contact">{firstName} <strong>{lastName}</strong></div>',
     *         store: store,
     *         items: [{
     *             xtype: 'button',
     *             scrollDock: 'bottom',
     *             docked: 'bottom',
     *             text: 'Load More...'
     *         }]
     *     });
     */
    export class List extends Ext.dataview.DataView implements Ext.dataview.ListConfig {
        /**
         * The base CSS class to apply to this component's element. This will also be prepended to
         * other elements within this component. To add specific styling for sub-classes, use the {@link #cls} config.
         */
        baseCls: string;

        /**
         * The amount of items we render additionally besides the ones currently visible.
         * We try to prevent the rendering of items while scrolling until the next time you stop scrolling.
         * If you scroll close to the end of the buffer, we start rendering individual items to always
         * have the {@link #minimumBufferSize} prepared.
         */
        bufferSize: number;

        /**
         * This config is used to control the internal {@link Ext.Container} created to
         * manage this list's items. One common use for this is to apply a {@link #userCls}
         * to the item container.
         *
         *      {
         *          xtype: 'list',
         *          container: {
         *              userCls: 'mylist-cls'
         *          },
         *          ...
         *      }
         *
         * @since 6.0.1
         */
        container: any;

        /**
         * A property to check on each record to display the disclosure on a per record basis.  This
         * property must be false to prevent the disclosure from being displayed on the item.
         */
        disclosureProperty: string;

        /**
         * Whether or not to group items in the provided Store with a header for each item.
         */
        grouped: boolean;

        /**
         * 'true' to render an alphabet IndexBar docked on the right.
         * This can also be a config object that will be passed to {@link Ext.IndexBar}.
         */
        indexBar: boolean|any;

        /**
         * Set this to false to render all items in this list, and render them relatively.
         * Note that this configuration can not be dynamically changed after the list has instantiated.
         */
        infinite: boolean;

        /**
         * This allows you to set the default item height and is used to roughly calculate the amount
         * of items needed to fill the list. By default items are around 50px high.
         */
        itemHeight: number;

        /**
         * 'true' to display a disclosure icon on each list item.
         * The list will still fire the disclose event, and the event can be stopped before itemtap.
         * By setting this config to a function, the function passed will be called when the disclosure
         * is tapped.
         * Finally you can specify an object with a 'scope' and 'handler'
         * property defined. This will also be bound to the tap event listener
         * and is useful when you want to change the scope of the handler.
         */
        onItemDisclosure: boolean|Function|any;

        /**
         * Whether or not to pin headers on top of item groups while scrolling for an iPhone native list experience.
         */
        pinHeaders: boolean;

        /**
         * 'true' to prevent the item selection when the user
         * taps a disclose icon.
         */
        preventSelectionOnDisclose: boolean;

        /**
         * Set this to false if you make many updates to your list (like in an interval), but updates
         * won't affect the item's height. Doing this will increase the performance of these updates.
         */
        refreshHeightOnUpdate: boolean;

        /**
         * Set this to true if you want the items in the list to be zebra striped, alternating their
         * background color.
         */
        striped: boolean;

        /**
         * Set this to true if you just want to have the list create simple items that use the itemTpl.
         * These simple items still support headers, grouping and disclosure functionality but avoid
         * container layouts and deeply nested markup. For many Lists using this configuration will
         * drastically increase the scrolling and render performance.
         */
        useSimpleItems: boolean;

        constructor();

        destroy();

        getBaseCls();

        getBufferSize();

        getContainer();

        getDefaultType();

        getDisclosureProperty();

        getGrouped();

        getIcon();

        getIndexBar();

        getInfinite();

        /**
         * Gets a list item by record.
         * @param {Ext.data.Model} The record
         * @return {Ext.dataview.component.(Simple)ListItem} The list item, if found.
         * 'null' if no matching item exists.
         */
        getItem(The: Ext.data.Model): any;

        /**
         * Returns an item at the specified index.
         * @param {Number} index Index of the item.
         * @return {Ext.dom.Element/Ext.dataview.component.DataItem} item Item at the specified index.
         */
        getItemAt(index: number): Ext.dom.Element|Ext.dataview.component.DataItem;

        getItemHeight();

        /**
         * Returns an index for the specified item.
         * @param {Number} item The item to locate.
         * @return {Number} Index for the specified item.
         */
        getItemIndex(item: number): number;

        getMinimumBufferDistance();

        getOnItemDisclosure();

        getPinHeaders();

        getPreventSelectionOnDisclose();

        getRefreshHeightOnUpdate();

        getScrollable();

        /**
         * Returns all the items that are docked in the scroller in this list.
         * @return {Ext.Component[]} An array of the scrollDock items
         */
        getScrollDockedItems(): Ext.Component;

        getStriped();

        getUseSimpleItems();

        /**
         * Returns an array of the current items in the DataView.
         * @return {Ext.dom.Element[]/Ext.dataview.component.DataItem[]} Array of Items.
         */
        getViewItems(): Ext.dom.Element|Ext.dataview.component.DataItem;

        protected initialize();

        /**
         * Scrolls the list so that the specified record is at the top.
         *
         * @param {Ext.data.Model} record Record in the store to scroll to.
         * @param {Boolean} [animate=false] Determines if scrolling is animated.
         * @param {Boolean} [overscroll=true] Determines if list can be overscrolled.
         */
        scrollToRecord(record: Ext.data.Model, animate?: boolean, overscroll?: boolean);

        setBaseCls();

        setBufferSize();

        setContainer();

        setDefaultType();

        setDisclosureProperty();

        setGrouped();

        setIcon();

        setIndexBar();

        setInfinite();

        setItemHeight();

        setMinimumBufferDistance();

        setOnItemDisclosure();

        setPinHeaders();

        setPreventSelectionOnDisclose();

        setRefreshHeightOnUpdate();

        setStriped();

        setUseSimpleItems();

        /**
         * Fires whenever a disclosure is handled
         * @param {Ext.dataview.List} this The List instance
         * @param {Ext.data.Model} record The record associated to the item
         * @param {HTMLElement} target The element disclosed
         * @param {Number} index The index of the item disclosed
         * @param {Ext.EventObject} e The event object
         */
        disclose(that: Ext.dataview.List, record: Ext.data.Model, target: HTMLElement, index: number, e: any);
    }

    interface ListItemHeaderConfig extends Ext.ComponentConfig {
        baseCls?: any;
    }

    /**
     * To be made a sample
     */
    export class ListItemHeader extends Ext.Component implements Ext.dataview.ListItemHeaderConfig {
        /**
         * The base CSS class to apply to this component's element. This will also be prepended to
         * other elements within this component. To add specific styling for sub-classes, use the {@link #cls} config.
         */
        baseCls: string;

        /**
         * Creates new Component.
         * @param {Object} config The standard configuration object.
         */
        constructor(config: Ext.ButtonConfig);

        getBaseCls();

        setBaseCls();
    }

    interface NestedListConfig extends Ext.ContainerConfig {
        /**
         * Set to 'true' to allow the user to deselect leaf items via interaction.
         */
        allowDeselect?: boolean;

        /**
         * The configuration for the back button used in the nested list.
         */
        backButton?: any;

        /**
         * The label to display for the back button.
         */
        backText?: string;

        baseCls?: any;

        /**
         * Animation to be used during transitions of cards.
         * @removed 2.0.0 please use {@link Ext.layout.Card#animation}
         */
        cardSwitchAnimation?: string|any|boolean;

        /**
         * provides the information for a leaf
         * in a Miller column list. In a Miller column, users follow a
         * hierarchial tree structure to a leaf, which provides information
         * about the item in the list. The detailCard lists the information at
         * the leaf.
         *
         * See http://docs.sencha.com/touch/2-2/#!/guide/nested_list-section-3
         * and http://en.wikipedia.org/wiki/Miller_columns
         */
        detailCard?: Ext.Component;

        /**
         * The container of the 'detailCard'.
         * A detailContainer is a reference to the container where a detail card
         * displays.
         *
         * See http://docs.sencha.com/touch/2-2/#!/guide/nested_list-section-4
         * and http://en.wikipedia.org/wiki/Miller_columns
         *
         * The two possible values for a detailContainer are undefined (default),
         * which indicates that a detailCard appear in the same container, or you
         * can specify a new container location. The default condition uses the
         * current List container.
         *
         * The following example shows creating a location for a detailContainer:
         *
         * var detailContainer = Ext.create('Ext.Container', {
         *     layout: 'card'
         * });
         *
         * var nestedList = Ext.create('Ext.NestedList', {
         *     store: treeStore,
         *     detailCard: true,
         *     detailContainer: detailContainer
         * });
         *
         * The default value is typically used for phone devices in portrait mode
         * where the small screen size dictates that the detailCard replace the
         * current container.
         */
        detailContainer?: Ext.Container;

        /**
         * Display field to use when setting item text and title.
         * This configuration is ignored when overriding {@link #getItemTextTpl} or
         * {@link #getTitleTextTpl} for the item text or title.
         */
        displayField?: string;

        /**
         * Empty text to display when a subtree is empty.
         */
        emptyText?: string;

        /**
         * This allows you to set the default item height and is used to roughly calculate the amount
         * of items needed to fill the list. By default items are around 50px high. If you set this
         * configuration in combination with setting the {@link #variableHeights} to false you
         * can improve the scrolling speed
         */
        itemHeight?: number;

        /**
         * An optional config object which is merged with the default
         * configuration used to create each nested list.
         */
        listConfig?: any;

        /**
         * Loading text to display when a subtree is loading.
         */
        loadingText?: string;

        /**
         * Maps to the {@link Ext.List#onItemDisclosure} configuration for individual lists.
         */
        onItemDisclosure?: boolean|Function;

        /**
         * The tree store to be used for this nested list.
         */
        store?: Ext.data.TreeStore|string;

        /**
         * The title of the toolbar
         */
        title?: string;

        /**
         * The configuration to be used for the toolbar displayed in this nested list.
         */
        toolbar?: Ext.Toolbar|any|boolean;

        ui?: any;

        /**
         * Update the title with the currently selected category.
         */
        updateTitleText?: boolean;

        /**
         * Set this to false if you want the lists in this NestedList to create complex container list items.
         */
        useSimpleItems?: boolean;

        /**
         * 'true' to use title as a label for back button.
         */
        useTitleAsBackText?: boolean;

        /**
         * @deprecated 2.0.0 Please set the {@link #toolbar} configuration to 'false' instead
         * 'true' to show the header toolbar.
         */
        useToolbar?: boolean;

        /**
         * This configuration allows you optimize the picker by not having it read the DOM heights of list items.
         * Instead it will assume (and set) the height to be the {@link #itemHeight}.
         */
        variableHeights?: boolean;
    }

    /**
     * NestedList provides a miller column interface to navigate between nested sets
     * and provide a clean interface with limited screen real-estate.
     *
     *     @example miniphone preview
     *      var data = {
     *          text: 'Groceries',
     *          items: [{
     *              text: 'Drinks',
     *              items: [{
     *                  text: 'Water',
     *                  items: [{
     *                      text: 'Sparkling',
     *                      leaf: true
     *                  }, {
     *                      text: 'Still',
     *                      leaf: true
     *                  }]
     *              }, {
     *                  text: 'Coffee',
     *                  leaf: true
     *              }, {
     *                  text: 'Espresso',
     *                  leaf: true
     *              }, {
     *                  text: 'Redbull',
     *                  leaf: true
     *              }, {
     *                  text: 'Coke',
     *                  leaf: true
     *              }, {
     *                  text: 'Diet Coke',
     *                  leaf: true
     *              }]
     *          }, {
     *              text: 'Fruit',
     *              items: [{
     *                  text: 'Bananas',
     *                  leaf: true
     *              }, {
     *                  text: 'Lemon',
     *                  leaf: true
     *              }]
     *          }, {
     *              text: 'Snacks',
     *              items: [{
     *                  text: 'Nuts',
     *                  leaf: true
     *              }, {
     *                  text: 'Pretzels',
     *                  leaf: true
     *              }, {
     *                  text: 'Wasabi Peas',
     *                  leaf: true
     *              }]
     *          }]
     *      };
     *
     *      Ext.define('ListItem', {
     *          extend: 'Ext.data.Model',
     *          config: {
     *              fields: [{
     *                  name: 'text',
     *                  type: 'string'
     *              }]
     *          }
     *      });
     *
     *      var store = Ext.create('Ext.data.TreeStore', {
     *          model: 'ListItem',
     *          defaultRootProperty: 'items',
     *          root: data
     *      });
     *
     *      var nestedList = Ext.create('Ext.NestedList', {
     *          fullscreen: true,
     *          title: 'Groceries',
     *          displayField: 'text',
     *          store: store
     *      });
     */
    export class NestedList extends Ext.Container implements Ext.dataview.NestedListConfig {
        /**
         * Set to 'true' to allow the user to deselect leaf items via interaction.
         */
        allowDeselect: boolean;

        /**
         * The configuration for the back button used in the nested list.
         */
        backButton: any;

        /**
         * The label to display for the back button.
         */
        backText: string;

        /**
         * The base CSS class to apply to this component's element. This will also be prepended to
         * other elements within this component. To add specific styling for sub-classes, use the {@link #cls} config.
         */
        baseCls: string;

        /**
         * Animation to be used during transitions of cards.
         * @removed 2.0.0 please use {@link Ext.layout.Card#animation}
         */
        cardSwitchAnimation: string|any|boolean;

        /**
         * provides the information for a leaf
         * in a Miller column list. In a Miller column, users follow a
         * hierarchial tree structure to a leaf, which provides information
         * about the item in the list. The detailCard lists the information at
         * the leaf.
         *
         * See http://docs.sencha.com/touch/2-2/#!/guide/nested_list-section-3
         * and http://en.wikipedia.org/wiki/Miller_columns
         */
        detailCard: Ext.Component;

        /**
         * The container of the 'detailCard'.
         * A detailContainer is a reference to the container where a detail card
         * displays.
         *
         * See http://docs.sencha.com/touch/2-2/#!/guide/nested_list-section-4
         * and http://en.wikipedia.org/wiki/Miller_columns
         *
         * The two possible values for a detailContainer are undefined (default),
         * which indicates that a detailCard appear in the same container, or you
         * can specify a new container location. The default condition uses the
         * current List container.
         *
         * The following example shows creating a location for a detailContainer:
         *
         * var detailContainer = Ext.create('Ext.Container', {
         *     layout: 'card'
         * });
         *
         * var nestedList = Ext.create('Ext.NestedList', {
         *     store: treeStore,
         *     detailCard: true,
         *     detailContainer: detailContainer
         * });
         *
         * The default value is typically used for phone devices in portrait mode
         * where the small screen size dictates that the detailCard replace the
         * current container.
         */
        detailContainer: Ext.Container;

        /**
         * Display field to use when setting item text and title.
         * This configuration is ignored when overriding {@link #getItemTextTpl} or
         * {@link #getTitleTextTpl} for the item text or title.
         */
        displayField: string;

        /**
         * Empty text to display when a subtree is empty.
         */
        emptyText: string;

        /**
         * This allows you to set the default item height and is used to roughly calculate the amount
         * of items needed to fill the list. By default items are around 50px high. If you set this
         * configuration in combination with setting the {@link #variableHeights} to false you
         * can improve the scrolling speed
         */
        itemHeight: number;

        /**
         * An optional config object which is merged with the default
         * configuration used to create each nested list.
         */
        listConfig: any;

        /**
         * Loading text to display when a subtree is loading.
         */
        loadingText: string;

        /**
         * Maps to the {@link Ext.List#onItemDisclosure} configuration for individual lists.
         */
        onItemDisclosure: boolean|Function;

        /**
         * The tree store to be used for this nested list.
         */
        store: Ext.data.TreeStore|string;

        /**
         * The title of the toolbar
         */
        title: string;

        /**
         * The configuration to be used for the toolbar displayed in this nested list.
         */
        toolbar: Ext.Toolbar|any|boolean;

        ui: string;

        /**
         * Update the title with the currently selected category.
         */
        updateTitleText: boolean;

        /**
         * Set this to false if you want the lists in this NestedList to create complex container list items.
         */
        useSimpleItems: boolean;

        /**
         * 'true' to use title as a label for back button.
         */
        useTitleAsBackText: boolean;

        /**
         * @deprecated 2.0.0 Please set the {@link #toolbar} configuration to 'false' instead
         * 'true' to show the header toolbar.
         */
        useToolbar: boolean;

        /**
         * This configuration allows you optimize the picker by not having it read the DOM heights of list items.
         * Instead it will assume (and set) the height to be the {@link #itemHeight}.
         */
        variableHeights: boolean;

        constructor(config: Ext.ActionSheetConfig);

        getAllowDeselect();

        getBackButton();

        getBackText();

        getBaseCls();

        getClearSelectionOnListChange();

        getDetailCard();

        getDetailContainer();

        getDisplayField();

        getEmptyText();

        getItemHeight();

        /**
         * Override this method to provide custom template rendering of individual
         * nodes. The template will receive all data within the Record and will also
         * receive whether or not it is a leaf node.
         * @return {String}
         */
        getItemTextTpl(node: Ext.data.Model): string;

        getListConfig();

        getLoadingText();

        getOnItemDisclosure();

        getStore();

        getTitle();

        /**
         * Override this method to provide custom template rendering of titles/back
         * buttons when {@link #useTitleAsBackText} is enabled.
         * @return {String}
         */
        getTitleTextTpl(node: Ext.data.Model): string;

        getToolbar();

        getUi();

        getUpdateTitleText();

        getUseSimpleItems();

        getUseTitleAsBackText();

        getUseToolbar();

        getVariableHeights();

        /**
         * The leaf you want to navigate to. You should pass a node instance.
         * @param {Ext.data.NodeInterface} node The specified node to navigate to.
         */
        goToLeaf(node: Ext.data.NodeInterface);

        /**
         * Method to handle going to a specific node within this nested list. Node must be part of the
         * internal {@link #store}.
         * @param {Ext.data.NodeInterface} node The specified node to navigate to.
         */
        goToNode(node: Ext.data.NodeInterface);

        /**
         * Called when the backButton has been tapped.
         */
        onBackTap();

        /**
         * Called when an list item has been tapped.
         * @param {Ext.List} list The subList the item is on.
         * @param {Number} index The id of the item tapped.
         * @param {Ext.Element} target The list item tapped.
         * @param {Ext.data.Record} record The record which as tapped.
         * @param {Ext.event.Event} e The event.
         */
        onItemTap(list: Ext.dataview.List, index: number, target: Ext.dom.Element, record: Ext.data.Model, e: Ext.event.Event);

        setAllowDeselect();

        setBackButton();

        setBackText();

        setBaseCls();

        setClearSelectionOnListChange();

        setDetailCard();

        setDetailContainer();

        setDisplayField();

        setEmptyText();

        setItemHeight();

        setListConfig();

        setLoadingText();

        setOnItemDisclosure();

        setStore();

        setTitle();

        setToolbar();

        setUi();

        setUpdateTitleText();

        setUseSimpleItems();

        setUseTitleAsBackText();

        setUseToolbar();

        setVariableHeights();

        /**
         * Fires when the user taps Back.
         * @param {HTMLElement} node The node to be selected.
         * @param {Ext.dataview.List} lastActiveList The Ext.dataview.List that was last active.
         * @param {Boolean} detailCardActive Flag set if the detail card is currently active.
         */
        back(that: Ext.dataview.NestedList, node: HTMLElement, lastActiveList: Ext.dataview.List, detailCardActive: boolean);

        /**
         * Fires before a request is made for a new data object.
         * @param {Ext.data.Store} store The store instance.
         * @param {Ext.data.Operation} operation The Ext.data.Operation object that will be passed to the Proxy to
         * load the Store.
         */
        beforeload(that: Ext.dataview.NestedList, store: Ext.data.Store, operation: Ext.data.operation.Operation);

        /**
         * Fires before a selection is made.
         * @param {Ext.dataview.List} list The Ext.dataview.List that is currently active.
         * @param {HTMLElement} node The node to be selected.
         * @param {Array} selections Array of currently selected nodes.
         * @deprecated 2.0.0 Please listen to the {@link #selectionchange} event with an order of 'before' instead.
         */
        beforeselectionchange(that: Ext.dataview.NestedList, list: Ext.dataview.List, node: HTMLElement, selections: any[]);

        /**
         * Fires when a tap occurs and it is not on a template node.
         * @param {Ext.dataview.List} list The Ext.dataview.List that is currently active.
         * @param {Ext.event.Event} e The raw event object.
         */
        containertap(that: Ext.dataview.NestedList, list: Ext.dataview.List, e: Ext.event.Event);

        /**
         * Fires when a node is double tapped on.
         * @param {Ext.dataview.List} list The Ext.dataview.List that is currently active.
         * @param {Number} index The index of the item that was tapped.
         * @param {Ext.dom.Element} target The element tapped.
         * @param {Ext.data.Record} record The record tapped.
         * @param {Ext.event.Event} e The event object.
         */
        itemdoubletap(that: Ext.dataview.NestedList, list: Ext.dataview.List, index: number, target: Ext.dom.Element, record: Ext.data.Model, e: Ext.event.Event);

        /**
         * Fires when a node is tapped on.
         * @param {Ext.dataview.List} list The Ext.dataview.List that is currently active.
         * @param {Number} index The index of the item tapped.
         * @param {Ext.dom.Element} target The element tapped.
         * @param {Ext.data.Record} record The record tapped.
         * @param {Ext.event.Event} e The event object.
         */
        itemtap(that: Ext.dataview.NestedList, list: Ext.dataview.List, index: number, target: Ext.dom.Element, record: Ext.data.Model, e: Ext.event.Event);

        /**
         * Fires when the user taps a leaf list item.
         * @param {Ext.List} list The subList the item is on.
         * @param {Number} index The index of the item tapped.
         * @param {Ext.dom.Element} target The element tapped.
         * @param {Ext.data.Record} record The record tapped.
         * @param {Ext.event.Event} e The event.
         */
        leafitemtap(that: Ext.dataview.NestedList, list: Ext.dataview.List, index: number, target: Ext.dom.Element, record: Ext.data.Model, e: Ext.event.Event);

        /**
         * Fires when the user taps a list item.
         * @param {Object} listitem The new active list.
         */
        listchange(that: Ext.dataview.NestedList, listitem: any);

        /**
         * Fires whenever records have been loaded into the store.
         * @param {Ext.data.Store} store The store instance.
         * @param {Ext.util.Grouper[]} records An array of records.
         * @param {Boolean} successful 'true' if the operation was successful.
         * @param {Ext.data.Operation} operation The associated operation.
         */
        load(that: Ext.dataview.NestedList, store: Ext.data.Store, records: Ext.util.Grouper, successful: boolean, operation: Ext.data.operation.Operation);

        /**
         * Fires when the selected nodes change.
         * @param {Ext.dataview.List} list The Ext.dataview.List that is currently active.
         * @param {Array} selections Array of the selected nodes.
         */
        selectionchange(that: Ext.dataview.NestedList, list: Ext.dataview.List, selections: any[]);
    }
}

declare module Ext.dataview.component {
    export class Container extends Ext.Container {
        constructor(config: Ext.ActionSheetConfig);

        destroy();

        /**
         * Fires whenever an item is doubletapped
         * @param {Ext.dataview.component.DataItem} item The item doubletapped
         * @param {Number} index The index of the item doubletapped
         * @param {Ext.event.Event} e The event object
         */
        itemdoubletap(that: Ext.dataview.component.Container, item: Ext.dataview.component.DataItem, index: number, e: Ext.event.Event);

        /**
         * Fires whenever an item is doubletapped
         * @param {Ext.dataview.component.DataItem} item The item singletapped
         * @param {Number} index The index of the item singletapped
         * @param {Ext.event.Event} e The event object
         */
        itemsingletap(that: Ext.dataview.component.Container, item: Ext.dataview.component.DataItem, index: number, e: Ext.event.Event);

        /**
         * Fires whenever an item is swiped
         * @param {Ext.dataview.component.DataItem} item The item swiped
         * @param {Number} index The index of the item swiped
         * @param {Ext.event.Event} e The event object
         */
        itemswipe(that: Ext.dataview.component.Container, item: Ext.dataview.component.DataItem, index: number, e: Ext.event.Event);

        /**
         * Fires whenever an item is tapped
         * @param {Ext.dataview.component.DataItem} item The item tapped
         * @param {Number} index The index of the item tapped
         * @param {Ext.event.Event} e The event object
         */
        itemtap(that: Ext.dataview.component.Container, item: Ext.dataview.component.DataItem, index: number, e: Ext.event.Event);

        /**
         * Fires whenever an item is tapped
         * @param {Ext.dataview.component.DataItem} item The item tapped
         * @param {Number} index The index of the item tapped
         * @param {Ext.event.Event} e The event object
         */
        itemtaphold(that: Ext.dataview.component.Container, item: Ext.dataview.component.DataItem, index: number, e: Ext.event.Event);

        /**
         * Fires whenever an item is touched
         * @param {Ext.dataview.component.DataItem} item The item touched
         * @param {Number} index The index of the item touched
         * @param {Ext.event.Event} e The event object
         */
        itemtouchend(that: Ext.dataview.component.Container, item: Ext.dataview.component.DataItem, index: number, e: Ext.event.Event);

        /**
         * Fires whenever an item is moved
         * @param {Ext.dataview.component.DataItem} item The item moved
         * @param {Number} index The index of the item moved
         * @param {Ext.event.Event} e The event object
         */
        itemtouchmove(that: Ext.dataview.component.Container, item: Ext.dataview.component.DataItem, index: number, e: Ext.event.Event);

        /**
         * Fires whenever an item is touched
         * @param {Ext.dataview.component.DataItem} item The item touched
         * @param {Number} index The index of the item touched
         * @param {Ext.event.Event} e The event object
         */
        itemtouchstart(that: Ext.dataview.component.Container, item: Ext.dataview.component.DataItem, index: number, e: Ext.event.Event);
    }

    interface DataItemConfig extends Ext.ContainerConfig {
        baseCls?: any;

        /**
         * The dataMap allows you to map {@link #record} fields to specific configurations in this component.
         *
         * For example, lets say you have a 'text' configuration which, when applied, gets turned into an instance of an Ext.Component.
         * We want to update the {@link #html} of this component when the 'text' field of the record gets changed.
         * For example:
         *
         *      dataMap: {
         *          getText: {
         *              setHtml: 'text'
         *          }
         *      }
         *
         * In this example, it is simply a matter of setting the key of the object to be the getter of the config ('getText'), and then give that
         * property a value of an object, which then has 'setHtml' (the html setter) as the key, and 'text' (the field name) as the value.
         */
        dataMap?: any;

        defaultType?: any;

        /**
         * An additional CSS class to apply to items within the DataView.
         */
        itemCls?: string;

        items?: any;

        /**
         * The model instance of this DataItem. It is controlled by the Component DataView.
         */
        record?: Ext.data.Model;

        width?: any;
    }

    /**
     * A DataItem is a container for records inside of {@link Ext.dataview.DataView} with useComponents: true.
     * It ties together {@link Ext.data.Model records} to its contained Components. Consider the following example:
     *
     *      @example phone portrait preview
     *     // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! MODEL
     *
     *     Ext.define('TestModel', {
     *         extend: 'Ext.data.Model',
     *         config: {
     *             fields: [{
     *                 name: 'val1'
     *             }, {
     *                 name: 'val2'
     *             }]
     *         }
     *     });
     *
     *     // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! STORE
     *
     *     Ext.define('TestStore', {
     *         extend: 'Ext.data.Store',
     *         config: {
     *             data: [{
     *                 val1: 'A Button',
     *                 val2: 'with text'
     *             }, {
     *                 val1: 'The Button',
     *                 val2: 'more text'
     *             }, {
     *                 val1: 'My Button',
     *                 val2: 'My Text'
     *             }],
     *             model: 'TestModel',
     *             storeId: 'TestStore'
     *         }
     *     });
     *
     *     // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! DATA ITEM
     *
     *     Ext.define('MyDataItem', {
     *         extend: 'Ext.dataview.component.DataItem',
     *         alias: 'widget.mydataitem',
     *         config: {
     *             padding: 10,
     *             layout: {
     *                 type: 'hbox'
     *             },
     *             defaults: {
     *                 margin: 5
     *             },
     *             items: [{
     *                 xtype: 'button',
     *                 text: 'Val1'
     *             }, {
     *                 xtype: 'component',
     *                 flex: 1,
     *                 html: 'val2',
     *                 itemId: 'textCmp'
     *             }]
     *         },
     *         updateRecord: function(record) {
     *             var me = this;
     *
     *             me.down('button').setText(record.get('val1'));
     *             me.down('#textCmp').setHtml(record.get('val2'));
     *
     *             me.callParent(arguments);
     *         }
     *     });
     *
     *     // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! DATA VIEW
     *
     *     Ext.define('MyDataView', {
     *         extend: 'Ext.dataview.DataView',
     *         config: {
     *             defaultType: 'mydataitem',
     *             useComponents: true
     *         }
     *     });
     *
     *     // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! RUN
     *
     *     Ext.create('MyDataView', {
     *         fullscreen: true,
     *         store: Ext.create('TestStore')
     *     });
     *
     * Another way to accomplish this is via a {@link #dataMap dataMap} configuration.
     *
     * For example, lets say you have a 'text' configuration which, when applied, gets turned into an instance of an
     * Ext.Component. We want to update the {@link #html} of a sub-component when the 'text' field of the record gets
     * changed.
     *
     * As you can see below, it is simply a matter of setting the key of the object to be the getter of the config
     * (getText), and then give that property a value of an object, which then has 'setHtml' (the html setter) as the key,
     * and 'text' (the field name) as the value. You can continue this for a as many sub-components as you wish.
     *
     *     dataMap: {
     *         // When the record is updated, get the text configuration, and
     *         // call setHtml with the 'text' field of the record.
     *         getText: {
     *             setHtml: 'text'
     *         },
     *
     *         // When the record is updated, get the userName configuration, and
     *         // call setHtml with the 'from_user' field of the record.
     *         getUserName: {
     *             setHtml: 'from_user'
     *         },
     *
     *         // When the record is updated, get the avatar configuration, and
     *         // call 'setSrc' with the 'profile_image_url' field of the record.
     *         getAvatar: {
     *             setSrc: 'profile_image_url'
     *         }
     *     }
     */
    export class DataItem extends Ext.Container implements Ext.dataview.component.DataItemConfig {
        baseCls: string;

        /**
         * The dataMap allows you to map {@link #record} fields to specific configurations in this component.
         *
         * For example, lets say you have a 'text' configuration which, when applied, gets turned into an instance of an Ext.Component.
         * We want to update the {@link #html} of this component when the 'text' field of the record gets changed.
         * For example:
         *
         *      dataMap: {
         *          getText: {
         *              setHtml: 'text'
         *          }
         *      }
         *
         * In this example, it is simply a matter of setting the key of the object to be the getter of the config ('getText'), and then give that
         * property a value of an object, which then has 'setHtml' (the html setter) as the key, and 'text' (the field name) as the value.
         */
        dataMap: any;

        defaultType: any;

        /**
         * An additional CSS class to apply to items within the DataView.
         */
        itemCls: string;

        items: any[]|any;

        /**
         * The model instance of this DataItem. It is controlled by the Component DataView.
         */
        record: Ext.data.Model;

        width: number|string;

        constructor(config: Ext.ActionSheetConfig);

        getBaseCls();

        getDataMap();

        getDefaultType();

        getItemCls();

        getItems();

        getRecord();

        getWidth();

        setBaseCls();

        setDataMap();

        setDefaultType();

        setItemCls();

        setItems();

        setRecord();

        setWidth();
    }

    interface ListItemConfig extends Ext.dataview.component.DataItemConfig {
        baseCls?: any;

        dataMap?: any;

        items?: any;

        tpl?: any;
    }

    /**
     * A ListItem is a container for {@link Ext.dataview.List} with
     * useSimpleItems: false.
     *
     * ListItem configures and updates the {@link Ext.data.Model records} for
     * the sub-component items in a list.
     *
     * Overwrite the 'updateRecord()' method to set a sub-component's value.
     * the framework calls 'updateRecord()' whenever the data in the list updates.
     *
     * The 'updatedata' event fires after 'updateRecord()' runs.
     *
     * *Note*: Use of ListItem increases overhead since it generates more markup than
     * using the List class with useSimpleItems: true. This overhead is more
     * noticeable in Internet Explorer. If at all possible, use
     * {@link Ext.dataview.component.SimpleListItem} instead.
     *
     * The following example shows how to configure and update sub-component items
     * in a list:
     *
     *     Ext.define('Twitter.view.TweetListItem', {
     *         extend: 'Ext.dataview.component.ListItem',
     *         xtype : 'tweetlistitem',
     *         requires: [
     *             'Ext.Img'
     *         ],
     *         config: {
     *             userName: {
     *                 cls: 'username'
     *             },
     *             text: {
     *                 cls: 'text'
     *             },
     *             avatar: {
     *                 docked: 'left',
     *                 xtype : 'image',
     *                 cls   : 'avatar',
     *                 width: '48px',
     *                 height: '48px'
     *             },
     *             layout: {
     *                 type: 'vbox'
     *             }
     *         },
     *
     *         applyUserName: function(config) {
     *             return Ext.factory(config, Ext.Component, this.getUserName());
     *         },
     *
     *         updateUserName: function(newUserName) {
     *             if (newUserName) {
     *                 this.insert(0, newUserName);
     *             }
     *         },
     *
     *         applyText: function(config) {
     *             return Ext.factory(config, Twitter.view.TweetListItemText, this.getText());
     *         },
     *
     *         updateText: function(newText) {
     *             if (newText) {
     *                 this.add(newText);
     *             }
     *         },
     *
     *         applyAvatar: function(config) {
     *             return Ext.factory(config, Ext.Img, this.getAvatar());
     *         },
     *
     *         updateAvatar: function(newAvatar) {
     *             if (newAvatar) {
     *                 this.add(newAvatar);
     *             }
     *         },
     *
     *         updateRecord: function(record) {
     *             if (!record) {
     *                 return;
     *             }
     *
     *             this.getUserName().setHtml(record.get('username'));
     *             this.getText().setHtml(record.get('text'));
     *             this.getAvatar().setSrc(record.get('avatar_url'));
     *             this.callParent(arguments);
     *
     *         }
     *     });
     */
    export class ListItem extends Ext.dataview.component.DataItem implements Ext.dataview.component.ListItemConfig {
        baseCls: string;

        dataMap: any;

        items: any[]|any;

        tpl: string|Ext.Template|Ext.XTemplate;

        constructor(config: Ext.ActionSheetConfig);

        destroy();

        getBaseCls();

        getBody();

        getDataMap();

        getDisclosure();

        getHeader();

        getItems();

        getTpl();

        setBaseCls();

        setBody();

        setDataMap();

        setDisclosure();

        setHeader();

        setItems();

        setTpl();
    }

    interface SimpleListItemConfig extends Ext.ComponentConfig {
        baseCls?: any;

        /**
         * The model instance of this ListTplItem. It is controlled by the List.
         */
        record?: Ext.data.Model;
    }

    /**
     * A SimpleListItem is a simplified list item that is used by {@link Ext.dataview.List} when
     * useSimpleItems is set to true.  It supports disclosure icons and headers and generates the
     * slimmest markup possible to achieve this. It doesn't support container functionality like adding
     * or docking items. If you require those features you should have your list use
     * {@link Ext.dataview.component.ListItem} instances.
     */
    export class SimpleListItem extends Ext.Component implements Ext.dataview.component.SimpleListItemConfig {
        baseCls: string;

        /**
         * The model instance of this ListTplItem. It is controlled by the List.
         */
        record: Ext.data.Model;

        /**
         * Creates new Component.
         * @param {Object} config The standard configuration object.
         */
        constructor(config: Ext.ButtonConfig);

        destroy();

        getBaseCls();

        getDisclosure();

        getHeader();

        getRecord();

        protected initialize();

        setBaseCls();

        setDisclosure();

        setHeader();

        setRecord();
    }
}

declare module Ext.dataview.element {
    export class Container extends Ext.Component {
        /**
         * Creates new Component.
         * @param {Object} config The standard configuration object.
         */
        constructor(config: Ext.ButtonConfig);

        destroy();

        /**
         * Fires whenever an item is doubletapped
         * @param {Ext.dom.Element} item The item doubletapped
         * @param {Number} index The index of the item doubletapped
         * @param {Ext.event.Event} e The event object
         */
        itemdoubletap(that: Ext.dataview.element.Container, item: Ext.dom.Element, index: number, e: Ext.event.Event);

        /**
         * Fires whenever an item is singletapped
         * @param {Ext.dom.Element} item The item singletapped
         * @param {Number} index The index of the item singletapped
         * @param {Ext.event.Event} e The event object
         */
        itemsingletap(that: Ext.dataview.element.Container, item: Ext.dom.Element, index: number, e: Ext.event.Event);

        /**
         * Fires whenever an item is swiped
         * @param {Ext.dom.Element} item The item swiped
         * @param {Number} index The index of the item swiped
         * @param {Ext.event.Event} e The event object
         */
        itemswipe(that: Ext.dataview.element.Container, item: Ext.dom.Element, index: number, e: Ext.event.Event);

        /**
         * Fires whenever an item is tapped
         * @param {Ext.dom.Element} item The item tapped
         * @param {Number} index The index of the item tapped
         * @param {Ext.event.Event} e The event object
         */
        itemtap(that: Ext.dataview.element.Container, item: Ext.dom.Element, index: number, e: Ext.event.Event);

        /**
         * Fires whenever an item is tapped
         * @param {Ext.dom.Element} item The item tapped
         * @param {Number} index The index of the item tapped
         * @param {Ext.event.Event} e The event object
         */
        itemtaphold(that: Ext.dataview.element.Container, item: Ext.dom.Element, index: number, e: Ext.event.Event);

        /**
         * Fires whenever an item is touched
         * @param {Ext.dom.Element} item The item touched
         * @param {Number} index The index of the item touched
         * @param {Ext.event.Event} e The event object
         */
        itemtouchend(that: Ext.dataview.element.Container, item: Ext.dom.Element, index: number, e: Ext.event.Event);

        /**
         * Fires whenever an item is moved
         * @param {Ext.dom.Element} item The item moved
         * @param {Number} index The index of the item moved
         * @param {Ext.event.Event} e The event object
         */
        itemtouchmove(that: Ext.dataview.element.Container, item: Ext.dom.Element, index: number, e: Ext.event.Event);

        /**
         * Fires whenever an item is touched
         * @param {Ext.dom.Element} item The item touched
         * @param {Number} index The index of the item touched
         * @param {Ext.event.Event} e The event object
         */
        itemtouchstart(that: Ext.dataview.element.Container, item: Ext.dom.Element, index: number, e: Ext.event.Event);
    }

    export class List extends Ext.dataview.element.Container {
        /**
         * Creates new Component.
         * @param {Object} config The standard configuration object.
         */
        constructor(config: Ext.ButtonConfig);

        destroy();
    }
}

declare module Ext.device {
    /**
     * Provides access to the native Accelerometer API when running on a device. There are three implementations of this API:
     *
     * - [PhoneGap](http://docs.phonegap.com/en/2.6.0/cordova_accelerometer_accelerometer.md.html#Accelerometer)
     *
     * This class will automatically select the correct implementation depending on the device your application is running on.
     *
     * ## Examples
     *
     * Getting the current location:
     *
     *     Ext.device.Accelerometer.getCurrentAcceleration({
     *         success: function(acceleration) {
     *                      alert('Acceleration X: ' + acceleration.x + '\n' +
     *                      'Acceleration Y: ' + acceleration.y + '\n' +
     *                      'Acceleration Z: ' + acceleration.z + '\n' +
     *                      'Timestamp: '      + acceleration.timestamp + '\n');
     *          },
     *         failure: function() {
     *             console.log('something went wrong!');
     *         }
     *     });
     *
     * Watching the current acceleration:
     *
     *     Ext.device.Accelerometer.watchAcceleration({
     *         frequency: 500, // Update every 1/2 second
     *         callback: function(acceleration) {
     *                      console.log('Acceleration X: ' + acceleration.x + '\n' +
     *                      'Acceleration Y: ' + acceleration.y + '\n' +
     *                      'Acceleration Z: ' + acceleration.z + '\n' +
     *                      'Timestamp: '      + acceleration.timestamp + '\n');
     *          },
     *         failure: function() {
     *             console.log('something went wrong!');
     *         }
     *     });
     *
     * @mixins Ext.device.accelerometer.Abstract
     */
    export class Accelerometer {
    }

    /**
     * Allows you to use Google Analytics within your Cordova application.
     *
     * For setup information, please read the [plugin documentation](https://github.com/phonegap/phonegap-facebook-plugin).
     *
     * @mixins Ext.device.analytics.Abstract
     */
    export class Analytics {
    }

    /**
     * @mixins Ext.device.browser.Abstract
     */
    export class Browser {
    }

    /**
     * This class allows you to use native APIs to take photos using the device camera.
     *
     * When this singleton is instantiated, it will automatically select the correct implementation depending on the
     * current device:
     *
     * - Sencha Packager
     * - Cordova
     * - Simulator
     *
     * Both the Sencha Packager and Cordova implementations will use the native camera functionality to take or select
     * a photo. The Simulator implementation will simply return fake images.
     *
     * ## Example
     *
     * You can use the {@link Ext.device.Camera#capture} function to take a photo:
     *
     *     Ext.device.Camera.capture({
     *         success: function(image) {
     *             imageView.setSrc(image);
     *         },
     *         quality: 75,
     *         width: 200,
     *         height: 200,
     *         destination: 'data'
     *     });
     *
     * See the documentation for {@link Ext.device.Camera#capture} all available configurations.
     *
     * @mixins Ext.device.camera.Abstract
     */
    export class Camera {
    }

    /**
     * Provides access to the audio and video capture capabilities of the device.
     *
     * @mixins Ext.device.capture.Abstract
     */
    export class Capture {
    }

    export class Communicator {
    }

    /**
     * Provides access to the native Compass API when running on a device. There are three implementations of this API:
     *
     * - [PhoneGap](http://docs.phonegap.com/en/2.6.0/cordova_compass_compass.md.html#Compass)
     *
     * This class will automatically select the correct implementation depending on the device your application is running on.
     *
     * ## Examples
     *
     * Getting the current location:
     *
     *     Ext.device.Compass.getCurrentHeading({
     *         success: function(heading) {
     *                      alert('Heading: ' + heading.magneticHeading);
     *          },
     *         failure: function() {
     *             console.log('something went wrong!');
     *         }
     *     });
     *
     * Watching the current compass:
     *
     *     Ext.device.Compass.watchHeading({
     *         frequency: 500, // Update every 1/2 second
     *         callback: function(heading) {
     *                      console.log('Heading: ' + heading.magneticHeading);
     *          },
     *         failure: function() {
     *             console.log('something went wrong!');
     *         }
     *     });
     *
     * @mixins Ext.device.compass.Abstract
     */
    export class Compass {
    }

    /**
     * This class is used to check if the current device is currently online or not. It has three different implementations:
     *
     * - Sencha Packager
     * - Cordova
     * - Simulator
     *
     * Both the Sencha Packager and Cordova implementations will use the native functionality to determine if the current
     * device is online. The Simulator version will simply use 'navigator.onLine'.
     *
     * When this singleton ({@link Ext.device.Connection}) is instantiated, it will automatically decide which version to
     * use based on the current platform.
     *
     * ## Examples
     *
     * Determining if the current device is online:
     *
     *     alert(Ext.device.Connection.isOnline());
     *
     * Checking the type of connection the device has:
     *
     *     alert('Your connection type is: ' + Ext.device.Connection.getType());
     *
     * The available connection types are:
     *
     * - {@link Ext.device.Connection#UNKNOWN UNKNOWN} - Unknown connection
     * - {@link Ext.device.Connection#ETHERNET ETHERNET} - Ethernet connection
     * - {@link Ext.device.Connection#WIFI WIFI} - WiFi connection
     * - {@link Ext.device.Connection#CELL_2G CELL_2G} - Cell 2G connection
     * - {@link Ext.device.Connection#CELL_3G CELL_3G} - Cell 3G connection
     * - {@link Ext.device.Connection#CELL_4G CELL_4G} - Cell 4G connection
     * - {@link Ext.device.Connection#NONE NONE} - No network connection
     *
     * @mixins Ext.device.connection.Abstract
     */
    export class Connection {
        static onlinechange();
    }

    /**
     * This device API allows you to access a users contacts using a {@link Ext.data.Store}. This allows you to search, filter
     * and sort through all the contacts using its methods.
     *
     * To use this API, all you need to do is require this class ('Ext.device.Contacts') and then use 'Ext.device.Contacts.getContacts()'
     * to retrieve an array of contacts.
     *
     * **Please note that getThumbnail and getLocalizedLabel are *only* for the Sencha Native Packager.**
     * **Both Cordova/PhoneGap and Sencha Native Packager can access the find method though properties of returned contacts will differ.**
     *
     * # Example
     *
     *     Ext.application({
     *         name: 'Sencha',
     *         requires: 'Ext.device.Contacts',
     *
     *         launch: function() {
     *             Ext.Viewport.add({
     *                 xtype: 'list',
     *                 itemTpl: '{First} {Last}',
     *                 store: {
     *                     fields: ['First', 'Last'],
     *                     data: Ext.device.Contacts.getContacts()
     *                 }
     *             });
     *         }
     *     });
     *
     * @mixins Ext.device.contacts.Abstract
     * @mixins Ext.device.contacts.Sencha
     * @mixins Ext.device.contacts.Cordova
     */
    export class Contacts {
    }

    /**
     * Provides a cross device way to get information about the device your application is running on. There are 3 different implementations:
     *
     * - Sencha Packager
     * - [Cordova](http://cordova.apache.org/docs/en/2.5.0/cordova_device_device.md.html#Device)
     * - Simulator
     *
     * ## Examples
     *
     * #### Device Information
     *
     * Getting the device information:
     *
     *     Ext.application({
     *         name: 'Sencha',
     *
     *         // Remember that the Ext.device.Device class *must* be required
     *         requires: ['Ext.device.Device'],
     *
     *         launch: function() {
     *             alert([
     *                 'Device name: ' + Ext.device.Device.name,
     *                 'Device platform: ' + Ext.device.Device.platform,
     *                 'Device UUID: ' + Ext.device.Device.uuid
     *             ].join('\n'));
     *         }
     *     });
     *
     * ### Custom Scheme URL
     *
     * Using custom scheme URL to application your application from other applications:
     *
     *     Ext.application({
     *         name: 'Sencha',
     *         requires: ['Ext.device.Device'],
     *         launch: function() {
     *             if (Ext.device.Device.scheme) {
     *                 // the application was opened via another application. Do something:
     *                 alert('Applicaton pened via another application: ' + Ext.device.Device.scheme.url);
     *             }
     *
     *             // Listen for future changes
     *             Ext.device.Device.on('schemeupdate', function(device, scheme) {
     *                 // the application was launched, closed, and then launched another from another application
     *                 // this means onReady wont be called again ('cause the application is already running in the
     *                 // background) - but this event will be fired
     *                 alert('Applicated reopened via another application: ' + scheme.url);
     *             }, this);
     *         }
     *     });
     *
     * Of course, you must add the custom scheme URL you would like to use when packaging your application.
     * You can do this by setting the 'URLScheme' property inside your 'package.json' file (Sencha Native Packager configuration file):
     *
     *     {
     *         ...
     *         "URLScheme": "sencha",
     *         ...
     *     }
     *
     * You can change the available URL scheme.
     *
     * You can then test it by packaging and installing the application onto a device/iOS Simulator, opening Safari and typing: 'sencha:testing'.
     * The application will launch and it will 'alert' the URL you specified.
     *
     * **PLEASE NOTE: This currently only works with the Sencha Native Packager. If you attempt to listen to this event when packaged with
     * PhoneGap or simply in the browser, it will not function.**
     *
     * @mixins Ext.device.device.Abstract
     */
    export class Device {
    }

    /**
     * Provides an API to navigate file system hierarchies.
     *
     * @mixins Ext.device.filesystem.Sencha
     */
    export class FileSystem {
    }

    /**
     * Provides access to the native Geolocation API when running on a device. There are three implementations of this API:
     *
     * - Sencha Packager
     * - [PhoneGap](http://docs.phonegap.com/en/1.4.1/phonegap_device_device.md.html)
     * - Browser
     *
     * This class will automatically select the correct implementation depending on the device your application is running on.
     *
     * ## Examples
     *
     * Getting the current location:
     *
     *     Ext.device.Geolocation.getCurrentPosition({
     *         success: function(position) {
     *             console.log(position.coords);
     *         },
     *         failure: function() {
     *             console.log('something went wrong!');
     *         }
     *     });
     *
     * Watching the current location:
     *
     *     Ext.device.Geolocation.watchPosition({
     *         frequency: 3000, // Update every 3 seconds
     *         callback: function(position) {
     *             console.log('Position updated!', position.coords);
     *         },
     *         failure: function() {
     *             console.log('something went wrong!');
     *         }
     *     });
     *
     * @mixins Ext.device.geolocation.Abstract
     */
    export class Geolocation {
    }

    /**
     * Provides access to the native Globalization API
     *
     * - [PhoneGap](http://docs.phonegap.com/en/2.6.0/cordova_globalization_globalization.md.html)
     *
     * Class currently only works with Cordova and does not have a simulated HTML counter part.
     * Please see notes on Cordova Docs for more information.
     *
     * http://docs.phonegap.com/en/2.6.0/cordova_globalization_globalization.md.html
     */
    export class Globalization {
    }

    /**
     * @mixins Ext.device.media.Abstract
     */
    export class Media {
    }

    /**
     * Provides a cross device way to show notifications. There are three different implementations:
     *
     * - Sencha Packager
     * - Cordova
     * - Simulator
     *
     * When this singleton is instantiated, it will automatically use the correct implementation depending on the current device.
     *
     * Both the Sencha Packager and Cordova versions will use the native implementations to display the notification. The
     * Simulator implementation will use {@link Ext.MessageBox} for {@link #show} and a simply animation when you call {@link #vibrate}.
     *
     * ## Examples
     *
     * To show a simple notification:
     *
     *     Ext.device.Notification.show({
     *         title: 'Verification',
     *         message: 'Is your email address: test@sencha.com',
     *         buttons: Ext.MessageBox.OKCANCEL,
     *         callback: function(button) {
     *             if (button === "ok") {
     *                 console.log('Verified');
     *             } else {
     *                 console.log('Nope');
     *             }
     *         }
     *     });
     *
     * To make the device vibrate:
     *
     *     Ext.device.Notification.vibrate();
     *
     * @mixins Ext.device.notification.Abstract
     */
    export class Notification {
    }

    /**
     * This class provides you with a cross platform way of listening to when the the orientation changes on the
     * device your application is running on.
     *
     * The {@link Ext.device.Orientation#orientationchange orientationchange} event gets passes the 'alpha', 'beta' and
     * 'gamma' values. ** These properties only exist when packaging with the Sencha Native Packager. **
     *
     * You can find more information about these values and how to use them on the [W3C device orientation specification](http://dev.w3.org/geo/api/spec-source-orientation.html#deviceorientation).
     *
     * ## Example
     *
     * To listen to the device orientation, you can do the following:
     *
     *     Ext.device.Orientation.on({
     *         scope: this,
     *         orientationchange: function(e) {
     *             console.log('Alpha: ', e.alpha);
     *             console.log('Beta: ', e.beta);
     *             console.log('Gamma: ', e.gamma);
     *         }
     *     });
     *
     * @mixins Ext.device.orientation.Abstract
     */
    export class Orientation {
    }

    /**
     * Provides a way to send push notifications to a device.
     *
     * # Example
     *
     *     Ext.device.Push.register({
     *         type: Ext.device.Push.ALERT|Ext.device.Push.BADGE|Ext.device.Push.SOUND,
     *         success: function(token) {
     *             console.log('# Push notification registration successful:');
     *             console.log('    token: ' + token);
     *         },
     *         failure: function(error) {
     *             console.log('# Push notification registration unsuccessful:');
     *             console.log('     error: ' + error);
     *         },
     *         received: function(notifications) {
     *             console.log('# Push notification received:');
     *             console.log('    ' + JSON.stringify(notifications));
     *         }
     *     });
     *
     *
     * ## Sencha Cmd
     *
     * Currently only available on iOS for apps packaged with Sencha Cmd.
     *
     * ## Cordova / PhoneGap
     *
     * For apps packaged with Cordova or PhoneGap, Ext.device.Push currently supports iOS and
     * Android via the [PushPlugin](https://github.com/phonegap-build/PushPlugin).
     *
     * Be sure to include that plugin in your project; Ext.device.Push simply normalizes the
     * interface for using notifications in your application.
     *
     * @mixins Ext.device.push.Abstract
     */
    export class Push {
    }

    /**
     * Provides access to the native Splashscreen API
     *
     * - [PhoneGap](http://docs.phonegap.com/en/2.6.0/cordova_splashscreen_splashscreen.md.html#Splashscreen)
     *
     * Class currently only works with Cordova and does not have a simulated HTML counter part.
     * Please see notes on Cordova Docs for proper Native project code changes that
     * will need to be made to use this plugin.
     *
     * http://docs.phonegap.com/en/2.6.0/cordova_splashscreen_splashscreen.md.html#Splashscreen
     */
    export class Splashscreen {
    }

    export class Storage {
    }

    /**
     * Allows you to interact with the Twitter API on iOS devices from within your Cordova application.
     *
     * For setup information, please read the [plugin guide](https://github.com/phonegap/phonegap-plugins/tree/master/iOS/Twitter).
     *
     * @mixins Ext.device.twitter.Abstract
     */
    export class Twitter {
    }
}

declare module Ext.device.accelerometer {
    interface AbstractConfig {
        /**
         * The default frequency to get the current acceleration when using {@link Ext.device.Accelerometer#watchAcceleration}.
         */
        frequency?: number;
    }

    export class Abstract extends Ext.Base implements Ext.device.accelerometer.AbstractConfig {
        /**
         * The default frequency to get the current acceleration when using {@link Ext.device.Accelerometer#watchAcceleration}.
         */
        frequency: number;

        getFrequency();

        setFrequency();
    }

    export class Cordova extends Ext.device.accelerometer.Abstract {
    }

    export class Simulator extends Ext.device.accelerometer.Abstract {
    }
}

declare module Ext.device.analytics {
    export class Abstract extends Ext.Base {
        getAccountID();

        /**
         * Registers yur Google Analytics account.
         *
         * @param {String} accountID Your Google Analytics account ID
         */
        registerAccount(accountID: string);

        setAccountID();

        /**
         * Track an event in your application.
         *
         * More information here: http://code.google.com/apis/analytics/docs/tracking/eventTrackerGuide.html
         *
         *
         * @param {String} config.category The name you supply for the group of objects you want to track
         *
         * @param {String} config.action A string that is uniquely paired with each category, and commonly
         * used to define the type of user interaction for the web object.
         *
         * @param {String} config.label An optional string to provide additional dimensions to the event data.
         *
         * @param {String} config.value An integer that you can use to provide numerical data about the user event
         *
         * @param {Boolean} config.nonInteraction A boolean that when set to true, indicates that the event hit will
         * not be used in bounce-rate calculation.
         */
        trackEvent(config: any, config_category: string, config_action: string, config_label: string, config_value: string, config_nonInteraction: boolean);

        /**
         * Track an pageview in your application.
         *
         * @param {String} config.page The page you want to track (must start with a slash).
         */
        trackPageview(config_page: string);
    }

    export class Cordova extends Ext.device.analytics.Abstract {
    }
}

declare module Ext.device.browser {
    export class Abstract extends Ext.Base {
        /**
         * Used to close the browser, if one is opened.
         */
        close();

        /**
         * Used to open a new browser window.
         *
         * When used with Cordova, a new InAppBrowser window opens. With Cordova, you also have the ability
         * to listen when the window starts loading, is finished loading, fails to load, and when it is closed.
         * You can also use the {@link #close} method to close the window, if opened.
         *
         * The options to use when opening a new browser window.
         *
         * The URL to open.
         *
         * The listeners you want to add onto the window. Available events are:
         *
         * - 'loadstart' - when the window starts loading the URL
         * - 'loadstop' - when the window is finished loading the URL
         * - 'loaderror' - when the window encounters an error loading the URL
         * - 'close' - when the window is closed
         *
         * True to show the toolbar in the browser window.
         *
         * A string of options which are used when using Cordova. For a full list of options, visit the
         * [PhoneGap documention](http://docs.phonegap.com/en/2.6.0/cordova_inappbrowser_inappbrowser.md.html#window.open).
         */
        open(options: any, options_url: string, options_listeners: any, options_showToolbar: boolean, options_options: string);
    }

    export class Cordova extends Ext.device.browser.Abstract {
        close();
    }

    export class Simulator extends Ext.Base {
    }

    export class Window extends Ext.Evented {
        constructor(config: Ext.util.GeolocationConfig);
    }
}

declare module Ext.device.camera {
    export class Abstract extends Ext.Base {
        /**
         * Allows you to capture a photo.
         *
         * The options to use when taking a photo.
         *
         * The success callback which is called when the photo has been taken.
         *
         * The image which was just taken, either a base64 encoded string or a URI depending on which
         * option you chose (destination).
         *
         * The function which is called when something goes wrong.
         *
         * The scope in which to call the 'success' and 'failure' functions, if specified.
         *
         * The quality of the image which is returned in the callback. This should be a percentage.
         *
         * The source of where the image should be taken. Available options are:
         *
         * - **album** - prompts the user to choose an image from an album
         * - **camera** - prompts the user to take a new photo
         * - **library** - prompts the user to choose an image from the library
         *
         * The destination of the image which is returned. Available options are:
         *
         * - **data** - returns a base64 encoded string
         * - **file** - returns the file's URI
         *
         * The encoding of the returned image. Available options are:
         *
         * - **jpg**
         * - **png**
         *
         * The width of the image to return
         *
         * The height of the image to return
         */
        capture(options: any, options_success: Function, options_success_image: string, options_failure: Function, scope: any, options_quality: number, options_source: string, destination: string, encoding: string, width: number, height: number);
    }

    export class Cordova extends Ext.device.camera.Abstract {
    }

    export class Simulator extends Ext.device.camera.Abstract {
        constructor(config: any);

        getSamples();

        setSamples();
    }
}

declare module Ext.device.capture {
    export class Abstract extends Ext.Base {
        /**
         * Start the audio recorder application and return information about captured audio clip file(s).
         *
         *     @example
         *     Ext.device.Capture.captureAudio({
         *         limit: 2, // limit to 2 recordings
         *         maximumDuration: 10, // limit to 10 seconds per recording
         *         success: function(files) {
         *             for (var i = 0; i < files.length; i++) {
         *                 console.log('Captured audio path: ', files[i].fullPath);
         *             };
         *         },
         *         failure: function() {
         *             console.log('Something went wrong!');
         *         }
         *     });
         *
         * @param {Object} config The configuration object to be passed:
         *
         * @param {Number} config.limit The maximum number of recordings allowed (defaults to 1).
         *
         * @param {Number} config.maximumDuration The maximum duration of the capture, in seconds.
         *
         * @param {Number} config.duration The maximum duration of the capture, in seconds.
         *
         * @param {Function} config.success Called if the capture is successful.
         * @param {Array} config.success.files An array of objects containing information about the captured audio.
         *
         * @param {Function} config.failure Called if the capture is unsuccessful.
         */
        captureAudio(config: any, config_limit: number, config_maximumDuration: number, config_duration: number, config_success: Function, config_success_files: any[], config_failure: Function);

        /**
         * Start the video recorder application and return information about captured video clip file(s).
         *
         *     @example
         *     Ext.device.Capture.captureVideo({
         *         limit: 2, // limit to 2 recordings
         *         maximumDuration: 10, // limit to 10 seconds per recording
         *         success: function(files) {
         *             for (var i = 0; i < files.length; i++) {
         *                 console.log('Captured video path: ', files[i].fullPath);
         *             };
         *         },
         *         failure: function() {
         *             console.log('Something went wrong!');
         *         }
         *     });
         *
         * @param {Object} config The configuration object to be passed:
         *
         * @param {Number} config.limit The maximum number of recordings allowed (defaults to 1).
         *
         * @param {Number} config.maximumDuration The maximum duration of the capture, in seconds.
         *
         * @param {Number} config.duration The maximum duration of the capture, in seconds.
         *
         * @param {Function} config.success Called if the capture is successful.
         * @param {Array} config.success.files An array of objects containing information about the captured video.
         *
         * @param {Function} config.failure Called if the capture is unsuccessful.
         */
        captureVideo(config: any, config_limit: number, config_maximumDuration: number, config_duration: number, config_success: Function, config_success_files: any[], config_failure: Function);
    }

    export class Cordova extends Ext.Base {
    }
}

declare module Ext.device.communicator {
    export class Android extends Ext.device.communicator.Default {
    }

    /**
     * This object handles communication between the WebView and Sencha's native shell.
     * Currently it has two primary responsibilities:
     *
     * 1. Maintaining unique string ids for callback functions, together with their scope objects
     * 2. Serializing given object data into HTTP GET request parameters
     *
     * As an example, to capture a photo from the device's camera, we use 'Ext.device.Camera.capture()' like:
     *
     *     Ext.device.Camera.capture(
     *         function(dataUri){
     *             // Do something with the base64-encoded 'dataUri' string
     *         },
     *         function(errorMessage) {
     *
     *         },
     *         callbackScope,
     *         {
     *             quality: 75,
     *             width: 500,
     *             height: 500
     *         }
     *     );
     *
     * Internally, 'Ext.device.Communicator.send()' will then be invoked with the following argument:
     *
     *     Ext.device.Communicator.send({
     *         command: 'Camera#capture',
     *         callbacks: {
     *             onSuccess: function() {
     *                 // ...
     *             },
     *             onError: function() {
     *                 // ...
     *             }
     *         },
     *         scope: callbackScope,
     *         quality: 75,
     *         width: 500,
     *         height: 500
     *     });
     *
     * Which will then be transformed into a HTTP GET request, sent to native shell's local
     * HTTP server with the following parameters:
     *
     *     ?quality=75&width=500&height=500&command=Camera%23capture&onSuccess=3&onError=5
     *
     * Notice that 'onSuccess' and 'onError' have been converted into string ids ('3' and '5'
     * respectively) and maintained by 'Ext.device.Communicator'.
     *
     * Whenever the requested operation finishes, 'Ext.device.Communicator.invoke()' simply needs
     * to be executed from the native shell with the corresponding ids given before. For example:
     *
     *     Ext.device.Communicator.invoke('3', ['DATA_URI_OF_THE_CAPTURED_IMAGE_HERE']);
     *
     * will invoke the original 'onSuccess' callback under the given scope. ('callbackScope'), with
     * the first argument of 'DATA_URI_OF_THE_CAPTURED_IMAGE_HERE'
     *
     * Note that 'Ext.device.Communicator' maintains the uniqueness of each function callback and
     * its scope object. If subsequent calls to 'Ext.device.Communicator.send()' have the same
     * callback references, the same old ids will simply be reused, which guarantee the best possible
     * performance for a large amount of repetitive calls.
     */
    export class Default extends Ext.Base {
    }
}

declare module Ext.device.compass {
    interface AbstractConfig {
        /**
         * The default frequency to get the current heading when using {@link Ext.device.Compass#watchHeading}.
         */
        frequency?: number;
    }

    export class Abstract extends Ext.Base implements Ext.device.compass.AbstractConfig {
        /**
         * The default frequency to get the current heading when using {@link Ext.device.Compass#watchHeading}.
         */
        frequency: number;

        getFrequency();

        setFrequency();
    }

    export class Cordova extends Ext.device.compass.Abstract {
    }

    export class Simulator extends Ext.device.compass.Abstract {
    }
}

declare module Ext.device.connection {
    export class Abstract extends Ext.Evented {
        /**
         * Text label for a connection type.
         */
        CELL_2G: string;

        /**
         * Text label for a connection type.
         */
        CELL_3G: string;

        /**
         * Text label for a connection type.
         */
        CELL_4G: string;

        /**
         * Text label for a connection type.
         */
        ETHERNET: string;

        /**
         * Text label for a connection type.
         */
        NONE: string;

        /**
         * Text label for a connection type.
         */
        UNKNOWN: string;

        /**
         * Text label for a connection type.
         */
        WIFI: string;

        constructor(config: Ext.util.GeolocationConfig);

        getOnline();

        /**
         * Returns the current connection type.
         * @return {String} type
         */
        getType(): string;

        /**
         * True if the device is currently online
         * @return {Boolean} online
         */
        isOnline(): boolean;

        setOnline();

        setType();

        /**
         * Fires when the device goes offline
         */
        offline();

        /**
         * Fires when the device goes online
         */
        online();
    }

    export class Cordova extends Ext.device.connection.Abstract {
        constructor();

        getOnline();
    }

    export class Simulator extends Ext.device.connection.Abstract {
        constructor(config: Ext.util.GeolocationConfig);

        getOnline();
    }
}

declare module Ext.device.contacts {
    interface AbstractConfig {
        /**
         * True to include images when you get the contacts store. Please beware that this can be very slow.
         */
        includeImages?: boolean;
    }

    export class Abstract extends Ext.Base implements Ext.device.contacts.AbstractConfig {
        /**
         * True to include images when you get the contacts store. Please beware that this can be very slow.
         */
        includeImages: boolean;

        /**
         * Returns an Array of contact objects.
         * @return {Object[]} An array of contact objects.
         */
        getContacts(): any;

        getIncludeImages();

        /**
         * Returns localized, user readable label for a contact field (i.e. "Mobile", "Home")
         * **This method is for Sencha Native Packager only**
         *
         * @return {String} user readable string
         */
        getLocalizedLabel(): string;

        /**
         * Returns base64 encoded image thumbnail for a contact specified in config.id
         * **This method is for Sencha Native Packager only**
         *
         * @return {String} base64 string
         */
        getThumbnail(): string;

        setIncludeImages();
    }

    export class Cordova extends Ext.device.contacts.Abstract {
    }
}

declare module Ext.device.device {
    export class Abstract extends Ext.Base {
        /**
         * Returns the name of the current device. If the current device does not have a name (for example, in a browser), it will
         * default to 'not available'.
         *
         *     alert('Device name: ' + Ext.device.Device.name);
         */
        name: string;

        /**
         * The current platform the device is running on.
         *
         *     alert('Device platform: ' + Ext.device.Device.platform);
         */
        platform: string;

        scheme: any|boolean;

        /**
         * Returns a unique identifier for the current device. If the current device does not have a unique identifier (for example,
         * in a browser), it will default to 'anonymous'.
         *
         *     alert('Device UUID: ' + Ext.device.Device.uuid);
         */
        uuid: string;

        /**
         * Opens a specified URL. The URL can contain a custom URL Scheme for another app or service:
         *
         *     // Safari
         *     Ext.device.Device.openURL('http://sencha.com');
         *
         *     // Telephone
         *     Ext.device.Device.openURL('tel:6501231234');
         *
         *     // SMS with a default number
         *     Ext.device.Device.openURL('sms:+12345678901');
         *
         *     // Email client
         *     Ext.device.Device.openURL('mailto:rob@sencha.com');
         *
         * You can find a full list of available URL schemes here: [http://wiki.akosma.com/IPhone_URL_Schemes](http://wiki.akosma.com/IPhone_URL_Schemes).
         *
         * __Note:__ This currently only works with the Sencha Native Packager. Attempting to use this on PhoneGap, iOS Simulator
         * or the browser will simply result in the current window location changing.**
         *
         * If successful, this will close the application (as another one opens).
         *
         * @param {String} url The URL to open
         */
        openURL(url: string);

        /**
         * Event which is fired when your Sencha Native packaged application is opened from another application using a custom URL scheme.
         *
         * This event will only fire if the application was already open (in other words; 'onReady' was already fired). This means you should check
         * if {@link Ext.device.Device#scheme} is set in your Application 'launch'/'onReady' method, and perform any needed changes for that URL (if defined).
         * Then listen to this event for future changed.
         *
         * ## Example
         *
         *     Ext.application({
         *         name: 'Sencha',
         *         requires: ['Ext.device.Device'],
         *         launch: function() {
         *             if (Ext.device.Device.scheme) {
         *                 // the application was opened via another application. Do something:
         *                 console.log('Applicaton opened via another application: ' + Ext.device.Device.scheme.url);
         *             }
         *
         *             // Listen for future changes
         *             Ext.device.Device.on('schemeupdate', function(device, scheme) {
         *                 // the application was launched, closed, and then launched another from another application
         *                 // this means onReady wont be called again ('cause the application is already running in the
         *                 // background) - but this event will be fired
         *                 console.log('Applicated reopened via another application: ' + scheme.url);
         *             }, this);
         *         }
         *     });
         *
         * __Note:__ This currently only works with the Sencha Native Packager. If you attempt to listen to this event when packaged with
         * PhoneGap or simply in the browser, it will never fire.**
         *
         * @param {Ext.device.Device} this The instance of Ext.device.Device
         * @param {Object/Boolean} scheme The scheme information, if opened via another application
         * @param {String} scheme.url The URL that was opened, if this application was opened via another application. Example: 'sencha:'
         * @param {String} scheme.sourceApplication The source application that opened this application. Example: 'com.apple.safari'.
         */
        schemeupdate(that: Ext.device.Device, scheme: any|boolean, scheme_url: string, scheme_sourceApplication: string);
    }

    export class Cordova extends Ext.device.device.Abstract {
        /**
         * Returns the version of Cordova running on the device.
         *
         *     alert('Device cordova: ' + Ext.device.Device.cordova);
         */
        cordova: string;

        /**
         * Returns the device's model name.
         *
         *     alert('Device Model: ' + Ext.device.Device.model);
         */
        model: string;

        /**
         * Returns the operating system version.
         *
         *     alert('Device Version: ' + Ext.device.Device.version);
         */
        version: string;

        constructor();

        /**
         * This is an event that fires when the user presses the back button.
         */
        backbutton();

        /**
         * This event that fires when a Cordova application detects the percentage of battery
         * has reached the critical battery threshold.
         */
        batterycritical();

        /**
         * This event that fires when a Cordova application detects the percentage of battery
         * has reached the low battery threshold.
         */
        batterylow();

        /**
         * This event that fires when a Cordova application detects the percentage of battery
         * has changed by at least 1 percent.
         */
        batterystatus();

        /**
         * This is an event that fires when the user presses the end call button.
         */
        endcallbutton();

        /**
         * This is an event that fires when the user presses the menu button.
         */
        menubutton();

        /**
         * Fires when the application goes into the background
         */
        pause();

        /**
         * Fires when the application goes into the foreground
         */
        resume();

        /**
         * This is an event that fires when the user presses the search button.
         */
        searchbutton();

        /**
         * This is an event that fires when the user presses the start call button.
         */
        startcallbutton();

        /**
         * This is an event that fires when the user presses the volume down button.
         */
        volumedownbutton();

        /**
         * This is an event that fires when the user presses the volume up button.
         */
        volumeupbutton();
    }

    export class Simulator extends Ext.device.device.Abstract {
    }
}

declare module Ext.device.filesystem {
    export class Abstract extends Ext.Base {
        getFileSystemSize();

        getFileSystemType();

        getReaderType();

        getStringEncoding();

        setFileSystemSize();

        setFileSystemType();

        setReaderType();

        setStringEncoding();
    }

    export class Chrome extends Ext.device.filesystem.HTML5 {
    }

    /**
     * Cordova File APi Abstraction
     *
     * For more documentation see
     * http://docs.phonegap.com/en/2.7.0/cordova_file_file.md.html#File
     */
    export class Cordova extends Ext.device.filesystem.HTML5 {
        constructor();

        /**
         * Downloads a file from the server saving it into the Local File System
         *
         *
         * URL of file to download
         *
         * if true it will accept all security certificates. Defaults to false
         *
         * Header parameters (Auth, etc)
         *
         *     {
         *         headers: {
         *             "Authorization": "Basic dGVzdHVzZXJuYW1lOnRlc3RwYXNzd29yZA=="
         *         }
         *     }
         *
         * The function called when the File is downloaded successfully
         *
         * File Entry object of the downloaded file
         *
         * The function called when the File download fails
         *
         *
         * @return {FileTransfer}
         */
        download(config: any, config_source: string, config_trustAllHosts: boolean, config_options: any, config_success: Function, config_success_entry: Function, config_failure: Function, config_failure_error: any): any;

        /**
         * File creation options {create:true, exclusive:false}
         *
         * Indicates if the file should be created if it doesn't exist
         *
         * Used with the create option only indicates whether a creation causes an error if the file already exists
         *
         * The function called when the File's Metadata is written successfully
         *
         * The function called when the File request causes an error
         */
        readMetadata(config: any, config_options: any, config_options_create: boolean, config_options_exclusive: boolean, config_success: Function, config_failure: Function, config_failure_error: any);

        /**
         * Send a file to a server
         *
         *
         * URL of server to receive the file
         *
         * (Optional) If true it will accept all security certificates. Defaults to false
         *
         * Name of the form element. Defaults to "file"
         *
         * Name of the file on the server
         *
         * mime type of the data being uploaded. defaults to "image/jpeg"
         *
         * (Optional) set of key/value pairs to be passed along with the request
         *
         * Should the data be uploaded in a chunked streaming mode. defaults to true
         *
         * Map of header name => header values. Multiple values should be specified an array of values
         * var headers={'headerParam':'headerValue'};
         *
         * The function called when the File is uploaded successfully
         *
         *
         * The function called when the File upload fails
         *
         *
         * @return {FileTransfer}
         */
        upload(config: any, config_url: string, config_trustAllHosts: boolean, config_fileKey: string, config_fileName: string, config_mimeType: string, config_params: any, config_chunkMode: boolean, config_headers: any, config_success: Function, config_success_metadata: Function, config_failure: Function, config_failure_error: any): any;

        /**
         * Metadata to add to the file or directory
         *
         * File creation options {create:true, exclusive:false}
         *
         * Indicates if the file should be created if it doesn't exist
         *
         * Used with the create option only indicates whether a creation causes an error if the file already exists
         *
         * The function called when the File's Metadata is written successfully
         *
         * The function called when the File request causes an error
         */
        writeMetadata(config: any, config_metadata: any, config_options: any, config_options_create: boolean, config_options_exclusive: boolean, config_success: Function, config_failure: Function, config_failure_error: any);
    }

    /**
     * The DirectoryEntry class which is used to represent a directory on a file system.
     */
    export class DirectoryEntry extends Ext.device.filesystem.Entry {
        constructor(path: any, fileSystem: any);

        /**
         * Works the same way as {@link Ext.device.filesystem.DirectoryEntry#getFile},
         * but creates or looks up a directory.
         */
        getDirectory();

        /**
         * Requests a Directory from the Local File System
         *
         *
         * File creation options {create:true, exclusive:false}
         *
         * Indicates if the directory should be created if it doesn't exist
         *
         * Used with the create option only indicates whether a creation causes an error if the directory already exists
         *
         * The function called when the Directory is returned successfully
         *
         * DirectoryEntry Object
         *
         * The function called when the Directory request causes an error
         */
        getEntry(config: any, config_options: any, config_options_create: boolean, config_options_exclusive: boolean, config_success: Function, config_success_directory: Ext.device.filesystem.DirectoryEntry, config_failure: Function, config_failure_error: any);

        /**
         * Creates or looks up a file.
         *
         * The object which contains the following config options:
         *
         * @param {String} config.path This is required.
         * The absolute path or relative path from the entry to the file to create or select.
         *
         * @param {Object} config.options This is optional.
         * The object which contains the following options:
         *
         * @param {Boolean} config.options.create This is optional.
         * Indicates whether to create a file, if path does not exist.
         *
         * @param {Boolean} config.options.exclusive This is optional. Used with 'create', by itself has no effect.
         * Indicates that method should fail, if path already exists.
         *
         * @param {Function} config.success This is optional.
         * The callback to be called when the file has been successfully created or selected.
         *
         * The created or selected file.
         *
         * @param {Function} config.failure This is optional.
         * The callback to be called when an error occurred.
         *
         * The occurred error.
         *
         * The scope object
         */
        getFile(config: any, config_path: string, config_options: any, config_options_create: boolean, config_options_exclusive: boolean, config_success: Function, config_success_entry: Ext.device.filesystem.Entry, config_failure: Function, config_failure_error: any, config_scope: any);

        /**
         * Lists all the entries in the directory.
         *
         * The object which contains the following config options:
         *
         * @param {Function} config.success This is required.
         * The callback to be called when the entries has been successfully read.
         *
         * The array of entries of the directory.
         *
         * @param {Function} config.failure This is optional.
         * The callback to be called when an error occurred.
         *
         * The occurred error.
         *
         * The scope object
         */
        readEntries(config: any, config_success: Function, config_success_entries: Ext.device.filesystem.Entry, config_failure: Function, config_failure_error: any, config_scope: any);

        /**
         * Works the same way as {@link Ext.device.filesystem.Entry#remove},
         * but removes the directory and all of its contents, if any.
         */
        removeRecursively();
    }

    /**
     * The Entry class which is used to represent entries in a file system,
     * each of which may be a {@link Ext.device.filesystem.FileEntry} or a {@link Ext.device.filesystem.DirectoryEntry}.
     *
     * This is an abstract class.
     * @abstract
     */
    export class Entry extends Ext.Base {
        constructor(directory: any, path: any, fileSystem: any);

        /**
         * Works the same way as {@link Ext.device.filesystem.Entry#moveTo}, but copies the entry.
         */
        copyTo();

        /**
         * Returns the file system on which the entry resides.
         *
         * @return {Ext.device.filesystem.FileSystem}
         * The entry file system.
         */
        getFileSystem(): Ext.device.filesystem.FileSystem;

        /**
         * Returns the full absolute path from the root to the entry.
         *
         * @return {String}
         * The entry full path.
         */
        getFullPath(): string;

        /**
         * Looks up the parent directory containing the entry.
         *
         * The object which contains the following config options:
         *
         * @param {Function} config.success This is required.
         * The callback to be called when the parent directory has been successfully selected.
         *
         * The parent directory of the entry.
         *
         * @param {Function} config.failure This is optional.
         * The callback to be called when an error occurred.
         *
         * The occurred error.
         *
         * The scope object
         */
        getParent(config: any, config_success: Function, config_success_entry: Ext.device.filesystem.DirectoryEntry, config_failure: Function, config_failure_error: any, config_scope: any);

        /**
         * Returns whether the entry is a directory.
         *
         * @return {Boolean}
         * The entry is a directory.
         */
        isDirectory(): boolean;

        /**
         * Returns whether the entry is a file.
         *
         * @return {Boolean}
         * The entry is a file.
         */
        isFile(): boolean;

        /**
         * Moves the entry to a different location on the file system.
         *
         * The object which contains the following config options:
         *
         * @param {Ext.device.filesystem.DirectoryEntry} config.parent This is required.
         * The directory to which to move the entry.
         *
         * @param {String} config.newName This is optional.
         * The new name of the entry to move. Defaults to the entry's current name if unspecified.
         *
         * @param {Function} config.success This is optional.
         * The callback to be called when the entry has been successfully moved.
         *
         * The entry for the new location.
         *
         * @param {Function} config.failure This is optional.
         * The callback to be called when an error occurred.
         *
         * The occurred error.
         *
         * The scope object
         */
        moveTo(config: any, config_parent: Ext.device.filesystem.DirectoryEntry, config_newName: string, config_success: Function, config_success_entry: Ext.device.filesystem.Entry, config_failure: Function, config_failure_error: any, config_scope: any);

        /**
         * Removes the entry from the file system.
         *
         * The object which contains the following config options:
         *
         * @param {Boolean} config.recursively This is optional
         * Deletes a directory and all of its contents
         *
         * @param {Function} config.success This is optional.
         * The callback to be called when the entry has been successfully removed.
         *
         * @param {Function} config.failure This is optional.
         * The callback to be called when an error occurred.
         *
         * The occurred error.
         *
         * The scope object
         */
        remove(config: any, config_recursively: boolean, config_success: Function, config_failure: Function, config_failure_error: any, config_scope: any);
    }

    /**
     * The FileEntry class which is used to represent a file on a file system.
     */
    export class FileEntry extends Ext.device.filesystem.Entry {
        constructor(path: any, fileSystem: any);

        /**
         * Requests a File Handle from the Local File System
         *
         *
         * Filename optionally including path in string format '/tmp/debug.txt' or a File Object
         *
         * File creation options {create:true, exclusive:false}
         *
         * Indicates if the file should be created if it doesn't exist
         *
         * Used with the create option only indicates whether a creation causes an error if the file already exists
         *
         * The function called when the filesystem is returned successfully
         *
         *
         * The function called when the filesystem request causes and error
         */
        getEntry(config: any, config_file: string, config_options: any, config_options_create: boolean, config_options_exclusive: boolean, config_success: Function, config_success_entry: any, config_failure: Function, config_failure_error: any);

        /**
         * Returns the byte offset into the file at which the next read/write will occur.
         *
         * @return {Number}
         * The file offset.
         */
        getOffset(): number;

        /**
         * Reads the data from the file starting at the file offset.
         *
         * The object which contains the following config options:
         *
         * @param {Number} config.length This is optional.
         * The length of bytes to read from the file. Defaults to the file's current size if unspecified.
         *
         * Optional encoding type used only for reading as Text
         *
         * Type of reading to use options are "text" (default), "dataURL", "binaryString" and "arrayBuffer"
         *
         * Optional config params to be applied to a File Reader
         *
         *
         * @param {Function} config.success This is optional.
         * The callback to be called when the data has been successfully read.
         *
         * The read data.
         *
         * @param {Function} config.failure This is optional.
         * The callback to be called when an error occurred.
         *
         * The occurred error.
         *
         * The scope object
         */
        read(config: any, config_length: number, config_encoding: string, config_type: string, config_reader: any, config_reader_onloadstart: Function, config_reader_onloadprogress: Function, config_reader_onload: Function, config_reader_onabort: Function, config_reader_onerror: Function, config_reader_onloadend: Function, config_success: Function, config_success_data: any, config_failure: Function, config_failure_error: any, config_scope: any);

        /**
         * Sets the byte offset into the file at which the next read/write will occur.
         *
         * The object which contains the following config options:
         *
         * @param {Number} config.offset This is required.
         * The file offset to set. If negative, the offset back from the end of the file.
         *
         * @param {Function} config.success This is optional.
         * The callback to be called when the file offset has been successfully set.
         *
         * @param {Function} config.failure This is optional.
         * The callback to be called when an error occurred.
         *
         * The occurred error.
         *
         * The scope object
         */
        seek(config: any, config_offset: number, config_success: Function, config_failure: Function, config_failure_error: any, config_scope: any);

        /**
         * Truncates or extends the file to the specified size in bytes.
         * If the file is extended, the added bytes are null bytes.
         *
         * The object which contains the following config options:
         *
         * @param {Number} config.size This is required.
         * The new file size.
         *
         * @param {Function} config.success This is optional.
         * The callback to be called when the file size has been successfully changed.
         *
         * @param {Function} config.failure This is optional.
         * The callback to be called when an error occurred.
         *
         * The occurred error.
         *
         * The scope object
         */
        truncate(config: any, config_size: number, config_success: Function, config_failure: Function, config_failure_error: any, config_scope: any);

        /**
         * Writes the data to the file starting at the file offset.
         *
         * The object which contains the following config options:
         *
         * @param {Object} config.data This is required.
         * The data to write to the file.
         *
         * @param {Boolean} config.append This is optional.
         * Append to the end of the file
         *
         * Optional config params to be applied to a File Reader
         *
         *
         * @param {Function} config.success This is optional.
         * The callback to be called when the data has been successfully written.
         *
         * @param {Function} config.failure This is optional.
         * The callback to be called when an error occurred.
         *
         * The occurred error.
         *
         * The scope object
         */
        write(config: any, config_data: any, config_append: boolean, config_writer: any, config_writer_onwritestart: Function, config_writer_onprogress: Function, config_writer_onwrite: Function, config_writer_onabort: Function, config_writer_onerror: Function, config_writer_onwriteend: Function, config_success: Function, config_failure: Function, config_failure_error: any, config_scope: any);
    }

    /**
     * The FileSystem class which is used to represent a file system.
     */
    export class FileSystem extends Ext.Base {
        constructor(fs: any);

        /**
         * Returns a {@link Ext.device.filesystem.DirectoryEntry} instance for the root of the file system.
         *
         * @return {Ext.device.filesystem.DirectoryEntry}
         * The file system root directory.
         */
        getRoot(): Ext.device.filesystem.DirectoryEntry;
    }

    export class HTML5 extends Ext.device.filesystem.Abstract {
        /**
         * Requests a {@link Ext.device.filesystem.FileSystem} instance.
         *
         *      var me = this;
         *      var fs = Ext.create("Ext.device.FileSystem", {});
         *      fs.requestFileSystem({
         *          type: window.PERSISTENT,
         *          size: 1024 * 1024,
         *          success: function(fileSystem) {
         *              me.fs = fileSystem;
         *          },
         *          failure: function(err) {
         *              console.log("FileSystem Failure: " + err.code);
         *          }
         *      });
         *
         * The object which contains the following config options:
         *
         * window.TEMPORARY (0) or window.PERSISTENT (1)
         *
         * Storage space, in Bytes, needed by the application
         *
         * @param {Function} config.success This is required.
         * The callback to be called when the file system has been successfully created.
         *
         * The created file system.
         *
         * @param {Function} config.failure This is optional.
         * The callback to be called when an error occurred.
         *
         * The occurred error.
         *
         * The scope object
         */
        requestFileSystem(config: any, config_type: number, config_size: number, config_success: Function, config_success_fileSystem: Ext.device.filesystem.FileSystem, config_failure: Function, config_failure_error: any, config_scope: any);
    }

    export class Simulator extends Ext.device.filesystem.HTML5 {
    }
}

declare module Ext.device.geolocation {
    interface AbstractConfig {
        /**
         * True to allow high accuracy when getting the current position.
         */
        allowHighAccuracy?: boolean;

        /**
         * The default frequency to get the current position when using {@link Ext.device.Geolocation#watchPosition}.
         */
        frequency?: number;

        /**
         * This option indicates that the application is willing to accept cached location information whose age
         * is no greater than the specified time in milliseconds. If maximumAge is set to 0, an attempt to retrieve
         * new location information is made immediately.
         */
        maximumAge?: number;

        /**
         * The maximum number of milliseconds allowed to elapse between a location update operation.
         */
        timeout?: number;
    }

    export class Abstract extends Ext.Base implements Ext.device.geolocation.AbstractConfig {
        /**
         * True to allow high accuracy when getting the current position.
         */
        allowHighAccuracy: boolean;

        /**
         * The default frequency to get the current position when using {@link Ext.device.Geolocation#watchPosition}.
         */
        frequency: number;

        /**
         * This option indicates that the application is willing to accept cached location information whose age
         * is no greater than the specified time in milliseconds. If maximumAge is set to 0, an attempt to retrieve
         * new location information is made immediately.
         */
        maximumAge: number;

        /**
         * The maximum number of milliseconds allowed to elapse between a location update operation.
         */
        timeout: number;

        /**
         * If you are currently watching for the current position, this will stop that task.
         */
        clearWatch();

        getAllowHighAccuracy();

        /**
         * Attempts to get the current position of this device.
         *
         *     Ext.device.Geolocation.getCurrentPosition({
         *         success: function(position) {
         *             console.log(position);
         *         },
         *         failure: function() {
         *             Ext.Msg.alert('Geolocation', 'Something went wrong!');
         *         }
         *     });
         *
         * *Note:* If you want to watch the current position, you could use {@link Ext.device.Geolocation#watchPosition} instead.
         *
         * @param {Object} config An object which contains the following config options:
         *
         * The function to call when the location of the current device has been received.
         *
         *
         * The function that is called when something goes wrong.
         *
         * The scope of the 'success' and 'failure' functions.
         *
         * The maximum age of a cached location. If you do not enter a value for this, the value of {@link #maximumAge}
         * will be used.
         *
         * The timeout for this request. If you do not specify a value, it will default to {@link #timeout}.
         *
         * True to enable allow accuracy detection of the location of the current device. If you do not specify a value, it will
         * default to {@link #allowHighAccuracy}.
         */
        getCurrentPosition(config: Ext.device.geolocation.AbstractConfig, config_success: Function, config_success_position: any, config_failure: Function, config_scope: any, config_maximumAge: number, config_timeout: number, config_allowHighAccuracy: boolean);

        getFrequency();

        getMaximumAge();

        getTimeout();

        setAllowHighAccuracy();

        setFrequency();

        setMaximumAge();

        setTimeout();

        /**
         * Watches for the current position and calls the callback when successful depending on the specified {@link #frequency}.
         *
         *     Ext.device.Geolocation.watchPosition({
         *         callback: function(position) {
         *             console.log(position);
         *         },
         *         failure: function() {
         *             Ext.Msg.alert('Geolocation', 'Something went wrong!');
         *         }
         *     });
         *
         * @param {Object} config An object which contains the following config options:
         *
         * The function to be called when the position has been updated.
         *
         * The function that is called when something goes wrong.
         *
         * The scope of the 'success' and 'failure' functions.
         *
         * The frequency in which to call the supplied callback. Defaults to {@link #frequency} if you do not specify a value.
         *
         * True to enable allow accuracy detection of the location of the current device. If you do not specify a value, it will
         * default to {@link #allowHighAccuracy}.
         */
        watchPosition(config: Ext.device.geolocation.AbstractConfig, config_callback: Function, config_failure: Function, config_scope: any, config_frequency: boolean, config_allowHighAccuracy: boolean);
    }

    export class Cordova extends Ext.device.geolocation.Abstract {
        clearWatch();
    }

    export class Simulator extends Ext.device.geolocation.Abstract {
        clearWatch();
    }
}

declare module Ext.device.globalization {
    export class Abstract extends Ext.Base {
        getCurrencyCode();

        getDateType();

        getFormatLength();

        getItems();

        getNumberType();

        getSelector();

        setCurrencyCode();

        setDateType();

        setFormatLength();

        setItems();

        setNumberType();

        setSelector();
    }

    export class Cordova extends Ext.device.globalization.Abstract {
    }

    export class Simulator extends Ext.device.globalization.Abstract {
    }
}

declare module Ext.device.media {
    export class Abstract extends Ext.Base {
        getSrc();

        setSrc();
    }

    export class Cordova extends Ext.device.media.Abstract {
        /**
         * A URI containing the audio content.
         */
        src: string;
    }
}

declare module Ext.device.notification {
    export class Abstract extends Ext.Base {
        /**
         * A simple way to show a notification.
         *
         *     Ext.device.Notification.show({
         *        title: 'Verification',
         *        message: 'Is your email address is: test@sencha.com',
         *        buttons: Ext.MessageBox.OKCANCEL,
         *        callback: function(button) {
         *            if (button == "ok") {
         *                console.log('Verified');
         *            } else {
         *                console.log('Nope.');
         *            }
         *        }
         *     });
         *
         * @param {Object} config An object which contains the following config options:
         *
         * @param {String} config.title The title of the notification
         *
         * @param {String} config.message The message to be displayed on the notification
         *
         * @param {String/String[]} [config.buttons="OK"]
         * The buttons to be displayed on the notification. It can be a string, which is the title of the button, or an array of multiple strings.
         * Please not that you should not use more than 2 buttons, as they may not be displayed correct on all devices.
         *
         * A callback function which is called when the notification is dismissed by clicking on the configured buttons.
         * @param {String} config.callback.buttonId The id of the button pressed, one of: 'ok', 'yes', 'no', 'cancel'.
         *
         * @param {Object} config.scope The scope of the callback function
         */
        show(config: any, config_title: string, config_message: string, config_buttons?: string, config_callback?: Function, config_callback_buttonId?: string, config_scope?: any);

        /**
         * Vibrates the device.
         */
        vibrate();
    }

    export class Cordova extends Ext.device.notification.Abstract {
    }

    export class Simulator extends Ext.device.notification.Abstract {
        vibrate();
    }
}

declare module Ext.device.orientation {
    export class Abstract extends Ext.Base {
        /**
         * Fires when the orientation has been changed on this device.
         *
         *     Ext.device.Orientation.on({
         *         scope: this,
         *         orientationchange: function(e) {
         *             console.log('Alpha: ', e.alpha);
         *             console.log('Beta: ', e.beta);
         *             console.log('Gamma: ', e.gamma);
         *         }
         *     });
         *
         * @param {Object} event The event object
         * @param {Object} event.alpha The alpha value of the orientation event
         * @param {Object} event.beta The beta value of the orientation event
         * @param {Object} event.gamma The gamma value of the orientation event
         */
        orientationchange(event: any, event_alpha: any, event_beta: any, event_gamma: any);
    }

    /**
     * Provides the HTML5 implementation for the orientation API.
     */
    export class HTML5 extends Ext.device.orientation.Abstract {
        constructor();
    }
}

declare module Ext.device.push {
    export class Abstract extends Ext.Base {
        /**
         * Notification type: alert.
         */
        ALERT: any;

        /**
         * Notification type: badge.
         */
        BADGE: any;

        /**
         * Notification type: sound.
         */
        SOUND: any;

        /**
         * Registers a push notification.
         *
         *     Ext.device.Push.register({
         *         type: Ext.device.Push.ALERT|Ext.device.Push.BADGE|Ext.device.Push.SOUND,
         *         success: function(token) {
         *             console.log('# Push notification registration successful:');
         *             console.log('    token: ' + token);
         *         },
         *         failure: function(error) {
         *             console.log('# Push notification registration unsuccessful:');
         *             console.log('     error: ' + error);
         *         },
         *         received: function(notifications) {
         *             console.log('# Push notification received:');
         *             console.log('    ' + JSON.stringify(notifications));
         *         }
         *     });
         *
         * The configuration for to pass when registering this push notification service.
         *
         * The type(s) of notifications to enable. Available options are:
         *
         *   - {@link Ext.device.Push#ALERT}
         *   - {@link Ext.device.Push#BADGE}
         *   - {@link Ext.device.Push#SOUND}
         *
         * **Usage**
         *
         * Enable alerts and badges:
         *
         *     Ext.device.Push.register({
         *         type: Ext.device.Push.ALERT|Ext.device.Push.BADGE
         *         // ...
         *     });
         *
         * Enable alerts, badges and sounds:
         *
         *     Ext.device.Push.register({
         *         type: Ext.device.Push.ALERT|Ext.device.Push.BADGE|Ext.device.Push.SOUND
         *         // ...
         *     });
         *
         * Enable only sounds:
         *
         *     Ext.device.Push.register({
         *         type: Ext.device.Push.SOUND
         *         // ...
         *     });
         *
         * The callback to be called when registration is complete.
         *
         * A unique token for this push notification service.
         *
         * The callback to be called when registration fails.
         *
         * The error message.
         *
         * The callback to be called when a push notification is received on this device.
         *
         * The notifications that have been received.
         */
        register(config: any, config_type: number, config_success: Function, config_success_token: string, config_failure: Function, config_failure_error: string, config_received: Function, config_received_notifications: any);
    }

    /**
     * Interfaces with Cordova PushPlugin: https://github.com/phonegap-build/PushPlugin
     */
    export class Cordova extends Ext.device.push.Abstract {
    }
}

declare module Ext.device.splashscreen {
    export class Abstract extends Ext.Base {
    }

    export class Cordova extends Ext.device.splashscreen.Abstract {
    }

    export class Simulator extends Ext.device.splashscreen.Abstract {
    }
}

declare module Ext.device.storage {
    export class Abstract extends Ext.Base {
        getDatabaseDisplayName();

        getDatabaseName();

        getDatabaseSize();

        getDatabaseVersion();

        setDatabaseDisplayName();

        setDatabaseName();

        setDatabaseSize();

        setDatabaseVersion();
    }

    export class Cordova extends Ext.device.storage.HTML5.HTML5 {
    }

    export class Simulator extends Ext.device.storage.HTML5.HTML5 {
    }
}

declare module Ext.device.storage.HTML5 {
    export class Database extends Ext.Base {
        constructor(config: any);

        /**
         * @param {String/String[]/Object/Object[]/SQLStatement/SQLStatement[]} sql SQL Command to run with optional arguments and callbacks
         * @param {Function} success callback for successful transaction
         * @param {Function} failure callback for failed transaction
         */
        transaction(sql: string|any, success: Function, failure: Function);
    }

    export class HTML5 extends Ext.device.storage.Abstract {
    }

    export class SQLStatement extends Ext.Base {
        constructor(config: any);
    }
}

declare module Ext.device.twitter {
    export class Abstract extends Ext.Base {
        /**
         * Pops up a Twitter compose sheet view with your specified tweet.
         *
         * @param {Object} config An object which contains the following config options:
         *
         * @param {String} config.tweet The default tweet text to add to the compose window.
         *
         * @param {String} config.url An optional URL to attatch to the Tweet.
         *
         * @param {String} config.image An optional image URL to attatch to the Tweet.
         *
         * @param {Function} config.success The callback when the Tweet is successfully posted.
         *
         * @param {Function} config.failure The callback when the Tweet is unsuccessfully posted.
         */
        compose(config: any, config_tweet: string, config_url: string, config_image: string, config_success: Function, config_failure: Function);

        /**
         * Gets Tweets from Twitter Mentions
         *
         * @param {Object} config An object which contains the following config options:
         *
         * @param {Function} config.success callback
         * @param {Object[]} config.success.response Tweet objects, see [Twitter Mentions Doc]
         *
         * @param {Function} config.failure callback
         * @param {String} config.failure.error reason for failure
         *
         * [Twitter Timeline Doc]: https://dev.twitter.com/docs/api/1/get/statuses/public_timeline
         */
        getMentions(config: any, config_success: Function, config_success_response: any, config_failure: Function, config_failure_error: string);

        /**
         * Gets Tweets from Twitter Timeline
         *
         * @param {Object} config An object which contains the following config options:
         *
         * @param {Function} config.success callback
         * @param {Object[]} config.success.response Tweet objects, see [Twitter Timeline Doc]
         *
         * @param {Function} config.failure callback
         * @param {String} config.failure.error reason for failure
         *
         * [Twitter Timeline Doc]: https://dev.twitter.com/docs/api/1/get/statuses/public_timeline
         */
        getPublicTimeline(config: any, config_success: Function, config_success_response: any, config_failure: Function, config_failure_error: string);

        /**
         * Gets a specific Twitter user info
         *
         * @param {Object} config An object which contains the following config options:
         *
         * @param {String} config.url of [Twitter API Endpoint]
         *
         * @param {Object} config.params key-value map, matching [Twitter API Endpoint]
         *
         * @param {Object} config.options (optional) other options for the HTTP request
         * @param {String} config.options.requestMethod HTTP Request type, ex: "POST"
         *
         * @param {Function} config.success callback
         * @param {Object[]} config.success.response objects returned from Twitter API (Tweets, Users,...)
         *
         * @param {Function} config.failure callback
         * @param {String} config.failure.error reason for failure
         *
         * [Twitter API Endpoint]: https://dev.twitter.com/docs/api
         */
        getTwitterRequest(config: any, config_url: string, config_params: any, config_options: any, config_options_requestMethod: string, config_success: Function, config_success_response: any, config_failure: Function, config_failure_error: string);

        /**
         * Gets a specific Twitter user info
         *
         * @param {Object} config An object which contains the following config options:
         *
         * @param {Function} config.success callback
         * @param {Object[]} config.success.response The JSON response form twitter
         *
         * @param {Function} config.failure callback
         * @param {String} config.failure.error reason for failure
         */
        getTwitterUsername(config: any, config_success: Function, config_success_response: any, config_failure: Function, config_failure_error: string);
    }

    export class Cordova extends Ext.Base {
    }
}

declare module Ext.direct {
    interface AmfRemotingProviderConfig extends Ext.direct.ProviderConfig {
        /**
         * Object literal defining the server side actions and methods. For example, if
         * the Provider is configured with:
         * <pre><code>
         "actions":{ // each property within the 'actions' object represents a server side Class
         "TestAction":[ // array of methods within each server side Class to be
         {              // stubbed out on client
         "name":"doEcho",
         "len":1
         },{
         "name":"multiply",// name of method
         "len":2           // The number of parameters that will be used to create an
         // array of data to send to the server side function.
         // Ensure the server sends back a Number, not a String.
         },{
         "name":"doForm",
         "formHandler":true, // direct the client to use specialized form handling method
         "len":1
         }]
         }
         * </code></pre>
         * <p>Note that a Store is not required, a server method can be called at any time.
         * In the following example a <b>client side</b> handler is used to call the
         * server side method "multiply" in the server-side "TestAction" Class:</p>
         * <pre><code>
         TestAction.multiply(
         2, 4, // pass two arguments to server, so specify len=2
         // callback function after the server is called
         // result: the result returned by the server
         //      e: Ext.direct.RemotingEvent object
         function(result, e) {
         var t = e.getTransaction();
         var action = t.action; // server side Class called
         var method = t.method; // server side method called
         if(e.status) {
         var answer = Ext.encode(result); // 8
         
         } else {
         var msg = e.message; // failure message
         }
         }
         );
         * </code></pre>
         * In the example above, the server side "multiply" function will be passed two
         * arguments (2 and 4).  The "multiply" method should return the value 8 which will be
         * available as the <tt>result</tt> in the example above.
         */
        actions?: any;

        /**
         * If true, use AMF binary encoding instead of AMFX XML-based encoding. Note that on some browsers, this will load a flash plugin to handle binary communication with the server. Important: If using binary encoding with older browsers, see notes in {@link Ext.data.flash.BinaryXhr BinaryXhr} regarding packaging the Flash plugin for use in older browsers.
         */
        binary?: string;

        /**
         * Specify which param will hold the arguments for the method.
         * Defaults to <tt>'data'</tt>.
         */
        enableUrlEncode?: string;

        /**
         * <b>Requred</b>. This is the channel id defined in services-config.xml on the server (e.g. my-amf or my-http).
         */
        endpoint?: string;

        /**
         * Number of times to re-attempt delivery on failure of a call.
         */
        maxRetries?: number;

        /**
         * Namespace for the Remoting Provider (defaults to the browser global scope of <i>window</i>).
         * Explicitly specify the namespace Object, or specify a String to have a
         * {@link Ext#namespace namespace created} implicitly.
         */
        namespace?: string|any;

        /**
         * The timeout to use for each request.
         */
        timeout?: number;

        /**
         * <b>Required</b>. The URL to connect to the Flex remoting server (LCDS, BlazeDS, etc).
         * This should include the /messagebroker/amf suffix as defined in the services-config.xml and remoting-config.xml files.
         */
        url?: string;
    }

    /**
     * <p>The {@link Ext.direct.AmfRemotingProvider AmfRemotingProvider}
     * allows making RPC calls to a Java object on a BlazeDS or ColdFusion using either the AMFX or the AMF protocols.</p>
     *
     * <p>The default protocol is AMFX which works on all browsers. If you choose AMF, a flash plugin might be loaded in certain browsers that do not support posting binary data to the server, e.g. Internet Explorer version 9 or less. To choose AMF, set the {@link Ext.direct.AmfRemotingProvider#binary binary} property to true.</p>
     * <p>For AMFX, the server must be configured to expose the desired services via an HTTPEndpoint. For example, the following configuration snippet adds an HTTPEndpoint (AMFX endpoint) to the BlazeDS services-config.xml file:</p>
     * <pre><code>
     &lt;channel-definition id="my-http" class="mx.messaging.channels.HTTPChannel"&gt;
     &lt;endpoint url="http://{server.name}:{server.port}/{context.root}/messagebroker/http" class="flex.messaging.endpoints.HTTPEndpoint"/&gt;
     &lt;/channel-definition&gt;
     </code></pre>
     *
     * <p>Once the HTTPEndpoint is configured, make sure the service is exposed via the channel by adding the channel (e.g. my-http) to your remoting-services.xml file.
     * For example this allows services to be accessed remotely by both AMF and AMFX:</p>
     * <pre><code>
     &lt;default-channels&gt;
     &lt;channel ref="my-amf"/&gt;
     &lt;channel ref="my-http"/&gt;
     &lt;/default-channels&gt;
     * </code></pre>
     *
     * <p>In order to make a call, you first need to declare the API to Ext direct. The following example defines local methods to the services provided by the sample Products application provided by Adobe as part of the BlazeDS 4.x binary turnkey distribution's testdrive (Sample 5: Updating Data):</p>
     * <pre><code>
     Ext.direct.Manager.addProvider({
     "url":"/samples/messagebroker/http", // URL for the HTTPEndpoint
     "type":"amfremoting",
     "endpoint": "my-http", // the name of the HTTPEndpoint channel as defined in the server's services-config.xml
     "actions":{
     "product":[{ // name of the destination as defined in remoting-config.xml on the server
     "name":"getProducts", // method name of the method to call
     "len":0 // number of parameters
     },{
     "name":"add",
     "len":1
     },{
     "name":"bad",
     "len":0
     }]
     }
     });
     * </code></pre>
     * <p>You can now call the service as follows:</p>
     <pre><code>
     product.getProducts((function(provider, response) {
     // do something with the response
     console.log("Got " + response.data.length + " objects");
     });
     </code></pre>
     *
     * Note that in case server methods require parameters of a specific class (e.g. flex.samples.product.Product), you should make sure the passed parameter has a field called $flexType set to the class name (in this case flex.Samples.product.Product). This is similar to the remote class alias definition in ActionScript.
     *
     *
     * <p>The following example shows how to define a binary AMF-based call:</p>
     * <pre><code>
     Ext.direct.Manager.addProvider({
     "url":"/samples/messagebroker/amf", // URL for the AMFEndpoint
     "type":"amfremoting",
     "endpoint": "my-amf", // the name of the AMFEndpoint channel as defined in the server's services-config.xml
     "binary": true, // chooses AMF encoding
     "actions":{
     "product":[{ // name of the destination as defined in remoting-config.xml on the server
     "name":"getProducts", // method name of the method to call
     "len":0 // number of parameters
     },{
     "name":"add",
     "len":1
     },{
     "name":"bad",
     "len":0
     }]
     }
     });
     * </code></pre>
     * <p>Calling the server is done the same way as for the AMFX-based definition.</p>
     */
    export class AmfRemotingProvider extends Ext.direct.Provider implements Ext.direct.AmfRemotingProviderConfig {
        /**
         * Object literal defining the server side actions and methods. For example, if
         * the Provider is configured with:
         * <pre><code>
         "actions":{ // each property within the 'actions' object represents a server side Class
         "TestAction":[ // array of methods within each server side Class to be
         {              // stubbed out on client
         "name":"doEcho",
         "len":1
         },{
         "name":"multiply",// name of method
         "len":2           // The number of parameters that will be used to create an
         // array of data to send to the server side function.
         // Ensure the server sends back a Number, not a String.
         },{
         "name":"doForm",
         "formHandler":true, // direct the client to use specialized form handling method
         "len":1
         }]
         }
         * </code></pre>
         * <p>Note that a Store is not required, a server method can be called at any time.
         * In the following example a <b>client side</b> handler is used to call the
         * server side method "multiply" in the server-side "TestAction" Class:</p>
         * <pre><code>
         TestAction.multiply(
         2, 4, // pass two arguments to server, so specify len=2
         // callback function after the server is called
         // result: the result returned by the server
         //      e: Ext.direct.RemotingEvent object
         function(result, e) {
         var t = e.getTransaction();
         var action = t.action; // server side Class called
         var method = t.method; // server side method called
         if(e.status) {
         var answer = Ext.encode(result); // 8
         
         } else {
         var msg = e.message; // failure message
         }
         }
         );
         * </code></pre>
         * In the example above, the server side "multiply" function will be passed two
         * arguments (2 and 4).  The "multiply" method should return the value 8 which will be
         * available as the <tt>result</tt> in the example above.
         */
        actions: any;

        /**
         * If true, use AMF binary encoding instead of AMFX XML-based encoding. Note that on some browsers, this will load a flash plugin to handle binary communication with the server. Important: If using binary encoding with older browsers, see notes in {@link Ext.data.flash.BinaryXhr BinaryXhr} regarding packaging the Flash plugin for use in older browsers.
         */
        binary: string;

        /**
         * Specify which param will hold the arguments for the method.
         * Defaults to <tt>'data'</tt>.
         */
        enableUrlEncode: string;

        /**
         * <b>Requred</b>. This is the channel id defined in services-config.xml on the server (e.g. my-amf or my-http).
         */
        endpoint: string;

        /**
         * Number of times to re-attempt delivery on failure of a call.
         */
        maxRetries: number;

        /**
         * Namespace for the Remoting Provider (defaults to the browser global scope of <i>window</i>).
         * Explicitly specify the namespace Object, or specify a String to have a
         * {@link Ext#namespace namespace created} implicitly.
         */
        namespace: string|any;

        /**
         * The timeout to use for each request.
         */
        timeout: number;

        /**
         * <b>Required</b>. The URL to connect to the Flex remoting server (LCDS, BlazeDS, etc).
         * This should include the /messagebroker/amf suffix as defined in the services-config.xml and remoting-config.xml files.
         */
        url: string;

        connect();

        constructor(config: Ext.direct.AmfRemotingProviderConfig);

        /**
         * Create an event from an AMFX response object
         * @param {Object} response The AMFX response object
         * @return {Ext.direct.Event} The event
         */
        createEvent(response: any): Ext.direct.Event;

        disconnect();

        isConnected();

        /**
         * Fires immediately before the client-side sends off the RPC call.
         * By returning false from an event handler you can prevent the call from
         * executing.
         * @param {Object} meta The meta data
         */
        beforecall(provider: Ext.direct.AmfRemotingProvider, transaction: Ext.direct.Transaction, meta: any);

        /**
         * Fires immediately after the request to the server-side is sent. This does
         * NOT fire after the response has come back from the call.
         * @param {Object} meta The meta data
         */
        call(provider: Ext.direct.AmfRemotingProvider, transaction: Ext.direct.Transaction, meta: any);
    }

    /**
     * Base class for all Ext Direct events. An event is
     * created after some kind of interaction with the server.
     * The event class is essentially just a data structure
     * to hold a Direct response.
     */
    export class Event extends Ext.Base {
        /**
         * Creates new Event.
         * @param {Object} [config] Config object.
         */
        constructor(config?: any);

        /**
         * Return the raw data for this event.
         * @return {Mixed} The data from the event
         */
        getData(): any;
    }

    /**
     * An event that is fired when an exception is received from a {@link Ext.direct.RemotingProvider}
     */
    export class ExceptionEvent extends Ext.direct.RemotingEvent {
        /**
         * Creates new Event.
         * @param {Object} [config] Config object.
         */
        constructor(config?: any);
    }

    /**
     * A base provider for communicating using JSON. This is an abstract class
     * and should not be instanced directly.
     *
     * @abstract
     */
    export class JsonProvider extends Ext.direct.Provider {
        constructor(config: Ext.direct.AmfRemotingProviderConfig);

        /**
         * Create an event from a response object
         *
         * @param {Object} response Response object
         *
         * @return {Ext.direct.Event} The event
         */
        createEvent(response: any): Ext.direct.Event;

        /**
         * Creates a set of events based on the XHR response
         *
         * @param {Object} response The XHR response
         *
         * @return {Ext.direct.Event[]} An array of Ext.direct.Event
         */
        createEvents(response: any): Ext.direct.Event;
    }

    /**
     * Ext Direct aims to streamline communication between the client and server
     * by providing a single interface that reduces the amount of common code
     * typically required to validate data and handle returned data packets
     * (reading data, error conditions, etc).
     *
     * The 'Ext.direct' namespace includes several classes for a closer integration
     * with the server-side. The Ext.data namespace also includes classes for working
     * with Ext.data.Stores which are backed by data from an Ext Direct method.
     *
     * # Specification
     *
     * For additional information consult the [Ext Direct Specification][1].
     *
     * # Providers
     *
     * Ext Direct uses a provider architecture, where one or more providers are used
     * to transport data to and from the server. There are several providers that exist
     * in the core at the moment:
     *
     * - {@link Ext.direct.JsonProvider JsonProvider} for simple JSON operations
     * - {@link Ext.direct.PollingProvider PollingProvider} for repeated requests
     * - {@link Ext.direct.RemotingProvider RemotingProvider} exposes server side to the client.
     *
     * A provider does not need to be invoked directly, providers are added via
     * {@link Ext.direct.Manager #addProvider}. RemotingProviders' API declarations
     * can also be loaded with {@link Ext.direct.Manager #loadProvider}, with
     * Provider instance created automatically after successful retrieval.
     *
     * # Router
     *
     * Ext Direct RemotingProviders utilize a "router" on the server to direct
     * requests from the client to the appropriate server-side method. Because
     * the Ext Direct API is platform-agnostic, you could completely swap out
     * a Java based server solution and replace it with one that uses C#
     * without changing the client side JavaScript at all, or vice versa.
     *
     * # Server side events
     *
     * Custom events from the server may be handled by the client by adding listeners, for example:
     *
     *     {"type":"event","name":"message","data":"Successfully polled at: 11:19:30 am"}
     *
     *     // add a handler for a 'message' event sent by the server
     *     Ext.direct.Manager.on('message', function(e){
     *         out.append(String.format('<p><i>{0}</i></p>', e.data));
     *         out.el.scrollTo('t', 100000, true);
     *     });
     *
     *    [1]: http://sencha.com/products/extjs/extdirect
     *
     * @alternateClassName Ext.Direct
     */
    export class Manager {
        /**
         * Exception types.
         */
        static exceptions: any;

        /**
         * Default variable name to use for Ext Direct API declaration.
         *
         * Optional, Defaults to: "Ext.REMOTING_API"
         */
        static varName: string;

        /**
         * Adds an Ext Direct Provider and creates the proxy or stub methods to execute
         * server-side methods for RemotingProviders. If the provider is not already connected,
         * it will auto-connect.
         *
         *      var pollProv = new Ext.direct.PollingProvider({
         *          id: 'polling1',
         *          url: 'php/poll2.php'
         *      });
         *
         *      Ext.direct.Manager.addProvider({
         *          id: 'remoting1',
         *          type: 'remoting',           // create a Ext.direct.RemotingProvider
         *          url:  'php/router.php',     // url to connect to the Ext Direct server-side router.
         *          actions: {                  // each property within the actions object represents an Action
         *              TestAction: [{          // array of Methods within each server side Action
         *                  name: 'doEcho',     // name of method
         *                  len:  1
         *              }, {
         *                  name: 'multiply',
         *                  len:  1
         *              }, {
         *                  name: 'doForm',
         *                  formHandler: true   // handle form on server with Ext.direct.Transaction
         *              }]
         *          },
         *          namespace: 'myApplication', // namespace to create the Remoting Provider in
         *      }, {
         *          id:   'polling2',
         *          type: 'polling',            // create an Ext.direct.PollingProvider
         *          url:  'php/poll.php'
         *      },
         *      pollProv);                      // reference to previously created instance
         *
         *
         * Accepts any number of Provider descriptions (an instance or config object for
         * a Provider). Each Provider description instructs Ext Direct how to create
         * client-side stub methods.
         */
        static addProvider(provider: Ext.direct.Provider[]|any[]);

        /**
         * Retrieves a {@link Ext.direct.Provider provider} by the id specified when the
         * provider is added.
         *
         * @param {String/Ext.direct.Provider} id The id of the provider, or the provider instance.
         */
        static getProvider(id: string|Ext.direct.Provider);

        static getVarName();

        /**
         * Load Ext Direct Provider API declaration from the server and construct
         * a new Provider instance. The new Provider will then auto-connect and
         * create stub functions for the methods exposed by the server side. See
         * {@link #addProvider}.
         *
         *      Ext.direct.Manager.loadProvider({
         *          url: 'php/api.php',
         *          varName: 'MY_REMOTING_API' // defaults to 'Ext.REMOTING_API'
         *      });
         *
         * @param {Object} config Remoting API configuration.
         * @param {String} config.url URL to retrieve remoting API declaration from.
         * @param {String} config.varName Name of the variable that will hold
         * RemotingProvider configuration block, including its Actions.
         * @param {Function} [callback] Optional callback to execute when
         * Provider is created, or when an error has occured.
         * @param {Object} [scope] Optional scope to execute callback function in.
         *
         * For additional information see the [Ext Direct specification][1].
         */
        static loadProvider(config: any, config_url: string, config_varName: string, callback?: Function, scope?: any);

        /**
         * Parses a direct function. It may be passed in a string format, for example:
         * "MyApp.Person.read".
         *
         * @param {String/Function} fn The direct function
         *
         * @return {Function} The function to use in the direct call. Null if not found
         */
        static parseMethod(fn: string|Function): Function;

        /**
         * Removes the provider.
         *
         * @param {String/Ext.direct.Provider} provider The provider instance or the id of the provider.
         *
         * @return {Ext.direct.Provider} The provider, null if not found.
         */
        static removeProvider(provider: string|Ext.direct.Provider): Ext.direct.Provider;

        static setVarName();

        /**
         * Fires after an event.
         *
         * @param {Ext.direct.Event} event The {@link Ext.direct.Event Event} that occurred.
         * @param {Ext.direct.Provider} provider The {@link Ext.direct.Provider Provider}
         * that provided the event.
         */
        static event(event: Ext.direct.Event, provider: Ext.direct.Provider);

        /**
         * Fires after an event exception.
         *
         * @param {Ext.direct.Event} event The {@link Ext.direct.Event Event} that occurred.
         * @param {Ext.direct.Provider} provider The {@link Ext.direct.Provider Provider}
         * that provided the event.
         */
        static exception(event: Ext.direct.Event, provider: Ext.direct.Provider);

        /**
         * Fired by {@link #loadProvider} after successfully loading RemotingProvider API
         * declaration and creating a new Provider instance.
         *
         * @param {String} url The URL used to retrieve remoting API.
         * @param {Ext.direct.Provider} provider The {@link Ext.direct.Provider Provider}
         * instance that was created.
         */
        static providerload(url: string, provider: Ext.direct.Provider);

        /**
         * Fired by {@link #loadProvider} when remoting API could not be loaded, or
         * Provider instance could not be created.
         *
         * @param {String} url The URL used to retrieve remoting API.
         * @param {String} error The error that occured.
         */
        static providerloaderror(url: string, error: string);
    }

    interface PollingProviderConfig extends Ext.direct.ProviderConfig {
        /**
         * An object containing properties which are to be sent as parameters on every
         * polling request. Note that if baseParams are set and {@link #url} parameter
         * is an URL string, poll requests will use POST method instead of default GET.
         *
         * Optional
         */
        baseParams?: any;

        /**
         * How often to poll the server-side in milliseconds. Defaults to every 3 seconds.
         *
         * Optional, Defaults to: 3000
         */
        interval?: number;

        /**
         * Ext Direct method to use for polling. If a method name is provided as a string,
         * the actual function will not be resolved until the first time this provider
         * is connected.
         *
         * The method should accept named arguments and will be passed {@link #baseParams}
         * if set.
         */
        pollFn?: string|Function;

        /**
         * The url which the PollingProvider should contact with each request. This can also be
         * an imported Ext Direct method which will be passed baseParams as named arguments.
         *
         * *Note* that using string 'url' is deprecated, use {@link #pollFn} instead.
         * @deprecated 5.1.0
         */
        url?: string|Function;
    }

    /**
     * Provides for repetitive polling of the server at distinct {@link #interval intervals}.
     * The initial request for data originates from the client, and then is responded to by the
     * server.
     *
     * Configuration for the PollingProvider can be generated by the server-side
     * API portion of the Ext Direct stack.
     *
     * An instance of PollingProvider may be created directly via the new keyword or by simply
     * specifying 'type = 'polling''. For example:
     *
     *      var pollA = new Ext.direct.PollingProvider({
     *          type:'polling',
     *          url: 'php/pollA.php',
     *      });
     *      Ext.direct.Manager.addProvider(pollA);
     *      pollA.disconnect();
     *
     *      Ext.direct.Manager.addProvider({
     *          type:'polling',
     *          url: 'php/pollB.php',
     *          id: 'pollB-provider'
     *      });
     *      var pollB = Ext.direct.Manager.getProvider('pollB-provider');
     */
    export class PollingProvider extends Ext.direct.JsonProvider implements Ext.direct.PollingProviderConfig {
        /**
         * An object containing properties which are to be sent as parameters on every
         * polling request. Note that if baseParams are set and {@link #url} parameter
         * is an URL string, poll requests will use POST method instead of default GET.
         *
         * Optional
         */
        baseParams: any;

        /**
         * How often to poll the server-side in milliseconds. Defaults to every 3 seconds.
         *
         * Optional, Defaults to: 3000
         */
        interval: number;

        /**
         * Ext Direct method to use for polling. If a method name is provided as a string,
         * the actual function will not be resolved until the first time this provider
         * is connected.
         *
         * The method should accept named arguments and will be passed {@link #baseParams}
         * if set.
         */
        pollFn: string|Function;

        /**
         * The url which the PollingProvider should contact with each request. This can also be
         * an imported Ext Direct method which will be passed baseParams as named arguments.
         *
         * *Note* that using string 'url' is deprecated, use {@link #pollFn} instead.
         * @deprecated 5.1.0
         */
        url: string|Function;

        constructor(config: Ext.direct.AmfRemotingProviderConfig);

        destroy();

        protected doConnect();

        protected doDisconnect();

        /**
         * Fired immediately before a poll takes place.
         */
        beforepoll(that: Ext.direct.PollingProvider);

        /**
         * Fired immediately after a poll takes place.
         */
        poll(that: Ext.direct.PollingProvider);
    }

    interface ProviderConfig {
        /**
         * The unique id of the provider (defaults to an {@link Ext#id auto-assigned id}).
         * You should assign an id if you need to be able to access the provider later and you do
         * not have an object reference available, for example:
         *
         *      Ext.direct.Manager.addProvider({
         *          type: 'polling',
         *          url:  'php/poll.php',
         *          id:   'poll-provider'
         *      });
         *      var p = {@link Ext.direct.Manager}.{@link Ext.direct.Manager#getProvider getProvider}('poll-provider');
         *     p.disconnect();
         */
        id?: string;

        /**
         * List of Provider events that should be relayed by {@link Ext.direct.Manager}.
         * 'data' event is always relayed.
         */
        relayedEvents?: string;
    }

    /**
     * Ext.direct.Provider is an abstract class meant to be extended.
     *
     * For example Ext JS implements the following subclasses:
     *
     *     Provider
     *     |
     *     +---JsonProvider
     *         |
     *         +---PollingProvider
     *         |
     *         +---RemotingProvider
     *
     * @abstract
     */
    export class Provider extends Ext.Base implements Ext.direct.ProviderConfig {
        /**
         * The unique id of the provider (defaults to an {@link Ext#id auto-assigned id}).
         * You should assign an id if you need to be able to access the provider later and you do
         * not have an object reference available, for example:
         *
         *      Ext.direct.Manager.addProvider({
         *          type: 'polling',
         *          url:  'php/poll.php',
         *          id:   'poll-provider'
         *      });
         *      var p = {@link Ext.direct.Manager}.{@link Ext.direct.Manager#getProvider getProvider}('poll-provider');
         *     p.disconnect();
         */
        id: string;

        /**
         * List of Provider events that should be relayed by {@link Ext.direct.Manager}.
         * 'data' event is always relayed.
         */
        relayedEvents: string;

        /**
         * Connect the provider and start its service.
         * Provider will fire 'connect' event upon successful connection.
         */
        connect();

        constructor(config: Ext.direct.AmfRemotingProviderConfig);

        destroy();

        /**
         * Disconnect the provider and stop its service.
         * Provider will fire 'disconnect' event upon successful disconnect.
         */
        disconnect();

        /**
         * Do connection setup. This is a template method.
         */
        protected doConnect();

        /**
         * Do connection teardown. This is a template method.
         */
        protected doDisconnect();

        /**
         * Returns whether or not the server-side is currently connected.
         */
        isConnected();

        /**
         * Fires when the Provider receives data from the server-side
         *
         * @param {Ext.direct.Provider} provider The {@link Ext.direct.Provider Provider}.
         * @param {Ext.direct.Event} e The Ext.direct.Event type that occurred.
         */
        data(provider: Ext.direct.Provider, e: Ext.direct.Event);

        /**
         * Fires when the Provider receives an exception from the server-side
         */
        exception();

        /**
         * Check if the passed configuration object contains enough
         * information to construct a Provider.
         *
         *
         * @return {Boolean} 'true' if config is sufficient, 'false' otherwise.
         * @inheritable
         */
        static checkConfig(config: Ext.direct.ProviderConfig): boolean;
    }

    /**
     * An event that is fired when data is received from a
     * {@link Ext.direct.RemotingProvider}. Contains a method to the
     * related transaction for the direct request, see {@link #getTransaction}
     */
    export class RemotingEvent extends Ext.direct.Event {
        /**
         * Creates new Event.
         * @param {Object} [config] Config object.
         */
        constructor(config?: any);

        /**
         * Get the transaction associated with this event.
         * @return {Ext.direct.Transaction} The transaction
         */
        getTransaction(): Ext.direct.Transaction;
    }

    /**
     * Small utility class used internally to represent a Direct method.
     */
    export class RemotingMethod extends Ext.Base {
        constructor(config: any);

        /**
         * Prepare Direct function arguments that can be used with getCallData().
         */
        getArgs();

        /**
         * Takes the arguments for a Direct function and splits the arguments
         * from the scope and the callback.
         *
         * @param {Array} args The arguments passed to the direct call
         *
         * @return {Object} An object with 4 properties: args, callback, scope, and options object.
         */
        getCallData(args: any[]): any;
    }

    interface RemotingProviderConfig extends Ext.direct.ProviderConfig {
        /**
         * Object literal defining the server side actions and methods. For example, if
         * the Provider is configured with:
         *
         *      // each property within the 'actions' object represents a server side Class
         *      actions: {
         *          // array of methods in each server side Class to be stubbed out on client
         *          TestAction: [{
         *              name: 'doEcho',   // stub method will be TestAction.doEcho
         *              len:  1,
         *              batched: false    // always send requests immediately for this method
         *          }, {
         *              name: 'multiply', // name of method
         *              len:  2           // The number of parameters that will be used to create an
         *                                // array of data to send to the server side function.
         *          }, {
         *              name: 'doForm',
         *              formHandler: true // tells the client that this method handles form calls
         *          }],
         *
         *          // These methods will be created in nested namespace TestAction.Foo
         *          'TestAction.Foo': [{
         *              name: 'ordered',  // stub method will be TestAction.Foo.ordered
         *              len:  1
         *          }, {
         *              name: 'noParams', // this method does not accept any parameters
         *              len:  0
         *          }, {
         *              name: 'named',    // stub method will be TestAction.Foo.named
         *              params: ['foo', 'bar']    // parameters are passed by name
         *          }, {
         *              name: 'namedNoStrict',
         *              params: [],       // this method accepts parameters by name
         *              strict: false     // but does not check if they are required
         *                                // and will pass any to the server side
         *          }]
         *      }
         *
         * Note that starting with 4.2, dotted Action names will generate nested objects.
         * If you wish to reverse to previous behavior, set {@link #cfg-disableNestedActions}
         * to 'true'.
         *
         * In the following example a *client side* handler is used to call the
         * server side method "multiply" in the server-side "TestAction" Class:
         *
         *      TestAction.multiply(
         *          // pass two arguments to server, so specify len=2
         *          2, 4,
         *
         *          // callback function after the server is called
         *          //  result: the result returned by the server
         *          //       e: Ext.direct.RemotingEvent object
         *          // success: true or false
         *          // options: options to be applied to method call and passed to callback
         *          function (result, e, success, options) {
         *              var t, action, method;
         *
         *              t = e.getTransaction();
         *              action = t.action; // server side Class called
         *              method = t.method; // server side method called
         *
         *              if (e.status) {
         *                  var answer = Ext.encode(result); // 8
         *              }
         *              else {
         *                  var msg = e.message; // failure message
         *              }
         *          },
         *
         *          // Scope to call the callback in (optional)
         *          window,
         *
         *          // Options to apply to this method call. This can include
         *          // Ajax.request() options; only 'timeout' is supported at this time.
         *          // When timeout is set for a method call, it will be executed immediately
         *          // without buffering.
         *          // The same options object is passed to the callback so it's possible
         *          // to "forward" some data when needed.
         *          {
         *              timeout: 60000, // milliseconds
         *              foo: 'bar'
         *          }
         *      );
         *
         * In the example above, the server side "multiply" function will be passed two
         * arguments (2 and 4). The "multiply" method should return the value 8 which will be
         * available as the 'result' in the callback example above.
         */
        actions?: any;

        /**
         * The maximum number of requests to batch together.
         * By default, an unlimited number of requests will be batched. This option will
         * allow to wait only for a certain number of Direct method calls before
         * dispatching a request to the server, even if {@link #enableBuffer} timeout
         * has not yet expired.
         *
         * Note that this option does nothing if {@link #enableBuffer} is set to 'false'.
         */
        bufferLimit?: number;

        /**
         * In versions prior to 4.2, using dotted Action names was not really meaningful,
         * because it generated flat {@link #cfg-namespace} object with dotted property names.
         * For example, take this API declaration:
         *
         *      {
         *          actions: {
         *              TestAction: [{
         *                  name: 'foo',
         *                  len:  1
         *              }],
         *              'TestAction.Foo' [{
         *                  name: 'bar',
         *                  len: 1
         *              }]
         *          },
         *          namespace: 'MyApp'
         *      }
         *
         * Before 4.2, that would generate the following API object:
         *
         *      window.MyApp = {
         *          TestAction: {
         *              foo: function() { ... }
         *          },
         *          'TestAction.Foo': {
         *              bar: function() { ... }
         *          }
         *      }
         *
         * In Ext JS 4.2, we introduced new namespace handling behavior. Now the same API object
         * will be like this:
         *
         *      window.MyApp = {
         *          TestAction: {
         *              foo: function() { ... },
         *
         *              Foo: {
         *                  bar: function() { ... }
         *              }
         *          }
         *      }
         *
         * Instead of addressing Action methods array-style 'MyApp['TestAction.Foo'].bar()',
         * now it is possible to use object addressing: 'MyApp.TestAction.Foo.bar()'.
         *
         * If you find this behavior undesirable, set this config option to 'true'.
         *
         * Optional, Defaults to: false
         */
        disableNestedActions?: boolean;

        /**
         * 'true' or 'false' to enable or disable combining of method
         * calls. If a number is specified this is the amount of time in milliseconds
         * to wait before sending a batched request.
         *
         * Calls which are received within the specified timeframe will be
         * concatenated together and sent in a single request, optimizing the
         * application by reducing the amount of round trips that have to be made
         * to the server. To cancel buffering for some particular invocations, pass
         * 'timeout' parameter in 'options' object for that method call.
         *
         * Optional, Defaults to: 10
         */
        enableBuffer?: number|boolean;

        /**
         * Specify which param will hold the arguments for the method.
         *
         * Optional, Defaults to: data
         */
        enableUrlEncode?: string;

        /**
         * Number of times to re-attempt delivery on failure of a call.
         *
         * Optional, Defaults to: 1
         */
        maxRetries?: number;

        /**
         * Namespace for the Remoting Provider (defaults to 'Ext.global').
         * Explicitly specify the namespace Object, or specify a String to have a
         * {@link Ext#namespace namespace} created implicitly.
         */
        namespace?: string|any;

        /**
         * The timeout to use for each request.
         *
         * Optional
         */
        timeout?: number;

        /**
         * **Required**. The url to connect to the {@link Ext.direct.Manager} server-side router.
         */
        url?: string;
    }

    /**
     * The {@link Ext.direct.RemotingProvider RemotingProvider} exposes access to
     * server side methods on the client (a remote procedure call (RPC) type of
     * connection where the client can initiate a procedure on the server).
     *
     * This allows for code to be organized in a fashion that is maintainable,
     * while providing a clear path between client and server, something that is
     * not always apparent when using URLs.
     *
     * To accomplish this the server-side needs to describe what classes and methods
     * are available on the client-side. This configuration will typically be
     * outputted by the server-side Ext Direct stack when the API description is built.
     */
    export class RemotingProvider extends Ext.direct.JsonProvider implements Ext.direct.RemotingProviderConfig {
        /**
         * Object literal defining the server side actions and methods. For example, if
         * the Provider is configured with:
         *
         *      // each property within the 'actions' object represents a server side Class
         *      actions: {
         *          // array of methods in each server side Class to be stubbed out on client
         *          TestAction: [{
         *              name: 'doEcho',   // stub method will be TestAction.doEcho
         *              len:  1,
         *              batched: false    // always send requests immediately for this method
         *          }, {
         *              name: 'multiply', // name of method
         *              len:  2           // The number of parameters that will be used to create an
         *                                // array of data to send to the server side function.
         *          }, {
         *              name: 'doForm',
         *              formHandler: true // tells the client that this method handles form calls
         *          }],
         *
         *          // These methods will be created in nested namespace TestAction.Foo
         *          'TestAction.Foo': [{
         *              name: 'ordered',  // stub method will be TestAction.Foo.ordered
         *              len:  1
         *          }, {
         *              name: 'noParams', // this method does not accept any parameters
         *              len:  0
         *          }, {
         *              name: 'named',    // stub method will be TestAction.Foo.named
         *              params: ['foo', 'bar']    // parameters are passed by name
         *          }, {
         *              name: 'namedNoStrict',
         *              params: [],       // this method accepts parameters by name
         *              strict: false     // but does not check if they are required
         *                                // and will pass any to the server side
         *          }]
         *      }
         *
         * Note that starting with 4.2, dotted Action names will generate nested objects.
         * If you wish to reverse to previous behavior, set {@link #cfg-disableNestedActions}
         * to 'true'.
         *
         * In the following example a *client side* handler is used to call the
         * server side method "multiply" in the server-side "TestAction" Class:
         *
         *      TestAction.multiply(
         *          // pass two arguments to server, so specify len=2
         *          2, 4,
         *
         *          // callback function after the server is called
         *          //  result: the result returned by the server
         *          //       e: Ext.direct.RemotingEvent object
         *          // success: true or false
         *          // options: options to be applied to method call and passed to callback
         *          function (result, e, success, options) {
         *              var t, action, method;
         *
         *              t = e.getTransaction();
         *              action = t.action; // server side Class called
         *              method = t.method; // server side method called
         *
         *              if (e.status) {
         *                  var answer = Ext.encode(result); // 8
         *              }
         *              else {
         *                  var msg = e.message; // failure message
         *              }
         *          },
         *
         *          // Scope to call the callback in (optional)
         *          window,
         *
         *          // Options to apply to this method call. This can include
         *          // Ajax.request() options; only 'timeout' is supported at this time.
         *          // When timeout is set for a method call, it will be executed immediately
         *          // without buffering.
         *          // The same options object is passed to the callback so it's possible
         *          // to "forward" some data when needed.
         *          {
         *              timeout: 60000, // milliseconds
         *              foo: 'bar'
         *          }
         *      );
         *
         * In the example above, the server side "multiply" function will be passed two
         * arguments (2 and 4). The "multiply" method should return the value 8 which will be
         * available as the 'result' in the callback example above.
         */
        actions: any;

        /**
         * The maximum number of requests to batch together.
         * By default, an unlimited number of requests will be batched. This option will
         * allow to wait only for a certain number of Direct method calls before
         * dispatching a request to the server, even if {@link #enableBuffer} timeout
         * has not yet expired.
         *
         * Note that this option does nothing if {@link #enableBuffer} is set to 'false'.
         */
        bufferLimit: number;

        /**
         * In versions prior to 4.2, using dotted Action names was not really meaningful,
         * because it generated flat {@link #cfg-namespace} object with dotted property names.
         * For example, take this API declaration:
         *
         *      {
         *          actions: {
         *              TestAction: [{
         *                  name: 'foo',
         *                  len:  1
         *              }],
         *              'TestAction.Foo' [{
         *                  name: 'bar',
         *                  len: 1
         *              }]
         *          },
         *          namespace: 'MyApp'
         *      }
         *
         * Before 4.2, that would generate the following API object:
         *
         *      window.MyApp = {
         *          TestAction: {
         *              foo: function() { ... }
         *          },
         *          'TestAction.Foo': {
         *              bar: function() { ... }
         *          }
         *      }
         *
         * In Ext JS 4.2, we introduced new namespace handling behavior. Now the same API object
         * will be like this:
         *
         *      window.MyApp = {
         *          TestAction: {
         *              foo: function() { ... },
         *
         *              Foo: {
         *                  bar: function() { ... }
         *              }
         *          }
         *      }
         *
         * Instead of addressing Action methods array-style 'MyApp['TestAction.Foo'].bar()',
         * now it is possible to use object addressing: 'MyApp.TestAction.Foo.bar()'.
         *
         * If you find this behavior undesirable, set this config option to 'true'.
         *
         * Optional, Defaults to: false
         */
        disableNestedActions: boolean;

        /**
         * 'true' or 'false' to enable or disable combining of method
         * calls. If a number is specified this is the amount of time in milliseconds
         * to wait before sending a batched request.
         *
         * Calls which are received within the specified timeframe will be
         * concatenated together and sent in a single request, optimizing the
         * application by reducing the amount of round trips that have to be made
         * to the server. To cancel buffering for some particular invocations, pass
         * 'timeout' parameter in 'options' object for that method call.
         *
         * Optional, Defaults to: 10
         */
        enableBuffer: number|boolean;

        /**
         * Specify which param will hold the arguments for the method.
         *
         * Optional, Defaults to: data
         */
        enableUrlEncode: string;

        /**
         * Number of times to re-attempt delivery on failure of a call.
         *
         * Optional, Defaults to: 1
         */
        maxRetries: number;

        /**
         * Namespace for the Remoting Provider (defaults to 'Ext.global').
         * Explicitly specify the namespace Object, or specify a String to have a
         * {@link Ext#namespace namespace} created implicitly.
         */
        namespace: string|any;

        /**
         * The timeout to use for each request.
         *
         * Optional
         */
        timeout: number;

        /**
         * **Required**. The url to connect to the {@link Ext.direct.Manager} server-side router.
         */
        url: string;

        /**
         * Connect the provider and start its service.
         * Provider will fire 'connect' event upon successful connection.
         */
        connect();

        constructor(config: Ext.direct.AmfRemotingProviderConfig);

        protected doConnect();

        /**
         * Fires immediately before the client-side sends off the RPC call. By returning
         * 'false' from an event handler you can prevent the call from being made.
         *
         * @param {Object} meta The meta data
         */
        beforecall(provider: Ext.direct.RemotingProvider, transaction: Ext.direct.Transaction, meta: any);

        /**
         * Fires before callback function is executed. By returning 'false' from an event handler
         * you can prevent the callback from executing.
         *
         * @param {Ext.direct.RemotingProvider} provider The provider instance
         * @param {Ext.direct.Event} event Event associated with the callback invocation
         * @param {Ext.direct.Transaction} transaction Transaction for which the callback
         * is about to be fired
         */
        beforecallback(provider: Ext.direct.RemotingProvider, event: Ext.direct.Event, transaction: Ext.direct.Transaction);

        /**
         * Fires immediately after the request to the server-side is sent. This does
         * NOT fire after the response has come back from the call.
         *
         * @param {Object} meta The meta data
         */
        call(provider: Ext.direct.RemotingProvider, transaction: Ext.direct.Transaction, meta: any);
    }

    interface TransactionConfig {
        /**
         * Provider to use with this Transaction.
         */
        provider?: Ext.direct.Provider;
    }

    /**
     * Supporting Class for Ext Direct (not intended to be used directly).
     */
    export class Transaction extends Ext.Base implements Ext.direct.TransactionConfig {
        /**
         * Provider to use with this Transaction.
         */
        provider: Ext.direct.Provider;

        /**
         * Creates new Transaction.
         * @param {Object} [config] Config object.
         */
        constructor(config?: Ext.direct.TransactionConfig);
    }
}

declare module Ext.dom {
    /**
     * This class encapsulates a _collection_ of DOM elements, providing methods to filter members, or to perform collective
     * actions upon the whole set.
     *
     * Although they are not listed, this class supports all of the methods of {@link Ext.dom.Element}. The methods from
     * these classes will be performed on all the elements in this collection.
     *
     * All methods return _this_ and can be chained.
     *
     * Usage:
     *
     *      var els = Ext.select("#some-el div.some-class", true);
     *      // or select directly from an existing element
     *      var el = Ext.get('some-el');
     *      el.select('div.some-class', true);
     *
     *      els.setWidth(100); // all elements become 100 width
     *      els.hide(true); // all elements fade out and hide
     *      // or
     *      els.setWidth(100).hide(true);
     */
    export class CompositeElement extends Ext.dom.CompositeElementLite {
        constructor(elements: any, skipValidation: any);
    }

    interface CompositeElementLiteConfig {
        bubbleEvents?: any;
    }

    /**
     * This class encapsulates a *collection* of DOM elements, providing methods to filter members, or to perform collective
     * actions upon the whole set.
     *
     * Although they are not listed, this class supports all of the methods of {@link Ext.dom.Element}. The
     * methods from these classes will be performed on all the elements in this collection.
     *
     * Example:
     *
     *     var els = Ext.select("#some-el div.some-class");
     *     // or select directly from an existing element
     *     var el = Ext.get('some-el');
     *     el.select('div.some-class');
     *
     *     els.setWidth(100); // all elements become 100 width
     *     els.hide(true); // all elements fade out and hide
     *     // or
     *     els.setWidth(100).hide(true);
     *
     * @mixins Ext.dom.Element
     */
    export class CompositeElementLite extends Ext.Base implements Ext.dom.CompositeElementLiteConfig {
        /**
         * @readonly
         * The Array of DOM elements which this CompositeElement encapsulates.
         *
         * This will not *usually* be accessed in developers' code, but developers wishing to augment the capabilities
         * of the CompositeElementLite class may use it when adding methods to the class.
         *
         * For example to add the 'nextAll' method to the class to **add** all following siblings of selected elements,
         * the code would be
         *
         *     Ext.override(Ext.dom.CompositeElementLite, {
         *         nextAll: function() {
         *             var elements = this.elements, i, l = elements.length, n, r = [], ri = -1;
         *
         *             // Loop through all elements in this Composite, accumulating
         *             // an Array of all siblings.
         *             for (i = 0; i < l; i++) {
         *                 for (n = elements[i].nextSibling; n; n = n.nextSibling) {
         *                     r[++ri] = n;
         *                 }
         *             }
         *
         *             // Add all found siblings to this Composite
         *             return this.add(r);
         *         }
         *     });
         */
        elements: HTMLElement;

        /**
         * 'true' in this class to identify an object as an instantiated CompositeElement, or subclass thereof.
         */
        isComposite: boolean;

        bubbleEvents: any;

        /**
         * Adds elements to this Composite object.
         * @param {HTMLElement[]/Ext.dom.CompositeElementLite} els Either an Array of DOM elements to add, or another Composite
         * object who's elements should be added.
         * @param {HTMLElement/String} [root] The root element of the query or id of the root.
         * @return {Ext.dom.CompositeElementLite} This Composite object.
         */
        add(els: HTMLElement|Ext.dom.CompositeElementLite, root?: HTMLElement|string): Ext.dom.CompositeElementLite;

        /**
         * Removes all elements from this Composite.
         * @param {Boolean} [removeDom] True to also remove the elements from the document.
         */
        clear(removeDom?: boolean);

        constructor(elements: any, skipValidation: any);

        /**
         * Returns 'true' if this composite contains the passed element
         * @param {String/HTMLElement/Ext.dom.Element/Number} el The id of an element, or an Ext.Element, or an HtmlElement to
         * find within the composite collection.
         * @return {Boolean}
         */
        contains(el: string|HTMLElement|Ext.dom.Element|number): boolean;

        destroy();

        /**
         * Calls the passed function for each element in this composite.
         * @param {Function} fn The function to call.
         * @param {Ext.dom.Element} fn.el The current Element in the iteration. **This is the flyweight
         * (shared) Ext.dom.Element instance, so if you require a a reference to the dom node, use el.dom.**
         * @param {Ext.dom.CompositeElementLite} fn.c This Composite object.
         * @param {Number} fn.index The zero-based index in the iteration.
         * @param {Object} [scope] The scope (this reference) in which the function is executed.
         * Defaults to the Element.
         * @return {Ext.dom.CompositeElementLite} this
         */
        each(fn: Function, fn_el: Ext.dom.Element, fn_c: Ext.dom.CompositeElementLite, fn_index: number, scope?: any): Ext.dom.CompositeElementLite;

        /**
         * Clears this Composite and adds the elements passed.
         * @param {HTMLElement[]/Ext.dom.CompositeElementLite} els Either an array of DOM elements, or another Composite from which
         * to fill this Composite.
         * @return {Ext.dom.CompositeElementLite} this
         */
        fill(els: HTMLElement|Ext.dom.CompositeElementLite): Ext.dom.CompositeElementLite;

        /**
         * Filters this composite to only elements that match the passed selector.
         * @param {String/Function} selector A string CSS selector or a comparison function. The comparison function will be
         * called with the following arguments:
         * @param {Ext.dom.Element} selector.el The current DOM element.
         * @param {Number} selector.index The current index within the collection.
         * @return {Ext.dom.CompositeElementLite} this
         */
        filter(selector: string|Function, selector_el: Ext.dom.Element, selector_index: number): Ext.dom.CompositeElementLite;

        /**
         * Returns the first Element
         * @return {Ext.dom.Element}
         */
        first(): Ext.dom.Element;

        /**
         * Returns the number of elements in this Composite.
         * @return {Number}
         */
        getCount(): number;

        /**
         * Find the index of the passed element within the composite collection.
         * @param {String/HTMLElement/Ext.dom.Element/Number} el The id of an element, or an Ext.dom.Element, or an HtmlElement
         * to find within the composite collection.
         * @return {Number} The index of the passed Ext.dom.Element in the composite collection, or -1 if not found.
         */
        indexOf(el: string|HTMLElement|Ext.dom.Element|number): number;

        /**
         * Returns a flyweight Element of the dom element object at the specified index.
         * @return {Ext.dom.Element}
         */
        item(index: number): Ext.dom.Element;

        /**
         * Returns the last Element
         * @return {Ext.dom.Element}
         */
        last(): Ext.dom.Element;

        /**
         * Removes the specified element(s).
         * @param {String/HTMLElement/Ext.dom.Element/Number} el The id of an element, the Element itself, the index of the
         * element in this composite or an array of any of those.
         * @param {Boolean} [removeDom] 'true' to also remove the element from the document
         * @return {Ext.dom.CompositeElementLite} this
         */
        removeElement(el: string|HTMLElement|Ext.dom.Element|number, removeDom?: boolean): Ext.dom.CompositeElementLite;

        /**
         * Replaces the specified element with the passed element.
         * @param {String/HTMLElement/Ext.dom.Element/Number} el The id of an element, the Element itself, the index of the
         * element in this composite to replace.
         * @param {String/Ext.dom.Element} replacement The id of an element or the Element itself.
         * @param {Boolean} [domReplace] 'true' to remove and replace the element in the document too.
         * @return {Ext.dom.CompositeElementLite} this
         */
        replaceElement(el: string|HTMLElement|Ext.dom.Element|number, replacement: string|Ext.dom.Element, domReplace?: boolean): Ext.dom.CompositeElementLite;

        /**
         * Gets a range nodes.
         * @param {Number} start (optional) The index of the first node in the range
         * @param {Number} end (optional) The index of the last node in the range
         * @return {HTMLElement[]} An array of nodes
         */
        slice(start: number, end: number): HTMLElement;
    }

    /**
     * @alternateClassName Ext.Element
     * @mixins Ext.util.Positionable
     * @mixins Ext.mixin.Observable
     *
     * Encapsulates a DOM element, adding simple DOM manipulation facilities, normalizing for browser differences.
     *
     * **Note:** The events included in this Class are the ones we've found to be the most commonly used. Many events are
     * not listed here due to the expedient rate of change across browsers. For a more comprehensive list, please visit the
     * following resources:
     *
     * + [Mozilla Event Reference Guide](https://developer.mozilla.org/en-US/docs/Web/Events)
     * + [W3 Pointer Events](http://www.w3.org/TR/pointerevents/)
     * + [W3 Touch Events](http://www.w3.org/TR/touch-events/)
     * + [W3 DOM 2 Events](http://www.w3.org/TR/DOM-Level-2-Events/)
     * + [W3 DOM 3 Events](http://www.w3.org/TR/DOM-Level-3-Events/)
     *
     * ## Usage
     *
     *     // by id
     *     var el = Ext.get("my-div");
     *
     *     // by DOM element reference
     *     var el = Ext.get(myDivElement);
     *
     * ## Selecting Descendant Elements
     *
     * Ext.dom.Element instances can be used to select descendant nodes using CSS selectors.
     * There are 3 methods that can be used for this purpose, each with a slightly different
     * twist:
     *
     * - {@link #method-query}
     * - {@link #method-selectNode}
     * - {@link #method-select}
     *
     * These methods can accept any valid CSS selector since they all use
     * [querySelectorAll](http://www.w3.org/TR/css3-selectors/) under the hood. The primary
     * difference between these three methods is their return type:
     *
     * To get an array of HTMLElement instances matching the selector '.foo' use the query
     * method:
     *
     *     element.query('.foo');
     *
     * This can easily be transformed into an array of Ext.dom.Element instances by setting
     * the 'asDom' parameter to 'false':
     *
     *     element.query('.foo', false);
     *
     * If the desired result is only the first matching HTMLElement use the selectNode method:
     *
     *     element.selectNode('.foo');
     *
     * Once again, the dom node can be wrapped in an Ext.dom.Element by setting the 'asDom'
     * parameter to 'false':
     *
     *     element.selectNode('.foo', false);
     *
     * The 'select' method is used when the desired return type is a {@link
     * Ext.CompositeElementLite CompositeElementLite} or a {@link Ext.CompositeElement
     * CompositeElement}.  These are collections of elements that can be operated on as a
     * group using any of the methods of Ext.dom.Element.  The only difference between the two
     * is that CompositeElementLite is a collection of HTMLElement instances, while
     * CompositeElement is a collection of Ext.dom.Element instances.  To retrieve a
     * CompositeElementLite that represents a collection of HTMLElements for selector '.foo':
     *
     *     element.select('.foo');
     *
     * For a {@link Ext.CompositeElement CompositeElement} simply pass 'true' as the
     * 'composite' parameter:
     *
     *     element.select('.foo', true);
     *
     * The query selection methods can be used even if you don't have a Ext.dom.Element to
     * start with For example to select an array of all HTMLElements in the document that match the
     * selector '.foo', simply wrap the document object in an Ext.dom.Element instance using
     * {@link Ext#fly}:
     *
     *     Ext.fly(document).query('.foo');
     *
     * # Animations
     *
     * When an element is manipulated, by default there is no animation.
     *
     *     var el = Ext.get("my-div");
     *
     *     // no animation
     *     el.setWidth(100);
     *
     * specified as boolean (true) for default animation effects.
     *
     *     // default animation
     *     el.setWidth(100, true);
     *
     * To configure the effects, an object literal with animation options to use as the Element animation configuration
     * object can also be specified. Note that the supported Element animation configuration options are a subset of the
     * {@link Ext.fx.Anim} animation options specific to Fx effects. The supported Element animation configuration options
     * are:
     *
     *     Option    Default   Description
     *     --------- --------  ---------------------------------------------
     *     duration  350       The duration of the animation in milliseconds
     *     easing    easeOut   The easing method
     *     callback  none      A function to execute when the anim completes
     *     scope     this      The scope (this) of the callback function
     *
     * Usage:
     *
     *     // Element animation options object
     *     var opt = {
     *         duration: 1000,
     *         easing: 'elasticIn',
     *         callback: this.foo,
     *         scope: this
     *     };
     *     // animation with some options set
     *     el.setWidth(100, opt);
     *
     * The Element animation object being used for the animation will be set on the options object as "anim", which allows
     * you to stop or manipulate the animation. Here is an example:
     *
     *     // using the "anim" property to get the Anim object
     *     if(opt.anim.isAnimated()){
     *         opt.anim.stop();
     *     }
     */
    export class Element extends Ext.Base {
        /**
         * A reference to the 'Component' that owns this element. This is 'null' if there
         * is no direct owner.
         */
        component: Ext.Component;

        /**
         * The DOM element
         */
        dom: HTMLElement;

        /**
         * The DOM element ID
         */
        id: string;

        /**
         * Adds the given CSS class(es) to this Element.
         * @param {String/String[]} names The CSS classes to add separated by space,
         * or an array of classes
         * @param {String} [prefix] Prefix to prepend to each class. The separator '-' will be
         * appended to the prefix.
         * @param {String} [suffix] Suffix to append to each class. The separator '-' will be
         * prepended to the suffix.
         * @return {Ext.dom.Element} this
         */
        addCls(names: string, prefix?: string, suffix?: string): Ext.dom.Element;

        /**
         * Appends the passed element(s) to this element
         * @param {String/HTMLElement/Ext.dom.Element/Object} el The id or element to insert
         * or a DomHelper config
         * @param {Boolean} [returnDom=false] True to return the raw DOM element instead
         * of Ext.dom.Element
         * @return {Ext.dom.Element/HTMLElement} The inserted Ext.dom.Element (or
         * HTMLElement if _returnDom_ is _true_).
         */
        appendChild(el: string|HTMLElement|Ext.dom.Element|any, returnDom?: boolean): Ext.dom.Element|HTMLElement;

        /**
         * Appends this element to the passed element.
         * @param {String/HTMLElement/Ext.dom.Element} el The new parent element.
         * The id of the node, a DOM Node or an existing Element.
         * @return {Ext.dom.Element} This element.
         */
        appendTo(el: string|HTMLElement|Ext.dom.Element): Ext.dom.Element;

        /**
         * More flexible version of {@link #setStyle} for setting style properties.
         *
         * Styles in object form should be a valid DOM element style property.
         * [Valid style property names](http://www.w3schools.com/jsref/dom_obj_style.asp)
         * (_along with the supported CSS version for each_)
         *
         *     // <div id="my-el">Phineas Flynn</div>
         *
         *     var el = Ext.get('my-el');
         *
         *     el.applyStyles('color: white;');
         *
         *     el.applyStyles({
         *         fontWeight: 'bold',
         *         backgroundColor: 'gray',
         *         padding: '10px'
         *     });
         *
         *     el.applyStyles(function () {
         *         if (name.initialConfig.html === 'Phineas Flynn') {
         *             return 'font-style: italic;';
         *             // OR return { fontStyle: 'italic' };
         *         }
         *     });
         *
         * @param {String/Object/Function} styles A style specification string, e.g. "width:100px", or object in the form '{width:"100px"}', or
         * a function which returns such a specification.
         * @return {Ext.dom.Element} this
         */
        applyStyles(styles: string|any|Function): Ext.dom.Element;

        /**
         * Tries to blur the element. Any exceptions are caught and ignored.
         * @return {Ext.dom.Element} this
         */
        blur(): Ext.dom.Element;

        /**
         * When an element is moved around in the DOM, or is hidden using 'display:none', it loses layout, and therefore
         * all scroll positions of all descendant elements are lost.
         *
         * This function caches them, and returns a function, which when run will restore the cached positions.
         * In the following example, the Panel is moved from one Container to another which will cause it to lose all scroll positions:
         *
         *     var restoreScroll = myPanel.el.cacheScrollValues();
         *     myOtherContainer.add(myPanel);
         *     restoreScroll();
         *
         * @return {Function} A function which will restore all descendant elements of this Element to their scroll
         * positions recorded when this function was executed. Be aware that the returned function is a closure which has
         * captured the scope of 'cacheScrollValues', so take care to dereference it as soon as not needed - if is it is a 'var'
         * it will drop out of scope, and the reference will be freed.
         */
        cacheScrollValues(): Function;

        /**
         * Centers the Element in either the viewport, or another Element.
         * @param {String/HTMLElement/Ext.dom.Element} centerIn element in
         * which to center the element.
         * @return {Ext.dom.Element} This element
         */
        center(centerIn: string|HTMLElement|Ext.dom.Element): Ext.dom.Element;

        /**
         * Selects a single *direct* child based on the passed CSS selector (the selector should not contain an id).
         * @param {String} selector The CSS selector.
         * @param {Boolean} [returnDom=false] 'true' to return the DOM node instead of Ext.dom.Element.
         * @return {HTMLElement/Ext.dom.Element} The child Ext.dom.Element (or DOM node if 'returnDom' is 'true')
         */
        child(selector: string, returnDom?: boolean): HTMLElement|Ext.dom.Element;

        /**
         * Clone this element.
         * @param {Boolean} [deep=false] 'true' if the children of the node should also be cloned.
         * @param {Boolean} [returnDom=false] 'true' to return the DOM node instead of Ext.dom.Element.
         * @return {HTMLElement/Ext.dom.Element} The newly cloned Ext.dom.Element (or DOM node if 'returnDom' is 'true').
         */
        clone(deep?: boolean, returnDom?: boolean): HTMLElement|Ext.dom.Element;

        /**
         * Returns 'true' if this element is an ancestor of the passed element, or is
         * the element.
         * @param {String/HTMLElement/Ext.dom.Element} element The dom element,
         * Ext.dom.Element, or id (string) of the dom element to check.
         * @return {Boolean} True if this element is an ancestor of el or the el itself, else false
         */
        contains(element: string|HTMLElement|Ext.dom.Element): boolean;

        /**
         * Creates the passed DomHelper config and appends it to this element or optionally
         * inserts it before the passed child element.
         * @param {Object} config DomHelper element config object.  If no tag is specified
         * (e.g., {tag:'input'}) then a div will be automatically generated with the specified
         * attributes.
         * @param {HTMLElement} [insertBefore] a child element of this element
         * @param {Boolean} [returnDom=false] true to return the dom node instead of creating
         * an Element
         * @return {Ext.dom.Element/HTMLElement} The new child element (or HTMLElement if
         * _returnDom_ is _true_)
         */
        createChild(config: any, insertBefore?: HTMLElement, returnDom?: boolean): Ext.dom.Element|HTMLElement;

        /**
         * Translates an element using CSS 3 in 2D.
         * @removed 5.0.0
         */
        cssTranslate();

        /**
         * Destroys this element by removing it from the cache, removing its DOM reference,
         * and removing all of its event listeners.
         */
        destroy();

        /**
         * Selects a single child at any depth below this element based on the passed CSS selector (the selector should not contain an id).
         * @param {String} selector The CSS selector
         * @param {Boolean} [returnDom=false] 'true' to return the DOM node instead of Ext.dom.Element
         * @return {HTMLElement/Ext.dom.Element} The child Ext.dom.Element (or DOM node if 'returnDom' is 'true')
         */
        down(selector: string, returnDom?: boolean): HTMLElement|Ext.dom.Element;

        /**
         * Looks at this node and then at parent nodes for a match of the passed simple selector.
         * @param {String} selector The simple selector to test. See {@link Ext.dom.Query} for information about simple selectors.
         * @param {Number/String/HTMLElement/Ext.dom.Element} [limit]
         * The max depth to search as a number or an element which causes the upward traversal to stop
         * and is **not** considered for inclusion as the result. (defaults to 50 || document.documentElement)
         * @param {Boolean} [returnEl=false] True to return a Ext.dom.Element object instead of DOM node
         * @return {HTMLElement/Ext.dom.Element} The matching DOM node (or
         * Ext.dom.Element if _returnEl_ is _true_).  Or null if no match was found.
         */
        findParent(selector: string, limit?: number|string|HTMLElement|Ext.dom.Element, returnEl?: boolean): HTMLElement|Ext.dom.Element;

        /**
         * Looks at parent nodes for a match of the passed simple selector.
         * @param {String} selector The simple selector to test. See {@link Ext.dom.Query} for information about simple selectors.
         * @param {Number/String/HTMLElement/Ext.dom.Element} [limit]
         * The max depth to search as a number or an element which causes the upward traversal to stop
         * and is **not** considered for inclusion as the result. (defaults to 50 || document.documentElement)
         * @param {Boolean} [returnEl=false] True to return a Ext.dom.Element object instead of DOM node
         * @return {HTMLElement/Ext.dom.Element} The matching DOM node (or
         * Ext.dom.Element if _returnEl_ is _true_).  Or null if no match was found.
         */
        findParentNode(selector: string, limit?: number|string|HTMLElement|Ext.dom.Element, returnEl?: boolean): HTMLElement|Ext.dom.Element;

        /**
         * Gets the first child, skipping text nodes
         * @param {String} [selector] Find the next sibling that matches the passed simple selector.
         * See {@link Ext.dom.Query} for information about simple selectors.
         * @param {Boolean} [returnDom=false] 'true' to return a raw DOM node instead of an Ext.dom.Element
         * @return {Ext.dom.Element/HTMLElement} The first child or null
         */
        first(selector?: string, returnDom?: boolean): Ext.dom.Element|HTMLElement;

        /**
         * Try to focus the element either immediately or after a timeout
         * if 'defer' argument is specified.
         *
         * @param {Number} [defer] Milliseconds to defer the focus
         * @return {Ext.dom.Element} this
         */
        focus(defer?: number): Ext.dom.Element;

        /**
         * Returns the value of an attribute from the element's underlying DOM node.
         * @param {String} name The attribute name.
         * @param {String} [namespace] The namespace in which to look for the attribute.
         * @return {String} The attribute value.
         */
        getAttribute(name: string, namespace?: string): string;

        /**
         * Returns an object containing a map of all attributes of this element's DOM node.
         *
         * @return {Object} Key/value pairs of attribute names and their values.
         */
        getAttributes(): any;

        /**
         * Gets the width of the border(s) for the specified side(s)
         * @param {String} side Can be t, l, r, b or any combination of those to add
         * multiple values. For example, passing ''lr'' would get the border **l**eft
         * width + the border **r**ight width.
         * @return {Number} The width of the sides passed added together
         */
        getBorderWidth(side: string): number;

        /**
         * Gets the bottom Y coordinate of the element (element Y position + element height)
         * @param {Boolean} local True to get the local css position instead of page
         * coordinate
         * @return {Number}
         */
        getBottom(local: boolean): number;

        /**
         * Returns a child element of this element given its 'id'.
         * @param {String} id The id of the desired child element.
         * @param {Boolean} [asDom=false] True to return the DOM element, false to return a
         * wrapped Element object.
         * @return {Ext.dom.Element/HTMLElement} The child element (or HTMLElement if
         * _asDom_ is _true_).  Or null if no match was found.
         */
        getById(id: string, asDom?: boolean): Ext.dom.Element|HTMLElement;

        /**
         * Returns the offset height of the element.
         * @param {Boolean} [contentHeight] 'true' to get the height minus borders and padding.
         * @return {Number} The element's height.
         */
        getHeight(contentHeight?: boolean): number;

        /**
         * Returns the 'innerHTML' of an Element or an empty string if the element's
         * dom no longer exists.
         * @return {String}
         */
        getHtml(): string;

        /**
         * @deprecated 5.0.0 Please use {@link #getHtml} instead.
         */
        getHTML();

        /**
         * Gets the left X coordinate
         * @param {Boolean} local True to get the local css position instead of
         * page coordinate
         * @return {Number}
         */
        getLeft(local: boolean): number;

        /**
         * Returns an object with properties top, left, right and bottom representing the margins of this element unless sides is passed,
         * then it returns the calculated width of the sides (see {@link #getPadding}).
         * @param {String} [sides] Any combination of 'l', 'r', 't', 'b' to get the sum of those sides.
         * @return {Object/Number}
         */
        getMargin(sides?: string): any|number;

        /**
         * Retrieves the height of the element account for the top and bottom margins.
         * @removed 5.0.0
         */
        getOuterHeight();

        /**
         * Retrieves the width of the element accounting for the left and right margins.
         * @removed 5.0.0
         */
        getOuterWidth();

        /**
         * Gets the width of the padding(s) for the specified side(s).
         * @param {String} side Can be t, l, r, b or any combination of those to add
         * multiple values. For example, passing ''lr'' would get the padding **l**eft +
         * the padding **r**ight.
         * @return {Number} The padding of the sides passed added together.
         */
        getPadding(side: string): number;

        /**
         * Returns an object defining the area of this Element which can be passed to
         * {@link Ext.util.Positionable#setBox} to set another Element's size/location to match this element.
         *
         * @param {Boolean} [asRegion] If true an Ext.util.Region will be returned
         * @return {Object/Ext.util.Region} box An object in the following format:
         *
         *     {
         *         left: <Element's X position>,
         *         top: <Element's Y position>,
         *         width: <Element's width>,
         *         height: <Element's height>,
         *         bottom: <Element's lower bound>,
         *         right: <Element's rightmost bound>
         *     }
         *
         * The returned object may also be addressed as an Array where index 0 contains
         * the X position and index 1 contains the Y position. So the result may also be
         * used for {@link #setXY}
         * @deprecated 5.0.0 use {@link Ext.util.Positionable#getBox} to get a box object, and
         * {@link Ext.util.Positionable#getRegion} to get a {@link Ext.util.Region Region}.
         */
        getPageBox(asRegion?: boolean): any|Ext.util.Region;

        /**
         * Gets the right X coordinate of the element (element X position + element width)
         * @param {Boolean} local True to get the local css position instead of page
         * coordinates
         * @return {Number}
         */
        getRight(local: boolean): number;

        /**
         * Returns the current scroll position of the element.
         * @return {Object} An object containing the scroll position in the format
         * '{left: (scrollLeft), top: (scrollTop)}'
         */
        getScroll(): any;

        /**
         * Gets the left scroll position
         * @return {Number} The left scroll position
         */
        getScrollLeft(): number;

        /**
         * Gets the Scroller instance of the first parent that has one.
         * @removed 5.0.0
         */
        getScrollParent();

        /**
         * Gets the top scroll position
         * @return {Number} The top scroll position
         */
        getScrollTop(): number;

        /**
         * Returns the size of the element.
         * @param {Boolean} [contentSize] 'true' to get the width/size minus borders and padding.
         * @return {Object} An object containing the element's size:
         * @return {Number} return.width
         * @return {Number} return.height
         */
        getSize(contentSize?: boolean): any;

        /**
         * Returns a named style property based on computed/currentStyle (primary) and
         * inline-style if primary is not available.
         *
         * @param {String/String[]} property The style property (or multiple property names
         * in an array) whose value is returned.
         * @param {Boolean} [inline=false] if 'true' only inline styles will be returned.
         * @return {String/Object} The current value of the style property for this element
         * (or a hash of named style values if multiple property arguments are requested).
         */
        getStyle(property: string, inline?: boolean): string|any;

        /**
         * Returns the width in pixels of the passed text, or the width of the text in this Element.
         * @param {String} text The text to measure. Defaults to the innerHTML of the element.
         * @param {Number} [min] The minumum value to return.
         * @param {Number} [max] The maximum value to return.
         * @return {Number} The text width in pixels.
         */
        getTextWidth(text: string, min?: number, max?: number): number;

        /**
         * Gets the top Y coordinate
         * @param {Boolean} local True to get the local css position instead of page
         * coordinates
         * @return {Number}
         */
        getTop(local: boolean): number;

        /**
         * Returns the value of the 'value' attribute.
         * @param {Boolean} asNumber 'true' to parse the value as a number.
         * @return {String/Number}
         */
        getValue(asNumber: boolean): string|number;

        /**
         * Returns the offset width of the element.
         * @param {Boolean} [contentWidth] 'true' to get the width minus borders and padding.
         * @return {Number} The element's width.
         */
        getWidth(contentWidth?: boolean): number;

        /**
         * Gets element X position in page coordinates
         *
         * @return {Number}
         */
        getX(): number;

        /**
         * Gets element X and Y positions in page coordinates
         *
         * @return {Array} [x, y]
         */
        getXY(): any[];

        /**
         * Gets element Y position in page coordinates
         *
         * @return {Number}
         */
        getY(): number;

        /**
         * Returns this element's z-index
         * @return {Number}
         */
        getZIndex(): number;

        /**
         * Checks if the specified CSS class exists on this element's DOM node.
         * @param {String} name The CSS class to check for.
         * @return {Boolean} 'true' if the class exists, else 'false'.
         */
        hasCls(name: string): boolean;

        /**
         * Hide this element - Uses display mode to determine whether to use "display",
         * "visibility", or "offsets". See {@link #setVisible}.
         * @return {Ext.dom.Element} this
         */
        hide(): Ext.dom.Element;

        /**
         * Inserts this element after the passed element in the DOM.
         * @param {String/HTMLElement/Ext.dom.Element} el The element to insert after.
         * The 'id' of the node, a DOM Node or an existing Element.
         * @return {Ext.dom.Element} This element.
         */
        insertAfter(el: string|HTMLElement|Ext.dom.Element): Ext.dom.Element;

        /**
         * Inserts this element before the passed element in the DOM.
         * @param {String/HTMLElement/Ext.dom.Element} el The element before which this element will be inserted.
         * The id of the node, a DOM Node or an existing Element.
         * @return {Ext.dom.Element} This element.
         */
        insertBefore(el: string|HTMLElement|Ext.dom.Element): Ext.dom.Element;

        /**
         * Inserts (or creates) an element as the first child of this element
         * @param {String/HTMLElement/Ext.dom.Element/Object} el The id or element to insert
         * or a DomHelper config to create and insert
         * @param {Boolean} [returnDom=false] True to return the raw DOM element instead
         * of Ext.dom.Element
         * @return {Ext.dom.Element/HTMLElement} The new child element (or HTMLElement if
         * _returnDom_ is _true_).
         */
        insertFirst(el: string|HTMLElement|Ext.dom.Element|any, returnDom?: boolean): Ext.dom.Element|HTMLElement;

        /**
         * Inserts an html fragment into this element
         * @param {String} where Where to insert the html in relation to this element - beforeBegin, afterBegin, beforeEnd, afterEnd.
         * See {@link Ext.dom.Helper#insertHtml} for details.
         * @param {String} html The HTML fragment
         * @param {Boolean} [returnEl=false] True to return an Ext.dom.Element
         * @return {HTMLElement/Ext.dom.Element} The inserted node (or nearest related if more than 1 inserted)
         */
        insertHtml(where: string, html: string, returnEl?: boolean): HTMLElement|Ext.dom.Element;

        /**
         * Inserts (or creates) the passed element (or DomHelper config) as a sibling of this element
         * @param {String/HTMLElement/Ext.dom.Element/Object/Array} el The id, element to insert or a DomHelper config
         * to create and insert *or* an array of any of those.
         * @param {String} [where='before'] 'before' or 'after'
         * @param {Boolean} [returnDom=false] True to return the raw DOM element instead of Ext.dom.Element
         * @return {Ext.dom.Element/HTMLElement} The inserted Ext.dom.Element (or
         * HTMLElement if _returnDom_ is _true_). If an array is passed, the last
         * inserted element is returned.
         */
        insertSibling(el: string|HTMLElement|Ext.dom.Element|any|any[], where?: string, returnDom?: boolean): Ext.dom.Element|HTMLElement;

        /**
         * Returns 'true' if this element matches the passed simple selector
         * (e.g. 'div.some-class' or 'span:first-child').
         * @param {String/Function} selector The simple selector to test or a function which is passed
         * candidate nodes, and should return 'true' for nodes which match.
         * @return {Boolean} 'true' if this element matches the selector, else 'false'.
         */
        is(selector: string|Function): boolean;

        /**
         * Returns 'true' if this element is an ancestor of the passed element
         * @param {String/HTMLElement/Ext.dom.Element} el The element or id of the element
         * to search for in this elements descendants.
         * @return {Boolean}
         */
        isAncestor(el: string|HTMLElement|Ext.dom.Element): boolean;

        /**
         * Determines if this element is a descendant of the passed in Element.
         * @removed 5.0.0
         */
        isDescendent();

        /**
         * Returns true if this element is scrollable.
         * @return {Boolean}
         */
        isScrollable(): boolean;

        /**
         * Checks if the current value of a style is equal to a given value.
         * @param {String} style property whose value is returned.
         * @param {String} value to check against.
         * @return {Boolean} 'true' for when the current value equals the given value.
         */
        isStyle(style: string, value: string): boolean;

        /**
         * Returns 'true' if the value of the given property is visually transparent. This
         * may be due to a 'transparent' style value or an rgba value with 0 in the alpha
         * component.
         * @param {String} prop The style property whose value is to be tested.
         * @return {Boolean} 'true' if the style property is visually transparent.
         * @deprecated 5.0.0
         */
        isTransparent(prop: string): boolean;

        /**
         * Checks whether the element is currently visible using both visibility and display properties.
         * @param {Boolean} [deep=false] True to walk the dom and see if parent elements are hidden.
         * If false, the function only checks the visibility of the element itself and it may return
         * 'true' even though a parent is not visible.
         * @return {Boolean} 'true' if the element is currently visible, else 'false'
         */
        isVisible(deep?: boolean): boolean;

        /**
         * Gets the last child, skipping text nodes
         * @param {String} [selector] Find the previous sibling that matches the passed simple selector.
         * See {@link Ext.dom.Query} for information about simple selectors.
         * @param {Boolean} [returnDom=false] 'true' to return a raw DOM node instead of an Ext.dom.Element
         * @return {Ext.dom.Element/HTMLElement} The last child Ext.dom.Element (or
         * HTMLElement if _returnDom_ is _true_).  Or null if no match is found.
         */
        last(selector?: string, returnDom?: boolean): Ext.dom.Element|HTMLElement;

        /**
         * Gets the next sibling, skipping text nodes
         * @param {String} [selector] Find the next sibling that matches the passed simple selector.
         * See {@link Ext.dom.Query} for information about simple selectors.
         * @param {Boolean} [returnDom=false] 'true' to return a raw dom node instead of an Ext.dom.Element
         * @return {Ext.dom.Element/HTMLElement} The next sibling Ext.dom.Element (or
         * HTMLElement if _asDom_ is _true_).  Or null if no match is found.
         */
        next(selector?: string, returnDom?: boolean): Ext.dom.Element|HTMLElement;

        /**
         * Gets the parent node for this element, optionally chaining up trying to match a selector
         * @param {String} [selector] Find a parent node that matches the passed simple selector.
         * See {@link Ext.dom.Query} for information about simple selectors.
         * @param {Boolean} [returnDom=false] True to return a raw dom node instead of an Ext.dom.Element
         * @return {Ext.dom.Element/HTMLElement} The parent node (Ext.dom.Element or
         * HTMLElement if _returnDom_ is _true_).  Or null if no match is found.
         */
        parent(selector?: string, returnDom?: boolean): Ext.dom.Element|HTMLElement;

        /**
         * Initializes positioning on this element. If a desired position is not passed,
         * it will make the the element positioned relative IF it is not already positioned.
         * @param {String} [pos] Positioning to use "relative", "absolute" or "fixed"
         * @param {Number} [zIndex] The zIndex to apply
         * @param {Number} [x] Set the page X position
         * @param {Number} [y] Set the page Y position
         */
        position(pos?: string, zIndex?: number, x?: number, y?: number);

        /**
         * Gets the previous sibling, skipping text nodes
         * @param {String} [selector] Find the previous sibling that matches the passed simple selector.
         * See {@link Ext.dom.Query} for information about simple selectors.
         * @param {Boolean} [returnDom=false] 'true' to return a raw DOM node instead of an Ext.dom.Element
         * @return {Ext.dom.Element/HTMLElement} The previous sibling (Ext.dom.Element or
         * HTMLElement if _returnDom_ is _true_).  Or null if no match is found.
         */
        prev(selector?: string, returnDom?: boolean): Ext.dom.Element|HTMLElement;

        /**
         * @deprecated 5.0.0 Please use {@link #clearListeners} instead.
         */
        purgeAllListeners();

        /**
         * Adds one or more CSS classes to this element and removes the same class(es) from all siblings.
         * @param {String/String[]} className The CSS class to add, or an array of classes.
         * @return {Ext.dom.Element} this
         */
        radioCls(className: string): Ext.dom.Element;

        /**
         * @deprecated 5.0.0 Please use {@link #destroy} instead.
         */
        remove();

        /**
         * @deprecated 5.0.0 Please use {@link #clearListeners} instead.
         */
        removeAllListeners();

        /**
         * Removes the given CSS class(es) from this Element.
         * @param {String/String[]} names The CSS classes to remove separated by space,
         * or an array of classes
         * @param {String} [prefix] Prefix to prepend to each class. The separator '-' will be
         * appended to the prefix.
         * @param {String} [suffix] Suffix to append to each class. The separator '-' will be
         * prepended to the suffix.
         * return {Ext.dom.Element} this
         */
        removeCls(names: string, prefix?: string, suffix?: string);

        /**
         * Forces the browser to repaint this element.
         * @return {Ext.dom.Element} this
         */
        repaint(): Ext.dom.Element;

        /**
         * Replaces the passed element with this element
         * @param {String/HTMLElement/Ext.dom.Element} el The element to replace.
         * The id of the node, a DOM Node or an existing Element.
         * @param {Boolean} [destroy=true] 'false' to prevent destruction of the replaced
         * element
         * @return {Ext.dom.Element} This element
         */
        replace(el: string|HTMLElement|Ext.dom.Element, destroy?: boolean): Ext.dom.Element;

        /**
         * Replaces a CSS class on the element with another.
         * If the old name does not exist, the new name will simply be added.
         * @param {String} oldName The CSS class to replace.
         * @param {String} newName The replacement CSS class.
         * @param {String} [prefix=''] Prefix to prepend to each class to be replaced.
         * @param {String} [suffix=''] Suffix to append to each class to be replaced.
         * @return {Ext.dom.Element} this
         */
        replaceCls(oldName: string, newName: string, prefix?: string, suffix?: string): Ext.dom.Element;

        /**
         * Replaces this element with the passed element
         * @param {String/HTMLElement/Ext.dom.Element/Object} el The new element (id of the
         * node, a DOM Node or an existing Element) or a DomHelper config of an element to create
         * @return {Ext.dom.Element} This element
         */
        replaceWith(el: string|HTMLElement|Ext.dom.Element|any): Ext.dom.Element;

        /**
         * Scrolls this element the specified direction. Does bounds checking to make sure the scroll is
         * within this element's scrollable range.
         * @param {String} direction Possible values are:
         *
         * - '"l"' (or '"left"')
         * - '"r"' (or '"right"')
         * - '"t"' (or '"top"', or '"up"')
         * - '"b"' (or '"bottom"', or '"down"')
         *
         * @param {Number} distance How far to scroll the element in pixels
         * @param {Boolean/Object} [animate] true for the default animation or a standard Element
         * animation config object
         * @return {Boolean} Returns true if a scroll was triggered or false if the element
         * was scrolled as far as it could go.
         */
        scroll(direction: string, distance: number, animate?: boolean|any): boolean;

        /**
         * Scrolls this element by the passed delta values, optionally animating.
         *
         * All of the following are equivalent:
         *
         *      el.scrollBy(10, 10, true);
         *      el.scrollBy([10, 10], true);
         *      el.scrollBy({ x: 10, y: 10 }, true);
         *
         * @param {Number/Number[]/Object} deltaX Either the x delta, an Array specifying x and y deltas or
         * an object with "x" and "y" properties.
         * @param {Number/Boolean/Object} deltaY Either the y delta, or an animate flag or config object.
         * @param {Boolean/Object} animate Animate flag/config object if the delta values were passed separately.
         * @return {Ext.dom.Element} this
         */
        scrollBy(deltaX: number|any, deltaY: number|boolean|any, animate: boolean|any): Ext.dom.Element;

        /**
         * Scrolls this element into view within the passed container.
         *
         *       Ext.create('Ext.data.Store', {
         *           storeId:'simpsonsStore',
         *           fields:['name', 'email', 'phone'],
         *           data:{'items':[
         *               { 'name': 'Lisa',  "email":"lisa@simpsons.com",  "phone":"555-111-1224"  },
         *               { 'name': 'Bart',  "email":"bart@simpsons.com",  "phone":"555-222-1234" },
         *               { 'name': 'Homer', "email":"homer@simpsons.com",  "phone":"555-222-1244"  },
         *               { 'name': 'Marge', "email":"marge@simpsons.com", "phone":"555-222-1254"  },
         *               { 'name': 'Milhouse', "email":"milhouse@simpsons.com",  "phone":"555-222-1244"  },
         *               { 'name': 'Willy', "email":"willy@simpsons.com", "phone":"555-222-1254"  },
         *               { 'name': 'Skinner', "email":"skinner@simpsons.com",  "phone":"555-222-1244"  },
         *               { 'name': 'Hank (last row)', "email":"hank@simpsons.com", "phone":"555-222-1254"  }
         *           ]},
         *           proxy: {
         *               type: 'memory',
         *               reader: {
         *                   type: 'json',
         *                   rootProperty: 'items'
         *               }
         *           }
         *       });
         *
         *       var grid = Ext.create('Ext.grid.Panel', {
         *           title: 'Simpsons',
         *           store: Ext.data.StoreManager.lookup('simpsonsStore'),
         *           columns: [
         *               { text: 'Name',  dataIndex: 'name', width: 125 },
         *               { text: 'Email', dataIndex: 'email', flex: 1 },
         *               { text: 'Phone', dataIndex: 'phone' }
         *           ],
         *           height: 190,
         *           width: 400,
         *           renderTo: Ext.getBody(),
         *           tbar: [{
         *               text: 'Scroll row 7 into view',
         *               handler: function () {
         *                   var view = grid.getView();
         *
         *                   Ext.get(view.getRow(7)).scrollIntoView(view.getEl(), null, true);
         *               }
         *           }]
         *       });
         *
         * @param {String/HTMLElement/Ext.Element} [container=document.body] The container element
         * to scroll.  Should be a string (id), dom node, or Ext.Element.
         * @param {Boolean} [hscroll=true] False to disable horizontal scroll.
         * @param {Boolean/Object} [animate] true for the default animation or a standard Element
         * animation config object
         * @param {Boolean} [highlight=false] true to {@link #highlight} the element when it is in view.
         * @return {Ext.dom.Element} this
         */
        scrollIntoView(container?: string|HTMLElement|Ext.dom.Element, hscroll?: boolean, animate?: boolean|any, highlight?: boolean): Ext.dom.Element;

        /**
         * Scrolls this element the specified scroll point. It does NOT do bounds checking so
         * if you scroll to a weird value it will try to do it. For auto bounds checking, use #scroll.
         * @param {String} side Either "left" for scrollLeft values or "top" for scrollTop values.
         * @param {Number} value The new scroll value
         * @param {Boolean/Object} [animate] true for the default animation or a standard Element
         * animation config object
         * @return {Ext.dom.Element} this
         */
        scrollTo(side: string, value: number, animate?: boolean|any): Ext.dom.Element;

        /**
         * Selects a single descendant element of this element using a CSS selector
         * (see {@link #query}).
         * @param {String} selector The selector query
         * @param {Boolean} [asDom=true] 'false' to return an Ext.dom.Element
         * @return {HTMLElement/Ext.dom.Element} The DOM element (or Ext.dom.Element if
         * _asDom_ is _false_) which matched the selector.
         */
        selectNode(selector: string, asDom?: boolean): HTMLElement|Ext.dom.Element;

        /**
         * Sets the passed attributes as attributes of this element (a 'style' attribute
         * can be a string, object or function).
         *
         * Example component (though any Ext.dom.Element would suffice):
         *
         *     var cmp = Ext.create({
         *         xtype: 'component',
         *         html: 'test',
         *         renderTo: Ext.getBody()
         *     });
         *
         * Once the component is rendered, you can fetch a reference to its outer
         * element to use 'set':
         *
         *     cmp.el.set({
         *         foo: 'bar'
         *     });
         *
         * This sets an attribute on the element of **foo="bar"**:
         *
         *     <div class="x-component x-component-default x-border-box" id="component-1009" foo="bar">test</div>
         *
         * To remove the attribute pass a value of **undefined**:
         *
         *     cmp.el.set({
         *         foo: undefined
         *     });
         *
         * **Note:**
         *
         *  - You cannot remove an attribute by passing 'undefined' when the
         * 'expandos' param is set to **false**.
         *  - Passing an attribute of 'style' results in the request being handed off to
         * {@link #method-applyStyles}.
         *  - Passing an attribute of 'cls' results in the element's dom's
         * [className](http://www.w3schools.com/jsref/prop_html_classname.asp) property
         * being set directly.  For additional flexibility when setting / removing
         * classes see:
         *     - {@link #method-addCls}
         *     - {@link #method-removeCls}
         *     - {@link #method-replaceCls}
         *     - {@link #method-setCls}
         *     - {@link #method-toggleCls}
         *
         * @param {Object} attributes The object with the attributes.
         * @param {Boolean} [useSet=true] 'false' to override the default 'setAttribute'
         * to use [expandos](http://help.dottoro.com/ljvovanq.php).
         * @return {Ext.dom.Element} this
         */
        set(attributes: any, useSet?: boolean): Ext.dom.Element;

        /**
         * Sets the element's CSS bottom style.
         * @param {Number/String} bottom Number of pixels or CSS string value to set as
         * the bottom CSS property value
         * @return {Ext.dom.Element} this
         */
        setBottom(bottom: number|string): Ext.dom.Element;

        /**
         * Sets the specified CSS class on this element's DOM node.
         * @param {String/String[]} className The CSS class to set on this element.
         */
        setCls(className: string);

        /**
         * Sets the CSS display property. Uses originalDisplay if the specified value is a
         * boolean true.
         * @param {Boolean/String} value Boolean value to display the element using its
         * default display, or a string to set the display directly.
         * @return {Ext.dom.Element} this
         */
        setDisplayed(value: boolean|string): Ext.dom.Element;

        /**
         * Set the height of this Element.
         * @param {Number/String} height The new height.
         * @return {Ext.dom.Element} this
         */
        setHeight(height: number|string): Ext.dom.Element;

        /**
         * Sets the 'innerHTML' of this element.
         * @param {String} html The new HTML.
         * @return {Ext.dom.Element} this
         */
        setHtml(html: string): Ext.dom.Element;

        /**
         * @deprecated 5.0.0 Please use {@link #setHtml} instead.
         */
        setHTML();

        /**
         * Sets the element's left position directly using CSS style
         * (instead of {@link #setX}).
         * @param {Number/String} left Number of pixels or CSS string value to
         * set as the left CSS property value
         * @return {Ext.dom.Element} this
         */
        setLeft(left: number|string): Ext.dom.Element;

        /**
         * Set the maximum height of this Element.
         * @param {Number/String} height The new maximum height.
         * @return {Ext.dom.Element} this
         */
        setMaxHeight(height: number|string): Ext.dom.Element;

        /**
         * Set the maximum width of this Element.
         * @param {Number/String} width The new maximum width.
         * @return {Ext.dom.Element} this
         */
        setMaxWidth(width: number|string): Ext.dom.Element;

        /**
         * Set the minimum height of this Element.
         * @param {Number/String} height The new minimum height.
         * @return {Ext.dom.Element} this
         */
        setMinHeight(height: number|string): Ext.dom.Element;

        /**
         * Set the minimum width of this Element.
         * @param {Number/String} width The new minimum width.
         * @return {Ext.dom.Element} this
         */
        setMinWidth(width: number|string): Ext.dom.Element;

        /**
         * Set the opacity of the element
         * @param {Number} opacity The new opacity. 0 = transparent, .5 = 50% visibile, 1 = fully visible, etc
         * @return {Ext.dom.Element} this
         */
        setOpacity(opacity: number): Ext.dom.Element;

        /**
         * Sets the element's CSS right style.
         * @param {Number/String} right Number of pixels or CSS string value to
         * set as the right CSS property value
         * @return {Ext.dom.Element} this
         */
        setRight(right: number|string): Ext.dom.Element;

        /**
         * Sets the left scroll position
         * @param {Number} left The left scroll position
         * @return {Ext.dom.Element} this
         */
        setScrollLeft(left: number): Ext.dom.Element;

        /**
         * Sets the top scroll position
         * @param {Number} top The top scroll position
         * @return {Ext.dom.Element} this
         */
        setScrollTop(top: number): Ext.dom.Element;

        /**
         * Set the size of this Element.
         *
         * @param {Number/String} width The new width. This may be one of:
         *
         * - A Number specifying the new width in pixels.
         * - A String used to set the CSS width style. Animation may **not** be used.
         * - A size object in the format '{width: widthValue, height: heightValue}'.
         *
         * @param {Number/String} height The new height. This may be one of:
         *
         * - A Number specifying the new height in pixels.
         * - A String used to set the CSS height style. Animation may **not** be used.
         * @return {Ext.dom.Element} this
         */
        setSize(width: number|string, height: number|string): Ext.dom.Element;

        /**
         * Wrapper for setting style properties, also takes single object parameter of
         * multiple styles.
         *
         * Styles should be a valid DOM element style property.
         * [Valid style property names](http://www.w3schools.com/jsref/dom_obj_style.asp)
         * (_along with the supported CSS version for each_)
         *
         *     // <div id="my-el">Phineas Flynn</div>
         *
         *     var el = Ext.get('my-el');
         *
         *     // two-param syntax
         *     el.setStyle('color', 'white');
         *
         *     // single-param syntax
         *     el.setStyle({
         *         fontWeight: 'bold',
         *         backgroundColor: 'gray',
         *         padding: '10px'
         *     });
         *
         * @param {String/Object} property The style property to be set, or an object of
         * multiple styles.
         * @param {String} [value] The value to apply to the given property, or null if
         * an object was passed.
         * @return {Ext.dom.Element} this
         */
        setStyle(property: string|any, value?: string): Ext.dom.Element;

        /**
         * Sets the element's top position directly using CSS style
         * (instead of {@link #setY}).
         * @param {Number/String} top Number of pixels or CSS string value to
         * set as the top CSS property value
         * @return {Ext.dom.Element} this
         */
        setTop(top: number|string): Ext.dom.Element;

        /**
         * Sets the element's top and left positions directly using CSS style.
         * @removed 5.0.0
         */
        setTopLeft();

        /**
         * Use this to change the visibility mode between {@link #VISIBILITY},
         * {@link #DISPLAY}, {@link #OFFSETS}, or {@link #CLIP}.
         *
         * The method by which the element will be {@link #hide hidden} (you can
         * also use the {@link #setVisible} or {@link #toggle} method to toggle element
         * visibility).
         *
         * @return {Ext.dom.Element} this
         */
        setVisibilityMode(mode: any): Ext.dom.Element;

        /**
         * Sets the visibility of the element based on the current visibility mode. Use
         * {@link #setVisibilityMode} to switch between the following visibility modes:
         *
         * - {@link #DISPLAY} (the default)
         * - {@link #VISIBILITY}
         * - {@link #OFFSETS}
         * - {@link #CLIP}
         *
         * @param {Boolean} visible Whether the element is visible.
         * @return {Ext.dom.Element} this
         */
        setVisible(visible: boolean): Ext.dom.Element;

        /**
         * Set the width of this Element.
         * @param {Number/String} width The new width.
         * @return {Ext.dom.Element} this
         */
        setWidth(width: number|string): Ext.dom.Element;

        /**
         * Sets this Element's page-level x coordinate
         * @return {Ext.dom.Element} this
         */
        setX(x: number): Ext.dom.Element;

        /**
         * Sets this Element's page-level x and y coordinates
         * @return {Ext.dom.Element} this
         */
        setXY(xy: number): Ext.dom.Element;

        /**
         * Sets this Element's page-level y coordinate
         * @return {Ext.dom.Element} this
         */
        setY(y: number): Ext.dom.Element;

        /**
         * Sets the z-index of this Element and synchronizes the z-index of shadow and/or
         * shim if present.
         *
         * @param {Number} zindex The new z-index to set
         * @return {Ext.dom.Element} this
         */
        setZIndex(zindex: number): Ext.dom.Element;

        /**
         * Show this element - Uses display mode to determine whether to use "display",
         * "visibility", "offsets", or "clip". See {@link #setVisible}.
         *
         * @return {Ext.dom.Element} this
         */
        show(): Ext.dom.Element;

        /**
         * Toggles the element's visibility, depending on visibility mode.
         * @return {Ext.dom.Element} this
         */
        toggle(): Ext.dom.Element;

        /**
         * Toggles the specified CSS class on this element (removes it if it already exists, otherwise adds it).
         * @param {String} className The CSS class to toggle.
         * @param {Boolean} [state] If specified as 'true', causes the class to be added. If specified as 'false', causes
         * the class to be removed.
         * @return {Ext.dom.Element} this
         */
        toggleCls(className: string, state?: boolean): Ext.dom.Element;

        /**.
         * Walks up the dom looking for a parent node that matches the passed simple selector (e.g. 'div.some-class' or 'span:first-child').
         * This is a shortcut for findParentNode() that always returns an Ext.dom.Element.
         * @param {String} selector The simple selector to test. See {@link Ext.dom.Query} for information about simple selectors.
         * @param {Number/String/HTMLElement/Ext.dom.Element} [limit]
         * The max depth to search as a number or an element that causes the upward
         * traversal to stop and is **not** considered for inclusion as the result.
         * (defaults to 50 || document.documentElement)
         * @param {Boolean} [returnDom=false] True to return the DOM node instead of Ext.dom.Element
         * @return {Ext.dom.Element/HTMLElement} The matching DOM node (or HTMLElement if
         * _returnDom_ is _true_).  Or null if no match was found.
         */
        up(selector: string, limit?: number|string|HTMLElement|Ext.dom.Element, returnDom?: boolean): Ext.dom.Element|HTMLElement;

        /**
         * @deprecated 5.0.0 Please use {@link #setHtml} instead.
         */
        update();

        /**
         * Creates and wraps this element with another element
         * @param {Object} [config] DomHelper element config object for the wrapper element or null for an empty div
         * @param {Boolean} [returnDom=false] True to return the raw DOM element instead of Ext.dom.Element
         * @param {String} [selector] A CSS selector to select a descendant node within the created element to use as the wrapping element.
         * @return {HTMLElement/Ext.dom.Element} The newly created wrapper element
         */
        wrap(config?: any, returnDom?: boolean, selector?: string): HTMLElement|Ext.dom.Element;

        /**
         * Fires when an object/image is stopped from loading before completely loaded.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        abort(e: Ext.event.Event, t: HTMLElement);

        /**
         * Fires when a control loses the input focus and its value has been modified since gaining focus.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        change(e: Ext.event.Event, t: HTMLElement);

        /**
         * Fires when a mouse click is detected within the element.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        click(e: Ext.event.Event, t: HTMLElement);

        /**
         * Fires when a right click is detected within the element.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        contextmenu(e: Ext.event.Event, t: HTMLElement);

        /**
         * Fires when a mouse double click is detected within the element.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        dblclick(e: Ext.event.Event, t: HTMLElement);

        /**
         * Where supported. Fires when an element is activated, for instance, through a mouse click or a keypress.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        DOMActivate(e: Ext.event.Event, t: HTMLElement);

        /**
         * Where supported. Fires when an attribute has been modified.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        DOMAttrModified(e: Ext.event.Event, t: HTMLElement);

        /**
         * Where supported. Fires when the character data has been modified.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        DOMCharacterDataModified(e: Ext.event.Event, t: HTMLElement);

        /**
         * Where supported. Similar to HTML focus event, but can be applied to any focusable element.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        DOMFocusIn(e: Ext.event.Event, t: HTMLElement);

        /**
         * Where supported. Similar to HTML blur event, but can be applied to any focusable element.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        DOMFocusOut(e: Ext.event.Event, t: HTMLElement);

        /**
         * Where supported. Fires when a node has been added as a child of another node.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        DOMNodeInserted(e: Ext.event.Event, t: HTMLElement);

        /**
         * Where supported. Fires when a node is being inserted into a document.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        DOMNodeInsertedIntoDocument(e: Ext.event.Event, t: HTMLElement);

        /**
         * Where supported. Fires when a descendant node of the element is removed.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        DOMNodeRemoved(e: Ext.event.Event, t: HTMLElement);

        /**
         * Where supported. Fires when a node is being removed from a document.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        DOMNodeRemovedFromDocument(e: Ext.event.Event, t: HTMLElement);

        /**
         * Where supported. Fires when the subtree is modified.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        DOMSubtreeModified(e: Ext.event.Event, t: HTMLElement);

        /**
         * Fires when there is a double tap.
         * @param {Ext.event.Event} event The {@link Ext.event.Event} event encapsulating the DOM event.
         * @param {HTMLElement} node The target of the event.
         * @param {Object} options The options object passed to Ext.mixin.Observable.addListener.
         */
        doubletap(event: Ext.event.Event, node: HTMLElement, options: any);

        /**
         * Fires when an object/image/frame cannot be loaded properly.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        error(e: Ext.event.Event, t: HTMLElement);

        /**
         * Fires when focus is moved *within* an element.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {Ext.dom.Element} e.target The {@link Ext.dom.Element} element which *recieved* focus.
         * @param {Ext.dom.Element} e.relatedTarget The {@link Ext.dom.Element} element which *lost* focus.
         * @param {HTMLElement} t The target of the event.
         */
        focusmove(e: Ext.event.Event, e_target: Ext.dom.Element, e_relatedTarget: Ext.dom.Element, t: HTMLElement);

        /**
         * Fires when a keydown is detected within the element.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        keydown(e: Ext.event.Event, t: HTMLElement);

        /**
         * Fires when a keypress is detected within the element.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        keypress(e: Ext.event.Event, t: HTMLElement);

        /**
         * Fires when a keyup is detected within the element.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        keyup(e: Ext.event.Event, t: HTMLElement);

        /**
         * Fires when the user agent finishes loading all content within the element. Only supported by window, frames,
         * objects and images.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        load(e: Ext.event.Event, t: HTMLElement);

        /**
         * Fires when you touch and hold still for more than 1 second.
         * @param {Ext.event.Event} event The {@link Ext.event.Event} event encapsulating the DOM event.
         * @param {HTMLElement} node The target of the event.
         * @param {Object} options The options object passed to Ext.mixin.Observable.addListener.
         */
        longpress(event: Ext.event.Event, node: HTMLElement, options: any);

        /**
         * Fires when a mousedown is detected within the element.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        mousedown(e: Ext.event.Event, t: HTMLElement);

        /**
         * Fires when the mouse enters the element.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        mouseenter(e: Ext.event.Event, t: HTMLElement);

        /**
         * Fires when the mouse leaves the element.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        mouseleave(e: Ext.event.Event, t: HTMLElement);

        /**
         * Fires when a mousemove is detected with the element.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        mousemove(e: Ext.event.Event, t: HTMLElement);

        /**
         * Fires when a mouseout is detected with the element.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        mouseout(e: Ext.event.Event, t: HTMLElement);

        /**
         * Fires when a mouseover is detected within the element.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        mouseover(e: Ext.event.Event, t: HTMLElement);

        /**
         * Fires when a mouseup is detected within the element.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        mouseup(e: Ext.event.Event, t: HTMLElement);

        /**
         * Fires whenever this Element actually becomes visible (painted) on the screen. This is useful when you need to
         * perform 'read' operations on the DOM element, i.e: calculating natural sizes and positioning.
         *
         * __Note:__ This event is not available to be used with event delegation. Instead 'painted' only fires if you explicitly
         * add at least one listener to it, for performance reasons.
         *
         * @param {Ext.dom.Element} this The component instance.
         */
        painted(that: Ext.dom.Element);

        /**
         * Fires continuously when there is pinching (the touch must move for this to be fired).
         * @param {Ext.event.Event} event The {@link Ext.event.Event} event encapsulating the DOM event.
         * @param {HTMLElement} node The target of the event.
         * @param {Object} options The options object passed to Ext.mixin.Observable.addListener.
         */
        pinch(event: Ext.event.Event, node: HTMLElement, options: any);

        /**
         * Fires when a pinch has ended.
         * @param {Ext.event.Event} event The {@link Ext.event.Event} event encapsulating the DOM event.
         * @param {HTMLElement} node The target of the event.
         * @param {Object} options The options object passed to Ext.mixin.Observable.addListener.
         */
        pinchend(event: Ext.event.Event, node: HTMLElement, options: any);

        /**
         * Fired once when a pinch has started.
         * @param {Ext.event.Event} event The {@link Ext.event.Event} event encapsulating the DOM event.
         * @param {HTMLElement} node The target of the event.
         * @param {Object} options The options object passed to Ext.mixin.Observable.addListener.
         */
        pinchstart(event: Ext.event.Event, node: HTMLElement, options: any);

        /**
         * Fires when a form is reset.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        reset(e: Ext.event.Event, t: HTMLElement);

        /**
         * Important note: For the best performance on mobile devices, use this only when you absolutely need to monitor
         * a Element's size.
         *
         * __Note:__ This event is not available to be used with event delegation. Instead 'resize' only fires if you explicitly
         * add at least one listener to it, for performance reasons.
         *
         * @param {Ext.dom.Element} this The component instance.
         */
        resize(that: Ext.dom.Element);

        /**
         * Fires continuously when there is rotation (the touch must move for this to be fired).
         * When listening to this, ensure you know about the {@link Ext.event.Event#angle} and {@link Ext.event.Event#rotation}
         * properties in the 'event' object.
         * @param {Ext.event.Event} event The {@link Ext.event.Event} event encapsulating the DOM event.
         * @param {HTMLElement} node The target of the event.
         * @param {Object} options The options object passed to Ext.mixin.Observable.addListener.
         */
        rotate(event: Ext.event.Event, node: HTMLElement, options: any);

        /**
         * Fires when a rotation event has ended.
         * @param {Ext.event.Event} event The {@link Ext.event.Event} event encapsulating the DOM event.
         * @param {HTMLElement} node The target of the event.
         * @param {Object} options The options object passed to Ext.mixin.Observable.addListener.
         */
        rotateend(event: Ext.event.Event, node: HTMLElement, options: any);

        /**
         * Fired once when a rotation has started.
         * @param {Ext.event.Event} event The {@link Ext.event.Event} event encapsulating the DOM event.
         * @param {HTMLElement} node The target of the event.
         * @param {Object} options The options object passed to Ext.mixin.Observable.addListener.
         */
        rotatestart(event: Ext.event.Event, node: HTMLElement, options: any);

        /**
         * Fires when there is a single tap.
         * @param {Ext.event.Event} event The {@link Ext.event.Event} event encapsulating the DOM event.
         * @param {HTMLElement} node The target of the event.
         * @param {Object} options The options object passed to Ext.mixin.Observable.addListener.
         */
        singletap(event: Ext.event.Event, node: HTMLElement, options: any);

        /**
         * Fires when a form is submitted.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        submit(e: Ext.event.Event, t: HTMLElement);

        /**
         * Fires when there is a swipe
         * When listening to this, ensure you know about the {@link Ext.event.Event#direction} property in the 'event' object.
         * @param {Ext.event.Event} event The {@link Ext.event.Event} event encapsulating the DOM event.
         * @param {HTMLElement} node The target of the event.
         * @param {Object} options The options object passed to Ext.mixin.Observable.addListener.
         */
        swipe(event: Ext.event.Event, node: HTMLElement, options: any);

        taphold();

        /**
         * Fires when the user agent removes all content from a window or frame. For elements, it fires when the target
         * element or any of its content has been removed.
         * @param {Ext.event.Event} e The {@link Ext.event.Event} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        unload(e: Ext.event.Event, t: HTMLElement);

        /**
         * Visibility mode constant for use with {@link Ext.dom.Element#setVisibilityMode}.
         * Use CSS 'clip' property to reduce element's dimensions to 0px by 0px, effectively
         * making it hidden while not being truly invisible. This is useful when an element
         * needs to be published to the Assistive Technologies such as screen readers.
         * @inheritable
         */
        static CLIP: any;

        /**
         * Visibility mode constant for use with {@link Ext.dom.Element#setVisibilityMode}.
         * Use the CSS 'display' property to hide the element.
         * @inheritable
         */
        static DISPLAY: any;

        /**
         * Visibility mode constant for use with {@link Ext.dom.Element#setVisibilityMode}.
         * Use CSS absolute positioning and top/left offsets to hide the element.
         * @inheritable
         */
        static OFFSETS: any;

        /**
         * Visibility mode constant for use with {@link Ext.dom.Element#setVisibilityMode}.
         * Use the CSS 'visibility' property to hide the element.
         *
         * Note that in this mode, {@link Ext.dom.Element#isVisible isVisible} may return true
         * for an element even though it actually has a parent element that is hidden. For this
         * reason, and in most cases, using the {@link #OFFSETS} mode is a better choice.
         * @inheritable
         */
        static VISIBILITY: any;

        /**
         * @inheritable
         */
        static fly();

        /**
         * Returns the top Element that is located at the passed coordinates
         * @inheritable
         * @param {Number} x The x coordinate
         * @param {Number} y The y coordinate
         * @return {String} The found Element
         */
        static fromPoint(x: number, y: number): string;

        /**
         * Retrieves Ext.dom.Element objects. {@link Ext#get} is alias for {@link Ext.dom.Element#get}.
         *
         * **This method does not retrieve {@link Ext.Component Component}s.** This method retrieves Ext.dom.Element
         * objects which encapsulate DOM elements. To retrieve a Component by its ID, use {@link Ext.ComponentManager#get}.
         *
         * When passing an id, it should not include the '#' character that is used for a css selector.
         *
         *     // For an element with id 'foo'
         *     Ext.get('foo'); // Correct
         *     Ext.get('#foo'); // Incorrect
         *
         * Uses simple caching to consistently return the same object. Automatically fixes if an object was recreated with
         * the same id via AJAX or DOM.
         *
         * @param {String/HTMLElement/Ext.dom.Element} el The 'id' of the node, a DOM Node or an existing Element.
         * @return {Ext.dom.Element} The Element object (or 'null' if no matching element was found).
         * @inheritable
         */
        static get(el: string|HTMLElement|Ext.dom.Element): Ext.dom.Element;

        /**
         * Returns the active element in the DOM. If the browser supports activeElement
         * on the document, this is returned. If not, the focus is tracked and the active
         * element is maintained internally.
         * @inheritable
         *
         * @param {Boolean} asElement Return Ext.Element instance instead of DOM node.
         *
         * @return {HTMLElement} The active (focused) element in the document.
         */
        static getActiveElement(asElement: boolean): HTMLElement;

        /**
         * Returns the common ancestor of the two passed elements.
         * @inheritable
         *
         * @param {Boolean} returnDom Pass 'true' to return a DOM element. Otherwise An {@link Ext.dom.Element Element} will be returned.
         * @return {Ext.dom.Element/HTMLElement} The common ancestor.
         */
        static getCommonAncestor(nodeA: Ext.dom.Element|HTMLElement, nodeB: Ext.dom.Element|HTMLElement, returnDom: boolean): Ext.dom.Element|HTMLElement;

        /**
         * Retrieves the document height
         * @inheritable
         * @return {Number} documentHeight
         */
        static getDocumentHeight(): number;

        /**
         * Retrieves the document width
         * @inheritable
         * @return {Number} documentWidth
         */
        static getDocumentWidth(): number;

        /**
         * Retrieves the current orientation of the window. This is calculated by
         * determining if the height is greater than the width.
         * @inheritable
         * @return {String} Orientation of window: 'portrait' or 'landscape'
         */
        static getOrientation(): string;

        /**
         * Retrieves the viewport height of the window.
         * @inheritable
         * @return {Number} viewportHeight
         */
        static getViewportHeight(): number;

        /**
         * Retrieves the viewport width of the window.
         * @inheritable
         * @return {Number} viewportWidth
         */
        static getViewportWidth(): number;

        /**
         * Retrieves the viewport size of the window.
         * @inheritable
         * @return {Object} object containing width and height properties
         */
        static getViewSize(): any;

        /**
         * Normalizes CSS property keys from dash delimited to camel case JavaScript Syntax.
         * For example:
         *
         * - border-width -> borderWidth
         * - padding-top -> paddingTop
         *
         * @inheritable
         * @param {String} prop The property to normalize
         * @return {String} The normalized string
         */
        static normalize(prop: string): string;

        /**
         * Parses a number or string representing margin sizes into an object. Supports CSS-style margin declarations
         * (e.g. 10, "10", "10 10", "10 10 10" and "10 10 10 10" are all valid options and would return the same result)
         * @inheritable
         * @param {Number/String} box The encoded margins
         * @return {Object} An object with margin sizes for top, right, bottom and left containing the unit
         */
        static parseBox(box: number|string): any;

        /**
         * Converts a CSS string into an object with a property for each style.
         *
         * The sample code below would return an object with 2 properties, one
         * for background-color and one for color.
         *
         *     var css = 'background-color: red; color: blue;';
         *     console.log(Ext.dom.Element.parseStyles(css));
         *
         * @inheritable
         * @param {String} styles A CSS string
         * @return {Object} styles
         */
        static parseStyles(styles: string): any;

        /**
         * Selects child nodes of a given root based on the passed CSS selector.
         * @inheritable
         * @param {String} selector The CSS selector.
         * @param {Boolean} [asDom=true] 'false' to return an array of Ext.dom.Element
         * @param {HTMLElement/String} [root] The root element of the query or id of
         * the root
         * @return {HTMLElement[]/Ext.dom.Element[]} An Array of elements that match
         * the selector.  If there are no matches, an empty Array is returned.
         */
        static query(selector: string, asDom?: boolean, root?: HTMLElement|string): HTMLElement|Ext.dom.Element;

        /**
         * Selects elements based on the passed CSS selector to enable
         * {@link Ext.dom.Element Element} methods to be applied to many related
         * elements in one statement through the returned
         * {@link Ext.dom.CompositeElementLite CompositeElementLite} object.
         * @inheritable
         * @param {String/HTMLElement[]} selector The CSS selector or an array of
         * elements
         * @param {Boolean} [composite=false] Return a CompositeElement as opposed to
         * a CompositeElementLite. Defaults to false.
         * @param {HTMLElement/String} [root] The root element of the query or id of
         * the root
         * @return {Ext.dom.CompositeElementLite/Ext.dom.CompositeElement}
         */
        static select(selector: string|HTMLElement, composite?: boolean, root?: HTMLElement|string): Ext.dom.CompositeElementLite|Ext.dom.CompositeElement;

        /**
         * Serializes a DOM form into a url encoded string
         * @param {Object} form The form
         * @return {String} The url encoded form
         * @inheritable
         */
        static serializeForm(form: any): string;

        /**
         * Parses a number or string representing margin sizes into an object. Supports CSS-style margin declarations
         * (e.g. 10, "10", "10 10", "10 10 10" and "10 10 10 10" are all valid options and would return the same result)
         * @inheritable
         * @param {Number/String/Object} box The encoded margins, or an object with top, right,
         * @param {String} units The type of units to add
         * @return {String} An string with unitized (px if units is not specified) metrics for top, right, bottom and left
         */
        static unitizeBox(box: number|string|any, units: string): string;
    }

    /**
     * A special Ext.util.Event subclass that adds support for capture (top-down propagation)
     * listeners, and non-delegated (directly attached to the dom) listeners.
     *
     * An Ext.Element will have one instance of this class per event type that is being listened
     * for.  The ElementEvent instance provides a single point for attaching event listeners
     * and abstracts away important details on the timing and ordering of event firing.
     * Internally this class manages up to 3 separate Ext.util.Event instances.  These represent
     * separate stacks of listeners that may be invoked during different phases of event propagation.
     *
     * - 'captures' - tracks listeners that should fire during the "capture" phase of the
     * standard delegated model (listeners attached using capture:true)
     * - 'direct' - tracks directly attached listeners, that is listeners that should fire
     * immediately when the event is dispatched to the dom element, before the event bubbles
     * upward and delegated listener processing begins
     * (listeners attached using delegated:false)
     * - 'directCaptures' - tracks directly attached capture listeners (only works in IE10+)
     *
     * For more detail on the timing of when these event stacks are dispatched please see
     * Ext.event.publisher.Dom
     */
    export class ElementEvent extends Ext.util.Event {
    }

    /**
     * A flyweight Ext.dom.Element that can be dynamically attached to a DOM node.
     * In general this class should not be instantiated directly.  Use {@link Ext#fly}
     * to create and retrieve Fly instances.
     */
    export class Fly extends Ext.dom.Element {
        /**
         * This is 'true' to identify Element flyweights
         */
        isFly: boolean;

        constructor(dom: any);
    }

    /**
     * Garbage collector for Ext.dom.Element instances.  Automatically cleans up Elements
     * that are no longer in the dom, but were not properly destroyed using
     * {@link Ext.dom.Element#destroy destroy()}.  Recommended practice is for Components to
     * clean up their own elements, but the GarbageCollector runs on regularly scheduled
     * intervals to attempt to clean up orphaned Elements that may have slipped through the cracks.
     */
    export class GarbageCollector {
        /**
         * The interval at which to run Element garbage collection. Set this property directly
         * to tune the interval.
         *
         *     Ext.dom.GarbageCollector.interval = 60000; // run garbage collection every one minute
         */
        static interval: any;

        /**
         * Collects orphaned Ext.dom.Elements by removing their listeners and evicting them
         * from the cache.  Runs on a regularly scheduled {@link #interval} but can be called
         * directly to force garbage collection.
         * @return {String[]} An array containing the IDs of the elements that were garbage
         * collected, prefixed by their tag names.  Only applies in dev mode.  Returns nothing
         * in a production build.
         */
        static collect(): string;

        /**
         * Pauses the timer and stops garbage collection
         */
        static pause();

        /**
         * Resumes garbage collection at the specified {@link #interval}
         */
        static resume();
    }

    /**
     * @alternateClassName Ext.DomHelper
     *
     * The DomHelper class provides a layer of abstraction from DOM and transparently supports creating elements via DOM or
     * using HTML fragments. It also has the ability to create HTML fragment templates from your DOM building code.
     *
     * ## DomHelper element specification object
     *
     * A specification object is used when creating elements. Attributes of this object are assumed to be element
     * attributes, except for 4 special attributes:
     *
     * * **tag**: The tag name of the element
     * * **children (or cn)**: An array of the same kind of element definition objects to be created and appended. These
     * can be nested as deep as you want.
     * * **cls**: The class attribute of the element. This will end up being either the "class" attribute on a HTML
     * fragment or className for a DOM node, depending on whether DomHelper is using fragments or DOM.
     * * **html**: The innerHTML for the element
     *
     * ## Insertion methods
     *
     * Commonly used insertion methods:
     *
     * * {@link #append}
     * * {@link #insertBefore}
     * * {@link #insertAfter}
     * * {@link #overwrite}
     * * {@link #insertHtml}
     *
     * ## Example
     *
     * This is an example, where an unordered list with 3 children items is appended to an existing element with id
     * 'my-div':
     *
     *     var dh = Ext.DomHelper; // create shorthand alias
     *     // specification object
     *     var spec = {
     *         id: 'my-ul',
     *         tag: 'ul',
     *         cls: 'my-list',
     *         // append children after creating
     *         children: [     // may also specify 'cn' instead of 'children'
     *             {tag: 'li', id: 'item0', html: 'List Item 0'},
     *             {tag: 'li', id: 'item1', html: 'List Item 1'},
     *             {tag: 'li', id: 'item2', html: 'List Item 2'}
     *         ]
     *     };
     *     var list = dh.append(
     *         'my-div', // the context element 'my-div' can either be the id or the actual node
     *         spec      // the specification object
     *     );
     *
     * Element creation specification parameters in this class may also be passed as an Array of specification objects.
     * This can be used to insert multiple sibling nodes into an existing container very efficiently. For example, to add
     * more list items to the example above:
     *
     *     dh.append('my-ul', [
     *         {tag: 'li', id: 'item3', html: 'List Item 3'},
     *         {tag: 'li', id: 'item4', html: 'List Item 4'}
     *     ]);
     *
     * ## Templating
     *
     * The real power is in the built-in templating. Instead of creating or appending any elements, createTemplate returns
     * a Template object which can be used over and over to insert new elements. Revisiting the example above, we could
     * utilize templating this time:
     *
     *     // create the node
     *     var list = dh.append('my-div', {tag: 'ul', cls: 'my-list'});
     *     // get template
     *     var tpl = dh.createTemplate({tag: 'li', id: 'item{0}', html: 'List Item {0}'});
     *
     *     for(var i = 0; i < 5; i++){
     *         tpl.append(list, i); // use template to append to the actual node
     *     }
     *
     * An example using a template:
     *
     *     var html = '"{0}" href="{1}" class="nav">{2}';
     *
     *     var tpl = new Ext.DomHelper.createTemplate(html);
     *     tpl.append('blog-roll', ['link1', 'http://www.foxmulder.com/', "Fox's Site"]);
     *     tpl.append('blog-roll', ['link2', 'http://www.danascully.org/', "Scully's Site"]);
     *
     * The same example using named parameters:
     *
     *     var html = '"{id}" href="{url}" class="nav">{text}';
     *
     *     var tpl = new Ext.DomHelper.createTemplate(html);
     *     tpl.append('blog-roll', {
     *         id: 'link1',
     *         url: 'http://www.danascully.org/',
     *         text: "Scully's Site"
     *     });
     *     tpl.append('blog-roll', {
     *         id: 'link2',
     *         url: 'http://www.foxmulder.com/',
     *         text: "Fox's Site"
     *     });
     *
     * ## Compiling Templates
     *
     * Templates are applied using regular expressions. The performance is great, but if you are adding a bunch of DOM
     * elements using the same template, you can increase performance even further by "compiling" the template. The way
     * "compile()" works is the template is parsed and broken up at the different variable points and a dynamic function is
     * created and eval'ed. The generated function performs string concatenation of these parts and the passed variables
     * instead of using regular expressions.
     *
     *     var html = '"{id}" href="{url}" class="nav">{text}';
     *
     *     var tpl = new Ext.DomHelper.createTemplate(html);
     *     tpl.compile();
     *
     *     // ... use template like normal
     *
     * ## Performance Boost
     *
     * DomHelper will transparently create HTML fragments when it can. Using HTML fragments instead of DOM can
     * significantly boost performance.
     *
     * Element creation specification parameters may also be strings which are used as innerHTML.
     */
    export class Helper {
        /**
         * Creates new DOM element(s) and appends them to el.
         * @param {String/HTMLElement/Ext.dom.Element} el The context element
         * @param {Object/String} o The DOM object spec (and children) or raw HTML blob
         * @param {Boolean} [returnElement] true to return a Ext.Element
         * @return {HTMLElement/Ext.dom.Element} The new node
         */
        static append(el: string|HTMLElement|Ext.dom.Element, o: any|string, returnElement?: boolean): HTMLElement|Ext.dom.Element;

        /**
         * Applies a style specification to an element.
         *
         * Styles in object form should be a valid DOM element style property.
         * [Valid style property names](http://www.w3schools.com/jsref/dom_obj_style.asp)
         * (_along with the supported CSS version for each_)
         *
         *     // <div id="my-el">Phineas Flynn</div>
         *
         *     var el = Ext.get('my-el'),
         *         dh = Ext.dom.Helper;
         *
         *     dh.applyStyles(el, 'color: white;');
         *
         *     dh.applyStyles(el, {
         *         fontWeight: 'bold',
         *         backgroundColor: 'gray',
         *         padding: '10px'
         *     });
         *
         *     dh.applyStyles(el, function () {
         *         if (name.initialConfig.html === 'Phineas Flynn') {
         *             return 'font-style: italic;';
         *             // OR return { fontStyle: 'italic' };
         *         }
         *     });
         *
         * @param {String/HTMLElement/Ext.dom.Element} el The element to apply styles to
         * @param {String/Object/Function} styles A style specification string e.g. 'width:100px', or object in the form {width:'100px'}, or
         * a function which returns such a specification.
         */
        static applyStyles(el: string|HTMLElement|Ext.dom.Element, styles: string|any|Function);

        /**
         * Creates new DOM element(s) without inserting them to the document.
         * @param {Object/String} o The DOM object spec (and children) or raw HTML blob
         * @return {HTMLElement} The new uninserted node
         */
        static createDom(o: any|string): HTMLElement;

        /**
         * Alias for {@link #markup}.
         * @deprecated 5.0.0
         */
        static createHtml();

        /**
         * Creates a new Ext.Template from the DOM object spec.
         * @param {Object} o The DOM object spec (and children)
         * @return {Ext.Template} The new template
         */
        static createTemplate(o: any): Ext.Template;

        /**
         * Converts the styles from the given object to text. The styles are CSS style names
         * with their associated value.
         *
         * The basic form of this method returns a string:
         *
         *      var s = Ext.DomHelper.generateStyles({
         *          backgroundColor: 'red'
         *      });
         *
         *      // s = 'background-color:red;'
         *
         * Alternatively, this method can append to an output array.
         *
         *      var buf = [];
         *
         *      ...
         *
         *      Ext.DomHelper.generateStyles({
         *          backgroundColor: 'red'
         *      }, buf);
         *
         * In this case, the style text is pushed on to the array and the array is returned.
         *
         * @param {Object} styles The object describing the styles.
         * @param {String[]} [buffer] The output buffer.
         * @param {Boolean} [encode] 'true' to {@link Ext.String#htmlEncode} property values if they
         * are going to be inserted as HTML attributes.
         * @return {String/String[]} If buffer is passed, it is returned. Otherwise the style
         * string is returned.
         */
        static generateStyles(styles: any, buffer?: string, encode?: boolean): string;

        /**
         * Creates new DOM element(s) and inserts them after el.
         * @param {String/HTMLElement/Ext.dom.Element} el The context element
         * @param {Object} o The DOM object spec (and children)
         * @param {Boolean} [returnElement] true to return a Ext.Element
         * @return {HTMLElement/Ext.dom.Element} The new node
         */
        static insertAfter(el: string|HTMLElement|Ext.dom.Element, o: any, returnElement?: boolean): HTMLElement|Ext.dom.Element;

        /**
         * Creates new DOM element(s) and inserts them before el.
         * @param {String/HTMLElement/Ext.dom.Element} el The context element
         * @param {Object/String} o The DOM object spec (and children) or raw HTML blob
         * @param {Boolean} [returnElement] true to return a Ext.Element
         * @return {HTMLElement/Ext.dom.Element} The new node
         */
        static insertBefore(el: string|HTMLElement|Ext.dom.Element, o: any|string, returnElement?: boolean): HTMLElement|Ext.dom.Element;

        /**
         * Creates new DOM element(s) and inserts them as the first child of el.
         * @param {String/HTMLElement/Ext.dom.Element} el The context element
         * @param {Object/String} o The DOM object spec (and children) or raw HTML blob
         * @param {Boolean} [returnElement] true to return a Ext.Element
         * @return {HTMLElement/Ext.dom.Element} The new node
         */
        static insertFirst(el: string|HTMLElement|Ext.dom.Element, o: any|string, returnElement?: boolean): HTMLElement|Ext.dom.Element;

        /**
         * Inserts an HTML fragment into the DOM.
         * @param {String} where Where to insert the html in relation to el - beforeBegin, afterBegin, beforeEnd, afterEnd.
         *
         * For example take the following HTML: '<div>Contents</div>'
         *
         * Using different 'where' values inserts element to the following places:
         *
         * - beforeBegin: '<HERE><div>Contents</div>'
         * - afterBegin: '<div><HERE>Contents</div>'
         * - beforeEnd: '<div>Contents<HERE></div>'
         * - afterEnd: '<div>Contents</div><HERE>'
         *
         * @param {HTMLElement/TextNode} el The context element
         * @param {String} html The HTML fragment
         * @return {HTMLElement} The new node
         */
        static insertHtml(where: string, el: HTMLElement|any, html: string): HTMLElement;

        /**
         * Returns the markup for the passed Element(s) config.
         * @param {Object} spec The DOM object spec (and children).
         * @return {String}
         */
        static markup(spec: any): string;

        /**
         * Creates new DOM element(s) and overwrites the contents of el with them.
         * @param {String/HTMLElement/Ext.dom.Element} el The context element
         * @param {Object/String} o The DOM object spec (and children) or raw HTML blob
         * @param {Boolean} [returnElement=false] true to return an Ext.Element
         * @return {HTMLElement/Ext.dom.Element} The new node
         */
        static overwrite(el: string|HTMLElement|Ext.dom.Element, o: any|string, returnElement?: boolean): HTMLElement|Ext.dom.Element;
    }

    /**
     * @alternateClassName Ext.DomQuery
     * @alternateClassName Ext.core.DomQuery
     *
     * Provides high performance selector/xpath processing by compiling queries into reusable functions. New pseudo classes
     * and matchers can be plugged. It works on HTML and XML documents (if a content node is passed in).
     *
     * DomQuery supports most of the [CSS3 selectors spec][1], along with some custom selectors and basic XPath.
     *
     * All selectors, attribute filters and pseudos below can be combined infinitely in any order. For example
     * 'div.foo:nth-child(odd)[@foo=bar].bar:first' would be a perfectly valid selector. Node filters are processed
     * in the order in which they appear, which allows you to optimize your queries for your document structure.
     *
     * ## Simple Selectors
     *
     * For performance reasons, some query methods accept selectors that are termed as **simple selectors**. A simple
     * selector is a selector that does not include contextual information about any parent/sibling elements.
     *
     * Some examples of valid simple selectors:
     *
     *     var simple = '.foo'; // Only asking for the class name on the element
     *     var simple = 'div.bar'; // Only asking for the tag/class name on the element
     *     var simple = '[href];' // Asking for an attribute on the element.
     *     var simple = ':not(.foo)'; // Only asking for the non-matches against the class name
     *     var simple = 'span:first-child'; // Doesn't require any contextual information about the parent node
     *
     * Simple examples of invalid simple selectors:
     *
     *     var notSimple = 'div.foo div.bar'; // Requires matching a parent node by class name
     *     var notSimple = 'span + div'; //  Requires matching a sibling by tag name
     *
     * ## Element Selectors:
     *
     *   - **'*'** any element
     *   - **'E'** an element with the tag E
     *   - **'E F'** All descendent elements of E that have the tag F
     *   - **'E > F'** or **E/F** all direct children elements of E that have the tag F
     *   - **'E + F'** all elements with the tag F that are immediately preceded by an element with the tag E
     *   - **'E ~ F'** all elements with the tag F that are preceded by a sibling element with the tag E
     *
     * ## Attribute Selectors:
     *
     * The use of '@' and quotes are optional. For example, 'div[@foo='bar']' is also a valid attribute selector.
     *
     *   - **'E[foo]'** has an attribute "foo"
     *   - **'E[foo=bar]'** has an attribute "foo" that equals "bar"
     *   - **'E[foo^=bar]'** has an attribute "foo" that starts with "bar"
     *   - **'E[foo$=bar]'** has an attribute "foo" that ends with "bar"
     *   - **'E[foo*=bar]'** has an attribute "foo" that contains the substring "bar"
     *   - **'E[foo%=2]'** has an attribute "foo" that is evenly divisible by 2
     *   - **'E[foo!=bar]'** attribute "foo" does not equal "bar"
     *
     * ## Pseudo Classes:
     *
     *   - **'E:first-child'** E is the first child of its parent
     *   - **'E:last-child'** E is the last child of its parent
     *   - **'E:nth-child(_n_)'** E is the _n_th child of its parent (1 based as per the spec)
     *   - **'E:nth-child(odd)'** E is an odd child of its parent
     *   - **'E:nth-child(even)'** E is an even child of its parent
     *   - **'E:only-child'** E is the only child of its parent
     *   - **'E:checked'** E is an element that is has a checked attribute that is true (e.g. a radio or checkbox)
     *   - **'E:first'** the first E in the resultset
     *   - **'E:last'** the last E in the resultset
     *   - **'E:nth(_n_)'** the _n_th E in the resultset (1 based)
     *   - **'E:odd'** shortcut for :nth-child(odd)
     *   - **'E:even'** shortcut for :nth-child(even)
     *   - **'E:contains(foo)'** E's innerHTML contains the substring "foo"
     *   - **'E:nodeValue(foo)'** E contains a textNode with a nodeValue that equals "foo"
     *   - **'E:not(S)'** an E element that does not match simple selector S
     *   - **'E:has(S)'** an E element that has a descendent that matches simple selector S
     *   - **'E:next(S)'** an E element whose next sibling matches simple selector S
     *   - **'E:prev(S)'** an E element whose previous sibling matches simple selector S
     *   - **'E:any(S1|S2|S2)'** an E element which matches any of the simple selectors S1, S2 or S3
     *   - **'E:visible(true)'** an E element which is deeply visible according to {@link Ext.dom.Element#isVisible}
     *
     * ## CSS Value Selectors:
     *
     *   - **'E{display=none}'** css value "display" that equals "none"
     *   - **'E{display^=none}'** css value "display" that starts with "none"
     *   - **'E{display$=none}'** css value "display" that ends with "none"
     *   - **'E{display*=none}'** css value "display" that contains the substring "none"
     *   - **'E{display%=2}'** css value "display" that is evenly divisible by 2
     *   - **'E{display!=none}'** css value "display" that does not equal "none"
     *
     * ## XML Namespaces:
     *   - **'ns|E'** an element with tag E and namespace prefix ns
     *
     * [1]: http://www.w3.org/TR/2005/WD-css3-selectors-20051215/#selectors
     */
    export class Query {
        /**
         * Collection of matching regular expressions and code snippets.
         * Each capture group within '()' will be replace the '{}' in the select
         * statement as specified by their index.
         */
        static matchers: any;

        /**
         * Collection of operator comparison functions.
         * The default operators are '=', '!=', '^=', '$=', '*=', '%=', '|=' and '~='.
         *
         * New operators can be added as long as the match the format *c*'=' where *c*
         * is any character other than space, '>', or '<'.
         *
         * Operator functions are passed the following parameters:
         *
         * * 'propValue' : The property value to test.
         * * 'compareTo' : The value to compare to.
         */
        static operators: any;

        /**
         * Object hash of "pseudo class" filter functions which are used when filtering selections.
         * Each function is passed two parameters:
         *
         * - **c** : Array
         *     An Array of DOM elements to filter.
         *
         * - **v** : String
         *     The argument (if any) supplied in the selector.
         *
         * A filter function returns an Array of DOM elements which conform to the pseudo class.
         * In addition to the provided pseudo classes listed above such as 'first-child' and 'nth-child',
         * developers may add additional, custom psuedo class filters to select elements according to application-specific requirements.
         *
         * For example, to filter 'a' elements to only return links to __external__ resources:
         *
         *     Ext.DomQuery.pseudos.external = function(c, v) {
         *         var r = [], ri = -1;
         *         for(var i = 0, ci; ci = c[i]; i++) {
         *             // Include in result set only if it's a link to an external resource
         *             if (ci.hostname != location.hostname) {
         *                 r[++ri] = ci;
         *             }
         *         }
         *         return r;
         *     };
         *
         * Then external links could be gathered with the following statement:
         *
         *     var externalLinks = Ext.select("a:external");
         */
        static pseudos: any;

        /**
         * Compiles a selector/xpath query into a reusable function. The returned function
         * takes one parameter "root" (optional), which is the context node from where the query should start.
         * @param {String} selector The selector/xpath query
         * @param {String} [type="select"] Either "select" or "simple" for a simple selector match
         * @return {Function}
         */
        static compile(selector: string, type?: string): Function;

        /**
         * Filters an array of elements to only include matches of a simple selector
         * @param {HTMLElement[]} el An array of elements to filter
         * @param {String} selector The simple selector to test
         * @param {Boolean} nonMatches If true, it returns the elements that DON'T match the selector instead of the
         * ones that match
         * @return {HTMLElement[]} An Array of DOM elements which match the selector. If there are no matches, and empty
         * Array is returned.
         */
        static filter(el: HTMLElement, selector: string, nonMatches: boolean): HTMLElement;

        /**
         * Get the text value for a node, optionally replacing null with the defaultValue.
         * @param {Object} node The node
         * @param {String} [defaultValue] When specified, this is return as empty value.
         * @return {String} The value
         */
        static getNodeValue(node: any, defaultValue?: string): string;

        /**
         * Returns true if the passed element(s) match the passed simple selector
         * @param {String/HTMLElement/HTMLElement[]} el An element id, element or array of elements
         * @param {String} selector The simple selector to test
         * @return {Boolean}
         */
        static is(el: string|HTMLElement, selector: string): boolean;

        /**
         * Selects an array of DOM nodes using JavaScript-only implementation.
         *
         * Use {@link #select} to take advantage of browsers built-in support for CSS selectors.
         * @param {String} selector The selector/xpath query (can be a comma separated list of selectors)
         * @param {HTMLElement/String} [root=document] The start of the query.
         * @return {HTMLElement[]} An Array of DOM elements which match the selector. If there are
         * no matches, and empty Array is returned.
         */
        static jsSelect(selector: string, root?: HTMLElement|string): HTMLElement;

        /**
         * Selects an array of DOM nodes by CSS/XPath selector.
         *
         * Uses [document.querySelectorAll][0] if browser supports that, otherwise falls back to
         * {@link Ext.dom.Query#jsSelect} to do the work.
         *
         * [0]: https://developer.mozilla.org/en/DOM/document.querySelectorAll
         *
         * @param {String} path The selector/xpath query
         * @param {HTMLElement} [root=document] The start of the query.
         * @return {HTMLElement[]} An array of DOM elements (not a NodeList as returned by 'querySelectorAll').
         * @param {String} [type="select"] Either "select" or "simple" for a simple selector match (only valid when
         * used when the call is deferred to the jsSelect method)
         * @param {Boolean} [single] Pass 'true' to select only the first matching node using 'document.querySelector' (where available)
         */
        static select(path: string, root?: HTMLElement, type?: string, single?: boolean): HTMLElement;

        /**
         * Selects a single element.
         * @param {String} selector The selector/xpath query
         * @param {HTMLElement} [root=document] The start of the query.
         * @return {HTMLElement} The DOM element which matched the selector.
         */
        static selectNode(selector: string, root?: HTMLElement): HTMLElement;

        /**
         * Selects the value of a node, parsing integers and floats.
         * Returns the defaultValue, or 0 if none is specified.
         * @param {String} selector The selector/xpath query
         * @param {HTMLElement} [root=document] The start of the query.
         * @param {Number} [defaultValue] When specified, this is return as empty value.
         * @return {Number}
         */
        static selectNumber(selector: string, root?: HTMLElement, defaultValue?: number): number;

        /**
         * Selects the value of a node, optionally replacing null with the defaultValue.
         * @param {String} selector The selector/xpath query
         * @param {HTMLElement} [root=document] The start of the query.
         * @param {String} [defaultValue] When specified, this is return as empty value.
         * @return {String}
         */
        static selectValue(selector: string, root?: HTMLElement, defaultValue?: string): string;
    }

    interface ShadowConfig extends Ext.dom.UnderlayConfig {
        /**
         * The shadow display mode.  Supports the following options:
         *
         * - sides : Shadow displays on both sides and bottom only
         * - frame : Shadow displays equally on all four sides
         * - drop : Traditional bottom-right drop shadow
         */
        mode?: string;

        /**
         * The number of pixels to offset the shadow from the element
         */
        offset?: number;
    }

    /**
     * Simple class that can provide a shadow effect for any absolutely positioned {@link
     * Ext.dom.Element Element}.
     *
     * Not meant to be used directly. To apply a shadow to an Element use the
     * {@link Ext.dom.Element#enableShadow enableShadow} method.
     */
    export class Shadow extends Ext.dom.Underlay implements Ext.dom.ShadowConfig {
        /**
         * The offsets used for positioning the shadow element
         * relative to its target element
         */
        offsets: any;

        /**
         * Offsets that represent the union of the areas
         * of the target element and the shadow combined.  Used by Ext.dom.Element for
         * ensuring that the shim (if present) extends under the full area of both elements.
         */
        outerOffsets: any;

        /**
         * The shadow display mode.  Supports the following options:
         *
         * - sides : Shadow displays on both sides and bottom only
         * - frame : Shadow displays equally on all four sides
         * - drop : Traditional bottom-right drop shadow
         */
        mode: string;

        /**
         * The number of pixels to offset the shadow from the element
         */
        offset: number;

        protected beforeShow();

        /**
         * Creates new Shadow.
         * @param {Object} config (optional) Config object.
         */
        constructor(config: Ext.dom.ShadowConfig);

        /**
         * Sets the opacity of the shadow
         * @param {Number} opacity The opacity
         */
        setOpacity(opacity: number);
    }

    /**
     * Simple class that provides an iframe shim for any absolutely positioned {@link
     * Ext.dom.Element Element} to prevent windowed objects from showing through.
     *
     * Not meant to be used directly. Internally shims are applied to Elements using
     * {@link Ext.dom.Element#enableShim enableShim}.  Developers should use the
     * {@link Ext.util.Floating#shim shim} config to add shims to their
     * {@link Ext.Component Components} or set {@link Ext#useShims Ext.useShims}=true.
     */
    export class Shim extends Ext.dom.Underlay {
        constructor(config: any);
    }

    interface UnderlayConfig {
        /**
         * The target element
         */
        target?: Ext.dom.Element;

        /**
         * The CSS z-index to use for this underlay.  Defaults to the z-index of {@link #target}.
         */
        zIndex?: number;
    }

    /**
     * A class that provides an underlay element which displays behind an absolutely positioned
     * target element and tracks its size and position. Abstract base class for
     * {@link Ext.dom.Shadow} and {@link Ext.dom.Shim}
     *
     *
     * @abstract
     */
    export class Underlay extends Ext.Base implements Ext.dom.UnderlayConfig {
        /**
         * The target element
         */
        target: Ext.dom.Element;

        /**
         * The CSS z-index to use for this underlay.  Defaults to the z-index of {@link #target}.
         */
        zIndex: number;

        /**
         * Called before the underlay is shown, immediately after its element is retrieved
         * from the pool
         */
        protected beforeShow();

        /**
         * Returns the dom element that this underlay should be inserted before.
         * Defaults to the target element
         * @return {Ext.dom.Element}
         */
        protected getInsertionTarget(): Ext.dom.Element;

        /**
         * @return {Ext.dom.UnderlayPool}
         */
        protected getPool(): Ext.dom.UnderlayPool;

        /**
         * Hides the underlay
         */
        hide();

        /**
         * Aligns the underlay to its target element
         * @param {Number} [x] The x position of the target element.  If not provided, the
         * x position will be read from the DOM.
         * @param {Number} [y] The y position of the target element.  If not provided, the
         * y position will be read from the DOM.
         * @param {Number} [width] The width of the target element.  If not provided, the
         * width will be read from the DOM.
         * @param {Number} [height] The height of the target element.  If not provided, the
         * height will be read from the DOM.
         */
        realign(x?: number, y?: number, width?: number, height?: number);

        /**
         * Adjust the z-index of this underlay
         * @param {Number} zIndex The new z-index
         */
        setZIndex(zIndex: number);

        /**
         * Shows the underlay
         */
        show();
    }

    /**
     * Private utility class that manages the internal cache for {@link Ext.dom.Shadow Underlays}
     * and {@link Ext.dom.Shim Shims}.
     */
    export class UnderlayPool extends Ext.Base {
        /**
         * Checks an element back into the pool for future reuse
         */
        checkIn(el: Ext.dom.Element);

        /**
         * Checks an element out of the pool.
         * @return {Ext.dom.Element}
         */
        checkOut(): Ext.dom.Element;

        /**
         * @constructor
         * @param {Object} elementConfig A {@link Ext.dom.Helper DomHelper} config object to
         * use for generating elements in the pool.
         */
        constructor(elementConfig: any);

        /**
         * Reset the pool by emptying the cache and destroying all its elements
         */
        reset();
    }
}

declare module Ext.draw {
    /**
     * Singleton class that manages the animation pool.
     */
    export class Animator {
        /**
         * Adds an animated object to the animation pool.
         *
         * @param {Object} animation The animation descriptor to add to the pool.
         */
        static add(animation: any);

        /**
         * Register a recursive callback that will be called at every frame.
         *
         * @return {String}
         */
        static addFrameCallback(callback: Function, scope: any): string;

        /**
         *  Cross platform 'animationTime' implementation.
         *  @return {Number}
         */
        static animationTime();

        /**
         * Cancel a registered one-time callback
         */
        static cancel(id: string);

        /**
         * Returns 'true' or 'false' whether it contains the given animation or not.
         *
         * @param {Object} animation The animation to check for.
         * @return {Boolean}
         */
        static contains(animation: any): boolean;

        /**
         * Returns 'true' or 'false' whether the pool is empty or not.
         * @return {Boolean}
         */
        static empty(): boolean;

        /**
         * Removes an animation from the pool.
         * TODO: This is broken when called within 'step' method.
         * @param {Object} animation The animation to remove from the pool.
         */
        static remove(animation: any);

        /**
         * Unregister a recursive callback.
         */
        static removeFrameCallback(id: string);

        /**
         * Register a one-time callback that will be called at the next frame.
         * @return {String} The ID of the scheduled callback.
         */
        static schedule(callback: Function|string, scope: any): string;

        /**
         * Register a one-time callback that will be called at the next frame,
         * if that callback (with a matching function and scope) isn't already scheduled.
         * @return {String/null} The ID of the scheduled callback or null, if that callback has already been scheduled.
         */
        static scheduleIf(callback: Function|string, scope: any): string;

        /**
         * Given a frame time it will filter out finished animations from the pool.
         *
         * @param {Number} frameTime The frame's start time, in milliseconds.
         */
        static step(frameTime: number);
    }

    interface ColorConfig {
        /**
         * The default factor to compute the lighter or darker color.
         */
        lightnessFactor?: number;
    }

    /**
     * Represents an RGB color and provides helper functions on it e.g. to get
     * color components in HSL color space.
     */
    export class Color extends Ext.Base implements Ext.draw.ColorConfig {
        /**
         * The default factor to compute the lighter or darker color.
         */
        lightnessFactor: number;

        /**
         * @constructor
         * @param {Number} red Red component (0..255)
         * @param {Number} green Green component (0..255)
         * @param {Number} blue Blue component (0..255)
         * @param {Number} [alpha=1] (optional) Alpha component (0..1)
         */
        constructor(red: number, green: number, blue: number, alpha?: number);

        /**
         * Returns a new color that is darker than this color in the HSL color space.
         * @param {Number} [factor=0.2] Darker factor (0..1).
         * @return {Ext.draw.Color}
         */
        createDarker(factor?: number): Ext.draw.Color;

        /**
         * Returns a new color that is lighter than this color in the HSL color space.
         * @param {Number} [factor=0.2] Lighter factor (0..1).
         * @return {Ext.draw.Color}
         */
        createLighter(factor?: number): Ext.draw.Color;

        /**
         * Returns the gray value (0 to 255) of the color.
         *
         * The gray value is calculated using the formula r*0.3 + g*0.59 + b*0.11.
         *
         * @return {Number}
         */
        getGrayscale(): number;

        /**
         * Get the equivalent HSL components of the color.
         * @return {Number[]}
         */
        getHSL(): number;

        /**
         * Get the equivalent HSV components of the color.
         * @return {Number[]}
         */
        getHSV(): number;

        /**
         * Parse the string and set the current color.
         *
         * Supported formats:
         *
         * + '#rrggbb'
         * + '#rgb', 'rgb(r,g,b)'
         * + 'rgba(r,g,b,a)'
         * + supported CSS color names (e.g., 'black', 'white', etc).
         *
         * If the string is not recognized, setFromString returns rgba(0,0,0,0).
         *
         * @param {String} Color Color as string.
         * @return this
         */
        setFromString(Color: string);

        /**
         * Set current color based on the specified HSL values.
         *
         * @param {Number} h Hue component [0..360)
         * @param {Number} s Saturation component [0..1]
         * @param {Number} l Lightness component [0..1]
         * @return {Ext.draw.Color}
         */
        setHSL(h: number, s: number, l: number): Ext.draw.Color;

        /**
         * Set current color based on the specified HSV values.
         *
         * @param {Number} h Hue component [0..360)
         * @param {Number} s Saturation component [0..1]
         * @param {Number} v Value component [0..1]
         * @return {Ext.draw.Color}
         */
        setHSV(h: number, s: number, v: number): Ext.draw.Color;

        /**
         * Convert a color to hexadecimal format.
         *
         * @param {String/Array} color The color value (i.e 'rgb(255, 255, 255)', 'color: #ffffff').
         * Can also be an Array, in this case the function handles the first member.
         * @return {String} The color in hexadecimal format.
         */
        toHex(color: string|any[]): string;

        /**
         * toString() returns a color in hex format ('#rrggbb') if the alpha is 1. If the
         * alpha is less than one, toString() returns the color in RGBA format ('rgba(255,0,0,0.3)').
         *
         * @return {String}
         */
        toString(): string;

        /**
         * Returns a flyweight instance of Ext.draw.Color.
         *
         * Can be called with either a CSS color string or with separate
         * arguments for red, green, blue, alpha.
         *
         * @param {Number/String} red Red component (0..255) or CSS color string.
         * @param {Number} [green] Green component (0..255)
         * @param {Number} [blue] Blue component (0..255)
         * @param {Number} [alpha=1] Alpha component (0..1)
         * @return {Ext.draw.Color}
         */
        static fly(red: number|string, green?: number, blue?: number, alpha?: number): Ext.draw.Color;

        /**
         * Create a new color based on the specified HSL values.
         *
         * @param {Number} h Hue component [0..360)
         * @param {Number} s Saturation component [0..1]
         * @param {Number} l Lightness component [0..1]
         * @return {Ext.draw.Color}
         */
        static fromHSL(h: number, s: number, l: number): Ext.draw.Color;

        /**
         * Create a new color based on the specified HSV values.
         *
         * @param {Number} h Hue component [0..360)
         * @param {Number} s Saturation component [0..1]
         * @param {Number} v Value component [0..1]
         * @return {Ext.draw.Color}
         */
        static fromHSV(h: number, s: number, v: number): Ext.draw.Color;

        /**
         * Parse the string and create a new color.
         *
         * Supported formats:
         *
         * + '#rrggbb'
         * + '#rgb', 'rgb(r,g,b)'
         * + 'rgba(r,g,b,a)'
         * + supported CSS color names (e.g., 'black', 'white', etc).
         *
         * If the string is not recognized, fromString returns rgba(0,0,0,0).
         *
         * @param {String} color Color as string.
         * @return {Ext.draw.Color}
         */
        static fromString(color: string): Ext.draw.Color;
    }

    interface ContainerConfig {
        /**
         * Defines the engine (type of surface) used to render draw container contents.
         *
         * The render engine is selected automatically depending on the platform used. Priority
         * is given to the {@link Ext.draw.engine.Canvas} engine due to its performance advantage.
         *
         * You may also set the engine config to be 'Ext.draw.engine.Svg' if so desired.
         *
         * Optional, Defaults to: "Ext.draw.engine.Canvas"
         */
        engine?: string;

        /**
         * Defines a set of gradients that can be used as color properties
         * (fillStyle and strokeStyle, but not shadowColor) in sprites.
         * The gradients array is an array of objects with the following properties:
         * - **id** - string - The unique name of the gradient.
         * - **type** - string, optional - The type of the gradient. Available types are: 'linear', 'radial'. Defaults to 'linear'.
         * - **angle** - number, optional - The angle of the gradient in degrees.
         * - **stops** - array - An array of objects with 'color' and 'offset' properties, where 'offset' is a real number from 0 to 1.
         *
         * For example:
         *
         *     gradients: [{
         *         id: 'gradientId1',
         *         type: 'linear',
         *         angle: 45,
         *         stops: [{
         *             offset: 0,
         *             color: 'red'
         *         }, {
         *            offset: 1,
         *            color: 'yellow'
         *         }]
         *     }, {
         *        id: 'gradientId2',
         *        type: 'radial',
         *        stops: [{
         *            offset: 0,
         *            color: '#555',
         *        }, {
         *            offset: 1,
         *            color: '#ddd',
         *        }]
         *     }]
         *
         * Then the sprites can use 'gradientId1' and 'gradientId2' by setting the color attributes to those ids, for example:
         *
         *     sprite.setAttributes({
         *         fillStyle: 'url(#gradientId1)',
         *         strokeStyle: 'url(#gradientId2)'
         *     });
         */
        gradients?: any;

        /**
         * The resize function that can be configured to have a behavior,
         * e.g. resize draw surfaces based on new draw container dimensions.
         *
         * __Note:__ since resize events trigger {@link #renderFrame} calls automatically,
         * return 'false' from the resize function, if it also calls 'renderFrame',
         * to prevent double rendering.
         *
         * Optional
         */
        resizeHandler?: Function;

        /**
         * Defines a set of sprites to be added to the drawContainer surface.
         *
         * For example:
         *
         *      sprites: [{
         *           type: 'circle',
         *           fillStyle: '#79BB3F',
         *           r: 100,
         *           x: 100,
         *           y: 100
         *      }]
         */
        sprites?: any;
    }

    /**
     * The container that holds and manages instances of the {@link Ext.draw.Surface}
     * in which {@link Ext.draw.sprite.Sprite sprites} are rendered.  Draw containers are
     * used as the foundation for all of the chart classes but may also be created directly
     * in order to create custom drawings.
     *
     *     @example
     *     var drawContainer = Ext.create('Ext.draw.Container', {
     *         renderTo: Ext.getBody(),
     *         width:200,
     *         height:200,
     *         sprites: [{
     *             type: 'circle',
     *             fillStyle: '#79BB3F',
     *             r: 100,
     *             x: 100,
     *             y: 100
     *          }]
     *     });
     *
     * In the previous example we created a draw container and configured it with a single
     * sprite.  The *type* of the sprite is {@link Ext.draw.sprite.Circle circle}, so if you
     * run this code you'll see a green circle.
     *
     * You can attach sprite event listeners to the draw container with the help of the
     * {@link Ext.draw.plugin.SpriteEvents} plugin.
     *
     * For more information on sprites, the core elements added to a draw container's
     * surface, refer to the Ext.draw.sprite.Sprite documentation.
     *
     * For more information on surfaces, the interface owned by the draw container used to
     * manage all sprites, see the Ext.draw.Surface documentation.
     */
    export class Container implements Ext.draw.ContainerConfig {
        /**
         * The default URL used by {@link #download}.
         *
         * Optional, Defaults to: "http://svg.sencha.io"
         */
        defaultDownloadServerUrl: string;

        /**
         * Defines the engine (type of surface) used to render draw container contents.
         *
         * The render engine is selected automatically depending on the platform used. Priority
         * is given to the {@link Ext.draw.engine.Canvas} engine due to its performance advantage.
         *
         * You may also set the engine config to be 'Ext.draw.engine.Svg' if so desired.
         *
         * Optional, Defaults to: "Ext.draw.engine.Canvas"
         */
        engine: string;

        /**
         * Defines a set of gradients that can be used as color properties
         * (fillStyle and strokeStyle, but not shadowColor) in sprites.
         * The gradients array is an array of objects with the following properties:
         * - **id** - string - The unique name of the gradient.
         * - **type** - string, optional - The type of the gradient. Available types are: 'linear', 'radial'. Defaults to 'linear'.
         * - **angle** - number, optional - The angle of the gradient in degrees.
         * - **stops** - array - An array of objects with 'color' and 'offset' properties, where 'offset' is a real number from 0 to 1.
         *
         * For example:
         *
         *     gradients: [{
         *         id: 'gradientId1',
         *         type: 'linear',
         *         angle: 45,
         *         stops: [{
         *             offset: 0,
         *             color: 'red'
         *         }, {
         *            offset: 1,
         *            color: 'yellow'
         *         }]
         *     }, {
         *        id: 'gradientId2',
         *        type: 'radial',
         *        stops: [{
         *            offset: 0,
         *            color: '#555',
         *        }, {
         *            offset: 1,
         *            color: '#ddd',
         *        }]
         *     }]
         *
         * Then the sprites can use 'gradientId1' and 'gradientId2' by setting the color attributes to those ids, for example:
         *
         *     sprite.setAttributes({
         *         fillStyle: 'url(#gradientId1)',
         *         strokeStyle: 'url(#gradientId2)'
         *     });
         */
        gradients: any;

        /**
         * The resize function that can be configured to have a behavior,
         * e.g. resize draw surfaces based on new draw container dimensions.
         *
         * __Note:__ since resize events trigger {@link #renderFrame} calls automatically,
         * return 'false' from the resize function, if it also calls 'renderFrame',
         * to prevent double rendering.
         *
         * Optional
         */
        resizeHandler: Function;

        /**
         * Defines a set of sprites to be added to the drawContainer surface.
         *
         * For example:
         *
         *      sprites: [{
         *           type: 'circle',
         *           fillStyle: '#79BB3F',
         *           r: 100,
         *           x: 100,
         *           y: 100
         *      }]
         */
        sprites: any;

        /**
         * Downloads an image or PDF of the chart / drawing or opens it in a separate
         * browser tab/window if the download can't be triggered. The exact behavior is
         * platform and browser specific. For more consistent results on mobile devices use
         * the {@link #preview} method instead.
         *
         * @param {Object} [config] The following config options are supported:
         *
         * @param {String} config.url The url to post the data to. Defaults to
         * the {@link #defaultDownloadServerUrl} configuration on the class.
         *
         * @param {String} config.format The format of image to export. See the
         * {@link #supportedFormats}. Defaults to 'png' on the Sencha IO server.
         * Note that you can't export to 'svg' format if the {@link Ext.draw.engine.Canvas Canvas}
         * {@link Ext.draw.Container#engine engine} is used.
         *
         * @param {Number} config.width A width to send to the server for
         * configuring the image width. Defaults to natural image width on
         * the Sencha IO server.
         *
         * @param {Number} config.height A height to send to the server for
         * configuring the image height. Defaults to natural image height on
         * the Sencha IO server.
         *
         * @param {String} config.filename The filename of the downloaded image.
         * Defaults to 'chart' on the Sencha IO server. The config.format is used
         * as a filename extension.
         *
         * @param {Number} config.scale The scaling of the downloaded image.
         * Defaults to 1 on the Sencha IO server. The server will try to determine the natural
         * size of the image unless the width/height configs have been set. If the
         * {@link Ext.draw.engine.Canvas Canvas} {@link Ext.draw.Container#engine engine} is
         * used the natural image size will depend on the value of the window.devicePixelRatio.
         * For example, for devices with devicePixelRatio of 2 the produced image will be
         * two times larger than for devices with devicePixelRatio of 1 for the same drawing.
         * This is done so that the users with devices with HiDPI screens get a downloaded
         * image that looks as crisp on their device as the original drawing.
         * If you want image size to be consistent across devices with different device
         * pixel ratios, you can set the value of this config to 1/devicePixelRatio.
         * This parameter is ignored by the Sencha IO server if config.format is set to 'svg'.
         *
         * @param {Object} config.pdf PDF specific options.
         * This config is only used if config.format is set to 'pdf'.
         * The given object should be in either this format:
         *
         *     {
         *       width: '200px',
         *       height: '300px',
         *       border: '0px'
         *     }
         *
         * or this format:
         *
         *     {
         *       format: 'A4',
         *       orientation: 'portrait',
         *       border: '1cm'
         *     }
         *
         * Supported dimension units are: 'mm', 'cm', 'in', 'px'. No unit means 'px'.
         * Supported formats are: 'A3', 'A4', 'A5', 'Legal', 'Letter', 'Tabloid'.
         * Orientation ('portrait', 'landscape') is optional and defaults to 'portrait'.
         *
         * @param {Object} config.jpeg JPEG specific options.
         * This config is only used if config.format is set to 'jpeg'.
         * The given object should be in this format:
         *
         *     {
         *       quality: 80
         *     }
         *
         * Where quality is an integer between 0 and 100.
         *
         * @return {Boolean} True if request was successfully sent to the server.
         */
        download(config?: Ext.draw.ContainerConfig, config_url?: string, config_format?: string, config_width?: number, config_height?: number, config_filename?: string, config_scale?: number, config_pdf?: any, config_jpeg?: any): boolean;

        getCls();

        getGradients();

        /**
         * Produces an image of the chart / drawing.
         * @param {String} [format] Possible options are 'image' (the method will return an
         * Image object) and 'stream' (the method will return the image as a byte stream).
         * If missing, the data URI of the drawing's (or chart's) image will be returned.
         * Note: for an SVG based drawing/chart in IE/Edge browsers the method will always
         * return SVG markup instead of a data URI, as 'img' elements won't accept a data
         * URI anyway in those browsers.
         * @return {Object}
         * @return {String} return.data Image element, byte stream or DataURL.
         * @return {String} return.type The type of the data (e.g. 'png' or 'svg').
         */
        getImage(format?: string): any;

        getResizeHandler();

        getSprites();

        /**
         * Get a surface by the given id or create one if it doesn't exist.
         * @param {String} [id="main"]
         * @return {Ext.draw.Surface}
         */
        getSurface(id?: string): Ext.draw.Surface;

        /**
         * Displays an image of a Ext.draw.Container on screen.
         * On mobile devices this lets users tap-and-hold to bring up the menu
         * with image saving options.
         * Note: some browsers won't save the preview image if it's SVG based
         * (i.e. generated from a draw container that uses 'Ext.draw.engine.Svg' engine).
         * And some platforms may not have the means of viewing successfully saved SVG images.
         */
        preview();

        /**
         * Render all the surfaces in the container.
         */
        renderFrame();

        setCls();

        setGradients();

        setResizeHandler();

        setSprites();

        /**
         * Fires when the size of the draw container body changes.
         * @param {Object} size The object containing 'width' and 'height' of the draw container's body.
         */
        bodyresize(size: any);

        /**
         * Fires when a click event occurs on a sprite.
         */
        spriteclick(sprite: any, event: Event);

        /**
         * Fires when a double click event occurs on a sprite.
         */
        spritedblclick(sprite: any, event: Event);

        /**
         * Fires when a mousedown event occurs on a sprite.
         */
        spritemousedown(sprite: any, event: Event);

        /**
         * Fires when the mouse is moved on a sprite.
         */
        spritemousemove(sprite: any, event: Event);

        /**
         * Fires when the mouse exits a sprite.
         */
        spritemouseout(sprite: any, event: Event);

        /**
         * Fires when the mouse enters a sprite.
         */
        spritemouseover(sprite: any, event: Event);

        /**
         * Fires when a mouseup event occurs on a sprite.
         */
        spritemouseup(sprite: any, event: Event);

        /**
         * Fires when a tap event occurs on a sprite.
         */
        spritetap(sprite: any, event: Event);
    }

    /**
     * Utility class providing mathematics functionalities through all the draw package.
     */
    export class Draw {
        /**
         * Converting radians to degrees.
         * @return {Number}
         */
        static degrees(radian: number): number;

        /**
         * @param {Number} [padding]
         * @return {Boolean}
         */
        static isBBoxIntersect(bbox1: any, bbox2: any, padding?: number): boolean;

        /**
         * Checks if a point is within a bounding box.
         * @return {Boolean}
         */
        static isPointInBBox(): boolean;

        /**
         * Converting degrees to radians.
         * @return {Number}
         */
        static rad(degrees: number): number;

        /**
         * @deprecated Please use the {@link Ext#identityFn} instead.
         * Function that returns its first element.
         * @return {Mixed}
         */
        static reflectFn(a: any): any;

        /**
         * Given coordinates of the points, calculates coordinates of a Bezier curve that goes through them.
         * @param dataX x-coordinates of the points.
         * @param dataY y-coordinates of the points.
         * @param value A value to control the smoothness of the curve.
         * @return {Object} Object holding two arrays, for x and y coordinates of the curve.
         */
        static smooth(): any;

        /**
         * Natural cubic spline interpolation.
         * This algorithm runs in linear time.
         *
         * @param {Array} points Array of numbers.
         */
        static spline(points: any[]);
    }

    interface LimitedCacheConfig {
        /**
         * Function that generates the object when look-up failed.
         * @return {Number}
         */
        feeder?: any;

        /**
         * The amount limit of the cache.
         */
        limit?: any;

        /**
         * The scope for {@link #feeder}
         */
        scope?: any;
    }

    /**
     * Limited cache is a size limited cache container that stores limited number of objects.
     *
     * When {@link #get} is called, the container will try to find the object in the list.
     * If failed it will call the {@link #feeder} to create that object. If there are too many
     * objects in the container, the old ones are removed.
     *
     * __Note:__ This is not using a Least Recently Used policy due to simplicity and performance consideration.
     */
    export class LimitedCache extends Ext.Base implements Ext.draw.LimitedCacheConfig {
        /**
         * Function that generates the object when look-up failed.
         * @return {Number}
         */
        feeder: any;

        /**
         * The amount limit of the cache.
         */
        limit: any;

        /**
         * The scope for {@link #feeder}
         */
        scope: any;

        /**
         * Clear all the objects.
         */
        clear();

        constructor(config: Ext.draw.LimitedCacheConfig);

        /**
         * Get a cached object.
         * @param {Mixed...} args Arguments appended to feeder.
         * @return {Object}
         */
        get(id: string, args: any): any;

        getFeeder();

        getLimit();

        getScope();

        setFeeder();

        setLimit();

        setScope();
    }

    /**
     * Ext.draw.Matix is a utility class used to calculate
     * [affine transformation](http://en.wikipedia.org/wiki/Affine_transformation) matrix.
     * The matrix class is used to apply transformations to existing
     * {@link Ext.draw.sprite.Sprite sprites} using a number of convenience transform
     * methods.
     *
     * Transformations configured directly on a sprite are processed in the following order:
     * scaling, rotation, and translation.  The matrix class offers additional flexibility.
     * Once a sprite is created, you can use the matrix class's transform methods as many
     * times as needed and in any order you choose.
     *
     * To demonstrate, we'll start with a simple {@link Ext.draw.sprite.Rect rect} sprite
     * with the intent of rotating it 180 degrees with the bottom right corner being the
     * center of rotation.  To begin, let's look at the initial, untransformed sprite:
     *
     *     @example
     *     var drawContainer = new Ext.draw.Container({
     *         renderTo: Ext.getBody(),
     *         width: 380,
     *         height: 380,
     *         sprites: [{
     *             type: 'rect',
     *             width: 100,
     *             height: 100,
     *             fillStyle: 'red'
     *         }]
     *     });
     *
     * Next, we'll use the {@link #rotate} and {@link #translate} methods from our matrix
     * class to position the rect sprite.
     *
     *     @example
     *     var drawContainer = new Ext.draw.Container({
     *         renderTo: Ext.getBody(),
     *         width: 380,
     *         height: 380,
     *         sprites: [{
     *             type: 'rect',
     *             width: 100,
     *             height: 100,
     *             fillStyle: 'red'
     *         }]
     *     });
     *
     *     var main = drawContainer.getSurface();
     *     var rect = main.getItems()[0];
     *
     *     var m = new Ext.draw.Matrix().translate(100, 100).
     *     rotate(Math.PI).
     *     translate(-100, - 100);
     *
     *     rect.setTransform(m);
     *     main.renderFrame();
     *
     * In the previous example we perform the following steps in order to achieve our
     * desired rotated output:
     *
     *  - translate the rect to the right and down by 100
     *  - rotate by 180 degrees
     *  - translate the rect to the right and down by 100
     *
     * **Note:** A couple of things to note at this stage; 1) the rotation center point is
     * the upper left corner of the sprite by default and 2) with transformations, the
     * sprite itself isn't transformed, but rather the entire coordinate plane of the sprite
     * is transformed.  The coordinate plane itself is translated by 100 and then rotated
     * 180 degrees.  And that is why in the third step we translate the sprite using
     * negative values.  Translating by -100 in the third step results in the sprite
     * visually moving to the right and down within the draw container.
     *
     * Fortunately there is a shortcut we can apply using two optional params of the rotate
     * method allowing us to specify the center point of rotation:
     *
     *     @example
     *     var drawContainer = new Ext.draw.Container({
     *         renderTo: Ext.getBody(),
     *         width: 380,
     *         height: 380,
     *         sprites: [{
     *             type: 'rect',
     *             width: 100,
     *             height: 100,
     *             fillStyle: 'red'
     *         }]
     *     });
     *
     *     var main = drawContainer.getSurface();
     *     var rect = main.getItems()[0];
     *
     *     var m = new Ext.draw.Matrix().rotate(Math.PI, 100, 100);
     *
     *     rect.setTransform(m);
     *     main.renderFrame();
     *
     *
     * This class is compatible with
     * [SVGMatrix](http://www.w3.org/TR/SVG11/coords.html#InterfaceSVGMatrix) except:
     *
     *   1. Ext.draw.Matrix is not read only
     *   2. Using Number as its values rather than floats
     *
     * Using this class helps to reduce the severe numeric
     * [problem with HTML Canvas and SVG transformation](http://stackoverflow.com/questions/8784405/large-numbers-in-html-canvas-translate-result-in-strange-behavior)
     *
     * Additionally, there's no way to get the current transformation matrix
     * [in Canvas](http://stackoverflow.com/questions/7395813/html5-canvas-get-transform-matrix).
     */
    export class Matrix extends Ext.Base {
        /**
         * Get x-to-x component of the matrix. Avoid using it for performance consideration.
         * Use {@link #getXX} instead.
         */
        a: number;

        /**
         * Postpend a matrix onto the current.
         *
         * __Note:__ The given transform will come before the current one.
         *
         * @param {Number} xx Coefficient from x to x.
         * @param {Number} xy Coefficient from x to y.
         * @param {Number} yx Coefficient from y to x.
         * @param {Number} yy Coefficient from y to y.
         * @param {Number} dx Offset of x.
         * @param {Number} dy Offset of y.
         * @return {Ext.draw.Matrix} this
         */
        append(xx: number, xy: number, yx: number, yy: number, dx: number, dy: number): Ext.draw.Matrix;

        /**
         * Postpend a matrix onto the current.
         *
         * __Note:__ The given transform will come before the current one.
         *
         * @return {Ext.draw.Matrix} this
         */
        appendMatrix(matrix: Ext.draw.Matrix): Ext.draw.Matrix;

        /**
         * Clone this matrix.
         * @return {Ext.draw.Matrix}
         */
        clone(): Ext.draw.Matrix;

        /**
         * Create an affine transform matrix.
         *
         * @param {Number} xx Coefficient from x to x
         * @param {Number} xy Coefficient from x to y
         * @param {Number} yx Coefficient from y to x
         * @param {Number} yy Coefficient from y to y
         * @param {Number} dx Offset of x
         * @param {Number} dy Offset of y
         */
        constructor(xx: number, xy: number, yx: number, yy: number, dx: number, dy: number);

        /**
         * @deprecated
         * @since 6.0.1
         * Determines if this matrix has the same values as another matrix.
         * @return {Boolean}
         */
        equals(matrix: Ext.draw.Matrix): boolean;

        /**
         * Horizontally flip the matrix
         * @return {Ext.draw.Matrix} this
         */
        flipX(): Ext.draw.Matrix;

        /**
         * Vertically flip the matrix
         * @return {Ext.draw.Matrix} this
         */
        flipY(): Ext.draw.Matrix;

        /**
         * Get offset x component of the matrix.
         * @return {Number}
         */
        getDX(): number;

        /**
         * Get offset y component of the matrix.
         * @return {Number}
         */
        getDY(): number;

        /**
         * Get the x scale of the matrix.
         * @return {Number}
         */
        getScaleX(): number;

        /**
         * Get the y scale of the matrix.
         * @return {Number}
         */
        getScaleY(): number;

        /**
         * Get x-to-x component of the matrix
         * @return {Number}
         */
        getXX(): number;

        /**
         * Get x-to-y component of the matrix.
         * @return {Number}
         */
        getXY(): number;

        /**
         * Get y-to-x component of the matrix.
         * @return {Number}
         */
        getYX(): number;

        /**
         * Get y-to-y component of the matrix.
         * @return {Number}
         */
        getYY(): number;

        /**
         * Return a new matrix represents the opposite transformation of the current one.
         *
         * @param {Ext.draw.Matrix} [target] A target matrix. If present, it will receive
         * the result of inversion to avoid creating a new object.
         *
         * @return {Ext.draw.Matrix}
         */
        inverse(target?: Ext.draw.Matrix): Ext.draw.Matrix;

        /**
         * Determines if this matrix has the same values as another matrix.
         * @param {Ext.draw.Matrix} matrix A maxtrix or array of its elements.
         * @return {Boolean}
         */
        isEqual(matrix: Ext.draw.Matrix): boolean;

        /**
         * Determines whether this matrix is an identity matrix (no transform).
         * @return {Boolean}
         */
        isIdentity(): boolean;

        /**
         * Performs matrix multiplication. This matrix is post-multiplied by another matrix.
         *
         * __Note:__ The given transform will come before the current one.
         *
         * @return {Ext.draw.Matrix} this
         */
        multiply(matrix: Ext.draw.Matrix): Ext.draw.Matrix;

        /**
         * Prepend a matrix onto the current.
         *
         * __Note:__ The given transform will come after the current one.
         *
         * @param {Number} xx Coefficient from x to x.
         * @param {Number} xy Coefficient from x to y.
         * @param {Number} yx Coefficient from y to x.
         * @param {Number} yy Coefficient from y to y.
         * @param {Number} dx Offset of x.
         * @param {Number} dy Offset of y.
         * @return {Ext.draw.Matrix} this
         */
        prepend(xx: number, xy: number, yx: number, yy: number, dx: number, dy: number): Ext.draw.Matrix;

        /**
         * Prepend a matrix onto the current.
         *
         * __Note:__ The given transform will come after the current one.
         * @return {Ext.draw.Matrix} this
         */
        prependMatrix(matrix: Ext.draw.Matrix): Ext.draw.Matrix;

        /**
         * Reset the matrix to identical.
         * @return {Ext.draw.Matrix} this
         */
        reset(): Ext.draw.Matrix;

        /**
         * Rotate the matrix.
         *
         * @param {Number} angle Radians to rotate
         * @param {Number|null} rcx Center of rotation.
         * @param {Number|null} rcy Center of rotation.
         * @param {Boolean} [prepend] If 'true', this will transformation be prepended to the matrix.
         * @return {Ext.draw.Matrix} this
         */
        rotate(angle: number, rcx?: number, rcy?: number, prepend?: boolean): Ext.draw.Matrix;

        /**
         * Rotate the matrix by the angle of a vector.
         *
         * @param {Boolean} [prepend] If 'true', this will transformation be prepended to the matrix.
         * @return {Ext.draw.Matrix} this
         */
        rotateFromVector(x: number, y: number, prepend?: boolean): Ext.draw.Matrix;

        /**
         * Scale the matrix.
         *
         * @param {Boolean} [prepend] If 'true', this will transformation be prepended to the matrix.
         * @return {Ext.draw.Matrix} this
         */
        scale(sx: number, sy: number, scx: number, scy: number, prepend?: boolean): Ext.draw.Matrix;

        /**
         * Set the elements of a Matrix
         * @return {Ext.draw.Matrix} this
         */
        set(xx: number, xy: number, yx: number, yy: number, dx: number, dy: number): Ext.draw.Matrix;

        /**
         * Shear the matrix along the x-axis.
         * @param factor The horizontal shear factor.
         * @return {Ext.draw.Matrix} this
         */
        shearX(): Ext.draw.Matrix;

        /**
         * Shear the matrix along the y-axis.
         * @param factor The vertical shear factor.
         * @return {Ext.draw.Matrix} this
         */
        shearY(): Ext.draw.Matrix;

        /**
         * Skew the matrix
         * @return {Ext.draw.Matrix} this
         */
        skewX(angle: number): Ext.draw.Matrix;

        /**
         * Skew the matrix
         * @return {Ext.draw.Matrix} this
         */
        skewY(angle: number): Ext.draw.Matrix;

        /**
         * Splits this transformation matrix into Scale, Rotate, Translate components,
         * assuming it was produced by applying transformations in that order.
         * @return {Object}
         */
        split(): any;

        /**
         * Create an array of elements by horizontal order (xx,yx,dx,yx,yy,dy).
         * @return {Array}
         */
        toArray(): any[];

        /**
         * Apply the matrix to a drawing context.
         * @return {Ext.draw.Matrix} this
         */
        toContext(ctx: any): Ext.draw.Matrix;

        /**
         * Get an array of elements.
         * The numbers are rounded to keep only 4 decimals.
         * @return {Array}
         */
        toString(): any[];

        /**
         * Return a string that can be used as transform attribute in SVG.
         * @return {String}
         */
        toSvg(): string;

        /**
         * Create an array of elements by vertical order (xx,xy,yx,yy,dx,dy).
         * @return {Array|String}
         */
        toVerticalArray(): any[]|string;

        /**
         * @param {Object} bbox Given as '{x: Number, y: Number, width: Number, height: Number}'.
         * @param {Number} [radius]
         * @param {Object} [target] Optional target object to recieve the result.
         * Recommended to use it for better gc.
         *
         * @return {Object} Object with x, y, width and height.
         */
        transformBBox(bbox: any, radius?: number, target?: any): any;

        /**
         * Transform a list for points.
         *
         * __Note:__ will change the original list but not points inside it.
         * @return {Array} list
         */
        transformList(list: any[]): any[];

        /**
         * Transform a point to a new array.
         * @return {Array}
         */
        transformPoint(point: any[]): any[];

        /**
         * Translate the matrix.
         *
         * @param {Boolean} [prepend] If 'true', this will transformation be prepended to the matrix.
         * @return {Ext.draw.Matrix} this
         */
        translate(x: number, y: number, prepend?: boolean): Ext.draw.Matrix;

        /**
         * Transform point returning the x component of the result.
         * @return {Number} x component of the result.
         */
        x(x: number, y: number): number;

        /**
         * Transform point returning the y component of the result.
         * @return {Number} y component of the result.
         */
        y(x: number, y: number): number;

        /**
         * Return the affine matrix that transform two points (x0, y0) and (x1, y1) to (x0p, y0p) and (x1p, y1p)
         */
        static createAffineMatrixFromTwoPair(x0: number, y0: number, x1: number, y1: number, x0p: number, y0p: number, x1p: number, y1p: number);

        /**
         * Return the affine matrix that transform two points (x0, y0) and (x1, y1) to (x0p, y0p) and (x1p, y1p)
         */
        static createPanZoomFromTwoPair(x0: number, y0: number, x1: number, y1: number, x0p: number, y0p: number, x1p: number, y1p: number);

        /**
         * Create a flyweight to wrap the given array.
         * The flyweight will directly refer the object and the elements can be changed by other methods.
         *
         * Do not hold the instance of flyweight matrix.
         *
         * @return {Ext.draw.Matrix}
         */
        static fly(elements: any[]): Ext.draw.Matrix;
    }

    /**
     * Class representing a path.
     * Designed to be compatible with [CanvasPathMethods](http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#canvaspathmethods)
     * and will hopefully be replaced by the browsers' implementation of the Path object.
     */
    export class Path extends Ext.Base {
        /**
         * Create an circular arc.
         */
        arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, anticlockwise: number);

        /**
         * [http://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes](http://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes)
         * @param {Number} rotation Differ from svg spec, this is radian.
         */
        arcSvg(rx: number, ry: number, rotation: number, fA: number, fS: number, x2: number, y2: number);

        /**
         * Create a elliptic arc curve compatible with SVG's arc to instruction.
         *
         * The curve start from ('x1', 'y1') and ends at ('x2', 'y2'). The ellipse
         * has radius 'rx' and 'ry' and a rotation of 'rotation'.
         * @param {Number} [rx]
         * @param {Number} [ry]
         * @param {Number} [rotation]
         */
        arcTo(x1: number, y1: number, x2: number, y2: number, rx?: number, ry?: number, rotation?: number);

        /**
         * A cubic bezier curve to a position.
         */
        bezierCurveTo(cx1: number, cy1: number, cx2: number, cy2: number, x: number, y: number);

        /**
         * Clear the path.
         */
        clear();

        /**
         * Clone this path.
         * @return {Ext.draw.Path}
         */
        clone(): Ext.draw.Path;

        /**
         * Close this path with a straight line.
         */
        closePath();

        /**
         * Create a path from pathString.
         * @constructor
         */
        constructor(pathString: string);

        /**
         * Create an elliptic arc.
         *
         * See [the whatwg reference of ellipse](http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-ellipse).
         */
        ellipse(cx: number, cy: number, radiusX: number, radiusY: number, rotation: number, startAngle: number, endAngle: number, anticlockwise: number);

        /**
         * Reconstruct path from cubic bezier curve stripes.
         */
        fromStripes(stripes: any[]);

        /**
         * Feed the path from svg path string.
         */
        fromSvgString(pathString: string);

        /**
         * Get the bounding box of this matrix.
         * @param {Object} [target] Optional object to receive the result.
         *
         * @return {Object} Object with x, y, width and height
         */
        getDimension(target?: any): any;

        /**
         * Get the bounding box as if the path is transformed by a matrix.
         *
         * @param {Object} [target] Optional object to receive the result.
         *
         * @return {Object} An object with x, y, width and height.
         */
        getDimensionWithTransform(matrix: Ext.draw.Matrix, target?: any): any;

        /**
         * Calculates the points where the given segment intersects the path.
         * If four parameters are given then the segment is considered to be a line segment,
         * where given parameters are the coordinates of the start and end points.
         * If eight parameters are given then the segment is considered to be
         * a cubic Bezier curve segment, where given parameters are the
         * coordinates of its edge points and control points.
         * @return {Array}
         */
        getSegmentIntersections(): any[];

        /**
         * Tests whether the given point is inside the path.
         * @return {Boolean}
         */
        isPointInPath(x: number, y: number): boolean;

        /**
         * Tests whether the given point is on the path.
         * @return {Boolean}
         */
        isPointOnPath(x: number, y: number): boolean;

        /**
         * A straight line to a position.
         */
        lineTo(x: number, y: number);

        /**
         * Move to a position.
         */
        moveTo(x: number, y: number);

        /**
         * A quadratic bezier curve to a position.
         */
        quadraticCurveTo(cx: number, cy: number, x: number, y: number);

        /**
         * Draw a rectangle and close it.
         */
        rect(x: number, y: number, width: number, height: number);

        /**
         * Return an svg path string for this path.
         * @return {String}
         */
        toString(): string;

        /**
         * Convert path to bezier curve stripes.
         * @param {Array} [target] The optional array to receive the result.
         * @return {Array}
         */
        toStripes(target?: any[]): any[];

        /**
         * Transform the current path by a matrix.
         */
        transform(matrix: Ext.draw.Matrix);
    }

    /**
     * Singleton that provides methods used by the Ext.draw.Path
     * for hit testing and finding path intersection points.
     */
    export class PathUtil extends Ext.Base {
    }

    /**
     * A helper class to facilitate common operations on points and vectors.
     */
    export class Point extends Ext.Base {
        /**
         * Returns a new point with absolute values of the x and y values of this point.
         * This point is not modified.
         * @return {Ext.draw.Point}
         */
        abs(): Ext.draw.Point;

        /**
         * Adds another vector to this one and returns the resulting vector
         * without changing this vector.
         * @return {Ext.draw.Point}
         */
        add(x: number|any|Ext.draw.Point, y: number|any|Ext.draw.Point): Ext.draw.Point;

        /**
         * Returns a new point with ceiled x and y values. This point is not modified.
         * @return {Ext.draw.Point}
         */
        ceil(): Ext.draw.Point;

        /**
         * Returns a copy of the point.
         * @return {Ext.draw.Point}
         */
        clone(): Ext.draw.Point;

        /**
         * Creates a point.
         *
         *     new Ext.draw.Point(3, 4);
         *     new Ext.draw.Point(3); // both x and y equal 3
         *     new Ext.draw.Point([3, 4]);
         *     new Ext.draw.Point({x: 3, y: 4});
         *     new Ext.draw.Point(p); // where 'p' is a Ext.draw.Point instance.
         */
        constructor(x: number|any|Ext.draw.Point, y: number|any|Ext.draw.Point);

        /**
         * Returns a vector which coordinates are the result of division of this vector's
         * coordinates by the given number. This vector is not modified.
         * This vector is not modified.
         * @param {Number} n The denominator.
         * @return {Ext.draw.Point}
         */
        div(n: number): Ext.draw.Point;

        /**
         * Returns the dot product of this vector and the given vector.
         * @return {Number}
         */
        dot(x: number|any|Ext.draw.Point, y: number|any|Ext.draw.Point): number;

        /**
         * Checks whether coordinates of the point match those of the point provided.
         * @return {Boolean}
         */
        equals(x: number|any|Ext.draw.Point, y: number|any|Ext.draw.Point): boolean;

        /**
         * Returns a new point with floored x and y values. This point is not modified.
         * @return {Ext.draw.Point}
         */
        floor(): Ext.draw.Point;

        /**
         * Returns the vector from the point perpendicular to the line (shortest distance).
         * Where line is specified using two points or the coordinates of those points.
         * @return {Ext.draw.Point}
         */
        getDistanceToLine(p1: Ext.draw.Point, p2: Ext.draw.Point): Ext.draw.Point;

        /**
         * Checks if both x and y coordinates of the point are valid numbers.
         * @return {Boolean}
         */
        isNumber(): boolean;

        /**
         * Checks if both x and y coordinates of the point are zero.
         * @return {Boolean}
         */
        isZero(): boolean;

        /**
         * Returns the result of scalar multiplication of this vector by the given factor.
         * This vector is not modified.
         * @param {Number} n The factor.
         * @return {Ext.draw.Point}
         */
        mul(n: number): Ext.draw.Point;

        /**
         * Normalizes the vector by changing its length to 1 without changing its angle.
         * The returned result is a normalized vector. This vector is not modified.
         * @param {Number} [factor=1] Multiplication factor. Defaults to 1.
         * @return {Ext.draw.Point}
         */
        normalize(factor?: number): Ext.draw.Point;

        /**
         * Rotates the point by the given angle. This point is not modified.
         * @param {Number} angle The rotation angle.
         * @param {Ext.draw.Point} center The center of rotation (optional). Defaults to origin.
         * @return {Ext.draw.Point} The rotated point.
         */
        rotate(angle: number, center: Ext.draw.Point): Ext.draw.Point;

        /**
         * Returns a new point with rounded x and y values. This point is not modified.
         * @return {Ext.draw.Point}
         */
        round(): Ext.draw.Point;

        /**
         * Sets coordinates of the point.
         * Takes the same parameters as the {@link #constructor}.
         */
        set(x: number|any|Ext.draw.Point, y: number|any|Ext.draw.Point);

        /**
         * Sets the angle of the vector (measured from the x-axis to the vector)
         * without changing its length.
         */
        setAngle(angle: number);

        /**
         * Sets the length of the vector without changing its angle.
         */
        setLength(length: number);

        /**
         * Sets both the angle and the length of the vector.
         * A point can be thought of as a vector pointing from the origin to the point's location.
         * This can also be interpreted as setting coordinates of a point in the polar
         * coordinate system.
         */
        setPolar(angle: number, length: number);

        /**
         * Sets the x-coordinate of the point.
         */
        setX(x: number);

        /**
         * Sets the y-coordinate of the point.
         */
        setY(y: number);

        /**
         * Subtracts another vector from this one and returns the resulting vector
         * without changing this vector.
         * @return {Ext.draw.Point}
         */
        sub(x: number|any|Ext.draw.Point, y: number|any|Ext.draw.Point): Ext.draw.Point;

        /**
         * Transforms the point from one coordinate system to another
         * using the transformation matrix provided. This point is not modified.
         * @param {Ext.draw.Matrix/Number[]} matrix A trasformation matrix or its elements.
         * @return {Ext.draw.Point}
         */
        transform(matrix: Ext.draw.Matrix|number): Ext.draw.Point;

        /**
         * Creates a flyweight Ext.draw.Point instance.
         * Takes the same parameters as the {@link Ext.draw.Point#constructor}.
         * Do not hold the instance of the flyweight point.
         *
         * @return {Ext.draw.Point}
         */
        static fly(point: number|any|Ext.draw.Point): Ext.draw.Point;
    }

    /**
     * This class we summarize the data and returns it when required.
     */
    export class SegmentTree extends Ext.Base {
        constructor(config: any);

        /**
         * Returns the minimum range of data that fits the given range and step size.
         *
         * @return {Object} The aggregation information.
         * @return {Number} return.start
         * @return {Number} return.end
         * @return {Object} return.data The aggregated data
         */
        getAggregation(min: number, max: number, estStep: number): any;

        getStrategy();

        /**
         * Sets the data of the segment tree.
         */
        setData(dataX: number, dataOpen: number, dataHigh: number, dataLow: number, dataClose: number);

        setStrategy();
    }

    interface SurfaceConfig {
        /**
         * Background sprite config of the surface.
         */
        background?: any;

        /**
         * Indicates whether the surface needs to redraw.
         */
        dirty?: any;

        /**
         * If the surface is in the RTL mode, text will render with the RTL direction,
         * but the alignment and position of the text won't change by default.
         * Setting this config to 'true' will get text alignment and its position
         * within a surface mirrored.
         */
        flipRtlText?: boolean;

        /**
         * Array of sprite instances.
         */
        items?: any;

        /**
         * The [x, y, width, height] rect of the surface related to its container.
         */
        rect?: any;
    }

    /**
     * A surface is an interface to render {@link Ext.draw.sprite.Sprite sprites} inside a
     * {@link Ext.draw.Container draw container}.  The surface API has methods to render
     * sprites, get sprite bounding boxes (dimensions), add sprites to the underlying DOM,
     * and more.
     *
     * A surface is automatically created when a draw container is created.  By default,
     * this will be a surface with an 'id' of "main" and will manage all sprites in the draw
     * container (unless the sprite configs specify a unique surface "id").
     *
     *     @example
     *     Ext.create({
     *         xtype: 'draw',
     *         renderTo: document.body,
     *         width: 400,
     *         height: 400,
     *         sprites: [{
     *             type: 'rect',
     *             surface: 'anim',  // a surface with id "anim" will be created automatically
     *             x: 50,
     *             y: 50,
     *             width: 100,
     *             height: 100,
     *             fillStyle: '#1F6D91'
     *         }]
     *     });
     *
     * The ability to have multiple surfaces is useful for performance (and battery life)
     * reasons. Because changes to sprite attributes cause the whole surface (and all
     * sprites in it) to re-render, it makes sense to group sprites by surface, so changes
     * to one group of sprites will only trigger the surface they are in to re-render.
     *
     * One of the more useful methods is the {@link #add} method used to add sprites to the
     * surface:
     *
     *     @example
     *     var drawCt = Ext.create({
     *         xtype: 'draw',
     *         renderTo: document.body,
     *         width: 400,
     *         height: 400
     *     });
     *
     *     // If the surface name is not specified then 'main' will be used
     *     var surface = drawCt.getSurface();
     *
     *     surface.add({
     *         type: 'rect',
     *         x: 50,
     *         y: 50,
     *         width: 100,
     *         height: 100,
     *         fillStyle: '#1F6D91'
     *     });
     *
     *     surface.renderFrame();
     *
     * **Note:** Changes to the sprites on a surface will be not be reflected in the DOM
     * until you call the surface's {@link Ext.draw.Surface#method-renderFrame renderFrame}
     * method.  This must be done after adding, removing, or modifying sprites in order to
     * see the changes on-screen.
     */
    export class Surface implements Ext.draw.SurfaceConfig {
        /**
         * The reported device pixel density.
         * devicePixelRatio is only supported from IE11,
         * so we use deviceXDPI and logicalXDPI that are supported from IE6.
         */
        devicePixelRatio: any;

        /**
         * Background sprite config of the surface.
         */
        background: any;

        /**
         * Indicates whether the surface needs to redraw.
         */
        dirty: any;

        /**
         * If the surface is in the RTL mode, text will render with the RTL direction,
         * but the alignment and position of the text won't change by default.
         * Setting this config to 'true' will get text alignment and its position
         * within a surface mirrored.
         */
        flipRtlText: boolean;

        /**
         * Array of sprite instances.
         */
        items: any;

        /**
         * The [x, y, width, height] rect of the surface related to its container.
         */
        rect: any;

        /**
         * Add a Sprite to the surface.
         * You can put any number of objects as the parameter.
         * See {@link Ext.draw.sprite.Sprite} for the configuration object to be passed into this method.
         *
         * For example:
         *
         *     drawContainer.getSurface().add({
         *         type: 'circle',
         *         fill: '#ffc',
         *         radius: 100,
         *         x: 100,
         *         y: 100
         *     });
         *     drawContainer.renderFrame();
         *
         * @returns {Ext.draw.sprite.Sprite/Ext.draw.sprite.Sprite[]}
         */
        add(sprite: any);

        /**
         * Empty the surface content (without touching the sprites.)
         */
        clear();

        constructor(config: Ext.draw.SurfaceConfig);

        /**
         * Destroys the surface. This is done by removing all components from it and
         * also removing its reference to a DOM element.
         *
         * For example:
         *
         *      drawContainer.surface.destroy();
         */
        destroy();

        /**
         * Flattens the given drawing surfaces into a single image
         * and returns an object containing the data (in the DataURL format)
         * and the type (e.g. 'png' or 'svg') of that image.
         * @param {Object} size The size of the final image.
         * @param {Ext.draw.Surface[]} surfaces The surfaces to flatten.
         * @return {Object}
         * @return {String} return.data The DataURL of the flattened image.
         * @return {String} return.type The type of the image.
         */
        flatten(size: any, size_width: number, size_height: number, surfaces: Ext.draw.Surface): any;

        /**
         * Get the sprite by id or index.
         * It will first try to find a sprite with the given id, otherwise will try to use the id as an index.
         * @return {Ext.draw.sprite.Sprite}
         */
        get(id: string|number): Ext.draw.sprite.Sprite;

        getBackground();

        /**
         * Return the minimal bounding box that contains all the sprites bounding boxes in the given list of sprites.
         * @param {Boolean} [isWithoutTransform=false]
         * @return {{x: Number, y: Number, width: number, height: number}}
         */
        getBBox(sprites: Ext.draw.sprite.Sprite, isWithoutTransform?: boolean): any;

        getCls();

        getDirty();

        getFlipRtlText();

        getItems();

        getRect();

        /**
         * Performs a hit test on all sprites in the surface, returning the first matching one.
         * @param {Array} point A two-item array containing x and y coordinates of the point.
         * @param {Object} options Hit testing options.
         * @return {Object} A hit result object that contains more information about what
         * exactly was hit or null if nothing was hit.
         */
        hitTest(point: any[], options: any): any;

        /**
         * Performs a hit test on all sprites in the surface, returning the first matching one.
         * Since hit testing is typically performed on mouse events, this convenience method
         * converts event's page coordinates to surface coordinates before calling {@link #hitTest}.
         * @param {Array} point An event object.
         * @param {Object} options Hit testing options.
         * @return {Object} A hit result object that contains more information about what
         * exactly was hit or null if nothing was hit.
         */
        hitTestEvent(point: any[], options: any): any;

        /**
         * Invoked when a sprite is added to the surface.
         * @param {Ext.draw.sprite.Sprite} sprite The sprite to be added.
         */
        protected onAdd(sprite: Ext.draw.sprite.Sprite);

        /**
         * Remove a given sprite from the surface,
         * optionally destroying the sprite in the process.
         * You can also call the sprite's own 'remove' method.
         *
         * For example:
         *
         *      drawContainer.surface.remove(sprite);
         *      // or...
         *      sprite.remove();
         *
         * @param {Ext.draw.sprite.Sprite/String} sprite A sprite instance or its ID.
         * @param {Boolean} [isDestroy=false] If 'true', the sprite will be destroyed.
         * @returns {Ext.draw.sprite.Sprite} Returns the removed/destroyed sprite or 'null' otherwise.
         */
        remove(sprite: Ext.draw.sprite.Sprite|string, isDestroy?: boolean);

        /**
         * Remove all sprites from the surface, optionally destroying the sprites in the process.
         *
         * For example:
         *
         *     drawContainer.getSurface('main').removeAll();
         *
         * @param {Boolean} [isDestroy=false]
         */
        removeAll(isDestroy?: boolean);

        /**
         * Triggers the re-rendering of the canvas.
         */
        renderFrame();

        /**
         * Force the element to redraw.
         */
        repaint();

        /**
         * Reset the matrix of the surface.
         */
        resetTransform();

        /**
         * Round the number to align to the pixels on device.
         * @param {Number} num The number to align.
         * @return {Number} The resultant alignment.
         */
        roundPixel(num: number): number;

        setBackground();

        setCls();

        setDirty();

        setFlipRtlText();

        setItems();

        setRect();

        /**
         * @deprecated 5.1.0
         * Stably sort the list of sprites by their zIndex.
         * Deprecated, use the {@link Ext.Array#sort} method instead.
         * @return {Array} Sorted array.
         */
        stableSort(list: any[]): any[];

        /**
         * Mark the surface to render after another surface is updated.
         * @param {Ext.draw.Surface} surface The surface to wait for.
         */
        waitFor(surface: Ext.draw.Surface);
    }

    /**
     * Utility class to provide a way to *approximately* measure the dimension of text
     * without a drawing context.
     */
    export class TextMeasurer {
        /**
         * This singleton tries not to make use of the Ext.util.TextMetrics because it is
         * several times slower than TextMeasurer's own solution. TextMetrics is more precise
         * though, so if you have a case where the error is too big, you may want to set
         * this config to 'true' to get perfect results at the expense of performance.
         * Note: defaults to 'true' in IE8.
         *
         * Optional, Defaults to: false
         */
        static precise: boolean;

        /**
         * Measure a text with specific font.
         * This will split the text to lines and add up their size.
         * That may *not* be the exact size of the text as it is displayed.
         * @return {Object} An object with 'width', 'height' and 'sizes' properties.
         * @return {Number} return.width
         * @return {Number} return.height
         * @return {Object} return.sizes Results of individual line measurements, in case of multiline text.
         */
        static measureText(text: string, font: string): any;

        /**
         * Measure a single-line text with specific font.
         * This will split the text into characters and add up their size.
         * That may *not* be the exact size of the text as it is displayed.
         * @return {Object} An object with 'width' and 'height' properties.
         * @return {Number} return.width
         * @return {Number} return.height
         */
        static measureTextSingleLine(text: string, font: string): any;
    }

    /**
     * Singleton that provides easing functions for use in sprite animations.
     */
    export class TimingFunctions {
    }
}

declare module Ext.draw.engine {
    interface CanvasConfig extends Ext.draw.SurfaceConfig {
        /**
         * True to have the Canvas use JavaScript Number instead of single precision floating point for transforms.
         *
         * For example, when using data with big numbers to plot line series, the transformation
         * matrix of the canvas will have big elements. Due to the implementation of the SVGMatrix,
         * the elements are represented by 32-bits floats, which will work incorrectly.
         * To compensate for that, we enable the canvas context to perform all the transformations
         * in JavaScript.
         *
         * Do not use this if you are not encountering 32-bit floating point errors problem,
         * since this will result in a performance penalty.
         */
        highPrecision?: boolean;
    }

    /**
     * Provides specific methods to draw with 2D Canvas element.
     */
    export class Canvas extends Ext.draw.Surface implements Ext.draw.engine.CanvasConfig {
        /**
         * True to have the Canvas use JavaScript Number instead of single precision floating point for transforms.
         *
         * For example, when using data with big numbers to plot line series, the transformation
         * matrix of the canvas will have big elements. Due to the implementation of the SVGMatrix,
         * the elements are represented by 32-bits floats, which will work incorrectly.
         * To compensate for that, we enable the canvas context to perform all the transformations
         * in JavaScript.
         *
         * Do not use this if you are not encountering 32-bit floating point errors problem,
         * since this will result in a performance penalty.
         */
        highPrecision: boolean;

        constructor(config: Ext.draw.SurfaceConfig);

        getHighPrecision();

        setHighPrecision();

        /**
         * 2D Canvas context in IE (up to IE10, inclusive) doesn't support
         * the setLineDash method and the lineDashOffset property.
         * @param dashList An even number of non-negative numbers specifying a dash list.
         */
        setLineDash();
    }

    /**
     * @define Ext.draw.engine.excanvas
     */
    export class excanvas {
        /**
         * Binds a function to an object. The returned function will always use the
         * passed in {@code obj} as {@code this}.
         *
         * Example:
         *
         *   g = bind(f, obj, a, b)
         *   g(c, d) // will do f.call(obj, a, b, c, d)
         *
         * @param {Function} f The function to bind the object to
         * @param {Object} obj The object that should act as this when the function
         *     is called
         * @param {*} var_args Rest arguments that will be used as the initial
         *     arguments when the function is called
         * @return {Function} A new function that has bound this
         */
        bind(f: Function, obj: any, var_args: any): Function;

        /**
         * This funtion is assigned to the <canvas></canvas> elements as element.getContext().
         * @this {HTMLElement}
         * @return {CanvasRenderingContext2D_}
         */
        getContext(): any;

        /**
         * Public initializes a canvas element so that it can be used as canvas
         * element from now on. This is called automatically before the page is
         * loaded but if you are creating elements using createElement you need to
         * make sure this is called on the element.
         * @param {HTMLElement} el The canvas element to initialize.
         * @return {HTMLElement} the element that was created.
         */
        initElement(el: HTMLElement): HTMLElement;
    }

    interface SvgConfig extends Ext.draw.SurfaceConfig {
        /**
         * Nothing needs to be done in high precision mode.
         */
        highPrecision?: any;
    }

    /**
     * @extends Ext.draw.Surface
     *
     * SVG engine.
     */
    export class Svg extends Ext.draw.Surface implements Ext.draw.engine.SvgConfig {
        /**
         * Nothing needs to be done in high precision mode.
         */
        highPrecision: any;

        /**
         * Empty the surface content (without touching the sprites.)
         */
        clear();

        clearTransform();

        constructor(config: Ext.draw.engine.SvgConfig);

        /**
         * Creates a DOM element under the SVG namespace of the given type.
         * @param {String} type The type of the SVG DOM element.
         * @return {*} The created element.
         */
        createSvgNode(type: string): any;

        /**
         * Destroys the Canvas element and prepares it for Garbage Collection.
         */
        destroy();

        getHighPrecision();

        renderSprite();

        setHighPrecision();
    }

    /**
     * A class that imitates a canvas context but generates svg elements instead.
     */
    export class SvgContext extends Ext.Base {
        /**
         * Adds points to the subpath such that the arc described by the circumference of the circle described by the arguments, starting at the given start angle and ending at the given end angle, going in the given direction (defaulting to clockwise), is added to the path, connected to the previous point by a straight line.
         */
        arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, anticlockwise: number);

        /**
         * Arc command using svg parameters.
         */
        arcSvg(r1: number, r2: number, rotation: number, large: number, swipe: number, x2: number, y2: number);

        /**
         * Adds an arc with the given control points and radius to the current subpath, connected to the previous point by a straight line.
         * If two radii are provided, the first controls the width of the arc's ellipse, and the second controls the height. If only one is provided, or if they are the same, the arc is from a circle.
         * In the case of an ellipse, the rotation argument controls the clockwise inclination of the ellipse relative to the x-axis.
         */
        arcTo(x1: number, y1: number, x2: number, y2: number, radiusX: number, radiusY: number, rotation: number);

        /**
         * Resets the current default path.
         */
        beginPath();

        /**
         * Adds the given point to the current subpath, connected to the previous one by a cubic BÃ©zier curve with the given control points.
         */
        bezierCurveTo(x1: number, y1: number, x2: number, y2: number, x3: number, y3: number);

        /**
         * Clears the context.
         */
        clear();

        /**
         * Marks the current subpath as closed, and starts a new subpath with a point the same as the start and end of the newly closed subpath.
         */
        closePath();

        constructor(SvgSurface: any);

        /**
         * Returns an object that represents a linear gradient that paints along the line
         * given by the coordinates represented by the arguments.
         * @return {Ext.draw.engine.SvgContext.Gradient}
         */
        createLinearGradient(x0: number, y0: number, x1: number, y1: number): Ext.draw.engine.SvgContext.Gradient;

        /**
         * Returns a CanvasGradient object that represents a radial gradient that paints
         * along the cone given by the circles represented by the arguments.
         * If either of the radii are negative, throws an IndexSizeError exception.
         * @return {Ext.draw.engine.SvgContext.Gradient}
         */
        createRadialGradient(x0: number, y0: number, r0: number, x1: number, y1: number, r1: number): Ext.draw.engine.SvgContext.Gradient;

        /**
         * Draws the given image onto the canvas.
         * If the first argument isn't an img, canvas, or video element, throws a TypeMismatchError exception. If the image has no image data, throws an InvalidStateError exception. If the one of the source rectangle dimensions is zero, throws an IndexSizeError exception. If the image isn't yet fully decoded, then nothing is drawn.
         */
        drawImage(image: HTMLElement, sx: number, sy: number, sw: number, sh: number, dx: number, dy: number, dw: number, dh: number);

        /**
         * Adds points to the subpath such that the arc described by the circumference of the ellipse described by the arguments, starting at the given start angle and ending at the given end angle, going in the given direction (defaulting to clockwise), is added to the path, connected to the previous point by a straight line.
         */
        ellipse(x: number, y: number, radiusX: number, radiusY: number, rotation: number, startAngle: number, endAngle: number, anticlockwise: number);

        /**
         * Fills the subpaths of the current default path or the given path with the current fill style.
         */
        fill();

        /**
         * Paints the given rectangle onto the canvas, using the current fill style.
         */
        fillRect(x: number, y: number, width: number, height: number);

        /**
         * Note: After the method guarantees the transform matrix will be inverted.
         * @param {Object} attr The attribute object
         * @param {Boolean} [transformFillStroke] Indicate whether to transform fill and stroke. If this is not
         *      given, then uses 'attr.transformFillStroke' instead.
         */
        protected fillStroke(attr: any, transformFillStroke?: boolean);

        /**
         * Fills the given text at the given position. If a maximum width is provided, the text will be scaled to fit that width if necessary.
         */
        fillText(text: string, x: number, y: number);

        /**
         * Adds the given point to the current subpath, connected to the previous one by a straight line.
         */
        lineTo(x: number, y: number);

        /**
         * Creates a new subpath with the given point.
         */
        moveTo(x: number, y: number);

        /**
         * Adds a new closed subpath to the path, representing the given rectangle.
         */
        rect(x: number, y: number, width: number, height: number);

        /**
         * Pops the state stack and restores the state.
         */
        restore();

        /**
         * Rotates the current context coordinates (that is, a transformation matrix).
         * @param {Number} angle The rotation angle, in radians.
         */
        rotate(angle: number);

        /**
         * Pushes the context state to the state stack.
         */
        save();

        /**
         * Scales the current context by the specified horizontal (x) and vertical (y) factors.
         * @param {Number} x The horizontal scaling factor, where 1 equals unity or 100% scale.
         * @param {Number} y The vertical scaling factor.
         */
        scale(x: number, y: number);

        /**
         * Changes the transformation matrix to the matrix given by the arguments as described below.
         */
        setTransform(xx: number, yx: number, xy: number, yy: number, dx: number, dy: number);

        /**
         * Strokes the subpaths of the current default path or the given path with the current stroke style.
         */
        stroke();

        /**
         * Paints the box that outlines the given rectangle onto the canvas, using the current stroke style.
         */
        strokeRect(x: number, y: number, width: number, height: number);

        /**
         * Strokes the given text at the given position. If a maximum width is provided, the text will be scaled to fit that width if necessary.
         */
        strokeText(text: string, x: number, y: number);

        /**
         * Changes the transformation matrix to apply the matrix given by the arguments as described below.
         */
        transform(xx: number, yx: number, xy: number, yy: number, dx: number, dy: number);

        /**
         * Specifies values to move the origin point in a canvas.
         * @param {Number} x The value to add to horizontal (or x) coordinates.
         * @param {Number} y The value to add to vertical (or y) coordinates.
         */
        translate(x: number, y: number);
    }
}

declare module Ext.draw.engine.SvgContext {
    /**
     * A class that implements native CanvasGradient interface
     * (https://developer.mozilla.org/en/docs/Web/API/CanvasGradient)
     * and a 'toString' method that returns the ID of the gradient.
     */
    export class Gradient extends Ext.Base {
        /**
         * Adds a color stop with the given color to the gradient at the given offset. 0.0 is the offset at one end of the gradient, 1.0 is the offset at the other end.
         */
        addColorStop(offset: number, color: string);

        constructor(ctx: any, surface: any, element: any, compression: any);
    }
}

declare module Ext.draw.gradient {
    interface GradientConfig {
        /**
         * Defines the stops of the gradient.
         */
        stops?: any;
    }

    /**
     * Creates a gradient.
     */
    export class Gradient extends Ext.Base implements Ext.draw.gradient.GradientConfig {
        /**
         * Defines the stops of the gradient.
         */
        stops: any;

        constructor(config: Ext.draw.gradient.GradientConfig);

        /**
         * Generates the gradient for the given context.
         * @param {Ext.draw.engine.SvgContext} ctx The context.
         * @return {CanvasGradient/Ext.draw.engine.SvgContext.Gradient/Ext.draw.Color.NONE}
         */
        protected generateGradient(ctx: Ext.draw.engine.SvgContext, bbox: any): any|Ext.draw.engine.SvgContext.Gradient;

        getStops();

        setStops();
    }

    /**
     * A global map of all gradient configs.
     */
    export class GradientDefinition {
    }

    interface LinearConfig extends Ext.draw.gradient.GradientConfig {
        /**
         * The angle of rotation of the gradient in degrees.
         */
        degrees?: number;

        /**
         * The angle of rotation of the gradient in radians.
         */
        radians?: number;
    }

    /**
     * Linear gradient.
     *
     *     @example
     *     Ext.create({
     *        xtype: 'draw',
     *        renderTo: document.body,
     *        width: 600,
     *        height: 400,
     *        sprites: [{
     *            type: 'circle',
     *            cx: 100,
     *            cy: 100,
     *            r: 100,
     *            fillStyle: {
     *                type: 'linear',
     *                degrees: 180,
     *                stops: [{
     *                    offset: 0,
     *                    color: '#1F6D91'
     *                }, {
     *                    offset: 1,
     *                    color: '#90BCC9'
     *                }]
     *            }
     *        }]
     *     });
     */
    export class Linear extends Ext.draw.gradient.Gradient implements Ext.draw.gradient.LinearConfig {
        /**
         * The angle of rotation of the gradient in degrees.
         */
        degrees: number;

        /**
         * The angle of rotation of the gradient in radians.
         */
        radians: number;

        constructor(config: Ext.draw.gradient.GradientConfig);

        getDegrees();

        getRadians();

        setDegrees();

        setRadians();
    }

    interface RadialConfig extends Ext.draw.gradient.GradientConfig {
        /**
         * The ending circle of the gradient.
         */
        end?: any;

        /**
         * The starting circle of the gradient.
         */
        start?: any;
    }

    /**
     * Radial gradient.
     *
     *     @example
     *     Ext.create({
     *        xtype: 'draw',
     *        renderTo: document.body,
     *        width: 600,
     *        height: 400,
     *        sprites: [{
     *            type: 'circle',
     *            cx: 100,
     *            cy: 100,
     *            r: 100,
     *            fillStyle: {
     *                type: 'radial',
     *                start: {
     *                    x: 0,
     *                    y: 0,
     *                    r: 0
     *                },
     *                end: {
     *                    x: 0,
     *                    y: 0,
     *                    r: 1
     *                },
     *                stops: [{
     *                    offset: 0,
     *                    color: '#90BCC9'
     *                }, {
     *                    offset: 1,
     *                    color: '#1F6D91'
     *                }]
     *            }
     *        }]
     *     });
     */
    export class Radial extends Ext.draw.gradient.Gradient implements Ext.draw.gradient.RadialConfig {
        /**
         * The ending circle of the gradient.
         */
        end: any;

        /**
         * The starting circle of the gradient.
         */
        start: any;

        constructor(config: Ext.draw.gradient.GradientConfig);

        getEnd();

        getStart();

        setEnd();

        setStart();
    }
}

declare module Ext.draw.modifier {
    interface AnimationConfig extends Ext.draw.modifier.ModifierConfig {
        /**
         * @deprecated Use {@link #customDurations} instead.
         */
        customDuration?: any;

        /**
         * Overrides the default duration for defined attributes. E.g.:
         *
         *     // Assuming the sprite the modifier is applied to is a 'circle'.
         *     customDurations: {
         *         r: 1000,
         *         'fillStyle,strokeStyle': 2000,
         *         'cx,cy': 1000
         *     }
         */
        customDurations?: any;

        /**
         * Overrides the default easing function for defined attributes. E.g.:
         *
         *     // Assuming the sprite the modifier is applied to is a 'circle'.
         *     customEasings: {
         *         r: 'easeOut',
         *         'fillStyle,strokeStyle': 'linear',
         *         'cx,cy': function (p, n) {
         *             p = 1 - p;
         *             n = n || 1.616;
         *             return 1 - p * p * ((n + 1) * p - n);
         *         }
         *     }
         */
        customEasings?: any;

        /**
         * Default duration time (ms).
         */
        duration?: number;

        /**
         * Default easing function.
         */
        easing?: Function;
    }

    /**
     * The Animation modifier.
     *
     * Sencha Charts allow users to use transitional animation on sprites. Simply set the duration
     * and easing in the animation modifier, then all the changes to the sprites will be animated.
     *
     *     @example
     *     var drawCt = Ext.create({
     *         xtype: 'draw',
     *         renderTo: document.body,
     *         width: 400,
     *         height: 400,
     *         sprites: [{
     *             type: 'rect',
     *             x: 50,
     *             y: 50,
     *             width: 100,
     *             height: 100,
     *             fillStyle: '#1F6D91'
     *         }]
     *     });
     *
     *     var rect = drawCt.getSurface().getItems()[0];
     *
     *     rect.setAnimation({
     *         duration: 1000,
     *         easing: 'elasticOut'
     *     });
     *
     *     Ext.defer(function () {
     *         rect.setAttributes({
     *             width: 250
     *         });
     *     }, 500);
     *
     * Also, you can use different durations and easing functions on different attributes by using
     * {@link #customDurations} and {@link #customEasings}.
     *
     * By default, an animation modifier will be created during the initialization of a sprite.
     * You can get the animation modifier of a sprite via its
     * {@link Ext.draw.sprite.Sprite#method-getAnimation getAnimation} method.
     */
    export class Animation extends Ext.draw.modifier.Modifier implements Ext.draw.modifier.AnimationConfig {
        /**
         * @deprecated Use {@link #customDurations} instead.
         */
        customDuration: any;

        /**
         * Overrides the default duration for defined attributes. E.g.:
         *
         *     // Assuming the sprite the modifier is applied to is a 'circle'.
         *     customDurations: {
         *         r: 1000,
         *         'fillStyle,strokeStyle': 2000,
         *         'cx,cy': 1000
         *     }
         */
        customDurations: any;

        /**
         * Overrides the default easing function for defined attributes. E.g.:
         *
         *     // Assuming the sprite the modifier is applied to is a 'circle'.
         *     customEasings: {
         *         r: 'easeOut',
         *         'fillStyle,strokeStyle': 'linear',
         *         'cx,cy': function (p, n) {
         *             p = 1 - p;
         *             n = n || 1.616;
         *             return 1 - p * p * ((n + 1) * p - n);
         *         }
         *     }
         */
        customEasings: any;

        /**
         * Default duration time (ms).
         */
        duration: number;

        /**
         * Default easing function.
         */
        easing: Function;

        /**
         * Remove special easings on the given attributes.
         * @param {Object} attrs The source attributes.
         */
        clearDurationOn(attrs: any);

        /**
         * Remove special easings on the given attributes.
         * @param {String/Array} attrs The source attribute(s).
         */
        clearEasingOn(attrs: string|any[]);

        constructor(config: Ext.draw.modifier.AnimationConfig);

        destroy();

        getCustomDuration();

        getCustomDurations();

        getCustomEasings();

        getDuration();

        getEasing();

        setCustomDuration();

        setCustomDurations();

        setCustomEasings();

        setDuration();

        /**
         * Set special duration on the given attributes. E.g.:
         *
         *     rectSprite.fx.setDurationOn('height', 2000);
         *
         * @param {String/Array} attrs The source attributes.
         * @param {Number} duration The special duration.
         */
        setDurationOn(attrs: string|any[], duration: number);

        setEasing();

        /**
         * Set special easings on the given attributes. E.g.:
         *
         *     circleSprite.fx.setEasingOn('r', 'elasticIn');
         *
         * @param {String/Array} attrs The source attribute(s).
         * @param {String} easing The special easings.
         */
        setEasingOn(attrs: string|any[], easing: string);

        /**
         * Stop all animations affected by this modifier.
         */
        stop();
    }

    interface HighlightConfig extends Ext.draw.modifier.ModifierConfig {
        /**
         * 'true' if the highlight is applied.
         */
        enabled?: boolean;

        /**
         * The style attributes of the highlight modifier.
         */
        highlightStyle?: any;
    }

    /**
     * @extends Ext.draw.modifier.Modifier
     *
     * Highlight is a modifier that will override sprite attributes
     * with {@link Ext.draw.modifier.Highlight#highlightStyle highlightStyle} attributes
     * when sprite's 'highlighted' attribute is true.
     */
    export class Highlight extends Ext.draw.modifier.Modifier implements Ext.draw.modifier.HighlightConfig {
        /**
         * 'true' if the highlight is applied.
         */
        enabled: boolean;

        /**
         * The style attributes of the highlight modifier.
         */
        highlightStyle: any;

        constructor(config: Ext.draw.modifier.HighlightConfig);

        /**
         * Filter out modifier changes that override highlightStyle or source attributes.
         * @param {Object} attr The source attributes.
         * @param {Object} changes The modifier changes.
         * @return {*} The filtered changes.
         */
        filterChanges(attr: any, changes: any): any;

        getEnabled();

        getHighlightStyle();

        setEnabled();

        setHighlightStyle();
    }

    interface ModifierConfig {
        /**
         * Next modifier that receives the
         * pop-up changes.
         */
        next?: Ext.draw.modifier.Modifier;

        /**
         * Previous modifier that receives
         * the push-down changes.
         */
        previous?: Ext.draw.modifier.Modifier;

        /**
         * The sprite to which the modifier belongs.
         */
        sprite?: Ext.draw.sprite.Sprite;
    }

    /**
     * Each sprite has a stack of modifiers. The resulting attributes of sprite is
     * the content of the stack top. When setting attributes to a sprite,
     * changes will be pushed-down though the stack of modifiers and pop-back the
     * additive changes; When modifier is triggered to change the attribute of a
     * sprite, it will pop-up the changes to the top.
     */
    export class Modifier extends Ext.Base implements Ext.draw.modifier.ModifierConfig {
        /**
         * Next modifier that receives the
         * pop-up changes.
         */
        next: Ext.draw.modifier.Modifier;

        /**
         * Previous modifier that receives
         * the push-down changes.
         */
        previous: Ext.draw.modifier.Modifier;

        /**
         * The sprite to which the modifier belongs.
         */
        sprite: Ext.draw.sprite.Sprite;

        constructor(config: Ext.draw.modifier.HighlightConfig);

        getNext();

        getPrevious();

        getSprite();

        /**
         * Invoked when changes need to be popped up to the top.
         * @param {Object} attributes The source attributes.
         * @param {Object} changes The changes to be popped up.
         */
        popUp(attributes: any, changes: any);

        /**
         * Validate attribute set before use.
         *
         * @param {Object} attr The attribute to be validated. Note that it may be already initialized, so do
         * not override properties that have already been used.
         */
        prepareAttributes(attr: any);

        /**
         * Invoked when changes need to be pushed down to the sprite.
         * @param {Object} attr The source attributes.
         * @param {Object} changes The changes to make. This object might be changed unexpectedly inside the method.
         * @return {Mixed}
         */
        pushDown(attr: any, changes: any): any;

        setNext();

        setPrevious();

        setSprite();
    }

    /**
     * @extends Ext.draw.modifier.Modifier
     *
     * This is the destination (top) modifier that has to be put at
     * the top of the modifier stack.
     *
     * The Target modifier figures out which updaters have to be called
     * for the changed set of attributes and makes the sprite and its instances (if any)
     * call them.
     */
    export class Target extends Ext.draw.modifier.Modifier {
        constructor(config: Ext.draw.modifier.HighlightConfig);
    }
}

declare module Ext.draw.plugin {
    /**
     * A draw container {@link Ext.AbstractPlugin plugin} that adds ability to listen
     * to sprite events. For example:
     *
     *     var drawContainer = Ext.create('Ext.draw.Container', {
     *          plugins: ['spriteevents'],
     *          renderTo: Ext.getBody(),
     *          width: 200,
     *          height: 200,
     *          sprites: [{
     *               type: 'circle',
     *               fillStyle: '#79BB3F',
     *               r: 50,
     *               x: 100,
     *               y: 100
     *          }],
     *          listeners: {
     *              spriteclick: function (item, event) {
     *                  var sprite = item && item.sprite;
     *                  if (sprite) {
     *                      sprite.setAttributes({fillStyle: 'red'});
     sprite.getSurface().renderFrame();
     *                  }
     *              }
     *          }
     *     });
     */
    export class SpriteEvents extends Ext.plugin.Abstract {
        /**
         * Instantiates the plugin.
         * @param {Object} [config] Configuration object.
         */
        constructor(config?: Ext.chart.plugin.ItemEventsConfig);

        /**
         * Fires when a click event occurs on a sprite.
         */
        spriteclick(sprite: any, event: Event);

        /**
         * Fires when a double click event occurs on a sprite.
         */
        spritedblclick(sprite: any, event: Event);

        /**
         * Fires when a mousedown event occurs on a sprite.
         */
        spritemousedown(sprite: any, event: Event);

        /**
         * Fires when the mouse is moved on a sprite.
         */
        spritemousemove(sprite: any, event: Event);

        /**
         * Fires when the mouse exits a sprite.
         */
        spritemouseout(sprite: any, event: Event);

        /**
         * Fires when the mouse enters a sprite.
         */
        spritemouseover(sprite: any, event: Event);

        /**
         * Fires when a mouseup event occurs on a sprite.
         */
        spritemouseup(sprite: any, event: Event);

        /**
         * Fires when a tap event occurs on a sprite.
         */
        spritetap(sprite: any, event: Event);
    }
}

declare module Ext.draw.sprite {
    /**
     * Computes an intermidiate value between two values of the same type for use in animations.
     * Can have pre- and post- processor functions if the values need to be processed
     * before an intermidiate value can be computed (parseInitial), or the computed value
     * needs to be processed before it can be used as a valid attribute value (serve).
     */
    export class AnimationParser extends Ext.Base {
    }

    interface ArcConfig extends Ext.draw.sprite.CircleConfig {
        /**
         * Determines whether or not the arc is drawn clockwise.
         *
         * Optional, Defaults to: false
         */
        anticlockwise?: boolean;

        /**
         * The ending angle of the arc.
         *
         * Optional, Defaults to: Math.PI*2
         */
        endAngle?: number;

        /**
         * The beginning angle of the arc.
         *
         * Optional, Defaults to: 0
         */
        startAngle?: number;
    }

    /**
     * @extend Ext.draw.sprite.Circle
     *
     *  A sprite that represents a circular arc.
     *
     *     @example
     *     Ext.create({
     *        xtype: 'draw',
     *        renderTo: document.body,
     *        width: 600,
     *        height: 400,
     *        sprites: [{
     *            type: 'arc',
     *            cx: 100,
     *            cy: 100,
     *            r: 80,
     *            fillStyle: '#1F6D91',
     *            startAngle: 0,
     *            endAngle: Math.PI,
     *            anticlockwise: true
     *        }]
     *     });
     */
    export class Arc extends Ext.draw.sprite.Circle implements Ext.draw.sprite.ArcConfig {
        /**
         * Determines whether or not the arc is drawn clockwise.
         *
         * Optional, Defaults to: false
         */
        anticlockwise: boolean;

        /**
         * The ending angle of the arc.
         *
         * Optional, Defaults to: Math.PI*2
         */
        endAngle: number;

        /**
         * The beginning angle of the arc.
         *
         * Optional, Defaults to: 0
         */
        startAngle: number;

        constructor(config: Ext.chart.axis.sprite.AxisConfig);
    }

    interface ArrowConfig extends Ext.draw.sprite.PathConfig {
        /**
         * The size of the sprite.
         * Meant to be comparable to the size of a circle sprite with the same radius.
         *
         * Optional, Defaults to: 4
         */
        size?: number;
    }

    /**
     * A sprite that represents an arrow.
     *
     *     @example
     *     Ext.create({
     *        xtype: 'draw',
     *        renderTo: document.body,
     *        width: 600,
     *        height: 400,
     *        sprites: [{
     *            type: 'arrow',
     *            translationX: 100,
     *            translationY: 100,
     *            size: 40,
     *            fillStyle: '#30BDA7'
     *        }]
     *     });
     */
    export class Arrow extends Ext.draw.sprite.Path implements Ext.draw.sprite.ArrowConfig {
        /**
         * The size of the sprite.
         * Meant to be comparable to the size of a circle sprite with the same radius.
         *
         * Optional, Defaults to: 4
         */
        size: number;

        constructor(config: Ext.chart.axis.sprite.AxisConfig);
    }

    interface AttributeDefinitionConfig {
        /**
         * Defines the alternative names for attributes.
         */
        aliases?: any;

        /**
         * Defines the process used to animate between attributes.
         * One doesn't have to define animation processors for sprite attributes that use
         * predefined {@link #processors} from the {@link Ext.draw.sprite.AttributeParser} singleton.
         * For such attributes matching animation processors from the {@link Ext.draw.sprite.AnimationParser}
         * singleton will be used automatically.
         * However, if you have a custom processor for an attribute that should support
         * animation, you must provide a corresponding animation processor for it here.
         * For more information on animation processors please see {@link Ext.draw.sprite.AnimationParser}
         * documentation.
         */
        animationProcessors?: any;

        /**
         * Defines the default values of attributes.
         */
        defaults?: any;

        /**
         * @deprecated Use the {@link #triggers} config instead.
         */
        dirtyTriggers?: any;

        /**
         * Defines the preprocessing used on the attributes.
         * One can define a custom processor function here or use the name of a predefined
         * processor from the {@link Ext.draw.sprite.AttributeParser} singleton.
         */
        processors?: any;

        /**
         * Defines which updaters have to be called when an attribute is changed.
         * For example, the config below indicates that the 'size' updater
         * of a {@link Ext.draw.sprite.Square square} sprite has to be called
         * when the 'size' attribute changes.
         *
         *     triggers: {
         *         size: 'size'   // Use comma-separated values here if multiple updaters have to be called.
         *     }                  // Note that the order is _not_ guaranteed.
         *
         * If any of the updaters to be called (triggered by the {@link Ext.draw.sprite.Sprite#setAttributes call)
         * set attributes themselves and those attributes have triggers defined for them,
         * then their updaters will be called after all current updaters finish execution.
         *
         * The updater functions themselves are defined in the {@link #updaters} config,
         * aside from the 'canvas' updater, which doesn't have to be defined and acts as a flag,
         * indicating that this attribute should be applied to a Canvas context (or whatever emulates it).
         * @since 5.1.0
         */
        triggers?: any;

        /**
         * Defines the postprocessing used by the attribute.
         * Inside the updater function 'this' refers to the sprite that the attributes belong to.
         * In case of an instancing sprite 'this' will refer to the instancing template.
         * The two parameters passed to the updater function are the attributes object
         * of the sprite or instance, and the names of attributes that triggered this updater call.
         *
         * The example below shows how the 'size' updater changes other attributes
         * of a {@link Ext.draw.sprite.Square square} sprite sprite when its 'size' attribute changes.
         *
         *     updaters: {
         *         size: function (attr) {
         *             var size = attr.size;
         *             this.setAttributes({   // Changes to these attributes will trigger the 'path' updater.
         *                 x: attr.x - size,
         *                 y: attr.y - size,
         *                 height: 2 * size,
         *                 width: 2 * size
         *             });
         *         }
         *     }
         */
        updaters?: any;
    }

    /**
     * Flyweight object to process the attributes of a sprite.
     * A single instance of the AttributeDefinition is created per sprite class.
     * See 'onClassCreated' and 'onClassExtended' callbacks
     * of the {@link Ext.draw.sprite.Sprite} for more info.
     */
    export class AttributeDefinition extends Ext.Base implements Ext.draw.sprite.AttributeDefinitionConfig {
        /**
         * Defines the alternative names for attributes.
         */
        aliases: any;

        /**
         * Defines the process used to animate between attributes.
         * One doesn't have to define animation processors for sprite attributes that use
         * predefined {@link #processors} from the {@link Ext.draw.sprite.AttributeParser} singleton.
         * For such attributes matching animation processors from the {@link Ext.draw.sprite.AnimationParser}
         * singleton will be used automatically.
         * However, if you have a custom processor for an attribute that should support
         * animation, you must provide a corresponding animation processor for it here.
         * For more information on animation processors please see {@link Ext.draw.sprite.AnimationParser}
         * documentation.
         */
        animationProcessors: any;

        /**
         * Defines the default values of attributes.
         */
        defaults: any;

        /**
         * @deprecated Use the {@link #triggers} config instead.
         */
        dirtyTriggers: any;

        /**
         * Defines the preprocessing used on the attributes.
         * One can define a custom processor function here or use the name of a predefined
         * processor from the {@link Ext.draw.sprite.AttributeParser} singleton.
         */
        processors: any;

        /**
         * Defines which updaters have to be called when an attribute is changed.
         * For example, the config below indicates that the 'size' updater
         * of a {@link Ext.draw.sprite.Square square} sprite has to be called
         * when the 'size' attribute changes.
         *
         *     triggers: {
         *         size: 'size'   // Use comma-separated values here if multiple updaters have to be called.
         *     }                  // Note that the order is _not_ guaranteed.
         *
         * If any of the updaters to be called (triggered by the {@link Ext.draw.sprite.Sprite#setAttributes call)
         * set attributes themselves and those attributes have triggers defined for them,
         * then their updaters will be called after all current updaters finish execution.
         *
         * The updater functions themselves are defined in the {@link #updaters} config,
         * aside from the 'canvas' updater, which doesn't have to be defined and acts as a flag,
         * indicating that this attribute should be applied to a Canvas context (or whatever emulates it).
         * @since 5.1.0
         */
        triggers: any;

        /**
         * Defines the postprocessing used by the attribute.
         * Inside the updater function 'this' refers to the sprite that the attributes belong to.
         * In case of an instancing sprite 'this' will refer to the instancing template.
         * The two parameters passed to the updater function are the attributes object
         * of the sprite or instance, and the names of attributes that triggered this updater call.
         *
         * The example below shows how the 'size' updater changes other attributes
         * of a {@link Ext.draw.sprite.Square square} sprite sprite when its 'size' attribute changes.
         *
         *     updaters: {
         *         size: function (attr) {
         *             var size = attr.size;
         *             this.setAttributes({   // Changes to these attributes will trigger the 'path' updater.
         *                 x: attr.x - size,
         *                 y: attr.y - size,
         *                 height: 2 * size,
         *                 width: 2 * size
         *             });
         *         }
         *     }
         */
        updaters: any;

        constructor(config: Ext.draw.sprite.AttributeDefinitionConfig);

        getAliases();

        getAnimationProcessors();

        getDefaults();

        getDirtyTriggers();

        getProcessors();

        getTriggers();

        getUpdaters();

        /**
         * Normalizes the changes given via their processors before they are applied as attributes.
         *
         * @param {Object} changes The changes given.
         * @param {Boolean} keepUnrecognized If 'true', unknown attributes will be passed through as normalized values.
         * @return {Object} The normalized values.
         */
        normalize(changes: any, keepUnrecognized: boolean): any;

        setAliases();

        setAnimationProcessors();

        setDefaults();

        setDirtyTriggers();

        setProcessors();

        setTriggers();

        setUpdaters();
    }

    /**
     * Parsers used for sprite attributes if they are {@link Ext.draw.sprite.AttributeDefinition#normalize normalized}
     * (default) when being {@link Ext.draw.sprite.Sprite#setAttributes set}.
     *
     * Methods of the singleton correpond either to the processor functions themselves or processor factories.
     */
    export class AttributeParser {
        /**
         * Normalize angle to the [-180,180) interval.
         * @param n Angle in radians.
         * @returns {Number/undefined} Normalized angle or undefined.
         */
        static angle();

        /**
         * Generates a function that checks if a value matches
         * one of the given attributes.
         * @return {Function}
         */
        static enums(): Function;
    }

    interface CircleConfig extends Ext.draw.sprite.PathConfig {
        /**
         * The center coordinate of the sprite on the x-axis.
         *
         * Optional, Defaults to: 0
         */
        cx?: number;

        /**
         * The center coordinate of the sprite on the y-axis.
         *
         * Optional, Defaults to: 0
         */
        cy?: number;

        /**
         * The radius of the sprite.
         *
         * Optional, Defaults to: 0
         */
        r?: number;
    }

    /**
     * @extends Ext.draw.sprite.Path
     *
     * A sprite that represents a circle.
     *
     *     @example
     *     Ext.create({
     *        xtype: 'draw',
     *        renderTo: document.body,
     *        width: 600,
     *        height: 400,
     *        sprites: [{
     *            type: 'circle',
     *            cx: 100,
     *            cy: 100,
     *            r: 50,
     *            fillStyle: '#1F6D91'
     *        }]
     *     });
     */
    export class Circle extends Ext.draw.sprite.Path implements Ext.draw.sprite.CircleConfig {
        /**
         * The center coordinate of the sprite on the x-axis.
         *
         * Optional, Defaults to: 0
         */
        cx: number;

        /**
         * The center coordinate of the sprite on the y-axis.
         *
         * Optional, Defaults to: 0
         */
        cy: number;

        /**
         * The radius of the sprite.
         *
         * Optional, Defaults to: 0
         */
        r: number;

        constructor(config: Ext.chart.axis.sprite.AxisConfig);

        protected updatePlainBBox(plain: any);
    }

    /**
     * @extends Ext.draw.sprite.Sprite
     *
     * Represents a group of sprites.
     */
    export class Composite extends Ext.draw.sprite.Sprite {
        /**
         * Adds a sprite to the composite.
         */
        add(sprite: Ext.draw.sprite.Sprite|any);

        /**
         * Adds a list of sprites to the composite.
         */
        addAll(sprites: Ext.draw.sprite.Sprite|any);

        constructor();

        destroy();

        getSprites();

        setSprites();
    }

    interface CrossConfig extends Ext.draw.sprite.PathConfig {
        /**
         * The size of the sprite.
         * Meant to be comparable to the size of a circle sprite with the same radius.
         *
         * Optional, Defaults to: 4
         */
        size?: number;
    }

    /**
     * A sprite that represents a cross.
     *
     *     @example
     *     Ext.create({
     *        xtype: 'draw',
     *        renderTo: document.body,
     *        width: 600,
     *        height: 400,
     *        sprites: [{
     *            type: 'cross',
     *            translationX: 100,
     *            translationY: 100,
     *            size: 40,
     *            fillStyle: '#1F6D91'
     *        }]
     *     });
     */
    export class Cross extends Ext.draw.sprite.Path implements Ext.draw.sprite.CrossConfig {
        /**
         * The size of the sprite.
         * Meant to be comparable to the size of a circle sprite with the same radius.
         *
         * Optional, Defaults to: 4
         */
        size: number;

        constructor(config: Ext.chart.axis.sprite.AxisConfig);
    }

    interface DiamondConfig extends Ext.draw.sprite.PathConfig {
        /**
         * The size of the sprite.
         * Meant to be comparable to the size of a circle sprite with the same radius.
         *
         * Optional, Defaults to: 4
         */
        size?: number;
    }

    /**
     * A sprite that represents a diamond.
     *
     *     @example
     *     Ext.create({
     *        xtype: 'draw',
     *        renderTo: document.body,
     *        width: 600,
     *        height: 400,
     *        sprites: [{
     *            type: 'diamond',
     *            translationX: 100,
     *            translationY: 100,
     *            size: 40,
     *            fillStyle: '#1F6D91'
     *        }]
     *     });
     */
    export class Diamond extends Ext.draw.sprite.Path implements Ext.draw.sprite.DiamondConfig {
        /**
         * The size of the sprite.
         * Meant to be comparable to the size of a circle sprite with the same radius.
         *
         * Optional, Defaults to: 4
         */
        size: number;

        constructor(config: Ext.chart.axis.sprite.AxisConfig);
    }

    interface EllipseConfig extends Ext.draw.sprite.PathConfig {
        /**
         * The rotation of the sprite about its axis.
         *
         * Optional, Defaults to: 0
         */
        axisRotation?: number;

        /**
         * The center coordinate of the sprite on the x-axis.
         *
         * Optional, Defaults to: 0
         */
        cx?: number;

        /**
         * The center coordinate of the sprite on the y-axis.
         *
         * Optional, Defaults to: 0
         */
        cy?: number;

        /**
         * The radius of the sprite on the x-axis.
         *
         * Optional, Defaults to: 1
         */
        rx?: number;

        /**
         * The radius of the sprite on the y-axis.
         *
         * Optional, Defaults to: 1
         */
        ry?: number;
    }

    /**
     * @extends Ext.draw.sprite.Path
     *
     * A sprite that represents an ellipse.
     *
     *     @example
     *     Ext.create({
     *        xtype: 'draw',
     *        renderTo: document.body,
     *        width: 600,
     *        height: 400,
     *        sprites: [{
     *            type: 'ellipse',
     *            cx: 100,
     *            cy: 100,
     *            rx: 80,
     *            ry: 50,
     *            fillStyle: '#1F6D91'
     *        }]
     *     });
     */
    export class Ellipse extends Ext.draw.sprite.Path implements Ext.draw.sprite.EllipseConfig {
        /**
         * The rotation of the sprite about its axis.
         *
         * Optional, Defaults to: 0
         */
        axisRotation: number;

        /**
         * The center coordinate of the sprite on the x-axis.
         *
         * Optional, Defaults to: 0
         */
        cx: number;

        /**
         * The center coordinate of the sprite on the y-axis.
         *
         * Optional, Defaults to: 0
         */
        cy: number;

        /**
         * The radius of the sprite on the x-axis.
         *
         * Optional, Defaults to: 1
         */
        rx: number;

        /**
         * The radius of the sprite on the y-axis.
         *
         * Optional, Defaults to: 1
         */
        ry: number;

        constructor(config: Ext.chart.axis.sprite.AxisConfig);

        protected updatePlainBBox(plain: any);
    }

    interface EllipticalArcConfig extends Ext.draw.sprite.EllipseConfig {
        /**
         * Determines whether or not the arc is drawn clockwise.
         *
         * Optional, Defaults to: false
         */
        anticlockwise?: boolean;

        /**
         * The ending angle of the arc.
         *
         * Optional, Defaults to: Math.PI*2
         */
        endAngle?: number;

        /**
         * The beginning angle of the arc.
         *
         * Optional, Defaults to: 0
         */
        startAngle?: number;
    }

    /**
     * @extends Ext.draw.sprite.Ellipse
     *
     * A sprite that represents an elliptical arc.
     *
     *     @example
     *     Ext.create({
     *        xtype: 'draw',
     *        renderTo: document.body,
     *        width: 600,
     *        height: 400,
     *        sprites: [{
     *            type: 'ellipticalArc',
     *            cx: 100,
     *            cy: 100,
     *            rx: 80,
     *            ry: 50,
     *            fillStyle: '#1F6D91',
     *            startAngle: 0,
     *            endAngle: Math.PI,
     *            anticlockwise: true
     *        }]
     *     });
     */
    export class EllipticalArc extends Ext.draw.sprite.Ellipse implements Ext.draw.sprite.EllipticalArcConfig {
        /**
         * Determines whether or not the arc is drawn clockwise.
         *
         * Optional, Defaults to: false
         */
        anticlockwise: boolean;

        /**
         * The ending angle of the arc.
         *
         * Optional, Defaults to: Math.PI*2
         */
        endAngle: number;

        /**
         * The beginning angle of the arc.
         *
         * Optional, Defaults to: 0
         */
        startAngle: number;

        constructor(config: Ext.chart.axis.sprite.AxisConfig);
    }

    interface ImageConfig extends Ext.draw.sprite.RectConfig {
        /**
         * The height of the image.
         * For consistent image size on all devices the height must be explicitly set.
         * Otherwise the natural image height devided by the device pixel ratio
         * (for a crisp looking image) will be used as the height of the sprite.
         *
         * Optional, Defaults to: null
         */
        height?: number;

        /**
         * The image source of the sprite.
         *
         * Optional, Defaults to: ''
         */
        src?: string;

        /**
         * The width of the image.
         * For consistent image size on all devices the width must be explicitly set.
         * Otherwise the natural image width devided by the device pixel ratio
         * (for a crisp looking image) will be used as the width of the sprite.
         *
         * Optional, Defaults to: null
         */
        width?: number;
    }

    /**
     * @extends Ext.draw.sprite.Rect
     *
     * A sprite that represents an image.
     */
    export class Image extends Ext.draw.sprite.Rect implements Ext.draw.sprite.ImageConfig {
        /**
         * The height of the image.
         * For consistent image size on all devices the height must be explicitly set.
         * Otherwise the natural image height devided by the device pixel ratio
         * (for a crisp looking image) will be used as the height of the sprite.
         *
         * Optional, Defaults to: null
         */
        height: number;

        /**
         * The image source of the sprite.
         *
         * Optional, Defaults to: ''
         */
        src: string;

        /**
         * The width of the image.
         * For consistent image size on all devices the width must be explicitly set.
         * Otherwise the natural image width devided by the device pixel ratio
         * (for a crisp looking image) will be used as the width of the sprite.
         *
         * Optional, Defaults to: null
         */
        width: number;

        constructor(config: Ext.chart.axis.sprite.AxisConfig);
    }

    interface InstancingConfig extends Ext.draw.sprite.SpriteConfig {
        /**
         * The sprite template used by all instances.
         *
         * Optional, Defaults to: null
         */
        template?: any;
    }

    /**
     * @extends Ext.draw.sprite.Sprite
     *
     * Sprite that represents multiple instances based on the given template.
     */
    export class Instancing extends Ext.draw.sprite.Sprite implements Ext.draw.sprite.InstancingConfig {
        /**
         * The sprite template used by all instances.
         *
         * Optional, Defaults to: null
         */
        template: any;

        constructor(config: Ext.chart.axis.sprite.AxisConfig);

        /**
         * Creates a new sprite instance.
         *
         * @param {Object} config The configuration of the instance.
         * @param {Boolean} [bypassNormalization] 'true' to bypass attribute normalization.
         * @param {Boolean} [avoidCopy] 'true' to avoid copying the 'config' object.
         * @return {Object} The attributes of the instance.
         */
        createInstance(config: Ext.draw.sprite.InstancingConfig, bypassNormalization?: boolean, avoidCopy?: boolean): any;

        destroy();

        /**
         * Returns the bounding box for the instance at the given index.
         *
         * @param {Number} index The index of the instance.
         * @param {Boolean} [isWithoutTransform] 'true' to not apply sprite transforms to the bounding box.
         * @return {Object} The bounding box for the instance.
         */
        getBBoxFor(index: number, isWithoutTransform?: boolean): any;

        getTemplate();

        /**
         * Sets the attributes for the instance at the given index.
         *
         * @param {Number} index the index of the instance
         * @param {Object} changes the attributes to change
         * @param {Boolean} [bypassNormalization] 'true' to avoid attribute normalization
         */
        setAttributesFor(index: number, changes: any, bypassNormalization?: boolean);

        setTemplate();
    }

    /**
     * A sprite that represents a line.
     *
     *     @example
     *     Ext.create({
     *        xtype: 'draw',
     *        renderTo: document.body,
     *        width: 600,
     *        height: 400,
     *        sprites: [{
     *            type: 'line',
     *            fromX: 20,
     *            fromY: 20,
     *            toX: 120,
     *            toY: 120,
     *            strokeStyle: '#1F6D91',
     *            lineWidth: 3
     *        }]
     *     });
     */
    export class Line extends Ext.draw.sprite.Sprite {
        constructor(config: Ext.chart.axis.sprite.AxisConfig);

        protected updatePlainBBox(plain: any);

        protected updateTransformedBBox(transform: any, plain: any);
    }

    interface PathConfig extends Ext.draw.sprite.SpriteConfig {
        /**
         * The SVG based path string used by the sprite.
         */
        path?: string;
    }

    /**
     * @extends Ext.draw.sprite.Sprite
     *
     * A sprite that represents a path.
     *
     *     @example
     *     Ext.create({
     *        xtype: 'draw',
     *        renderTo: document.body,
     *        width: 600,
     *        height: 400,
     *        sprites: [{
     *            type: 'path',
     *            path: 'M20,30 c0,-50 75,50 75,0 c0,-50 -75,50 -75,0',
     *            fillStyle: '#1F6D91'
     *        }]
     *     });
     *
     * ### Drawing with SVG Paths
     * You may use special SVG Path syntax to "describe" the drawing path.  Here are the SVG path commands:
     *
     * + M = moveto
     * + L = lineto
     * + H = horizontal lineto
     * + V = vertical lineto
     * + C = curveto
     * + S = smooth curveto
     * + Q = quadratic BÃ©zier curve
     * + T = smooth quadratic BÃ©zier curveto
     * + A = elliptical Arc
     * + Z = closepath
     *
     * **Note:** Capital letters indicate that the item should be absolutely positioned.
     * Use lower case letters for relative positioning.
     */
    export class Path extends Ext.draw.sprite.Sprite implements Ext.draw.sprite.PathConfig {
        /**
         * The SVG based path string used by the sprite.
         */
        path: string;

        constructor(config: Ext.chart.axis.sprite.AxisConfig);

        /**
         * Returns all points where this sprite intersects the given sprite.
         * The given sprite must be an instance of the {@link Ext.draw.sprite.Path} class
         * or its subclass.
         * @return {Array}
         */
        getIntersections(): any[];

        /**
         * Tests whether the given point is inside the path.
         * @return {Boolean}
         */
        isPointInPath(): boolean;

        /**
         * Tests whether the given point is on the path.
         * @return {Boolean}
         */
        isPointOnPath(): boolean;

        /**
         * Update the path.
         * @param {Ext.draw.Path} path An empty path to draw on using path API.
         * @param {Object} attr The attribute object. Note: DO NOT use the 'sprite.attr' instead of this
         * if you want to work with instancing.
         */
        updatePath(path: Ext.draw.Path, attr: any);

        protected updatePlainBBox(plain: any);
    }

    interface PlusConfig extends Ext.draw.sprite.PathConfig {
        /**
         * The size of the sprite.
         * Meant to be comparable to the size of a circle sprite with the same radius.
         *
         * Optional, Defaults to: 4
         */
        size?: number;
    }

    /**
     * A sprite that represents a plus.
     *
     *     @example
     *     Ext.create({
     *        xtype: 'draw',
     *        renderTo: document.body,
     *        width: 600,
     *        height: 400,
     *        sprites: [{
     *            type: 'plus',
     *            translationX: 100,
     *            translationY: 100,
     *            size: 40,
     *            fillStyle: '#1F6D91'
     *        }]
     *     });
     */
    export class Plus extends Ext.draw.sprite.Path implements Ext.draw.sprite.PlusConfig {
        /**
         * The size of the sprite.
         * Meant to be comparable to the size of a circle sprite with the same radius.
         *
         * Optional, Defaults to: 4
         */
        size: number;

        constructor(config: Ext.chart.axis.sprite.AxisConfig);
    }

    interface RectConfig extends Ext.draw.sprite.PathConfig {
        /**
         * The height of the sprite.
         *
         * Optional, Defaults to: 8
         */
        height?: number;

        /**
         * The radius of the rounded corners.
         *
         * Optional, Defaults to: 0
         */
        radius?: number;

        /**
         * The width of the sprite.
         *
         * Optional, Defaults to: 8
         */
        width?: number;

        /**
         * The position of the sprite on the x-axis.
         *
         * Optional, Defaults to: 0
         */
        x?: number;

        /**
         * The position of the sprite on the y-axis.
         *
         * Optional, Defaults to: 0
         */
        y?: number;
    }

    /**
     * @extends Ext.draw.sprite.Path
     *
     * A sprite that represents a rectangle.
     *
     *     @example
     *     Ext.create({
     *        xtype: 'draw',
     *        renderTo: document.body,
     *        width: 600,
     *        height: 400,
     *        sprites: [{
     *            type: 'rect',
     *            x: 50,
     *            y: 50,
     *            width: 100,
     *            height: 100,
     *            fillStyle: '#1F6D91'
     *        }]
     *     });
     */
    export class Rect extends Ext.draw.sprite.Path implements Ext.draw.sprite.RectConfig {
        /**
         * The height of the sprite.
         *
         * Optional, Defaults to: 8
         */
        height: number;

        /**
         * The radius of the rounded corners.
         *
         * Optional, Defaults to: 0
         */
        radius: number;

        /**
         * The width of the sprite.
         *
         * Optional, Defaults to: 8
         */
        width: number;

        /**
         * The position of the sprite on the x-axis.
         *
         * Optional, Defaults to: 0
         */
        x: number;

        /**
         * The position of the sprite on the y-axis.
         *
         * Optional, Defaults to: 0
         */
        y: number;

        constructor(config: Ext.chart.axis.sprite.AxisConfig);

        protected updatePlainBBox(plain: any);

        protected updateTransformedBBox(transform: any, plain: any);
    }

    interface SectorConfig extends Ext.draw.sprite.PathConfig {
        /**
         * The center coordinate of the sprite on the x-axis.
         *
         * Optional, Defaults to: 0
         */
        centerX?: number;

        /**
         * The center coordinate of the sprite on the y-axis.
         *
         * Optional, Defaults to: 0
         */
        centerY?: number;

        /**
         * The ending angle of the sprite.
         *
         * Optional, Defaults to: 0
         */
        endAngle?: number;

        /**
         * The ending point of the radius of the sprite.
         *
         * Optional, Defaults to: 150
         */
        endRho?: number;

        /**
         * The margin of the sprite from the center of pie.
         *
         * Optional, Defaults to: 0
         */
        margin?: number;

        /**
         * The starting angle of the sprite.
         *
         * Optional, Defaults to: 0
         */
        startAngle?: number;

        /**
         * The starting point of the radius of the sprite.
         *
         * Optional, Defaults to: 0
         */
        startRho?: number;
    }

    /**
     * @extends Ext.draw.sprite.Path
     *
     * A sprite representing a pie slice.
     *
     *     @example
     *     Ext.create({
     *        xtype: 'draw',
     *        renderTo: document.body,
     *        width: 600,
     *        height: 400,
     *        sprites: [{
     *            type: 'sector',
     *            centerX: 100,
     *            centerY: 100,
     *            startAngle: -2.355,
     *            endAngle: -.785,
     *            endRho: 50,
     *            fillStyle: '#1F6D91'
     *        }]
     *     });
     */
    export class Sector extends Ext.draw.sprite.Path implements Ext.draw.sprite.SectorConfig {
        /**
         * The center coordinate of the sprite on the x-axis.
         *
         * Optional, Defaults to: 0
         */
        centerX: number;

        /**
         * The center coordinate of the sprite on the y-axis.
         *
         * Optional, Defaults to: 0
         */
        centerY: number;

        /**
         * The ending angle of the sprite.
         *
         * Optional, Defaults to: 0
         */
        endAngle: number;

        /**
         * The ending point of the radius of the sprite.
         *
         * Optional, Defaults to: 150
         */
        endRho: number;

        /**
         * The margin of the sprite from the center of pie.
         *
         * Optional, Defaults to: 0
         */
        margin: number;

        /**
         * The starting angle of the sprite.
         *
         * Optional, Defaults to: 0
         */
        startAngle: number;

        /**
         * The starting point of the radius of the sprite.
         *
         * Optional, Defaults to: 0
         */
        startRho: number;

        constructor(config: Ext.chart.axis.sprite.AxisConfig);
    }

    interface SpriteConfig {
        animation?: Ext.draw.modifier.Animation;

        /**
         * The opacity of the fill. Limited from 0 to 1.
         *
         * Optional, Defaults to: 1
         */
        fillOpacity?: number;

        /**
         * The color of the shape (a CSS color value).
         *
         * Optional, Defaults to: "none"
         */
        fillStyle?: string;

        /**
         * The opacity of the sprite. Limited from 0 to 1.
         *
         * Optional, Defaults to: 1
         */
        globalAlpha?: number;

        /**
         * Indicates how source images are drawn onto a destination image.
         * globalCompositeOperation attribute is not supported by the SVG and VML (excanvas) engines.
         *
         * Optional, Defaults to: source-over
         */
        globalCompositeOperation?: string;

        /**
         * Determines whether or not the sprite is hidden.
         *
         * Optional, Defaults to: false
         */
        hidden?: boolean;

        /**
         * The style of the line caps.
         *
         * Optional, Defaults to: "butt"
         */
        lineCap?: string;

        /**
         * An even number of non-negative numbers specifying a dash/space sequence.
         * Note that while this is supported in IE8 (VML engine), the behavior is
         * different from Canvas and SVG. Please refer to this document for details:
         * http://msdn.microsoft.com/en-us/library/bb264085(v=vs.85).aspx
         * Although IE9 and IE10 have Canvas support, the 'lineDash'
         * attribute is not supported in those browsers.
         *
         * Optional, Defaults to: [
         */
        lineDash?: any[];

        /**
         * A number specifying how far into the line dash sequence drawing commences.
         *
         * Optional, Defaults to: 0
         */
        lineDashOffset?: number;

        /**
         * The style of the line join.
         *
         * Optional, Defaults to: "miter"
         */
        lineJoin?: string;

        /**
         * The width of the line stroke.
         *
         * Optional, Defaults to: 1
         */
        lineWidth?: number;

        /**
         * Sets the distance between the inner corner and the outer corner where two lines meet.
         *
         * Optional, Defaults to: 10
         */
        miterLimit?: number;

        /**
         * The immediate parent of the sprite. Not necessarily a surface.
         */
        parent?: Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite;

        /**
         * Applies an initial angle of rotation to the sprite.  May be a number
         * specifying the rotation in degrees.  Or may be a config object using
         * the below config options.
         *
         * **Note:** Rotation config options will be overridden by values set on
         * the {@link #rotationRads}, {@link #rotationCenterX}, and
         * {@link #rotationCenterY} configs.
         *
         *     Ext.create({
         *         xtype: 'draw',
         *         renderTo: Ext.getBody(),
         *         width: 600,
         *         height: 400,
         *         sprites: [{
         *             type: 'rect',
         *             x: 50,
         *             y: 50,
         *             width: 100,
         *             height: 100,
         *             fillStyle: '#1F6D91',
         *             //rotation: 45
         *             rotation: {
         *                 degrees: 45,
         *                 //rads: Math.PI / 4,
         *                 //centerX: 50,
         *                 //centerY: 50
         *             }
         *         }]
         *     });
         *
         * **Note:** Transform configs are *always* performed in the following
         * order:
         *
         *  1. Scaling
         *  2. Rotation
         *  3. Translation
         *
         * The angle in radians to rotate the sprite
         *
         * The angle in degrees to rotate the sprite (is ignored if rads or
         * {@link #rotationRads} is set
         *
         * The central coordinate of the sprite's rotation on the x-axis.
         * Unless explicitly set, will default to the calculated center of the
         * sprite along the x-axis.
         *
         * The central coordinate of the sprite's rotation on the y-axis.
         * Unless explicitly set, will default to the calculated center of the
         * sprite along the y-axis.
         */
        rotation?: number|any;

        /**
         * The central coordinate of the sprite's scale operation on the x-axis.
         * Unless explicitly set, will default to the calculated center of the
         * sprite along the x-axis.
         *
         * **Note:** Transform configs are *always* performed in the following
         * order:
         *
         *  1. Scaling
         *  2. Rotation
         *  3. Translation
         *
         * See also: {@link #rotation}, {@link #rotationRads}, and
         * {@link #rotationCenterY}
         *
         * Optional, Defaults to: null
         */
        rotationCenterX?: number;

        /**
         * The central coordinate of the sprite's rotate operation on the y-axis.
         * Unless explicitly set, will default to the calculated center of the
         * sprite along the y-axis.
         *
         * **Note:** Transform configs are *always* performed in the following
         * order:
         *
         *  1. Scaling
         *  2. Rotation
         *  3. Translation
         *
         * See also: {@link #rotation}, {@link #rotationRads}, and
         * {@link #rotationCenterX}
         *
         * Optional, Defaults to: null
         */
        rotationCenterY?: number;

        /**
         * The angle of rotation of the sprite in radians.
         *
         * **Note:** Transform configs are *always* performed in the following
         * order:
         *
         *  1. Scaling
         *  2. Rotation
         *  3. Translation
         *
         * See also: {@link #rotation}, {@link #rotationCenterX}, and
         * {@link #rotationCenterY}
         *
         * Optional, Defaults to: 0
         */
        rotationRads?: number;

        /**
         * Applies initial scaling to the sprite.  May be a number specifying
         * the amount to scale both the x and y-axis.  The number value
         * represents a percentage by which to scale the sprite.  **1** is equal
         * to 100%, **2** would be 200%, etc.  Or may be a config object using
         * the below config options.
         *
         * **Note:** Scaling config options will be overridden by values set on
         * the {@link #scalingX}, {@link #scalingY}, {@link #scalingCenterX},
         * and {@link #scalingCenterY} configs.
         *
         *     Ext.create({
         *         xtype: 'draw',
         *         renderTo: Ext.getBody(),
         *         width: 600,
         *         height: 400,
         *         sprites: [{
         *             type: 'rect',
         *             x: 50,
         *             y: 50,
         *             width: 100,
         *             height: 100,
         *             fillStyle: '#1F6D91',
         *             //scaling: 2,
         *             scaling: {
         *                 x: 2,
         *                 y: 2
         *                 //centerX: 100,
         *                 //centerY: 100
         *             }
         *         }]
         *     });
         *
         * **Note:** Transform configs are *always* performed in the following
         * order:
         *
         *  1. Scaling
         *  2. Rotation
         *  3. Translation
         *
         * The amount by which to scale the sprite along the x-axis.  The number
         * value represents a percentage by which to scale the sprite.  **1** is
         * equal to 100%, **2** would be 200%, etc.
         *
         * The amount by which to scale the sprite along the y-axis.  The number
         * value represents a percentage by which to scale the sprite.  **1** is
         * equal to 100%, **2** would be 200%, etc.
         *
         * The central coordinate of the sprite's scaling on the x-axis.  Unless
         * explicitly set, will default to the calculated center of the sprite
         * along the x-axis.
         *
         * The central coordinate of the sprite's scaling on the y-axis.  Unless
         * explicitly set, will default to the calculated center of the sprite
         * along the y-axis.
         */
        scaling?: number|any;

        /**
         * The central coordinate of the sprite's scale operation on the x-axis.
         *
         * **Note:** Transform configs are *always* performed in the following
         * order:
         *
         *  1. Scaling
         *  2. Rotation
         *  3. Translation
         *
         * See also: {@link #scaling}, {@link #scalingX},
         * {@link #scalingY}, and {@link #scalingCenterY}
         *
         * Optional, Defaults to: null
         */
        scalingCenterX?: number;

        /**
         * The central coordinate of the sprite's scale operation on the y-axis.
         *
         * **Note:** Transform configs are *always* performed in the following
         * order:
         *
         *  1. Scaling
         *  2. Rotation
         *  3. Translation
         *
         * See also: {@link #scaling}, {@link #scalingX},
         * {@link #scalingY}, and {@link #scalingCenterX}
         *
         * Optional, Defaults to: null
         */
        scalingCenterY?: number;

        /**
         * The scaling of the sprite on the x-axis.
         * The number value represents a percentage by which to scale the
         * sprite.  **1** is equal to 100%, **2** would be 200%, etc.
         *
         * **Note:** Transform configs are *always* performed in the following
         * order:
         *
         *  1. Scaling
         *  2. Rotation
         *  3. Translation
         *
         * See also: {@link #scaling}, {@link #scalingY},
         * {@link #scalingCenterX}, and {@link #scalingCenterY}
         *
         * Optional, Defaults to: 1
         */
        scalingX?: number;

        /**
         * The scaling of the sprite on the y-axis.
         * The number value represents a percentage by which to scale the
         * sprite.  **1** is equal to 100%, **2** would be 200%, etc.
         *
         * **Note:** Transform configs are *always* performed in the following
         * order:
         *
         *  1. Scaling
         *  2. Rotation
         *  3. Translation
         *
         * See also: {@link #scaling}, {@link #scalingX},
         * {@link #scalingCenterX}, and {@link #scalingCenterY}
         *
         * Optional, Defaults to: 1
         */
        scalingY?: number;

        /**
         * The amount blur used on the shadow.
         *
         * Optional, Defaults to: 0
         */
        shadowBlur?: number;

        /**
         * The color of the shadow (a CSS color value).
         *
         * Optional, Defaults to: "none"
         */
        shadowColor?: string;

        /**
         * The offset of the sprite's shadow on the x-axis.
         *
         * Optional, Defaults to: 0
         */
        shadowOffsetX?: number;

        /**
         * The offset of the sprite's shadow on the y-axis.
         *
         * Optional, Defaults to: 0
         */
        shadowOffsetY?: number;

        /**
         * The opacity of the stroke. Limited from 0 to 1.
         *
         * Optional, Defaults to: 1
         */
        strokeOpacity?: number;

        /**
         * The color of the stroke (a CSS color value).
         *
         * Optional, Defaults to: "none"
         */
        strokeStyle?: string;

        /**
         * The surface that this sprite is rendered into.
         */
        surface?: Ext.draw.Surface;

        /**
         * Determines whether the fill and stroke are affected by sprite transformations.
         *
         * Optional, Defaults to: false
         */
        transformFillStroke?: boolean;

        /**
         * Applies an initial translation, adjustment in x/y positioning, to the
         * sprite.
         *
         * **Note:** Translation config options will be overridden by values set
         * on the {@link #translationX} and {@link #translationY} configs.
         *
         *     Ext.create({
         *         xtype: 'draw',
         *         renderTo: Ext.getBody(),
         *         width: 600,
         *         height: 400,
         *             sprites: [{
         *             type: 'rect',
         *             x: 50,
         *             y: 50,
         *             width: 100,
         *             height: 100,
         *             fillStyle: '#1F6D91',
         *             translation: {
         *                 x: 50,
         *                 y: 50
         *             }
         *         }]
         *     });
         *
         * **Note:** Transform configs are *always* performed in the following
         * order:
         *
         *  1. Scaling
         *  2. Rotation
         *  3. Translation
         *
         * The amount to translate the sprite along the x-axis.
         *
         * The amount to translate the sprite along the y-axis.
         */
        translation?: any;

        /**
         * The translation, position offset, of the sprite on the x-axis.
         *
         * **Note:** Transform configs are *always* performed in the following
         * order:
         *
         *  1. Scaling
         *  2. Rotation
         *  3. Translation
         *
         * See also: {@link #translation} and {@link #translationY}
         *
         * Optional, Defaults to: 0
         */
        translationX?: number;

        /**
         * The translation, position offset, of the sprite on the y-axis.
         *
         * **Note:** Transform configs are *always* performed in the following
         * order:
         *
         *  1. Scaling
         *  2. Rotation
         *  3. Translation
         *
         * See also: {@link #translation} and {@link #translationX}
         *
         * Optional, Defaults to: 0
         */
        translationY?: number;

        /**
         * The stacking order of the sprite.
         *
         * Optional, Defaults to: 0
         */
        zIndex?: number;
    }

    /**
     * A sprite is a basic primitive from the charts package which represents a graphical
     * object that can be drawn. Sprites are used extensively in the charts package to
     * create the visual elements of each chart.  You can also create a desired image by
     * adding one or more sprites to a {@link Ext.draw.Container draw container}.
     *
     * The Sprite class itself is an abstract class and is not meant to be used directly.
     * There are many different kinds of sprites available in the charts package that extend
     * Ext.draw.sprite.Sprite. Each sprite type has various attributes that define how that
     * sprite should look. For example, this is a {@link Ext.draw.sprite.Rect rect} sprite:
     *
     *     @example
     *     Ext.create({
     *         xtype: 'draw',
     *         renderTo: document.body,
     *         width: 400,
     *         height: 400,
     *         sprites: [{
     *             type: 'rect',
     *             x: 50,
     *             y: 50,
     *             width: 100,
     *             height: 100,
     *             fillStyle: '#1F6D91'
     *         }]
     *     });
     *
     * By default, sprites are added to the default 'main' {@link Ext.draw.Surface surface}
     * of the draw container.  However, sprites may also be configured with a reference to a
     * specific Ext.draw.Surface when set in the draw container's
     * {@link Ext.draw.Container#cfg-sprites sprites} config.  Specifying a surface
     * other than 'main' will create a surface by that name if it does not already exist.
     *
     *     @example
     *     Ext.create({
     *         xtype: 'draw',
     *         renderTo: document.body,
     *         width: 400,
     *         height: 400,
     *         sprites: [{
     *             type: 'rect',
     *             surface: 'anim',  // a surface with id "anim" will be created automatically
     *             x: 50,
     *             y: 50,
     *             width: 100,
     *             height: 100,
     *             fillStyle: '#1F6D91'
     *         }]
     *     });
     *
     * The ability to have multiple surfaces is useful for performance (and battery life)
     * reasons. Because changes to sprite attributes cause the whole surface (and all
     * sprites in it) to re-render, it makes sense to group sprites by surface, so changes
     * to one group of sprites will only trigger the surface they are in to re-render.
     *
     * You can add a sprite to an existing drawing by adding the sprite to a draw surface.
     *
     *     @example
     *     var drawCt = Ext.create({
     *         xtype: 'draw',
     *         renderTo: document.body,
     *         width: 400,
     *         height: 400
     *     });
     *
     *     // If the surface name is not specified then 'main' will be used
     *     var surface = drawCt.getSurface();
     *
     *     surface.add({
     *         type: 'rect',
     *         x: 50,
     *         y: 50,
     *         width: 100,
     *         height: 100,
     *         fillStyle: '#1F6D91'
     *     });
     *
     *     surface.renderFrame();
     *
     * **Note:** Changes to the sprites on a surface will be not be reflected in the DOM
     * until you call the surface's {@link Ext.draw.Surface#method-renderFrame renderFrame}
     * method.  This must be done after adding, removing, or modifying sprites in order to
     * see the changes on-screen.
     *
     * For information on configuring a sprite with an initial transformation see
     * {@link #scaling}, {@link rotation}, and {@link translation}.
     *
     * For information on applying a transformation to an existing sprite see the
     * Ext.draw.Matrix class.
     */
    export class Sprite extends Ext.Base implements Ext.draw.sprite.SpriteConfig {
        /**
         * The visual attributes of the sprite, e.g. strokeStyle, fillStyle, lineWidth...
         */
        attr: any;

        animation: Ext.draw.modifier.Animation;

        /**
         * The opacity of the fill. Limited from 0 to 1.
         *
         * Optional, Defaults to: 1
         */
        fillOpacity: number;

        /**
         * The color of the shape (a CSS color value).
         *
         * Optional, Defaults to: "none"
         */
        fillStyle: string;

        /**
         * The opacity of the sprite. Limited from 0 to 1.
         *
         * Optional, Defaults to: 1
         */
        globalAlpha: number;

        /**
         * Indicates how source images are drawn onto a destination image.
         * globalCompositeOperation attribute is not supported by the SVG and VML (excanvas) engines.
         *
         * Optional, Defaults to: source-over
         */
        globalCompositeOperation: string;

        /**
         * Determines whether or not the sprite is hidden.
         *
         * Optional, Defaults to: false
         */
        hidden: boolean;

        /**
         * The style of the line caps.
         *
         * Optional, Defaults to: "butt"
         */
        lineCap: string;

        /**
         * An even number of non-negative numbers specifying a dash/space sequence.
         * Note that while this is supported in IE8 (VML engine), the behavior is
         * different from Canvas and SVG. Please refer to this document for details:
         * http://msdn.microsoft.com/en-us/library/bb264085(v=vs.85).aspx
         * Although IE9 and IE10 have Canvas support, the 'lineDash'
         * attribute is not supported in those browsers.
         *
         * Optional, Defaults to: [
         */
        lineDash: any[];

        /**
         * A number specifying how far into the line dash sequence drawing commences.
         *
         * Optional, Defaults to: 0
         */
        lineDashOffset: number;

        /**
         * The style of the line join.
         *
         * Optional, Defaults to: "miter"
         */
        lineJoin: string;

        /**
         * The width of the line stroke.
         *
         * Optional, Defaults to: 1
         */
        lineWidth: number;

        /**
         * Sets the distance between the inner corner and the outer corner where two lines meet.
         *
         * Optional, Defaults to: 10
         */
        miterLimit: number;

        /**
         * The immediate parent of the sprite. Not necessarily a surface.
         */
        parent: Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite;

        /**
         * Applies an initial angle of rotation to the sprite.  May be a number
         * specifying the rotation in degrees.  Or may be a config object using
         * the below config options.
         *
         * **Note:** Rotation config options will be overridden by values set on
         * the {@link #rotationRads}, {@link #rotationCenterX}, and
         * {@link #rotationCenterY} configs.
         *
         *     Ext.create({
         *         xtype: 'draw',
         *         renderTo: Ext.getBody(),
         *         width: 600,
         *         height: 400,
         *         sprites: [{
         *             type: 'rect',
         *             x: 50,
         *             y: 50,
         *             width: 100,
         *             height: 100,
         *             fillStyle: '#1F6D91',
         *             //rotation: 45
         *             rotation: {
         *                 degrees: 45,
         *                 //rads: Math.PI / 4,
         *                 //centerX: 50,
         *                 //centerY: 50
         *             }
         *         }]
         *     });
         *
         * **Note:** Transform configs are *always* performed in the following
         * order:
         *
         *  1. Scaling
         *  2. Rotation
         *  3. Translation
         *
         * The angle in radians to rotate the sprite
         *
         * The angle in degrees to rotate the sprite (is ignored if rads or
         * {@link #rotationRads} is set
         *
         * The central coordinate of the sprite's rotation on the x-axis.
         * Unless explicitly set, will default to the calculated center of the
         * sprite along the x-axis.
         *
         * The central coordinate of the sprite's rotation on the y-axis.
         * Unless explicitly set, will default to the calculated center of the
         * sprite along the y-axis.
         */
        rotation: number|any;

        /**
         * The central coordinate of the sprite's scale operation on the x-axis.
         * Unless explicitly set, will default to the calculated center of the
         * sprite along the x-axis.
         *
         * **Note:** Transform configs are *always* performed in the following
         * order:
         *
         *  1. Scaling
         *  2. Rotation
         *  3. Translation
         *
         * See also: {@link #rotation}, {@link #rotationRads}, and
         * {@link #rotationCenterY}
         *
         * Optional, Defaults to: null
         */
        rotationCenterX: number;

        /**
         * The central coordinate of the sprite's rotate operation on the y-axis.
         * Unless explicitly set, will default to the calculated center of the
         * sprite along the y-axis.
         *
         * **Note:** Transform configs are *always* performed in the following
         * order:
         *
         *  1. Scaling
         *  2. Rotation
         *  3. Translation
         *
         * See also: {@link #rotation}, {@link #rotationRads}, and
         * {@link #rotationCenterX}
         *
         * Optional, Defaults to: null
         */
        rotationCenterY: number;

        /**
         * The angle of rotation of the sprite in radians.
         *
         * **Note:** Transform configs are *always* performed in the following
         * order:
         *
         *  1. Scaling
         *  2. Rotation
         *  3. Translation
         *
         * See also: {@link #rotation}, {@link #rotationCenterX}, and
         * {@link #rotationCenterY}
         *
         * Optional, Defaults to: 0
         */
        rotationRads: number;

        /**
         * Applies initial scaling to the sprite.  May be a number specifying
         * the amount to scale both the x and y-axis.  The number value
         * represents a percentage by which to scale the sprite.  **1** is equal
         * to 100%, **2** would be 200%, etc.  Or may be a config object using
         * the below config options.
         *
         * **Note:** Scaling config options will be overridden by values set on
         * the {@link #scalingX}, {@link #scalingY}, {@link #scalingCenterX},
         * and {@link #scalingCenterY} configs.
         *
         *     Ext.create({
         *         xtype: 'draw',
         *         renderTo: Ext.getBody(),
         *         width: 600,
         *         height: 400,
         *         sprites: [{
         *             type: 'rect',
         *             x: 50,
         *             y: 50,
         *             width: 100,
         *             height: 100,
         *             fillStyle: '#1F6D91',
         *             //scaling: 2,
         *             scaling: {
         *                 x: 2,
         *                 y: 2
         *                 //centerX: 100,
         *                 //centerY: 100
         *             }
         *         }]
         *     });
         *
         * **Note:** Transform configs are *always* performed in the following
         * order:
         *
         *  1. Scaling
         *  2. Rotation
         *  3. Translation
         *
         * The amount by which to scale the sprite along the x-axis.  The number
         * value represents a percentage by which to scale the sprite.  **1** is
         * equal to 100%, **2** would be 200%, etc.
         *
         * The amount by which to scale the sprite along the y-axis.  The number
         * value represents a percentage by which to scale the sprite.  **1** is
         * equal to 100%, **2** would be 200%, etc.
         *
         * The central coordinate of the sprite's scaling on the x-axis.  Unless
         * explicitly set, will default to the calculated center of the sprite
         * along the x-axis.
         *
         * The central coordinate of the sprite's scaling on the y-axis.  Unless
         * explicitly set, will default to the calculated center of the sprite
         * along the y-axis.
         */
        scaling: number|any;

        /**
         * The central coordinate of the sprite's scale operation on the x-axis.
         *
         * **Note:** Transform configs are *always* performed in the following
         * order:
         *
         *  1. Scaling
         *  2. Rotation
         *  3. Translation
         *
         * See also: {@link #scaling}, {@link #scalingX},
         * {@link #scalingY}, and {@link #scalingCenterY}
         *
         * Optional, Defaults to: null
         */
        scalingCenterX: number;

        /**
         * The central coordinate of the sprite's scale operation on the y-axis.
         *
         * **Note:** Transform configs are *always* performed in the following
         * order:
         *
         *  1. Scaling
         *  2. Rotation
         *  3. Translation
         *
         * See also: {@link #scaling}, {@link #scalingX},
         * {@link #scalingY}, and {@link #scalingCenterX}
         *
         * Optional, Defaults to: null
         */
        scalingCenterY: number;

        /**
         * The scaling of the sprite on the x-axis.
         * The number value represents a percentage by which to scale the
         * sprite.  **1** is equal to 100%, **2** would be 200%, etc.
         *
         * **Note:** Transform configs are *always* performed in the following
         * order:
         *
         *  1. Scaling
         *  2. Rotation
         *  3. Translation
         *
         * See also: {@link #scaling}, {@link #scalingY},
         * {@link #scalingCenterX}, and {@link #scalingCenterY}
         *
         * Optional, Defaults to: 1
         */
        scalingX: number;

        /**
         * The scaling of the sprite on the y-axis.
         * The number value represents a percentage by which to scale the
         * sprite.  **1** is equal to 100%, **2** would be 200%, etc.
         *
         * **Note:** Transform configs are *always* performed in the following
         * order:
         *
         *  1. Scaling
         *  2. Rotation
         *  3. Translation
         *
         * See also: {@link #scaling}, {@link #scalingX},
         * {@link #scalingCenterX}, and {@link #scalingCenterY}
         *
         * Optional, Defaults to: 1
         */
        scalingY: number;

        /**
         * The amount blur used on the shadow.
         *
         * Optional, Defaults to: 0
         */
        shadowBlur: number;

        /**
         * The color of the shadow (a CSS color value).
         *
         * Optional, Defaults to: "none"
         */
        shadowColor: string;

        /**
         * The offset of the sprite's shadow on the x-axis.
         *
         * Optional, Defaults to: 0
         */
        shadowOffsetX: number;

        /**
         * The offset of the sprite's shadow on the y-axis.
         *
         * Optional, Defaults to: 0
         */
        shadowOffsetY: number;

        /**
         * The opacity of the stroke. Limited from 0 to 1.
         *
         * Optional, Defaults to: 1
         */
        strokeOpacity: number;

        /**
         * The color of the stroke (a CSS color value).
         *
         * Optional, Defaults to: "none"
         */
        strokeStyle: string;

        /**
         * The surface that this sprite is rendered into.
         */
        surface: Ext.draw.Surface;

        /**
         * Determines whether the fill and stroke are affected by sprite transformations.
         *
         * Optional, Defaults to: false
         */
        transformFillStroke: boolean;

        /**
         * Applies an initial translation, adjustment in x/y positioning, to the
         * sprite.
         *
         * **Note:** Translation config options will be overridden by values set
         * on the {@link #translationX} and {@link #translationY} configs.
         *
         *     Ext.create({
         *         xtype: 'draw',
         *         renderTo: Ext.getBody(),
         *         width: 600,
         *         height: 400,
         *             sprites: [{
         *             type: 'rect',
         *             x: 50,
         *             y: 50,
         *             width: 100,
         *             height: 100,
         *             fillStyle: '#1F6D91',
         *             translation: {
         *                 x: 50,
         *                 y: 50
         *             }
         *         }]
         *     });
         *
         * **Note:** Transform configs are *always* performed in the following
         * order:
         *
         *  1. Scaling
         *  2. Rotation
         *  3. Translation
         *
         * The amount to translate the sprite along the x-axis.
         *
         * The amount to translate the sprite along the y-axis.
         */
        translation: any;

        /**
         * The translation, position offset, of the sprite on the x-axis.
         *
         * **Note:** Transform configs are *always* performed in the following
         * order:
         *
         *  1. Scaling
         *  2. Rotation
         *  3. Translation
         *
         * See also: {@link #translation} and {@link #translationY}
         *
         * Optional, Defaults to: 0
         */
        translationX: number;

        /**
         * The translation, position offset, of the sprite on the y-axis.
         *
         * **Note:** Transform configs are *always* performed in the following
         * order:
         *
         *  1. Scaling
         *  2. Rotation
         *  3. Translation
         *
         * See also: {@link #translation} and {@link #translationX}
         *
         * Optional, Defaults to: 0
         */
        translationY: number;

        /**
         * The stacking order of the sprite.
         *
         * Optional, Defaults to: 0
         */
        zIndex: number;

        constructor(config: Ext.chart.axis.sprite.AxisConfig);

        /**
         * Removes the sprite and clears all listeners.
         */
        destroy();

        /**
         * Returns the current animation instance.
         * return {Ext.draw.modifier.Animation} The animation modifier used to animate the
         * sprite
         */
        getAnimation();

        /**
         * Returns the bounding box for the given Sprite as calculated with the Canvas engine.
         *
         * @param {Boolean} [isWithoutTransform] Whether to calculate the bounding box with the current transforms or not.
         */
        getBBox(isWithoutTransform?: boolean);

        /**
         * Subclass can rewrite this function to gain better performance.
         * @return {Array}
         */
        getBBoxCenter(isWithoutTransform: boolean): any[];

        getParent();

        getSurface();

        /**
         * Hide the sprite.
         * @return {Ext.draw.sprite.Sprite} this
         */
        hide(): Ext.draw.sprite.Sprite;

        /**
         * Performs a hit test on the sprite.
         * @param {Array} point A two-item array containing x and y coordinates of the point.
         * @param {Object} options Hit testing options.
         * @return {Object} A hit result object that contains more information about what
         * exactly was hit or null if nothing was hit.
         */
        hitTest(point: any[], options: any): any;

        /**
         * Called before rendering.
         */
        preRender();

        /**
         * Removes this sprite from its surface.
         * The sprite itself is not destroyed.
         * @return {Ext.draw.sprite.Sprite} Returns the removed sprite or 'null' otherwise.
         */
        remove(): Ext.draw.sprite.Sprite;

        /**
         * Render method.
         * @param {Ext.draw.Surface} surface The surface.
         * @param {Object} ctx A context object compatible with CanvasRenderingContext2D.
         * @param {Array} rect The clip rect (or called dirty rect) of the current rendering. Not to be confused
         * with 'surface.getRect()'.
         *
         * @return {*} returns 'false' to stop rendering in this frame.
         * All the sprites that haven't been rendered will have their dirty flag untouched.
         */
        render(surface: Ext.draw.Surface, ctx: any, rect: any[]): any;

        /**
         * Resets current transformation matrix of a sprite to the identify matrix.
         * @param {Boolean} [isSplit=false] If 'true', transformation attributes are updated.
         * @return {Ext.draw.sprite.Sprite} This sprite.
         */
        resetTransform(isSplit?: boolean): Ext.draw.sprite.Sprite;

        /**
         * Sets the animation config used by the sprite when animating the sprite's
         * attributes and transformation properties.
         *
         *     var drawCt = Ext.create({
         *         xtype: 'draw',
         *         renderTo: document.body,
         *         width: 400,
         *         height: 400,
         *         sprites: [{
         *             type: 'rect',
         *             x: 50,
         *             y: 50,
         *             width: 100,
         *             height: 100,
         *             fillStyle: '#1F6D91'
         *         }]
         *     });
         *
         *     var rect = drawCt.getSurface().getItems()[0];
         *
         *     rect.setAnimation({
         *         duration: 1000,
         *         easing: 'elasticOut'
         *     });
         *
         *     Ext.defer(function () {
         *         rect.setAttributes({
         *             width: 250
         *         });
         *     }, 500);
         *
         * @param {Object} config The Ext.draw.modifier.Animation config for this sprite's
         * animations.
         */
        setAnimation(config: Ext.draw.sprite.SpriteConfig);

        /**
         * Set attributes of the sprite.
         * By default only the attributes that have processors will be set
         * and all other attributes will be filtered out as a result of the
         * normalization process.
         * The normalization process can be skipped. In that case all the given
         * attributes will be set unprocessed. This will result in better
         * performance, but might also pollute the sprite's attributes with
         * unwanted attributes or attributes with invalid values, if one is not
         * careful. See also {@link #setAttributesBypassingNormalization}.
         * If normalization is skipped, one may also chose to avoid copying
         * the given object. This may result in even better performance, but
         * only in cases where most of the attributes have values that are
         * different from the old values, because copying additionally checks
         * if the value has changed.
         *
         * @param {Object} changes The content of the change.
         * @param {Boolean} [bypassNormalization] 'true' to avoid normalization of the given changes.
         * @param {Boolean} [avoidCopy] 'true' to avoid copying the 'changes' object.
         * 'bypassNormalization' should also be 'true'. The content of object may be destroyed.
         */
        setAttributes(changes: any, bypassNormalization?: boolean, avoidCopy?: boolean);

        /**
         * Set attributes of the sprite, assuming the names and values have already been
         * normalized.
         *
         * @deprecated Use setAttributes directy with bypassNormalization argument being 'true'.
         * @param {Object} changes The content of the change.
         * @param {Boolean} [avoidCopy] 'true' to avoid copying the 'changes' object.
         * The content of object may be destroyed.
         */
        setAttributesBypassingNormalization(changes: any, avoidCopy?: boolean);

        setParent();

        setSurface();

        /**
         * Resets current transformation matrix of a sprite to the identify matrix
         * and pre-multiplies it with the given matrix.
         * This is effectively the same as calling {@link #resetTransform},
         * followed by {@link #transform} with the same arguments.
         *
         * See also: {@link #transform}
         *
         *     var drawContainer = new Ext.draw.Container({
         *         renderTo: Ext.getBody(),
         *         width: 380,
         *         height: 380,
         *         sprites: [{
         *             type: 'rect',
         *             width: 100,
         *             height: 100,
         *             fillStyle: 'red'
         *         }]
         *     });
         *
         *     var main = drawContainer.getSurface();
         *     var rect = main.getItems()[0];
         *
         *     var m = new Ext.draw.Matrix().rotate(Math.PI, 100, 100);
         *
         *     rect.setTransform(m);
         *     main.renderFrame();
         *
         * There may be times where the transformation you need to apply cannot easily be
         * accomplished using the spriteâ€™s convenience transform methods.  Or, you may want
         * to pass a matrix directly to the sprite in order to set a transformation.  The
         * 'setTransform' method allows for this sort of advanced usage as well.  The
         * following tables show each transformation matrix used when applying
         * transformations to a sprite.
         *
         * ### Translate
         * <table style="text-align: center;">
         *     <tr>
         *         <td style="font-weight: normal;">1</td>
         *         <td style="font-weight: normal;">0</td>
         *         <td style="font-weight: normal;">tx</td>
         *     </tr>
         *     <tr>
         *         <td>0</td>
         *         <td>1</td>
         *         <td>ty</td>
         *     </tr>
         *     <tr>
         *         <td>0</td>
         *         <td>0</td>
         *         <td>1</td>
         *     </tr>
         * </table>
         *
         * ### Rotate (Î¸ is the angle of rotation)
         * <table style="text-align: center;">
         *     <tr>
         *         <td style="font-weight: normal;">cos(Î¸)</td>
         *         <td style="font-weight: normal;">-sin(Î¸)</td>
         *         <td style="font-weight: normal;">0</td>
         *     </tr>
         *     <tr>
         *         <td>0</td>
         *         <td>cos(Î¸)</td>
         *         <td>0</td>
         *     </tr>
         *     <tr>
         *         <td>0</td>
         *         <td>0</td>
         *         <td>1</td>
         *     </tr>
         * </table>
         *
         * ### Scale
         * <table style="text-align: center;">
         *     <tr>
         *         <td style="font-weight: normal;">sx</td>
         *         <td style="font-weight: normal;">0</td>
         *         <td style="font-weight: normal;">0</td>
         *     </tr>
         *     <tr>
         *         <td>0</td>
         *         <td>cos(Î¸)</td>
         *         <td>0</td>
         *     </tr>
         *     <tr>
         *         <td>0</td>
         *         <td>0</td>
         *         <td>1</td>
         *     </tr>
         * </table>
         *
         * ### Shear X _(Î» is the distance on the x axis to shear by)_
         * <table style="text-align: center;">
         *     <tr>
         *         <td style="font-weight: normal;">1</td>
         *         <td style="font-weight: normal;">Î»x</td>
         *         <td style="font-weight: normal;">0</td>
         *     </tr>
         *     <tr>
         *         <td>0</td>
         *         <td>1</td>
         *         <td>0</td>
         *     </tr>
         *     <tr>
         *         <td>0</td>
         *         <td>0</td>
         *         <td>1</td>
         *     </tr>
         * </table>
         *
         * ### Shear Y (Î» is the distance on the y axis to shear by)
         * <table style="text-align: center;">
         *     <tr>
         *         <td style="font-weight: normal;">1</td>
         *         <td style="font-weight: normal;">0</td>
         *         <td style="font-weight: normal;">0</td>
         *     </tr>
         *     <tr>
         *         <td>Î»y</td>
         *         <td>1</td>
         *         <td>0</td>
         *     </tr>
         *     <tr>
         *         <td>0</td>
         *         <td>0</td>
         *         <td>1</td>
         *     </tr>
         * </table>
         *
         * ### Skew X (Î¸ is the angle to skew by)
         * <table style="text-align: center;">
         *     <tr>
         *         <td style="font-weight: normal;">1</td>
         *         <td style="font-weight: normal;">tan(Î¸)</td>
         *         <td style="font-weight: normal;">0</td>
         *     </tr>
         *     <tr>
         *         <td>0</td>
         *         <td>1</td>
         *         <td>0</td>
         *     </tr>
         *     <tr>
         *         <td>0</td>
         *         <td>0</td>
         *         <td>1</td>
         *     </tr>
         * </table>
         *
         * ### Skew Y (Î¸ is the angle to skew by)
         * <table style="text-align: center;">
         *     <tr>
         *         <td style="font-weight: normal;">1</td>
         *         <td style="font-weight: normal;">0</td>
         *         <td style="font-weight: normal;">0</td>
         *     </tr>
         *     <tr>
         *         <td>tan(Î¸)</td>
         *         <td>1</td>
         *         <td>0</td>
         *     </tr>
         *     <tr>
         *         <td>0</td>
         *         <td>0</td>
         *         <td>1</td>
         *     </tr>
         * </table>
         *
         * Multiplying matrices for translation, rotation, scaling, and shearing / skewing
         * any number of times in the desired order produces a single matrix for a composite
         * transformation.  You can use the product as a value for the 'setTransform'method
         * of a sprite:
         *
         *     mySprite.setTransform([a, b, c, d, e, f]);
         *
         * Where 'a', 'b', 'c', 'd', 'e', 'f' are numeric values that correspond to the
         * following transformation matrix components:
         *
         * <table style="text-align: center;">
         *     <tr>
         *         <td style="font-weight: normal;">a</td>
         *         <td style="font-weight: normal;">c</td>
         *         <td style="font-weight: normal;">e</td>
         *     </tr>
         *     <tr>
         *         <td>b</td>
         *         <td>d</td>
         *         <td>f</td>
         *     </tr>
         *     <tr>
         *         <td>0</td>
         *         <td>0</td>
         *         <td>1</td>
         *     </tr>
         * </table>
         *
         * @param {Ext.draw.Matrix/Number[]} matrix The transformation matrix to apply or its
         * raw elements as an array.
         * @param {Boolean} [isSplit=false] If 'true', transformation attributes are updated.
         * @return {Ext.draw.sprite.Sprite} This sprite.
         */
        setTransform(matrix: Ext.draw.Matrix|number, isSplit?: boolean): Ext.draw.sprite.Sprite;

        /**
         * Show the sprite.
         * @return {Ext.draw.sprite.Sprite} this
         */
        show(): Ext.draw.sprite.Sprite;

        /**
         * Pre-multiplies the current transformation matrix of a sprite with the given matrix.
         * If 'isSplit' parameter is 'true', the resulting matrix is also split into
         * individual components (scaling, rotation, translation) and corresponding sprite
         * attributes are updated. The shearing component is not extracted.
         * Note, that transformation attributes work as if transformations are applied to the
         * local coordinate system of a sprite, while matrix transformations transform
         * the global coordinate space or the surface grid.
         * Since the 'transform' method returns the sprite itself, calls to the method
         * can be chained. And if updating sprite transformation attributes is desired,
         * it can be achieved by setting the 'isSplit' parameter of the last call to 'true'.
         * For example:
         *
         *     sprite.transform(matrixA).transform(matrixB).transform(matrixC, true);
         *
         * See also: {@link #setTransform}
         *
         * @param {Ext.draw.Matrix/Number[]} matrix A transformation matrix or array of its elements.
         * @param {Boolean} [isSplit=false] If 'true', transformation attributes are updated.
         * @return {Ext.draw.sprite.Sprite} This sprite.
         */
        transform(matrix: Ext.draw.Matrix|number, isSplit?: boolean): Ext.draw.sprite.Sprite;

        /**
         * Subclass will fill the plain object with 'x', 'y', 'width', 'height' information
         * of the plain bounding box of this sprite.
         *
         * @param {Object} plain Target object.
         */
        protected updatePlainBBox(plain: any);

        /**
         * Subclass will fill the plain object with 'x', 'y', 'width', 'height' information
         * of the transformed bounding box of this sprite.
         *
         * @param {Object} transform Target object (transformed bounding box) to populate.
         * @param {Object} plain Untransformed bounding box.
         */
        protected updateTransformedBBox(transform: any, plain: any);

        /**
         * Applies sprite's attributes to the given context.
         * @param {Object} ctx Context to apply sprite's attributes to.
         * @param {Array} rect The rect of the context to be affected by gradients.
         */
        useAttributes(ctx: any, rect: any[]);

        /**
         * Debug rendering options:
         *
         * debug: {
         *     bbox: true, // renders the bounding box of the sprite
         *     xray: true  // renders control points of the path (for Ext.draw.sprite.Path and descendants only)
         * }
         */
        static debug: any;
    }

    interface SquareConfig extends Ext.draw.sprite.RectConfig {
        /**
         * The size of the sprite.
         * Meant to be comparable to the size of a circle sprite with the same radius.
         *
         * Optional, Defaults to: 4
         */
        size?: number;
    }

    /**
     * A sprite that represents a square.
     *
     *     @example
     *     Ext.create({
     *        xtype: 'draw',
     *        renderTo: document.body,
     *        width: 600,
     *        height: 400,
     *        sprites: [{
     *            type: 'square',
     *            x: 100,
     *            y: 100,
     *            size: 50,
     *            fillStyle: '#1F6D91'
     *        }]
     *     });
     */
    export class Square extends Ext.draw.sprite.Rect implements Ext.draw.sprite.SquareConfig {
        /**
         * The size of the sprite.
         * Meant to be comparable to the size of a circle sprite with the same radius.
         *
         * Optional, Defaults to: 4
         */
        size: number;

        constructor(config: Ext.chart.axis.sprite.AxisConfig);
    }

    interface TextConfig extends Ext.draw.sprite.SpriteConfig {
        /**
         * The font displayed.
         *
         * Optional, Defaults to: '10px sans-serif'
         */
        font?: string;

        /**
         * The family of the font displayed.
         *
         * Optional, Defaults to: 'sans-serif'
         */
        fontFamily?: string;

        /**
         * The size of the font displayed.
         *
         * Optional, Defaults to: '10px'
         */
        fontSize?: string|number;

        /**
         * The style of the font displayed. {normal, italic, oblique}
         *
         * Optional, Defaults to: ''
         */
        fontStyle?: string;

        /**
         * The variant of the font displayed. {normal, small-caps}
         *
         * Optional, Defaults to: ''
         */
        fontVariant?: string;

        /**
         * The weight of the font displayed. {normal, bold, bolder, lighter}
         *
         * Optional, Defaults to: ''
         */
        fontWeight?: string;

        /**
         * The text represented in the sprite.
         *
         * Optional, Defaults to: ''
         */
        text?: string;

        /**
         * The alignment of the text displayed.
         * {left, right, center, start, end}
         *
         * Optional, Defaults to: 'start'
         */
        textAlign?: string;

        /**
         * The baseline of the text displayed.
         * {top, hanging, middle, alphabetic, ideographic, bottom}
         *
         * Optional, Defaults to: "alphabetic"
         */
        textBaseline?: string;

        /**
         * The position of the sprite on the x-axis.
         *
         * Optional, Defaults to: 0
         */
        x?: number;

        /**
         * The position of the sprite on the y-axis.
         *
         * Optional, Defaults to: 0
         */
        y?: number;
    }

    /**
     * @extends Ext.draw.sprite.Sprite
     *
     * A sprite that represents text.
     *
     *     @example
     *     Ext.create({
     *        xtype: 'draw',
     *        renderTo: document.body,
     *        width: 600,
     *        height: 400,
     *        sprites: [{
     *            type: 'text',
     *            x: 50,
     *            y: 50,
     *            text: 'Sencha',
     *            fontSize: 30,
     *            fillStyle: '#1F6D91'
     *        }]
     *     });
     */
    export class Text extends Ext.draw.sprite.Sprite implements Ext.draw.sprite.TextConfig {
        /**
         * The font displayed.
         *
         * Optional, Defaults to: '10px sans-serif'
         */
        font: string;

        /**
         * The family of the font displayed.
         *
         * Optional, Defaults to: 'sans-serif'
         */
        fontFamily: string;

        /**
         * The size of the font displayed.
         *
         * Optional, Defaults to: '10px'
         */
        fontSize: string|number;

        /**
         * The style of the font displayed. {normal, italic, oblique}
         *
         * Optional, Defaults to: ''
         */
        fontStyle: string;

        /**
         * The variant of the font displayed. {normal, small-caps}
         *
         * Optional, Defaults to: ''
         */
        fontVariant: string;

        /**
         * The weight of the font displayed. {normal, bold, bolder, lighter}
         *
         * Optional, Defaults to: ''
         */
        fontWeight: string;

        /**
         * The text represented in the sprite.
         *
         * Optional, Defaults to: ''
         */
        text: string;

        /**
         * The alignment of the text displayed.
         * {left, right, center, start, end}
         *
         * Optional, Defaults to: 'start'
         */
        textAlign: string;

        /**
         * The baseline of the text displayed.
         * {top, hanging, middle, alphabetic, ideographic, bottom}
         *
         * Optional, Defaults to: "alphabetic"
         */
        textBaseline: string;

        /**
         * The position of the sprite on the x-axis.
         *
         * Optional, Defaults to: 0
         */
        x: number;

        /**
         * The position of the sprite on the y-axis.
         *
         * Optional, Defaults to: 0
         */
        y: number;

        constructor(config: Ext.chart.axis.sprite.AxisConfig);
    }

    interface TickConfig extends Ext.draw.sprite.SpriteConfig {
        /**
         * The size of the sprite.
         * Meant to be comparable to the size of a circle sprite with the same radius.
         *
         * Optional, Defaults to: 4
         */
        size?: number;

        /**
         * The position of the center of the sprite on the x-axis.
         */
        x?: any;

        /**
         * The position of the center of the sprite on the y-axis.
         */
        y?: any;
    }

    /**
     * A veritical line sprite. The x and y configs set the center of the line with the size
     * value determining the height of the line (the line will be twice the height of 'size'
     * since 'size' is added to above and below 'y' to set the line endpoints).
     *
     *     @example
     *     Ext.create({
     *        xtype: 'draw',
     *        renderTo: document.body,
     *        width: 600,
     *        height: 400,
     *        sprites: [{
     *            type: 'tick',
     *            x: 20,
     *            y: 40,
     *            size: 10,
     *            strokeStyle: '#388FAD',
     *            lineWidth: 2
     *        }]
     *     });
     */
    export class Tick extends Ext.draw.sprite.Line implements Ext.draw.sprite.TickConfig {
        /**
         * The size of the sprite.
         * Meant to be comparable to the size of a circle sprite with the same radius.
         *
         * Optional, Defaults to: 4
         */
        size: number;

        /**
         * The position of the center of the sprite on the x-axis.
         */
        x: any;

        /**
         * The position of the center of the sprite on the y-axis.
         */
        y: any;

        constructor(config: Ext.chart.axis.sprite.AxisConfig);
    }

    interface TriangleConfig extends Ext.draw.sprite.PathConfig {
        /**
         * The size of the sprite.
         * Meant to be comparable to the size of a circle sprite with the same radius.
         *
         * Optional, Defaults to: 4
         */
        size?: number;
    }

    /**
     * A sprite that represents a triangle.
     *
     *     @example
     *     Ext.create({
     *        xtype: 'draw',
     *        renderTo: document.body,
     *        width: 600,
     *        height: 400,
     *        sprites: [{
     *            type: 'triangle',
     *            size: 50,
     *            translationX: 100,
     *            translationY: 100,
     *            fillStyle: '#1F6D91'
     *        }]
     *     });
     */
    export class Triangle extends Ext.draw.sprite.Path implements Ext.draw.sprite.TriangleConfig {
        /**
         * The size of the sprite.
         * Meant to be comparable to the size of a circle sprite with the same radius.
         *
         * Optional, Defaults to: 4
         */
        size: number;

        constructor(config: Ext.chart.axis.sprite.AxisConfig);
    }
}

declare module Ext.env {
    /**
     * Provides information about browser.
     *
     * Should not be manually instantiated unless for unit-testing.
     * Access the global instance stored in {@link Ext.browser} instead.
     */
    export class Browser {
        /**
         * The full name of the current browser's engine.
         * Possible values are:
         *
         * - WebKit
         * - Gecko
         * - Presto
         * - Trident
         * - Other
         * @readonly
         */
        engineName: string;

        /**
         * Refer to {@link Ext.Version}.
         * @readonly
         */
        engineVersion: Ext.Version;

        /**
         * 'true' if page is running over SSL.
         */
        isSecure: any;

        /**
         * 'true' if browser is using strict mode.
         */
        isStrict: any;

        /**
         * The full name of the current browser.
         * Possible values are:
         *
         * - IE
         * - Firefox
         * - Safari
         * - Chrome
         * - Opera
         * - Other
         * @readonly
         */
        name: string;

        /**
         * Browser User Agent string.
         */
        userAgent: any;

        /**
         * Refer to {@link Ext.Version}.
         * @readonly
         */
        version: Ext.Version;

        /**
         * A "hybrid" property, can be either accessed as a method call, for example:
         *
         *     if (Ext.browser.is('IE')) {
         *         // ...
         *     }
         *
         * Or as an object with Boolean properties, for example:
         *
         *     if (Ext.browser.is.IE) {
         *         // ...
         *     }
         *
         * Versions can be conveniently checked as well. For example:
         *
         *     if (Ext.browser.is.IE10) {
         *         // Equivalent to (Ext.browser.is.IE && Ext.browser.version.equals(10))
         *     }
         *
         * __Note:__ Only {@link Ext.Version#getMajor major component}  and {@link Ext.Version#getShortVersion simplified}
         * value of the version are available via direct property checking.
         *
         * Supported values are:
         *
         * - IE
         * - Firefox
         * - Safari
         * - Chrome
         * - Opera
         * - WebKit
         * - Gecko
         * - Presto
         * - Trident
         * - WebView
         * - Other
         *
         * @param {String} name The OS name to check.
         * @return {Boolean}
         */
        is(name: string): boolean;
    }

    /**
     * Provides information about operating system environment.
     *
     * Should not be manually instantiated unless for unit-testing.
     * Access the global instance stored in {@link Ext.os} instead.
     */
    export class OS {
    }

    /**
     * This class manages ready detection and handling. Direct use of this class is not
     * recommended. Instead use 'Ext.onReady':
     *
     *      Ext.onReady(function () {
     *          // DOM and Framework are ready...
     *      });
     *
     * ## DOM Ready
     *
     * The lowest-level of readiness is DOM readiness. This level implies only that the document
     * body exists. Many things require the DOM to be ready for manipulation. If that is all
     * that is required, the 'Ext.onDocumentReady' method can be called to register a callback
     * to be called as soon as the DOM is ready:
     *
     *      Ext.onDocumentReady(function () {
     *          // the document body is ready
     *      });
     *
     * ## Framework Ready
     *
     * In production builds of applications it is common to have all of the code loaded before
     * DOM ready, so the need to wait for "onReady" is often confused with only that concern.
     * This is easy to understand, at least in part because historically 'Ext.onReady' only
     * waited for DOM ready.
     *
     * With the introduction of 'Ext.Loader', however, it became common for DOM ready to occur
     * in the middle of dynamically loading code. If application code were executed at that
     * time, any use of the yet-to-be-loaded classes would throw errors. As a consequence of
     * this, the 'Ext.onReady' mechanism was extended to wait for both DOM ready *and* all of
     * the required classes to be loaded.
     *
     * When the framework enters or leaves a state where it is not ready (for example, the
     * first dynamic load is requested or last load completes), 'Ext.env.Ready' is informed.
     * For example:
     *
     *      Ext.env.Ready.block();
     *
     *      //...
     *
     *      Ext.env.Ready.unblock();
     *
     * When there are no blocks and the DOM is ready, the Framework is ready and the "onReady"
     * callbacks are called.
     *
     * Priority can be used to control the ordering of onReady listeners, for example:
     *
     *     Ext.onReady(function() {
     *
     *     }, null, {
     *         priority: 100
     *     });
     *
     * Ready listeners with higher priorities will run sooner than those with lower priorities,
     * the default priority being '0'.  Internally the framework reserves priorities of 1000
     * or greater, and -1000 or lesser for onReady handlers that must run before or after
     * any application code.  Applications should stick to using priorities in the -999 - 999
     * range. The following priorities are currently in use by the framework:
     *
     * - Element_scroll rtl override: '1001'
     * - Event system initialization: '2000'
     * - Ext.dom.Element: '1500'
     *
     * @since 5.0.0
     */
    export class Ready {
        /**
         * This method invokes the given 'listener' instance based on its options.
         */
        static invoke(listener: any);

        /**
         * Invokes as many listeners as are appropriate given the current state. This should
         * only be called when DOM ready is achieved. The remaining business of 'blocks' is
         * handled here.
         */
        static invokeAll();
    }
}

declare module Ext.event {
    /**
     * Just as {@link Ext.dom.Element} wraps around a native DOM node, {@link Ext.event.Event} wraps the browser's native
     * event-object normalizing cross-browser differences such as mechanisms to stop event-propagation along with a method
     * to prevent default actions from taking place.
     *
     * Here is a simple example of how you use it:
     *
     *     @example preview
     *     var container = Ext.create('Ext.Container', {
     *         layout: 'fit',
     *         renderTo: Ext.getBody(),
     *         items: [{
     *             id: 'logger',
     *             styleHtmlContent: true,
     *             html: 'Click somewhere!',
     *             padding: 5
     *         }]
     *     });
     *
     *     container.getEl().on({
     *         click: function(e, node) {
     *             var string = '';
     *
     *             string += 'You clicked at: <strong>{ x: ' + e.pageX + ', y: ' + e.pageY + ' }</strong> <i>(e.pageX & e.pageY)</i>';
     *             string += '<hr />';
     *             string += 'The HTMLElement you clicked has the className of: <strong>' + e.target.className + '</strong> <i>(e.target)</i>';
     *             string += '<hr />';
     *             string += 'The HTMLElement which has the listener has a className of: <strong>' + e.currentTarget.className + '</strong> <i>(e.currentTarget)</i>';
     *
     *             Ext.getCmp('logger').setHtml(string);
     *         }
     *     });
     *
     * ## Recognizers
     *
     * Ext JS includes many default event recognizers to know when a user interacts with the application.
     *
     * For a full list of default recognizers, and more information, please view the {@link Ext.event.gesture.Recognizer} documentation.
     *
     * This class also provides a set of constants for use with key events.  These are useful
     * for determining if a specific key was pressed, and are available both on instances,
     * and as static properties of the class.  The following two statements are equivalent:
     *
     *     if (e.getKey() === Ext.event.Event.TAB) {
     *         // tab key was pressed
     *     }
     *
     *     if (e.getKey() === e.TAB) {
     *         // tab key was pressed
     *     }
     */
    export class Event extends Ext.Base {
        /** Key constant @type Number */
        A: any;

        /** Key constant @type Number */
        ALT: any;

        /**
         * True if the alt key was down during the event.
         */
        altKey: boolean;

        /**
         * The angle of the rotation.
         *
         * **This is only available when the event type is 'rotate'**
         */
        angle: number;

        /** Key constant @type Number */
        B: any;

        /** Key constant @type Number */
        BACKSPACE: any;

        /**
         * The raw browser event which this object wraps.
         */
        browserEvent: Event;

        /**
         * Indicates which mouse button caused the event for mouse events, for example
         * 'mousedown', 'click', 'mouseup':
         * - '0' for left button.
         * - '1' for middle button.
         * - '2' for right button.
         *
         * *Note*: In IE8 & IE9, the 'click' event does not provide the button.
         */
        button: number;

        /** Key constant @type Number */
        C: any;

        /** Key constant @type Number */
        CAPS_LOCK: any;

        /** Key constant @type Number */
        CONTEXT_MENU: any;

        /** Key constant @type Number */
        CTRL: any;

        /**
         * True if the control key was down during the event.
         * In Mac this will also be true when meta key was down.
         */
        ctrlKey: boolean;

        /**
         * Refers to the element the event handler was attached to, vs the 'target', which is
         * the actual element that fired the event.  For example, if the event bubbles, the
         * 'target' element may be a descendant of the 'currentTarget', as the event may
         * have been triggered on the 'target' and then bubbled up to the 'currentTarget'
         * where it was handled.
         */
        currentTarget: HTMLElement;

        /** Key constant @type Number */
        D: any;

        /**
         * Indicates whether or not {@link #preventDefault preventDefault()} was called on the event.
         */
        defaultPrevented: any;

        /**
         * Same as 'currentTarget'
         * @deprecated 5.0.0 use {@link #currentTarget} instead.
         */
        delegatedTarget: HTMLElement;

        /** Key constant @type Number */
        DELETE: any;

        /**
         * The direction of the swipe. Available options are:
         *
         * - up
         * - down
         * - left
         * - right
         *
         * **This is only available when the event type is 'swipe'**
         */
        direction: number;

        /**
         * The distance of the event.
         *
         * **This is only available when the event type is 'swipe' and 'pinch'.**
         */
        distance: number;

        /** Key constant @type Number */
        DOWN: any;

        /**
         * The duration of the swipe.
         *
         * **This is only available when the event type is 'swipe'**
         */
        duration: number;

        /** Key constant @type Number */
        E: any;

        /** Key constant @type Number */
        EIGHT: any;

        /** Key constant @type Number */
        END: any;

        /** Key constant @type Number */
        ENTER: any;

        /** Key constant @type Number */
        ESC: any;

        /** Key constant @type Number */
        F: any;

        /** Key constant @type Number */
        F1: any;

        /** Key constant @type Number */
        F10: any;

        /** Key constant @type Number */
        F11: any;

        /** Key constant @type Number */
        F12: any;

        /** Key constant @type Number */
        F2: any;

        /** Key constant @type Number */
        F3: any;

        /** Key constant @type Number */
        F4: any;

        /** Key constant @type Number */
        F5: any;

        /** Key constant @type Number */
        F6: any;

        /** Key constant @type Number */
        F7: any;

        /** Key constant @type Number */
        F8: any;

        /** Key constant @type Number */
        F9: any;

        /** Key constant @type Number */
        FIVE: any;

        /** Key constant @type Number */
        FOUR: any;

        /** Key constant @type Number */
        G: any;

        /** Key constant @type Number */
        H: any;

        /** Key constant @type Number */
        HOME: any;

        /** Key constant @type Number */
        I: any;

        /** Key constant @type Number */
        INSERT: any;

        /** Key constant @type Number */
        J: any;

        /** Key constant @type Number */
        K: any;

        /** Key constant @type Number */
        L: any;

        /** Key constant @type Number */
        LEFT: any;

        /** Key constant @type Number */
        M: any;

        /** Key constant @type Number */
        N: any;

        /** Key constant @type Number */
        NINE: any;

        /** Key constant @type Number */
        NUM_CENTER: any;

        /** Key constant @type Number */
        NUM_DIVISION: any;

        /** Key constant @type Number */
        NUM_EIGHT: any;

        /** Key constant @type Number */
        NUM_FIVE: any;

        /** Key constant @type Number */
        NUM_FOUR: any;

        /** Key constant @type Number */
        NUM_MINUS: any;

        /** Key constant @type Number */
        NUM_MULTIPLY: any;

        /** Key constant @type Number */
        NUM_NINE: any;

        /** Key constant @type Number */
        NUM_ONE: any;

        /** Key constant @type Number */
        NUM_PERIOD: any;

        /** Key constant @type Number */
        NUM_PLUS: any;

        /** Key constant @type Number */
        NUM_SEVEN: any;

        /** Key constant @type Number */
        NUM_SIX: any;

        /** Key constant @type Number */
        NUM_THREE: any;

        /** Key constant @type Number */
        NUM_TWO: any;

        /** Key constant @type Number */
        NUM_ZERO: any;

        /** Key constant @type Number */
        O: any;

        /** Key constant @type Number */
        ONE: any;

        /** Key constant @type Number */
        P: any;

        /** Key constant @type Number */
        PAGE_DOWN: any;

        /** Key constant @type Number */
        PAGE_UP: any;

        /**
         * The browsers x coordinate of the event.
         * Note: this only works in browsers that support pageX on the native browser event
         * object (pageX is not natively supported in IE9 and earlier).  In Ext JS, for a
         * cross browser normalized x-coordinate use {@link #getX}
         */
        pageX: number;

        /**
         * The browsers y coordinate of the event.
         * Note: this only works in browsers that support pageY on the native browser event
         * object (pageY is not natively supported in IE9 and earlier).  In Ext JS, for a
         * cross browser normalized y-coordinate use {@link #getY}
         */
        pageY: number;

        /** Key constant @type Number */
        PAUSE: any;

        /** Key constant @type Number */
        PRINT_SCREEN: any;

        /** Key constant @type Number */
        Q: any;

        /** Key constant @type Number */
        R: any;

        /** Key constant @type Number */
        RETURN: any;

        /** Key constant @type Number */
        RIGHT: any;

        /**
         * A amount of rotation, since the start of the event.
         *
         * **This is only available when the event type is 'rotate'**
         */
        rotation: number;

        /** Key constant @type Number */
        S: any;

        /**
         * The scape of a pinch event.
         *
         * **This is only available when the event type is 'pinch'**
         */
        scale: number;

        /** Key constant @type Number */
        SEVEN: any;

        /** Key constant @type Number */
        SHIFT: any;

        /**
         * True if the shift key was down during the event.
         */
        shiftKey: boolean;

        /** Key constant @type Number */
        SIX: any;

        /** Key constant @type Number */
        SPACE: any;

        /** Key constant @type Number */
        T: any;

        /** Key constant @type Number */
        TAB: any;

        /**
         * The element that fired this event.  For the element whose handlers are currently
         * being processed, i.e. the element that the event handler was attached to, use
         * 'currentTarget'
         */
        target: HTMLElement;

        /** Key constant @type Number */
        THREE: any;

        /** Key constant @type Number */
        TWO: any;

        /** Key constant @type Number */
        U: any;

        /** Key constant @type Number */
        UP: any;

        /** Key constant @type Number */
        V: any;

        /** Key constant @type Number */
        W: any;

        /**
         * The mouse wheel delta scaling factor. This value depends on browser version and OS and
         * attempts to produce a similar scrolling experience across all platforms and browsers.
         *
         * To change this value:
         *
         *      Ext.event.Event.prototype.WHEEL_SCALE = 72;
         */
        WHEEL_SCALE: number;

        /** Key constant @type Number */
        X: any;

        /** Key constant @type Number */
        Y: any;

        /** Key constant @type Number */
        Z: any;

        /** Key constant @type Number */
        ZERO: any;

        /**
         * Prevents interpretation of this event as part of a gesture lifecycle.
         *
         * For example a 'touchstart' listener might call 'cancelGesture' to prevent
         * any drag gestures being started by the 'touchstart'.
         */
        cancelGesture();

        constructor(event: any);

        /**
         * Gets the character code for the event.
         * @return {Number}
         */
        getCharCode(): number;

        /**
         * Returns a normalized keyCode for the event.
         * @return {Number} The key code
         */
        getKey(): number;

        /**
         * Returns the name of the keyCode for the event.
         * @return {String} The key name
         */
        getKeyName(): string;

        /**
         * Gets the x coordinate of the event.
         * @return {Number}
         * @deprecated 4.0 use {@link #getX} instead
         */
        getPageX(): number;

        /**
         * Gets the y coordinate of the event.
         * @return {Number}
         * @deprecated 4.0 use {@link #getY} instead
         */
        getPageY(): number;

        /**
         * Returns a point object that consists of the object coordinates.
         * @return {Ext.util.Point} point
         */
        getPoint(): Ext.util.Point;

        /**
         * Gets the related target.
         * @param {String} [selector] A simple selector to filter the target or look for an
         * ancestor of the target. See {@link Ext.dom.Query} for information about simple
         * selectors.
         * @param {Number/HTMLElement} [maxDepth] The max depth to search as a number or
         * element (defaults to 10 || document.body).
         * @param {Boolean} [returnEl] 'true' to return a Ext.Element object instead of DOM
         * node.
         * @return {HTMLElement}
         */
        getRelatedTarget(selector?: string, maxDepth?: number|HTMLElement, returnEl?: boolean): HTMLElement;

        /**
         * Gets the target for the event.
         * @param {String} selector (optional) A simple selector to filter the target or look
         * for an ancestor of the target
         * @param {Number/Mixed} [maxDepth=10||document.body] (optional) The max depth to
         * search as a number or element (defaults to 10 || document.body)
         * @param {Boolean} returnEl (optional) 'true' to return a Ext.Element object instead
         * of DOM node.
         * @return {HTMLElement}
         */
        getTarget(selector: string, maxDepth?: number|any, returnEl?: boolean): HTMLElement;

        /**
         * Returns the time of the event.
         * @return {Date}
         */
        getTime(): Date;

        /**
         * Normalizes mouse wheel y-delta across browsers. To get x-delta information, use
         * {@link #getWheelDeltas} instead.
         * @return {Number} The mouse wheel y-delta
         */
        getWheelDelta(): number;

        /**
         * Returns the mouse wheel deltas for this event.
         * @return {Object} An object with "x" and "y" properties holding the mouse wheel deltas.
         */
        getWheelDeltas(): any;

        /**
         * Gets the x coordinate of the event.
         * @return {Number}
         */
        getX(): number;

        /**
         * Gets the X and Y coordinates of the event.
         * @return {Number[]} The xy values like [x, y]
         */
        getXY(): number;

        /**
         * Gets the y coordinate of the event.
         * @return {Number}
         */
        getY(): number;

        /**
         * Returns true if the control, meta, shift or alt key was pressed during this event.
         * @return {Boolean}
         */
        hasModifier(): boolean;

        /**
         * Checks if the key pressed was a "navigation" key. A navigation key is defined by
         * these keys:
         *
         *  - Page Up
         *  - Page Down
         *  - End
         *  - Home
         *  - Left
         *  - Up
         *  - Right
         *  - Down
         *  - Return
         *  - Tab
         *  - Esc
         *
         * @param {Boolean} [scrollableOnly] Only check navigation keys that can cause
         * element scrolling by their default action.
         *
         * @return {Boolean} 'true' if the press is a navigation keypress
         */
        isNavKeyPress(scrollableOnly?: boolean): boolean;

        /**
         * Checks if the key pressed was a "special" key. A special key is defined as one of
         * these keys:
         *
         *  - Page Up
         *  - Page Down
         *  - End
         *  - Home
         *  - Left arrow
         *  - Up arrow
         *  - Right arrow
         *  - Down arrow
         *  - Return
         *  - Tab
         *  - Esc
         *  - Backspace
         *  - Delete
         *  - Shift
         *  - Ctrl
         *  - Alt
         *  - Pause
         *  - Caps Lock
         *  - Print Screen
         *  - Insert
         *
         * @return {Boolean} 'true' if the key for this event is special
         */
        isSpecialKey(): boolean;

        /**
         * Prevents the browsers default handling of the event.
         */
        preventDefault();

        /**
         * Stop the event ('{@link #preventDefault}' and '{@link #stopPropagation}').
         */
        stopEvent();

        /**
         * Cancels bubbling of the event.
         */
        stopPropagation();

        /**
         * Returns true if the target of this event is a child of 'el'.  Unless the allowEl
         * parameter is set, it will return false if if the target is 'el'.
         * Example usage:
         *
         *     // Handle click on any child of an element
         *     Ext.getBody().on('click', function(e){
         *         if(e.within('some-el')){
         *             alert('Clicked on a child of some-el!');
         *         }
         *     });
         *
         *     // Handle click directly on an element, ignoring clicks on child nodes
         *     Ext.getBody().on('click', function(e,t){
         *         if((t.id == 'some-el') && !e.within(t, true)){
         *             alert('Clicked directly on some-el!');
         *         }
         *     });
         *
         * @param {String/HTMLElement/Ext.dom.Element} el The id, DOM element or Ext.Element to check
         * @param {Boolean} [related] 'true' to test if the related target is within el instead
         * of the target
         * @param {Boolean} [allowEl] 'true' to also check if the passed element is the target
         * or related target
         * @return {Boolean}
         */
        within(el: string|HTMLElement|Ext.dom.Element, related?: boolean, allowEl?: boolean): boolean;
    }
}

declare module Ext.event.gesture {
    interface DoubleTapConfig {
        /**
         * The maximum distance a touch can move without canceling recognition
         */
        moveDistance?: any;

        /**
         * The minimum distance the second tap can occur from the first tap and still
         * be considered a doubletap
         */
        tapDistance?: any;
    }

    /**
     * A simple event recognizer which knows when you double tap.
     */
    export class DoubleTap extends Ext.event.gesture.SingleTouch implements Ext.event.gesture.DoubleTapConfig {
        priority: any;

        /**
         * The maximum distance a touch can move without canceling recognition
         */
        moveDistance: any;

        /**
         * The minimum distance the second tap can occur from the first tap and still
         * be considered a doubletap
         */
        tapDistance: any;

        constructor(config: Ext.event.gesture.DoubleTapConfig);

        getMaxDuration();

        getMoveDistance();

        getTapDistance();

        setMaxDuration();

        setMoveDistance();

        setTapDistance();
    }

    interface DragConfig {
        /**
         * The minimum distance of pixels before a touch event becomes a drag event.
         */
        minDistance?: number;
    }

    export class Drag extends Ext.event.gesture.SingleTouch implements Ext.event.gesture.DragConfig {
        priority: any;

        /**
         * The minimum distance of pixels before a touch event becomes a drag event.
         */
        minDistance: number;

        constructor();

        getMinDistance();

        setMinDistance();
    }

    /**
     * A event recognizer created to recognize swipe movements from the edge of a container.
     */
    export class EdgeSwipe extends Ext.event.gesture.Swipe {
        priority: any;

        constructor(config: Ext.event.gesture.DoubleTapConfig);

        getMinDistance();

        setMinDistance();
    }

    /**
     * A event recognizer which knows when you tap and hold for more than 1 second.
     */
    export class LongPress extends Ext.event.gesture.SingleTouch {
        priority: any;

        constructor(config: Ext.event.gesture.DoubleTapConfig);

        getMinDuration();

        getMoveDistance();

        setMinDuration();

        setMoveDistance();
    }

    /**
     * A base class for gesture recognizers that involve multiple simultaneous contact points
     * between the screen and the input-device, e.g. 'pinch' and 'rotate'
     * @abstract
     */
    export class MultiTouch extends Ext.event.gesture.Recognizer {
        constructor(config: Ext.event.gesture.DoubleTapConfig);
    }

    /**
     * A event recognizer which knows when you pinch.
     */
    export class Pinch extends Ext.event.gesture.MultiTouch {
        priority: any;

        constructor(config: Ext.event.gesture.DoubleTapConfig);
    }

    /**
     * A base class for all gesture recognizers.
     *
     * The following gestures are enabled by default in both Ext JS and Sencha Touch:
     *
     * * {@link Ext.event.gesture.Tap}
     * * {@link Ext.event.gesture.DoubleTap}
     * * {@link Ext.event.gesture.LongPress}
     * * {@link Ext.event.gesture.Drag}
     * * {@link Ext.event.gesture.Swipe}
     * * {@link Ext.event.gesture.Pinch}
     * * {@link Ext.event.gesture.Rotate}
     * * {@link Ext.event.gesture.EdgeSwipe}
     *
     * @abstract
     */
    export class Recognizer extends Ext.Base {
        /**
         * The priority of the recognizer. Determines the order in which it recognizes gestures
         * relative to other recognizers.  The default recognizers use the following priorities:
         *
         * - Ext.event.gesture.Drag: 100
         * - Ext.event.gesture.Tap: 200
         * - Ext.event.gesture.DoubleTap: 300
         * - Ext.event.gesture.LongPress: 400
         * - Ext.event.gesture.Swipe: 500
         * - Ext.event.gesture.Pinch: 600
         * - Ext.event.gesture.Rotate: 700
         * - Ext.event.gesture.EdgeSwipe: 800
         */
        priority: any;

        constructor(config: Ext.event.gesture.DoubleTapConfig);

        getCallbackScope();

        getOnRecognized();

        setCallbackScope();

        setOnRecognized();
    }

    /**
     * A simple event recognizer which knows when you rotate.
     */
    export class Rotate extends Ext.event.gesture.MultiTouch {
        priority: any;

        constructor(config: Ext.event.gesture.DoubleTapConfig);
    }

    /**
     * A base class for gesture recognizers that are only concerned with a single point of
     * contact between the screen and the input-device.
     * @abstract
     */
    export class SingleTouch extends Ext.event.gesture.Recognizer {
        constructor(config: Ext.event.gesture.DoubleTapConfig);
    }

    /**
     * A gesture recognizer for swipe events
     */
    export class Swipe extends Ext.event.gesture.SingleTouch {
        priority: any;

        constructor(config: Ext.event.gesture.DoubleTapConfig);

        getMaxDuration();

        getMaxOffset();

        getMinDistance();

        setMaxDuration();

        setMaxOffset();

        setMinDistance();
    }

    interface TapConfig {
        /**
         * The maximimum distance in pixels a touchstart event can travel and still be considered a tap event.
         */
        moveDistance?: number;
    }

    /**
     * A simple event recogniser which knows when you tap.
     */
    export class Tap extends Ext.event.gesture.SingleTouch implements Ext.event.gesture.TapConfig {
        priority: any;

        /**
         * The maximimum distance in pixels a touchstart event can travel and still be considered a tap event.
         */
        moveDistance: number;

        constructor(config: Ext.event.gesture.DoubleTapConfig);

        getMoveDistance();

        setMoveDistance();
    }
}

declare module Ext.event.publisher {
    export class Dom extends Ext.event.publisher.Publisher {
        /**
         * An array of DOM events that this publisher handles.  Events specified in this array
         * will be added as global listeners on the {@link #target}
         */
        handledDomEvents: any[];

        constructor();

        destroy();

        /**
         * Resets the internal state of the Dom publisher.  Internally the Dom publisher
         * keeps track of timing and coordinates of events for eliminating browser duplicates
         * (e.g. emulated mousedown after pointerdown etc.).  This method resets all this
         * cached data to a state similar to when the publisher was first instantiated.
         *
         * Applications will not typically need to use this method, but it is useful for
         * Unit-testing situations where a clean slate is required for each test.
         */
        reset();
    }

    export class ElementPaint extends Ext.event.publisher.Publisher {
        handledEvents: any[];

        constructor();
    }

    export class ElementSize extends Ext.event.publisher.Publisher {
        handledEvents: any[];

        constructor();
    }

    export class Focus extends Ext.event.publisher.Dom {
        handledDomEvents: any[];

        handledEvents: any[];

        constructor();
    }

    export class Gesture extends Ext.event.publisher.Dom {
        handledDomEvents: any[];

        handledEvents: any[];

        constructor(config: any);

        /**
         * Resets the internal state of the Gesture publisher and all of its recognizers.
         * Applications will not typically need to use this method, but it is useful for
         * Unit-testing situations where a clean slate is required for each test.
         *
         * Calling this method will also reset the state of Ext.event.publisher.Dom
         */
        reset();
    }

    /**
     * Abstract base class for event publishers
     */
    export class Publisher extends Ext.Base {
        /**
         * An array of events that this publisher handles.
         */
        handledEvents: any[];

        constructor();

        /**
         * Registers all {@link #handledEvents} in the
         * {@link Ext.event.publisher.Publisher#publishersByEvent} map.
         * @param {String[]} [events] optional events to register instead of handledEvents.
         */
        protected registerEvents(events?: string);

        /**
         * A map of all publisher singleton instances.  Publishers register themselves
         * in this map as soon as they are constructed.
         */
        static publishers: any;

        /**
         * A map of handled event names to the publisher that handles each event.
         * Provides a convenient way for looking up the publisher that handles any given
         * event, for example:
         *
         *     // get the publisher that  handles click:
         *     var publisher = Ext.event.publisher.Publisher.publishersByEvent.click;
         */
        static publishersByEvent: any;
    }
}

declare module Ext.field {
    interface CheckboxConfig extends Ext.field.FieldConfig {
        /**
         * 'true' if the checkbox should render initially checked.
         */
        checked?: boolean;

        component?: any;

        publishes?: any;

        twoWayBindable?: any;

        ui?: any;
    }

    /**
     * The checkbox field is an enhanced version of the native browser checkbox and is great for enabling your user to
     * choose one or more items from a set (for example choosing toppings for a pizza order). It works like any other
     * {@link Ext.field.Field field} and is usually found in the context of a form:
     *
     * ## Example
     *
     *     @example miniphone preview
     *     var form = Ext.create('Ext.form.Panel', {
     *         fullscreen: true,
     *         items: [
     *             {
     *                 xtype: 'checkboxfield',
     *                 name : 'tomato',
     *                 label: 'Tomato',
     *                 value: 'tomato',
     *                 checked: true
     *             },
     *             {
     *                 xtype: 'checkboxfield',
     *                 name : 'salami',
     *                 label: 'Salami'
     *             },
     *             {
     *                 xtype: 'toolbar',
     *                 docked: 'bottom',
     *                 items: [
     *                     { xtype: 'spacer' },
     *                     {
     *                         text: 'getValues',
     *                         handler: function() {
     *                             var form = Ext.ComponentQuery.query('formpanel')[0],
     *                                 values = form.getValues();
     *
     *                             Ext.Msg.alert(null,
     *                                 "Tomato: " + ((values.tomato) ? "yes" : "no") +
     *                                 "<br />Salami: " + ((values.salami) ? "yes" : "no")
     *                             );
     *                         }
     *                     },
     *                     { xtype: 'spacer' }
     *                 ]
     *             }
     *         ]
     *     });
     *
     *
     * The form above contains two check boxes - one for Tomato, one for Salami. We configured the Tomato checkbox to be
     * checked immediately on load, and the Salami checkbox to be unchecked. We also specified an optional text
     * {@link #value} that will be sent when we submit the form. We can get this value using the Form's
     * {@link Ext.form.Panel#getValues getValues} function, or have it sent as part of the data that is sent when the
     * form is submitted:
     *
     *     form.getValues(); //contains a key called 'tomato' if the Tomato field is still checked
     *     form.submit(); //will send 'tomato' in the form submission data
     */
    export class Checkbox extends Ext.field.Field implements Ext.field.CheckboxConfig {
        defaultBindProperty: any;

        /**
         * 'true' if the checkbox should render initially checked.
         */
        checked: boolean;

        /**
         * The inner component for this field.
         */
        component: any;

        publishes: any;

        twoWayBindable: any;

        /**
         * The ui to be used on this Component
         */
        ui: string;

        /**
         * Set the checked state of the checkbox to 'true'.
         * @return {Ext.field.Checkbox} This checkbox.
         */
        check(): Ext.field.Checkbox;

        /**
         * Creates new Component.
         * @param {Object} config The standard configuration object.
         */
        constructor(config: Ext.ButtonConfig);

        getChecked();

        getComponent();

        /**
         * Returns an array of values from the checkboxes in the group that are checked.
         * @return {Array}
         */
        getGroupValues(): any[];

        /**
         * Returns the submit value for the checkbox which can be used when submitting forms.
         * @return {Boolean/String} value The value of {@link #value} or 'true', if {@link #checked}.
         */
        getSubmitValue(): boolean|string;

        getUi();

        getValue();

        /**
         * Returns the checked state of the checkbox.
         * @return {Boolean} 'true' if checked, 'false' otherwise.
         */
        isChecked(): boolean;

        /**
         * Resets the status of all matched checkboxes in the same group to checked.
         * @return {Ext.field.Checkbox} This checkbox.
         */
        resetGroupValues(): Ext.field.Checkbox;

        setChecked();

        setComponent();

        /**
         * Set the status of all matched checkboxes in the same group to checked.
         * @param {Array} values An array of values.
         * @return {Ext.field.Checkbox} This checkbox.
         */
        setGroupValues(values: any[]): Ext.field.Checkbox;

        setUi();

        setValue();

        /**
         * Set the checked state of the checkbox to 'false'.
         * @return {Ext.field.Checkbox} This checkbox.
         */
        uncheck(): Ext.field.Checkbox;

        /**
         * Fires when the field value changes.
         * @param {Ext.field.Checkbox} this This field.
         * @param {Boolean} newValue The new value.
         * @param {Boolean} oldValue The original value.
         */
        change(that: Ext.field.Checkbox, newValue: boolean, oldValue: boolean);
    }

    interface DatePickerConfig extends Ext.field.PickerConfig {
        /**
         * The format to be used when displaying the date in this field.
         * Accepts any valid date format. You can view formats over in the {@link Ext.Date} documentation.
         *
         * Optional, Defaults to: Ext.util.Format.defaultDateFormat
         */
        dateFormat?: string;

        /**
         * Whether or not to destroy the picker widget on hide. This save memory if it's not used frequently,
         * but increase delay time on the next show due to re-instantiation.
         */
        destroyPickerOnHide?: boolean;

        /**
         * An object that is used when creating the internal {@link Ext.picker.Date} component or a direct instance of {@link Ext.picker.Date}.
         */
        picker?: any|Ext.picker.Date;

        ui?: any;
    }

    /**
     * This is a specialized field which shows a {@link Ext.picker.Date} when tapped. If it has a predefined value,
     * or a value is selected in the {@link Ext.picker.Date}, it will be displayed like a normal {@link Ext.field.Text}
     * (but not selectable/changable).
     *
     *     Ext.create('Ext.field.DatePicker', {
     *         label: 'Birthday',
     *         value: new Date()
     *     });
     *
     * {@link Ext.field.DatePicker} fields are very simple to implement, and have no required configurations.
     *
     * ## Examples
     *
     * It can be very useful to set a default {@link #value} configuration on {@link Ext.field.DatePicker} fields. In
     * this example, we set the {@link #value} to be the current date. You can also use the {@link #setValue} method to
     * update the value at any time.
     *
     *     @example miniphone preview
     *     Ext.create('Ext.form.Panel', {
     *         fullscreen: true,
     *         items: [
     *             {
     *                 xtype: 'fieldset',
     *                 items: [
     *                     {
     *                         xtype: 'datepickerfield',
     *                         label: 'Birthday',
     *                         name: 'birthday',
     *                         value: new Date()
     *                     }
     *                 ]
     *             },
     *             {
     *                 xtype: 'toolbar',
     *                 docked: 'bottom',
     *                 items: [
     *                     { xtype: 'spacer' },
     *                     {
     *                         text: 'setValue',
     *                         handler: function() {
     *                             var datePickerField = Ext.ComponentQuery.query('datepickerfield')[0];
     *
     *                             var randomNumber = function(from, to) {
     *                                 return Math.floor(Math.random() * (to - from + 1) + from);
     *                             };
     *
     *                             datePickerField.setValue({
     *                                 month: randomNumber(0, 11),
     *                                 day  : randomNumber(0, 28),
     *                                 year : randomNumber(1980, 2011)
     *                             });
     *                         }
     *                     },
     *                     { xtype: 'spacer' }
     *                 ]
     *             }
     *         ]
     *     });
     *
     * When you need to retrieve the date from the {@link Ext.field.DatePicker}, you can either use the {@link #getValue} or
     * {@link #getFormattedValue} methods:
     *
     *     @example preview
     *     Ext.create('Ext.form.Panel', {
     *         fullscreen: true,
     *         items: [
     *             {
     *                 xtype: 'fieldset',
     *                 items: [
     *                     {
     *                         xtype: 'datepickerfield',
     *                         label: 'Birthday',
     *                         name: 'birthday',
     *                         value: new Date()
     *                     }
     *                 ]
     *             },
     *             {
     *                 xtype: 'toolbar',
     *                 docked: 'bottom',
     *                 items: [
     *                     {
     *                         text: 'getValue',
     *                         handler: function() {
     *                             var datePickerField = Ext.ComponentQuery.query('datepickerfield')[0];
     *                             Ext.Msg.alert(null, datePickerField.getValue());
     *                         }
     *                     },
     *                     { xtype: 'spacer' },
     *                     {
     *                         text: 'getFormattedValue',
     *                         handler: function() {
     *                             var datePickerField = Ext.ComponentQuery.query('datepickerfield')[0];
     *                             Ext.Msg.alert(null, datePickerField.getFormattedValue());
     *                         }
     *                     }
     *                 ]
     *             }
     *         ]
     *     });
     */
    export class DatePicker extends Ext.field.Picker implements Ext.field.DatePickerConfig {
        /**
         * The format to be used when displaying the date in this field.
         * Accepts any valid date format. You can view formats over in the {@link Ext.Date} documentation.
         *
         * Optional, Defaults to: Ext.util.Format.defaultDateFormat
         */
        dateFormat: string;

        /**
         * Whether or not to destroy the picker widget on hide. This save memory if it's not used frequently,
         * but increase delay time on the next show due to re-instantiation.
         */
        destroyPickerOnHide: boolean;

        /**
         * An object that is used when creating the internal {@link Ext.picker.Date} component or a direct instance of {@link Ext.picker.Date}.
         */
        picker: any|Ext.picker.Date;

        ui: string;

        /**
         * Creates new Component.
         * @param {Object} config The standard configuration object.
         */
        constructor(config: Ext.ButtonConfig);

        getDateFormat();

        getDestroyPickerOnHide();

        /**
         * Returns the value of the field formatted using the specified format. If it is not specified, it will default to
         * {@link #dateFormat} and then {@link Ext.util.Format#defaultDateFormat}.
         * @param {String} format The format to be returned.
         * @return {String} The formatted date.
         */
        getFormattedValue(format: string): string;

        getUi();

        setDateFormat();

        setDestroyPickerOnHide();

        setPicker();

        setUi();

        setValue();
    }

    export class DatePickerNative extends Ext.field.DatePicker {
        /**
         * Creates new Component.
         * @param {Object} config The standard configuration object.
         */
        constructor(config: Ext.ButtonConfig);
    }

    interface EmailConfig extends Ext.field.TextConfig {
        autoCapitalize?: any;

        component?: any;
    }

    /**
     * The Email field creates an HTML5 email input and is usually created inside a form. Because it creates an HTML email
     * input field, most browsers will show a specialized virtual keyboard for email address input. Aside from that, the
     * email field is just a normal text field. Here's an example of how to use it in a form:
     *
     *     @example
     *     Ext.create('Ext.form.Panel', {
     *         fullscreen: true,
     *         items: [
     *             {
     *                 xtype: 'fieldset',
     *                 title: 'Register',
     *                 items: [
     *                     {
     *                         xtype: 'emailfield',
     *                         label: 'Email',
     *                         name: 'email'
     *                     },
     *                     {
     *                         xtype: 'passwordfield',
     *                         label: 'Password',
     *                         name: 'password'
     *                     }
     *                 ]
     *             }
     *         ]
     *     });
     *
     * Or on its own, outside of a form:
     *
     *     Ext.create('Ext.field.Email', {
     *         label: 'Email address',
     *         value: 'prefilled@email.com'
     *     });
     *
     * Because email field inherits from {@link Ext.field.Text textfield} it gains all of the functionality that text fields
     * provide, including getting and setting the value at runtime, validations and various events that are fired as the
     * user interacts with the component. Check out the {@link Ext.field.Text} docs to see the additional functionality
     * available.
     */
    export class Email extends Ext.field.Text implements Ext.field.EmailConfig {
        /**
         * True to set the field's DOM element autocapitalize attribute to "on", false to set to "off".
         */
        autoCapitalize: boolean;

        /**
         * The inner component for this field, which defaults to an input text.
         */
        component: any;

        /**
         * Creates new Component.
         * @param {Object} config The standard configuration object.
         */
        constructor(config: Ext.ButtonConfig);

        getAutoCapitalize();

        getComponent();

        setAutoCapitalize();

        setComponent();
    }

    interface FieldConfig extends Ext.DecoratorConfig {
        baseCls?: any;

        /**
         * 'true' to use a clear icon in this field.
         */
        clearIcon?: boolean;

        /**
         * The inner component for this field.
         */
        component?: any;

        /**
         * CSS class to add to the input element of this fields {@link #component}
         */
        inputCls?: string;

        /**
         * The type attribute for input fields -- e.g. radio, text, password, file.
         * The types 'file' and 'password' must be used to render those field types currently -- there are
         * no separate Ext components for those.
         * @deprecated 2.0 Please use 'input.type' instead.
         *
         * Optional, Defaults to: 'text'
         */
        inputType?: string;

        /**
         * The label of this field
         */
        label?: string;

        /**
         * The position to render the label relative to the field input.
         * Available options are: 'top', 'left', 'bottom' and 'right'
         */
        labelAlign?: string;

        /**
         * Optional CSS class to add to the Label element.
         */
        labelCls?: string;

        /**
         * The width to make this field's label.
         */
        labelWidth?: number|string;

        /**
         * 'true' to allow the label to wrap. If set to 'false', the label will be truncated with
         * an ellipsis.
         */
        labelWrap?: boolean;

        /**
         * The field's HTML name attribute.
         *
         * __Note:__ this property must be set if this field is to be automatically included with.
         * {@link Ext.form.Panel#method-submit form submit()}.
         */
        name?: string;

        /**
         * 'true' to make this field required.
         *
         * __Note:__ this only causes a visual indication.
         *
         * Doesn't prevent user from submitting the form.
         */
        required?: boolean;

        /**
         * The 'className' to be applied to this Field when the {@link #required} configuration is set to 'true'.
         */
        requiredCls?: string;

        /**
         * The 'tabIndex' for this field. Note this only applies to fields that are rendered,
         * not those which are built via 'applyTo'.
         */
        tabIndex?: number;

        /**
         * A value to initialize this field with.
         */
        value?: any;
    }

    /**
     * Field is the base class for all form fields. It provides a lot of shared functionality to all
     * field subclasses (for example labels, simple validation, {@link #clearIcon clearing} and tab index management), but
     * is rarely used directly. Instead, it is much more common to use one of the field subclasses:
     *
     *     xtype            Class
     *     ---------------------------------------
     *     textfield        {@link Ext.field.Text}
     *     numberfield      {@link Ext.field.Number}
     *     textareafield    {@link Ext.field.TextArea}
     *     hiddenfield      {@link Ext.field.Hidden}
     *     radiofield       {@link Ext.field.Radio}
     *     filefield        {@link Ext.field.File}
     *     checkboxfield    {@link Ext.field.Checkbox}
     *     selectfield      {@link Ext.field.Select}
     *     togglefield      {@link Ext.field.Toggle}
     *     fieldset         {@link Ext.form.FieldSet}
     *
     * Fields are normally used within the context of a form and/or fieldset. See the {@link Ext.form.Panel FormPanel}
     * and {@link Ext.form.FieldSet FieldSet} docs for examples on how to put those together, or the list of links above
     * for usage of individual field types. If you wish to create your own Field subclasses you can extend this class,
     * though it is sometimes more useful to extend {@link Ext.field.Text} as this provides additional text entry
     * functionality.
     */
    export class Field extends Ext.Decorator implements Ext.field.FieldConfig {
        /**
         * Set to 'true' on all Ext.field.Field subclasses. This is used by {@link Ext.form.Panel#getValues} to determine which
         * components inside a form are fields.
         */
        isField: boolean;

        /**
         * The label Element associated with this Field.
         *
         * __Note:__ Only available if a {@link #label} is specified.
         * @deprecated 2.0
         */
        labelEl: Ext.dom.Element;

        /**
         * The original value of the field as configured in the {@link #value} configuration.
         * setting is 'true'.
         */
        originalValue: any;

        /**
         * The base CSS class to apply to this component's element. This will also be prepended to
         * other elements within this component. To add specific styling for sub-classes, use the {@link #cls} config.
         */
        baseCls: string;

        /**
         * 'true' to use a clear icon in this field.
         */
        clearIcon: boolean;

        /**
         * The inner component for this field.
         */
        component: any;

        /**
         * CSS class to add to the input element of this fields {@link #component}
         */
        inputCls: string;

        /**
         * The type attribute for input fields -- e.g. radio, text, password, file.
         * The types 'file' and 'password' must be used to render those field types currently -- there are
         * no separate Ext components for those.
         * @deprecated 2.0 Please use 'input.type' instead.
         *
         * Optional, Defaults to: 'text'
         */
        inputType: string;

        /**
         * The label of this field
         */
        label: string;

        /**
         * The position to render the label relative to the field input.
         * Available options are: 'top', 'left', 'bottom' and 'right'
         */
        labelAlign: string;

        /**
         * Optional CSS class to add to the Label element.
         */
        labelCls: string;

        /**
         * The width to make this field's label.
         */
        labelWidth: number|string;

        /**
         * 'true' to allow the label to wrap. If set to 'false', the label will be truncated with
         * an ellipsis.
         */
        labelWrap: boolean;

        /**
         * The field's HTML name attribute.
         *
         * __Note:__ this property must be set if this field is to be automatically included with.
         * {@link Ext.form.Panel#method-submit form submit()}.
         */
        name: string;

        /**
         * 'true' to make this field required.
         *
         * __Note:__ this only causes a visual indication.
         *
         * Doesn't prevent user from submitting the form.
         */
        required: boolean;

        /**
         * The 'className' to be applied to this Field when the {@link #required} configuration is set to 'true'.
         */
        requiredCls: string;

        /**
         * The 'tabIndex' for this field. Note this only applies to fields that are rendered,
         * not those which are built via 'applyTo'.
         */
        tabIndex: number;

        /**
         * A value to initialize this field with.
         */
        value: any;

        /**
         * Creates new Component.
         * @param {Object} config The standard configuration object.
         */
        constructor(config: Ext.ButtonConfig);

        getBaseCls();

        getClearIcon();

        getInputCls();

        getInputType();

        getLabel();

        getLabelAlign();

        getLabelCls();

        getLabelWidth();

        getLabelWrap();

        getRequired();

        getRequiredCls();

        getTabIndex();

        getValue();

        /**
         * Returns 'true' if the value of this Field has been changed from its {@link #originalValue}.
         * Will return 'false' if the field is disabled or has not been rendered yet.
         *
         * @return {Boolean} 'true' if this field has been changed from its original value (and
         * is not disabled), 'false' otherwise.
         */
        isDirty(): boolean;

        /**
         * Resets the current field value back to the original value on this field when it was created.
         *
         *     // This will create a field with an original value
         *     var field = Ext.Viewport.add({
         *         xtype: 'textfield',
         *         value: 'first value'
         *     });
         *
         *     // Update the value
         *     field.setValue('new value');
         *
         *     // Now you can reset it back to the 'first value'
         *     field.reset();
         *
         * @return {Ext.field.Field} this
         */
        reset(): Ext.field.Field;

        /**
         * Resets the field's {@link #originalValue} property so it matches the current {@link #getValue value}. This is
         * called by {@link Ext.form.Panel}.{@link Ext.form.Panel#setValues setValues} if the form's
         * {@link Ext.form.Panel#trackResetOnLoad trackResetOnLoad} property is set to true.
         */
        resetOriginalValue();

        setBaseCls();

        setClearIcon();

        setInputCls();

        setInputType();

        setLabel();

        setLabelAlign();

        setLabelCls();

        setLabelWidth();

        setLabelWrap();

        setName();

        setRequired();

        setRequiredCls();

        setTabIndex();

        setValue();
    }

    interface FileConfig extends Ext.field.FieldConfig {
        /**
         * File input accept attribute documented here (http://www.w3schools.com/tags/att_input_accept.asp)
         * Also can be simple strings -- e.g. audio, video, image
         */
        accept?: string;

        /**
         * File input capture attribute. Accepts values such as "camera", "camcorder", "microphone"
         */
        capture?: string;

        component?: any;

        /**
         * Allow selection of multiple files
         */
        multiple?: boolean;
    }

    /**
     * Creates an HTML file input field on the page. This is usually used to upload files to remote server. File fields are usually
     * created inside a form like this:
     *
     *     @example
     *     Ext.create('Ext.form.Panel', {
     *         fullscreen: true,
     *         items: [
     *             {
     *                 xtype: 'fieldset',
     *                 title: 'My Uploader',
     *                 items: [
     *                     {
     *                         xtype: 'filefield',
     *                         label: "MyPhoto:",
     *                         name: 'photo',
     *                         accept: 'image'
     *                     }
     *                 ]
     *             }
     *         ]
     *     });
     */
    export class File extends Ext.field.Field implements Ext.field.FileConfig {
        /**
         * File input accept attribute documented here (http://www.w3schools.com/tags/att_input_accept.asp)
         * Also can be simple strings -- e.g. audio, video, image
         */
        accept: string;

        /**
         * File input capture attribute. Accepts values such as "camera", "camcorder", "microphone"
         */
        capture: string;

        component: any;

        /**
         * Allow selection of multiple files
         */
        multiple: boolean;

        /**
         * Creates new Component.
         * @param {Object} config The standard configuration object.
         */
        constructor(config: Ext.ButtonConfig);

        getAccept();

        getCapture();

        getComponent();

        getMultiple();

        setAccept();

        setCapture();

        setComponent();

        setMultiple();

        /**
         * Fires when a file has been selected
         * @param {Ext.field.File} this This field
         * @param {Mixed} newValue The new value
         * @param {Mixed} oldValue The original value
         */
        change(that: Ext.field.File, newValue: any, oldValue: any);
    }

    interface FileInputConfig extends Ext.field.InputConfig {
        /**
         * Called when the value changes on this input item
         * new Value
         * Original Value
         */
        me?: any;

        name?: any;

        /**
         * Sets the internal value. Security restrictions prevent setting file values on the input element
         * New Value
         * @return {String}
         */
        newValue?: any;

        type?: any;

        /**
         * Called when the name being changed
         * value
         * @return {*}
         */
        value?: any;
    }

    export class FileInput extends Ext.field.Input implements Ext.field.FileInputConfig {
        /**
         * Called when the value changes on this input item
         * new Value
         * Original Value
         */
        me: any;

        name: string;

        /**
         * Sets the internal value. Security restrictions prevent setting file values on the input element
         * New Value
         * @return {String}
         */
        newValue: any;

        type: string;

        /**
         * Called when the name being changed
         * value
         * @return {*}
         */
        value: any;

        /**
         * Updates the accept attribute with the {@link #accept} configuration.
         */
        applyAccept();

        /**
         * Updated the capture attribute with the {@ink capture} configuration
         */
        applyCapture();

        /**
         * Creates new Component.
         * @param {Object} config The standard configuration object.
         */
        constructor(config: Ext.ButtonConfig);

        getAccept();

        getCapture();

        /**
         * Returns the field files.
         * @return {FileList} List of the files selected.
         */
        getFiles(): any;

        getMultiple();

        getType();

        setAccept();

        setCapture();

        setMultiple();

        setName();

        setType();

        /**
         * Called when the multiple property is updated. The name will automatically be toggled to an array if needed.
         */
        updateMultiple();

        /**
         * Fires just before the field blurs if the field value has changed
         * @param {Ext.field.Text} this This field
         * @param {Mixed} newValue The new value
         * @param {Mixed} oldValue The original value
         */
        change(that: Ext.field.Text, newValue: any, oldValue: any);
    }

    interface HiddenConfig extends Ext.field.TextConfig {
        component?: any;

        ui?: any;
    }

    /**
     * Hidden fields allow you to easily inject additional data into a {@link Ext.form.Panel form} without displaying
     * additional fields on the screen. This is often useful for sending dynamic or previously collected data back to the
     * server in the same request as the normal form submission. For example, here is how we might set up a form to send
     * back a hidden userId field:
     *
     *     @example
     *     var form = Ext.create('Ext.form.Panel', {
     *         fullscreen: true,
     *         items: [
     *             {
     *                 xtype: 'fieldset',
     *                 title: 'Enter your name',
     *                 items: [
     *                     {
     *                         xtype: 'hiddenfield',
     *                         name: 'userId',
     *                         value: 123
     *                     },
     *                     {
     *                         xtype: 'checkboxfield',
     *                         label: 'Enable notifications',
     *                         name: 'notifications'
     *                     }
     *                 ]
     *             }
     *         ]
     *     });
     *
     * In the form above we created two fields - a hidden field and a {@link Ext.field.Checkbox check box field}. Only the
     * check box will be visible, but both fields will be submitted. Hidden fields cannot be tabbed to - they are removed
     * from the tab index so when your user taps the next/previous field buttons the hidden field is skipped over.
     *
     * It's easy to read and update the value of a hidden field within a form. Using the example above, we can get a
     * reference to the hidden field and then set it to a new value in 2 lines of code:
     *
     *     var userId = form.down('hiddenfield')[0];
     *     userId.setValue(1234);
     */
    export class Hidden extends Ext.field.Text implements Ext.field.HiddenConfig {
        /**
         * The inner component for this field, which defaults to an input text.
         */
        component: any;

        /**
         * The ui to be used on this Component
         */
        ui: string;

        /**
         * Creates new Component.
         * @param {Object} config The standard configuration object.
         */
        constructor(config: Ext.ButtonConfig);

        getComponent();

        getUi();

        setComponent();

        setUi();
    }

    interface InputConfig extends Ext.ComponentConfig {
        /**
         * 'true' to set the field's DOM element 'autocapitalize' attribute to '"on"', 'false' to set to '"off"'. Defaults to 'undefined', leaving the attribute unset
         *
         * Optional, Defaults to: undefined
         */
        autoCapitalize?: boolean;

        /**
         * 'true' to set the field's DOM element 'autocomplete' attribute to '"on"', 'false' to set to '"off"'. Defaults to 'undefined', leaving the attribute unset.
         *
         * Optional, Defaults to: undefined
         */
        autoComplete?: boolean;

        /**
         * 'true' to set the field DOM element 'autocorrect' attribute to '"on"', 'false' to set to '"off"'. Defaults to 'undefined', leaving the attribute unset.
         */
        autoCorrect?: boolean;

        baseCls?: any;

        /**
         * 'true' if the checkbox should render initially checked.
         */
        checked?: boolean;

        /**
         * The 'className' to be applied to this input.
         */
        cls?: string;

        /**
         * 'true' to disable the field.
         *
         * Be aware that conformant with the [HTML specification](http://www.w3.org/TR/html401/interact/forms.html),
         * disabled Fields will not be {@link Ext.form.Panel#method-submit submitted}.
         *
         * Optional, Defaults to: false
         */
        disabled?: boolean;

        /**
         * Enable Fast Input Focusing on iOS, using this workaround will stop some touchstart events in order to prevent
         * delayed focus issues.
         */
        fastFocus?: boolean;

        /**
         * The CSS class to use when the field receives focus.
         */
        focusCls?: string;

        /**
         * The maximum number of permitted input characters.
         *
         * Optional, Defaults to: 0
         */
        maxLength?: number;

        /**
         * Sets the field DOM element 'maxRows' attribute. Defaults to 'undefined', leaving the attribute unset.
         *
         * Optional, Defaults to: undefined
         */
        maxRows?: number;

        /**
         * The maximum value that this Number field can accept (defaults to 'undefined', e.g. no maximum).
         *
         * Optional, Defaults to: undefined
         */
        maxValue?: number;

        /**
         * The minimum value that this Number field can accept (defaults to 'undefined', e.g. no minimum).
         *
         * Optional, Defaults to: undefined
         */
        minValue?: number;

        /**
         * The field's HTML name attribute.
         * __Note:__ This property must be set if this field is to be automatically included with
         * {@link Ext.form.Panel#method-submit form submit()}.
         */
        name?: string;

        /**
         * The value for the HTML5 'pattern' attribute.
         * You can use this to change which keyboard layout will be used.
         *
         *     Ext.define('Ux.field.Pattern', {
         *         extend : 'Ext.field.Text',
         *         xtype  : 'patternfield',
         *
         *         config : {
         *             component : {
         *                 pattern : '[0-9]*'
         *             }
         *         }
         *     });
         *
         * Even though it extends {@link Ext.field.Text}, it will display the number keyboard.
         */
        pattern?: string;

        /**
         * A string value displayed in the input (if supported) when the control is empty.
         */
        placeHolder?: string;

        /**
         * 'true' to set the field DOM element 'readonly' attribute to '"true"'. Defaults to 'undefined', leaving the attribute unset.
         *
         * Optional, Defaults to: undefined
         */
        readOnly?: boolean;

        /**
         * The value that the Field had at the time it was last focused. This is the value that is passed
         * to the {@link Ext.field.Text#change} event which is fired if the value has been changed when the Field is blurred.
         *
         * __This will be 'undefined' until the Field has been visited.__ Compare {@link #originalValue}.
         */
        startValue?: any;

        /**
         * The amount by which the field is incremented or decremented each time the spinner is tapped.
         * Defaults to 'undefined', which means that the field goes up or down by 1 each time the spinner is tapped.
         *
         * Optional, Defaults to: undefined
         */
        stepValue?: number;

        /**
         * The 'tabIndex' for this field.
         *
         * __Note:__ This only applies to fields that are rendered, not those which are built via 'applyTo'.
         */
        tabIndex?: number;

        /**
         * The type attribute for input fields -- e.g. radio, text, password.
         *
         * If you want to use a 'file' input, please use the {@link Ext.field.File} component instead.
         */
        type?: string;

        /**
         * A value to initialize this field with.
         */
        value?: any;
    }

    export class Input extends Ext.Component implements Ext.field.InputConfig {
        /**
         * if the field currently has focus.
         */
        isFocused: boolean;

        /**
         * 'true' to set the field's DOM element 'autocapitalize' attribute to '"on"', 'false' to set to '"off"'. Defaults to 'undefined', leaving the attribute unset
         *
         * Optional, Defaults to: undefined
         */
        autoCapitalize: boolean;

        /**
         * 'true' to set the field's DOM element 'autocomplete' attribute to '"on"', 'false' to set to '"off"'. Defaults to 'undefined', leaving the attribute unset.
         *
         * Optional, Defaults to: undefined
         */
        autoComplete: boolean;

        /**
         * 'true' to set the field DOM element 'autocorrect' attribute to '"on"', 'false' to set to '"off"'. Defaults to 'undefined', leaving the attribute unset.
         */
        autoCorrect: boolean;

        /**
         * The base CSS class to apply to this component's element. This will also be prepended to
         * other elements within this component. To add specific styling for sub-classes, use the {@link #cls} config.
         */
        baseCls: string;

        /**
         * 'true' if the checkbox should render initially checked.
         */
        checked: boolean;

        /**
         * The 'className' to be applied to this input.
         */
        cls: string;

        /**
         * 'true' to disable the field.
         *
         * Be aware that conformant with the [HTML specification](http://www.w3.org/TR/html401/interact/forms.html),
         * disabled Fields will not be {@link Ext.form.Panel#method-submit submitted}.
         *
         * Optional, Defaults to: false
         */
        disabled: boolean;

        /**
         * Enable Fast Input Focusing on iOS, using this workaround will stop some touchstart events in order to prevent
         * delayed focus issues.
         */
        fastFocus: boolean;

        /**
         * The CSS class to use when the field receives focus.
         */
        focusCls: string;

        /**
         * The maximum number of permitted input characters.
         *
         * Optional, Defaults to: 0
         */
        maxLength: number;

        /**
         * Sets the field DOM element 'maxRows' attribute. Defaults to 'undefined', leaving the attribute unset.
         *
         * Optional, Defaults to: undefined
         */
        maxRows: number;

        /**
         * The maximum value that this Number field can accept (defaults to 'undefined', e.g. no maximum).
         *
         * Optional, Defaults to: undefined
         */
        maxValue: number;

        /**
         * The minimum value that this Number field can accept (defaults to 'undefined', e.g. no minimum).
         *
         * Optional, Defaults to: undefined
         */
        minValue: number;

        /**
         * The field's HTML name attribute.
         * __Note:__ This property must be set if this field is to be automatically included with
         * {@link Ext.form.Panel#method-submit form submit()}.
         */
        name: string;

        /**
         * The value for the HTML5 'pattern' attribute.
         * You can use this to change which keyboard layout will be used.
         *
         *     Ext.define('Ux.field.Pattern', {
         *         extend : 'Ext.field.Text',
         *         xtype  : 'patternfield',
         *
         *         config : {
         *             component : {
         *                 pattern : '[0-9]*'
         *             }
         *         }
         *     });
         *
         * Even though it extends {@link Ext.field.Text}, it will display the number keyboard.
         */
        pattern: string;

        /**
         * A string value displayed in the input (if supported) when the control is empty.
         */
        placeHolder: string;

        /**
         * 'true' to set the field DOM element 'readonly' attribute to '"true"'. Defaults to 'undefined', leaving the attribute unset.
         *
         * Optional, Defaults to: undefined
         */
        readOnly: boolean;

        /**
         * The value that the Field had at the time it was last focused. This is the value that is passed
         * to the {@link Ext.field.Text#change} event which is fired if the value has been changed when the Field is blurred.
         *
         * __This will be 'undefined' until the Field has been visited.__ Compare {@link #originalValue}.
         */
        startValue: any;

        /**
         * The amount by which the field is incremented or decremented each time the spinner is tapped.
         * Defaults to 'undefined', which means that the field goes up or down by 1 each time the spinner is tapped.
         *
         * Optional, Defaults to: undefined
         */
        stepValue: number;

        /**
         * The 'tabIndex' for this field.
         *
         * __Note:__ This only applies to fields that are rendered, not those which are built via 'applyTo'.
         */
        tabIndex: number;

        /**
         * The type attribute for input fields -- e.g. radio, text, password.
         *
         * If you want to use a 'file' input, please use the {@link Ext.field.File} component instead.
         */
        type: string;

        /**
         * A value to initialize this field with.
         */
        value: any;

        /**
         * Attempts to forcefully blur input focus for the field.
         * @return {Ext.field.Input} this
         */
        blur(): Ext.field.Input;

        /**
         * Creates new Component.
         * @param {Object} config The standard configuration object.
         */
        constructor(config: Ext.ButtonConfig);

        /**
         * Attempts to set the field as the active input focus.
         * @return {Ext.field.Input} this
         */
        focus(): Ext.field.Input;

        getAutoCapitalize();

        getAutoComplete();

        getAutoCorrect();

        getBaseCls();

        /**
         * Returns the 'checked' value of this field
         * @return {Mixed} value The field value
         */
        getChecked(): any;

        getCls();

        getDisabled();

        getFastFocus();

        getFocusCls();

        getMaxLength();

        getMaxRows();

        getMaxValue();

        getMinValue();

        getPattern();

        getPlaceHolder();

        getReadOnly();

        getStartValue();

        getStepValue();

        getTabIndex();

        getType();

        /**
         * Returns the field data value.
         * @return {Mixed} value The field value.
         */
        getValue(): any;

        protected initElement();

        /**
         * Returns 'true' if the value of this Field has been changed from its original value.
         * Will return 'false' if the field is disabled or has not been rendered yet.
         * @return {Boolean}
         */
        isDirty(): boolean;

        /**
         * Resets the current field value to the original value.
         */
        reset();

        /**
         * Attempts to forcefully select all the contents of the input field.
         * @return {Ext.field.Input} this
         */
        select(): Ext.field.Input;

        setAutoCapitalize();

        setAutoComplete();

        setAutoCorrect();

        setBaseCls();

        setCls();

        setDisabled();

        setFastFocus();

        setFocusCls();

        setMaxLength();

        setMaxRows();

        setMaxValue();

        setMinValue();

        setName();

        setPattern();

        setPlaceHolder();

        setReadOnly();

        setStartValue();

        setStepValue();

        setTabIndex();

        setType();

        /**
         * Updates the {@link #cls} configuration.
         */
        updateCls();

        /**
         * Updates the useMask configuration
         */
        updateUseMask();

        /**
         * Fires whenever the clear icon is tapped.
         * @param {Ext.event.Event} e The event object
         */
        clearicontap(that: Ext.field.Input, e: Ext.event.Event);

        /**
         * Fires whenever the input is clicked.
         * @param {Ext.event.Event} e The event object.
         */
        click(e: Ext.event.Event);

        /**
         * Fires whenever keyup is detected.
         * @param {Ext.event.Event} e The event object.
         */
        keyup(e: Ext.event.Event);

        /**
         * Fires whenever a mask is tapped.
         * @param {Ext.event.Event} e The event object.
         */
        masktap(that: Ext.field.Input, e: Ext.event.Event);

        /**
         * Fires whenever the input has a mousedown occur.
         * @param {Ext.event.Event} e The event object.
         */
        mousedown(e: Ext.event.Event);

        /**
         * Fires whenever paste is detected.
         * @param {Ext.event.Event} e The event object.
         */
        paste(e: Ext.event.Event);
    }

    interface NumberConfig extends Ext.field.TextConfig {
        component?: any;

        /**
         * The maximum value that this Number field can accept
         */
        maxValue?: number;

        /**
         * The minimum value that this Number field can accept
         */
        minValue?: number;

        /**
         * The amount by which the field is incremented or decremented each time the spinner is tapped.
         * Defaults to undefined, which means that the field goes up or down by 1 each time the spinner is tapped
         */
        stepValue?: number;

        ui?: any;
    }

    /**
     * The Number field creates an HTML5 number input and is usually created inside a form. Because it creates an HTML
     * number input field, most browsers will show a specialized virtual keyboard for entering numbers. The Number field
     * only accepts numerical input and also provides additional spinner UI that increases or decreases the current value
     * by a configured {@link #stepValue step value}. Here's how we might use one in a form:
     *
     *     @example
     *     Ext.create('Ext.form.Panel', {
     *         fullscreen: true,
     *         items: [
     *             {
     *                 xtype: 'fieldset',
     *                 title: 'How old are you?',
     *                 items: [
     *                     {
     *                         xtype: 'numberfield',
     *                         label: 'Age',
     *                         minValue: 18,
     *                         maxValue: 150,
     *                         name: 'age'
     *                     }
     *                 ]
     *             }
     *         ]
     *     });
     *
     * Or on its own, outside of a form:
     *
     *     Ext.create('Ext.field.Number', {
     *         label: 'Age',
     *         value: '26'
     *     });
     *
     * ## minValue, maxValue and stepValue
     *
     * The {@link #minValue} and {@link #maxValue} configurations are self-explanatory and simply constrain the value
     * entered to the range specified by the configured min and max values. The other option exposed by this component
     * is {@link #stepValue}, which enables you to set how much the value changes every time the up and down spinners
     * are tapped on. For example, to create a salary field that ticks up and down by $1,000 each tap we can do this:
     *
     *     @example
     *     Ext.create('Ext.form.Panel', {
     *         fullscreen: true,
     *         items: [
     *             {
     *                 xtype: 'fieldset',
     *                 title: 'Are you rich yet?',
     *                 items: [
     *                     {
     *                         xtype: 'numberfield',
     *                         label: 'Salary',
     *                         value: 30000,
     *                         minValue: 25000,
     *                         maxValue: 50000,
     *                         stepValue: 1000
     *                     }
     *                 ]
     *             }
     *         ]
     *     });
     *
     * This creates a field that starts with a value of $30,000, steps up and down in $1,000 increments and will not go
     * beneath $25,000 or above $50,000.
     *
     * Because number field inherits from {@link Ext.field.Text textfield} it gains all of the functionality that text
     * fields provide, including getting and setting the value at runtime, validations and various events that are fired as
     * the user interacts with the component. Check out the {@link Ext.field.Text} docs to see the additional functionality
     * available.
     */
    export class Number extends Ext.field.Text implements Ext.field.NumberConfig {
        /**
         * The inner component for this field, which defaults to an input text.
         */
        component: any;

        /**
         * The maximum value that this Number field can accept
         */
        maxValue: number;

        /**
         * The minimum value that this Number field can accept
         */
        minValue: number;

        /**
         * The amount by which the field is incremented or decremented each time the spinner is tapped.
         * Defaults to undefined, which means that the field goes up or down by 1 each time the spinner is tapped
         */
        stepValue: number;

        /**
         * The ui to be used on this Component
         */
        ui: string;

        /**
         * Creates new Component.
         * @param {Object} config The standard configuration object.
         */
        constructor(config: Ext.ButtonConfig);

        getComponent();

        getMaxValue();

        getMinValue();

        getStepValue();

        getUi();

        getValue();

        setComponent();

        setMaxValue();

        setMinValue();

        setStepValue();

        setUi();
    }

    interface PasswordConfig extends Ext.field.TextConfig {
        autoCapitalize?: any;

        component?: any;

        /**
         * Enables the reveal toggle button that will show the password in clear text. This is currently only implemented in the Blackberry theme
         */
        revealable?: any;

        /**
         * A value of 'true' for this config will show the password from clear text
         */
        revealed?: any;
    }

    /**
     * The Password field creates a password input and is usually created inside a form. Because it creates a password
     * field, when the user enters text it will show up as stars. Aside from that, the password field is just a normal text
     * field. Here's an example of how to use it in a form:
     *
     *     @example
     *     Ext.create('Ext.form.Panel', {
     *         fullscreen: true,
     *         items: [
     *             {
     *                 xtype: 'fieldset',
     *                 title: 'Register',
     *                 items: [
     *                     {
     *                         xtype: 'emailfield',
     *                         label: 'Email',
     *                         name: 'email'
     *                     },
     *                     {
     *                         xtype: 'passwordfield',
     *                         label: 'Password',
     *                         name: 'password'
     *                     }
     *                 ]
     *             }
     *         ]
     *     });
     *
     * Or on its own, outside of a form:
     *
     *     Ext.create('Ext.field.Password', {
     *         label: 'Password',
     *         value: 'existingPassword'
     *     });
     *
     * Because the password field inherits from {@link Ext.field.Text textfield} it gains all of the functionality that text
     * fields provide, including getting and setting the value at runtime, validations and various events that are fired as
     * the user interacts with the component. Check out the {@link Ext.field.Text} docs to see the additional functionality
     * available.
     */
    export class Password extends Ext.field.Text implements Ext.field.PasswordConfig {
        /**
         * True to set the field's DOM element autocapitalize attribute to "on", false to set to "off".
         */
        autoCapitalize: boolean;

        /**
         * The inner component for this field, which defaults to an input text.
         */
        component: any;

        /**
         * Enables the reveal toggle button that will show the password in clear text. This is currently only implemented in the Blackberry theme
         */
        revealable: any;

        /**
         * A value of 'true' for this config will show the password from clear text
         */
        revealed: any;

        /**
         * Creates new Component.
         * @param {Object} config The standard configuration object.
         */
        constructor(config: Ext.ButtonConfig);

        getAutoCapitalize();

        getComponent();

        getRevealable();

        getRevealed();

        setAutoCapitalize();

        setComponent();

        setRevealable();

        setRevealed();
    }

    interface PickerConfig extends Ext.field.TextConfig {
        /**
         * 'true' if you want this component to always use a {@link Ext.picker.Picker}.
         * 'false' if you want it to use a popup overlay {@link Ext.List}.
         * 'auto' if you want to show a {@link Ext.picker.Picker} only on phones.
         */
        usePicker?: string|boolean;
    }

    /**
     * An abstract class for fields that have a single trigger which opens a "picker" popup
     * above the field. It provides a base implementation for toggling the picker's
     * visibility when the trigger is tapped.
     *
     * You would not normally use this class directly, but instead use it as the parent
     * class for a specific picker field implementation.
     */
    export class Picker extends Ext.field.Text implements Ext.field.PickerConfig {
        /**
         * 'true' if you want this component to always use a {@link Ext.picker.Picker}.
         * 'false' if you want it to use a popup overlay {@link Ext.List}.
         * 'auto' if you want to show a {@link Ext.picker.Picker} only on phones.
         */
        usePicker: string|boolean;

        /**
         * Creates new Component.
         * @param {Object} config The standard configuration object.
         */
        constructor(config: Ext.ButtonConfig);

        destroy();

        getUsePicker();

        setUsePicker();
    }

    interface RadioConfig extends Ext.field.CheckboxConfig {
        component?: any;

        ui?: any;
    }

    /**
     * The radio field is an enhanced version of the native browser radio controls and is a good way of allowing your user
     * to choose one option out of a selection of several (for example, choosing a favorite color):
     *
     *     @example
     *     var form = Ext.create('Ext.form.Panel', {
     *         fullscreen: true,
     *         items: [
     *             {
     *                 xtype: 'radiofield',
     *                 name : 'color',
     *                 value: 'red',
     *                 label: 'Red',
     *                 checked: true
     *             },
     *             {
     *                 xtype: 'radiofield',
     *                 name : 'color',
     *                 value: 'green',
     *                 label: 'Green'
     *             },
     *             {
     *                 xtype: 'radiofield',
     *                 name : 'color',
     *                 value: 'blue',
     *                 label: 'Blue'
     *             }
     *         ]
     *     });
     *
     * Above we created a simple form which allows the user to pick a color from the options red, green and blue. Because
     * we gave each of the fields above the same {@link #name}, the radio field ensures that only one of them can be
     * checked at a time. When we come to get the values out of the form again or submit it to the server, only 1 value
     * will be sent for each group of radio fields with the same name:
     *
     *     form.getValues(); //looks like {color: 'red'}
     *     form.submit(); //sends a single field back to the server (in this case color: red)
     */
    export class Radio extends Ext.field.Checkbox implements Ext.field.RadioConfig {
        /**
         * The inner component for this field.
         */
        component: any;

        /**
         * The ui to be used on this Component
         */
        ui: string;

        /**
         * Creates new Component.
         * @param {Object} config The standard configuration object.
         */
        constructor(config: Ext.ButtonConfig);

        getComponent();

        /**
         * Returns the selected value if this radio is part of a group (other radio fields with the same name, in the same FormPanel),
         * @return {String}
         */
        getGroupValue(): string;

        getUi();

        getValue();

        setComponent();

        /**
         * Set the matched radio field's status (that has the same value as the given string) to checked.
         * @param {String} value The value of the radio field to check.
         * @return {Ext.field.Radio} The field that is checked.
         */
        setGroupValue(value: string): Ext.field.Radio;

        setUi();
    }

    interface SearchConfig extends Ext.field.TextConfig {
        component?: any;

        ui?: any;
    }

    /**
     * The Search field creates an HTML5 search input and is usually created inside a form. Because it creates an HTML
     * search input type, the visual styling of this input is slightly different to normal text input controls (the corners
     * are rounded), though the virtual keyboard displayed by the operating system is the standard keyboard control.
     *
     * As with all other form fields, the search field gains a "clear" button that appears whenever there
     * is text entered into the form, and which removes that text when tapped.
     *
     *     @example
     *     Ext.create('Ext.form.Panel', {
     *         fullscreen: true,
     *         items: [
     *             {
     *                 xtype: 'fieldset',
     *                 title: 'Search',
     *                 items: [
     *                     {
     *                         xtype: 'searchfield',
     *                         label: 'Query',
     *                         name: 'query'
     *                     }
     *                 ]
     *             }
     *         ]
     *     });
     *
     * Or on its own, outside of a form:
     *
     *     Ext.create('Ext.field.Search', {
     *         label: 'Search:',
     *         value: 'query'
     *     });
     *
     * Because search field inherits from {@link Ext.field.Text textfield} it gains all of the functionality that text
     * fields provide, including getting and setting the value at runtime, validations and various events that are fired
     * as the user interacts with the component. Check out the {@link Ext.field.Text} docs to see the additional
     * functionality available.
     */
    export class Search extends Ext.field.Text implements Ext.field.SearchConfig {
        /**
         * The inner component for this field, which defaults to an input text.
         */
        component: any;

        /**
         * The ui to be used on this Component
         */
        ui: string;

        /**
         * Creates new Component.
         * @param {Object} config The standard configuration object.
         */
        constructor(config: Ext.ButtonConfig);

        getComponent();

        getUi();

        setComponent();

        setUi();
    }

    interface SelectConfig extends Ext.field.PickerConfig {
        /**
         * 'true' to auto select the first value in the {@link #store} or {@link #options} when they are changed. Only happens when
         * the {@link #value} is set to 'null'.
         */
        autoSelect?: boolean;

        /**
         * The underlying {@link Ext.data.Field#name data value name} (or numeric Array index) to bind to this
         * Select control. This resolved value is the visibly rendered value of the available selection options.
         */
        displayField?: string|number;

        /**
         * Specify a 'hiddenName' if you're using the {@link Ext.form.Panel#standardSubmit standardSubmit} option.
         * This name will be used to post the underlying value of the select to the server.
         */
        hiddenName?: string;

        name?: any;

        /**
         * An array of select options.
         *
         *     [
         *         {text: 'First Option',  value: 'first'},
         *         {text: 'Second Option', value: 'second'},
         *         {text: 'Third Option',  value: 'third'}
         *     ]
         *
         * __Note:__ Option object member names should correspond with defined {@link #valueField valueField} and {@link #displayField displayField} values.
         * This config will be ignored if a {@link #store store} instance is provided.
         */
        options?: any[];

        publishes?: any;

        /**
         * The selected model. 'null' if no value exists.
         */
        selection?: Ext.data.Model;

        /**
         * The store to provide selection options data.
         * Either a Store instance, configuration object or store ID.
         */
        store?: Ext.data.Store|any|string;

        twoWayBindable?: any;

        ui?: any;

        useClearIcon?: boolean;

        /**
         * The underlying {@link Ext.data.Field#name data value name} (or numeric Array index) to bind to this
         * Select control.
         */
        valueField?: string|number;
    }

    /**
     * Simple Select field wrapper. Example usage:
     *
     *     @example
     *     Ext.create('Ext.form.Panel', {
     *         fullscreen: true,
     *         items: [{
     *             xtype: 'fieldset',
     *             title: 'Select',
     *             items: [{
     *                 xtype: 'selectfield',
     *                 label: 'Choose one',
     *                 options: [{
     *                     text: 'First Option',
     *                     value: 'first'
     *                 }, {
     *                     text: 'Second Option',
     *                     value: 'second'
     *                 }, {
     *                     text: 'Third Option',
     *                     value: 'third'
     *                 }]
     *             }]
     *         }]
     *     });
     */
    export class Select extends Ext.field.Picker implements Ext.field.SelectConfig {
        /**
         * 'true' to auto select the first value in the {@link #store} or {@link #options} when they are changed. Only happens when
         * the {@link #value} is set to 'null'.
         */
        autoSelect: boolean;

        /**
         * The underlying {@link Ext.data.Field#name data value name} (or numeric Array index) to bind to this
         * Select control. This resolved value is the visibly rendered value of the available selection options.
         */
        displayField: string|number;

        /**
         * Specify a 'hiddenName' if you're using the {@link Ext.form.Panel#standardSubmit standardSubmit} option.
         * This name will be used to post the underlying value of the select to the server.
         */
        hiddenName: string;

        /**
         * The field's HTML name attribute.
         *
         * __Note:__ this property must be set if this field is to be automatically included with.
         * {@link Ext.form.Panel#method-submit form submit()}.
         */
        name: string;

        /**
         * An array of select options.
         *
         *     [
         *         {text: 'First Option',  value: 'first'},
         *         {text: 'Second Option', value: 'second'},
         *         {text: 'Third Option',  value: 'third'}
         *     ]
         *
         * __Note:__ Option object member names should correspond with defined {@link #valueField valueField} and {@link #displayField displayField} values.
         * This config will be ignored if a {@link #store store} instance is provided.
         */
        options: any[];

        publishes: any;

        /**
         * The selected model. 'null' if no value exists.
         */
        selection: Ext.data.Model;

        /**
         * The store to provide selection options data.
         * Either a Store instance, configuration object or store ID.
         */
        store: Ext.data.Store|any|string;

        twoWayBindable: any;

        /**
         * The ui to be used on this Component
         */
        ui: string;

        useClearIcon: boolean;

        /**
         * The underlying {@link Ext.data.Field#name data value name} (or numeric Array index) to bind to this
         * Select control.
         */
        valueField: string|number;

        /**
         * Creates new Component.
         * @param {Object} config The standard configuration object.
         */
        constructor(config: Ext.ButtonConfig);

        destroy();

        getAutoSelect();

        getDisplayField();

        getHiddenName();

        getOptions();

        getSelection();

        getStore();

        getUi();

        /**
         * Gets the currently selected value
         * @returns {String} Value Field from Selected Model
         */
        getValue();

        getValueField();

        /**
         * Called when the internal {@link #store}'s data has changed.
         */
        onStoreDataChanged();

        setAutoSelect();

        setDisplayField();

        setHiddenName();

        setName();

        setOptions();

        setSelection();

        setStore();

        setUi();

        setValueField();

        /**
         * Shows the picker for the select field, whether that is a {@link Ext.picker.Picker} or a simple
         * {@link Ext.List list}.
         */
        showPicker();

        /**
         * Updates the underlying '<options>' list with new values.
         *
         * @param {Array} newOptions An array of options configurations to insert or append.
         *
         *     selectBox.setOptions([
         *         {text: 'First Option',  value: 'first'},
         *         {text: 'Second Option', value: 'second'},
         *         {text: 'Third Option',  value: 'third'}
         *     ]).setValue('third');
         *
         * __Note:__ option object member names should correspond with defined {@link #valueField valueField} and
         * {@link #displayField displayField} values.
         *
         * @return {Ext.field.Select} this
         */
        updateOptions(newOptions: any[]): Ext.field.Select;
    }

    interface SingleSliderConfig extends Ext.field.SliderConfig {
        publishes?: any;
    }

    /**
     * The slider is a way to allow the user to select a value from a given numerical range. You might use it for choosing
     */
    export class SingleSlider extends Ext.field.Slider implements Ext.field.SingleSliderConfig {
        publishes: any;

        /**
         * Creates new Component.
         * @param {Object} config The standard configuration object.
         */
        constructor(config: Ext.ButtonConfig);

        getValue();

        setValue();

        /**
         * Fires when the slider thumb starts a drag operation.
         * @param {Ext.slider.Slider} sl Slider Component.
         * @param {Ext.slider.Thumb} thumb The thumb being dragged.
         */
        drag(that: Ext.field.Slider, sl: Ext.slider.Slider, thumb: Ext.slider.Thumb, e: Ext.event.Event);

        /**
         * Fires when the slider thumb ends a drag operation.
         * @param {Ext.slider.Slider} sl Slider Component.
         * @param {Ext.slider.Thumb} thumb The thumb being dragged.
         * @param {Array} value The end value.
         */
        dragend(that: Ext.field.Slider, sl: Ext.slider.Slider, thumb: Ext.slider.Thumb, value: any[], e: Ext.event.Event);

        /**
         * Fires when the slider thumb starts a drag operation.
         * @param {Ext.slider.Slider} sl Slider Component.
         * @param {Ext.slider.Thumb} thumb The thumb being dragged.
         * @param {Array} value The start value.
         */
        dragstart(that: Ext.field.Slider, sl: Ext.slider.Slider, thumb: Ext.slider.Thumb, value: any[], e: Ext.event.Event);
    }

    interface SliderConfig extends Ext.field.FieldConfig {
        cls?: any;

        increment?: number;

        /**
         * 'true' to fire change events while the slider is dragging. 'false' will
         * only fire a change once the drag is complete.
         */
        liveUpdate?: boolean;

        maxValue?: number;

        minValue?: number;

        /**
         * Will make this field read only, meaning it cannot be changed with used interaction.
         */
        readOnly?: boolean;

        tabIndex?: any;

        twoWayBindable?: any;

        values?: number;
    }

    /**
     * The slider is a way to allow the user to select a value from a given numerical range. You might use it for choosing
     * a percentage, combine two of them to get min and max values, or use three of them to specify the hex values for a
     * color. Each slider contains a single 'thumb' that can be dragged along the slider's length to change the value.
     * Sliders are equally useful inside {@link Ext.form.Panel forms} and standalone. Here's how to quickly create a
     * slider in form, in this case enabling a user to choose a percentage:
     *
     *     @example
     *     Ext.create('Ext.form.Panel', {
     *         fullscreen: true,
     *         items: [
     *             {
     *                 xtype: 'sliderfield',
     *                 label: 'Percentage',
     *                 value: 50,
     *                 minValue: 0,
     *                 maxValue: 100
     *             }
     *         ]
     *     });
     *
     * In this case we set a starting value of 50%, and defined the min and max values to be 0 and 100 respectively, giving
     * us a percentage slider. Because this is such a common use case, the defaults for {@link #minValue} and
     * {@link #maxValue} are already set to 0 and 100 so in the example above they could be removed.
     *
     * It's often useful to render sliders outside the context of a form panel too. In this example we create a slider that
     * allows a user to choose the waist measurement of a pair of jeans. Let's say the online store we're making this for
     * sells jeans with waist sizes from 24 inches to 60 inches in 2 inch increments - here's how we might achieve that:
     *
     *     @example
     *     Ext.create('Ext.form.Panel', {
     *         fullscreen: true,
     *         items: [
     *             {
     *                 xtype: 'sliderfield',
     *                 label: 'Waist Measurement',
     *                 minValue: 24,
     *                 maxValue: 60,
     *                 increment: 2,
     *                 value: 32
     *             }
     *         ]
     *     });
     *
     * Now that we've got our slider, we can ask it what value it currently has and listen to events that it fires. For
     * example, if we wanted our app to show different images for different sizes, we can listen to the {@link #change}
     * event to be informed whenever the slider is moved:
     *
     *     slider.on('change', function(field, newValue) {
     *         if (newValue[0] > 40) {
     *             imgComponent.setSrc('large.png');
     *         } else {
     *             imgComponent.setSrc('small.png');
     *         }
     *     }, this);
     *
     * Here we listened to the {@link #change} event on the slider and updated the background image of an
     * {@link Ext.Img image component} based on what size the user selected. Of course, you can use any logic inside your
     * event listener.
     */
    export class Slider extends Ext.field.Field implements Ext.field.SliderConfig {
        defaultBindProperty: any;

        /**
         * The CSS class to add to this component's element, in
         * addition to the {@link #baseCls}. In many cases, this property will be specified
         * by the derived component class. See {@link #userCls} for adding additional CSS
         * classes to component instances (such as items in a {@link Ext.Container}).
         */
        cls: string;

        increment: number;

        /**
         * 'true' to fire change events while the slider is dragging. 'false' will
         * only fire a change once the drag is complete.
         */
        liveUpdate: boolean;

        maxValue: number;

        minValue: number;

        /**
         * Will make this field read only, meaning it cannot be changed with used interaction.
         */
        readOnly: boolean;

        /**
         * The 'tabIndex' for this field. Note this only applies to fields that are rendered,
         * not those which are built via 'applyTo'.
         */
        tabIndex: number;

        twoWayBindable: any;

        values: number;

        /**
         * Creates new Component.
         * @param {Object} config The standard configuration object.
         */
        constructor(config: Ext.ButtonConfig);

        getCls();

        getIncrement();

        getLiveUpdate();

        getMaxValue();

        getMinValue();

        getReadOnly();

        getTabIndex();

        getValue();

        /**
         * Convenience method. Calls {@link #getValue}
         * @return {Object}
         */
        getValues(): any;

        setCls();

        setIncrement();

        setLiveUpdate();

        setMaxValue();

        setMinValue();

        setReadOnly();

        setTabIndex();

        setValue();

        /**
         * Convenience method. Calls {@link #setValue}.
         */
        setValues(value: any);

        /**
         * Fires when the value changes.
         * @param {Number[]} newValue The new value.
         * @param {Number[]} oldValue The old value.
         */
        change(me: Ext.field.Slider, newValue: number, oldValue: number);

        /**
         * Fires when the slider thumb starts a drag operation.
         * @param {Ext.slider.Slider} sl Slider Component.
         * @param {Ext.slider.Thumb} thumb The thumb being dragged.
         */
        drag(that: Ext.field.Slider, sl: Ext.slider.Slider, thumb: Ext.slider.Thumb, e: Ext.event.Event);

        /**
         * Fires when a thumb value changes via drag.
         * @param {Ext.slider.Slider} sl Slider Component.
         * @param {Number[]} newValue The new value of this thumb.
         * @param {Number[]} oldValue The old value of this thumb.
         */
        dragchange(me: Ext.field.Slider, sl: Ext.slider.Slider, thumb: Ext.slider.Thumb, newValue: number, oldValue: number);

        /**
         * Fires when the slider thumb ends a drag operation.
         * @param {Ext.slider.Slider} sl Slider Component.
         * @param {Ext.slider.Thumb} thumb The thumb being dragged.
         * @param {Array} value The end value.
         */
        dragend(that: Ext.field.Slider, sl: Ext.slider.Slider, thumb: Ext.slider.Thumb, value: any[], e: Ext.event.Event);

        /**
         * Fires when the slider thumb starts a drag operation.
         * @param {Ext.slider.Slider} sl Slider Component.
         * @param {Ext.slider.Thumb} thumb The thumb being dragged.
         * @param {Array} value The start value.
         */
        dragstart(that: Ext.field.Slider, sl: Ext.slider.Slider, thumb: Ext.slider.Thumb, value: any[], e: Ext.event.Event);
    }

    interface SpinnerConfig extends Ext.field.NumberConfig {
        /**
         * True if autorepeating should start slowly and accelerate.
         */
        accelerateOnTapHold?: boolean;

        cls?: any;

        component?: any;

        /**
         * When set to 'true', it will loop the values of a minimum or maximum is reached.
         * If the maximum value is reached, the value will be set to the minimum.
         */
        cycle?: boolean;

        /**
         * The default value for this field when no value has been set.
         * It is also used when the value is set to 'NaN'.
         */
        defaultValue?: number;

        /**
         * 'true' if you want to group the buttons to the right of the fields. 'false' if you want the buttons
         * to be at either side of the field.
         */
        groupButtons?: boolean;

        /**
         * The maximum allowed value.
         *
         * Optional, Defaults to: infinity
         */
        maxValue?: number;

        /**
         * The minimum allowed value.
         *
         * Optional, Defaults to: -infinity
         */
        minValue?: number;

        /**
         * Value that is added or subtracted from the current value when a spinner is used.
         */
        stepValue?: number;

        value?: any;
    }

    /**
     * Wraps an HTML5 number field. Example usage:
     *
     *     @example miniphone
     *     var spinner = Ext.create('Ext.field.Spinner', {
     *         label: 'Spinner Field',
     *         minValue: 0,
     *         maxValue: 100,
     *         stepValue: 2,
     *         cycle: true
     *     });
     *     Ext.Viewport.add({ xtype: 'container', items: [spinner] });
     */
    export class Spinner extends Ext.field.Number implements Ext.field.SpinnerConfig {
        /**
         * True if autorepeating should start slowly and accelerate.
         */
        accelerateOnTapHold: boolean;

        /**
         * The CSS class to add to this component's element, in
         * addition to the {@link #baseCls}. In many cases, this property will be specified
         * by the derived component class. See {@link #userCls} for adding additional CSS
         * classes to component instances (such as items in a {@link Ext.Container}).
         */
        cls: string;

        /**
         * The inner component for this field, which defaults to an input text.
         */
        component: any;

        /**
         * When set to 'true', it will loop the values of a minimum or maximum is reached.
         * If the maximum value is reached, the value will be set to the minimum.
         */
        cycle: boolean;

        /**
         * The default value for this field when no value has been set.
         * It is also used when the value is set to 'NaN'.
         */
        defaultValue: number;

        /**
         * 'true' if you want to group the buttons to the right of the fields. 'false' if you want the buttons
         * to be at either side of the field.
         */
        groupButtons: boolean;

        /**
         * The maximum allowed value.
         *
         * Optional, Defaults to: infinity
         */
        maxValue: number;

        /**
         * The minimum allowed value.
         *
         * Optional, Defaults to: -infinity
         */
        minValue: number;

        /**
         * Value that is added or subtracted from the current value when a spinner is used.
         */
        stepValue: number;

        value: any;

        /**
         * Creates new Component.
         * @param {Object} config The standard configuration object.
         */
        constructor(config: Ext.ButtonConfig);

        getAccelerateOnTapHold();

        getCls();

        getComponent();

        getCycle();

        getDefaultValue();

        getGroupButtons();

        getMaxValue();

        getMinValue();

        getStepValue();

        getValue();

        setAccelerateOnTapHold();

        setCls();

        setComponent();

        setCycle();

        setDefaultValue();

        setGroupButtons();

        setMaxValue();

        setMinValue();

        setStepValue();

        setValue();

        /**
         * Updates the {@link #component} configuration
         */
        updateComponent();

        /**
         * Fires when the value is changed via either spinner buttons.
         * @param {String} direction 'up' or 'down'.
         */
        spin(that: Ext.field.Spinner, value: number, direction: string);

        /**
         * Fires when the value is changed via the spinner down button.
         */
        spindown(that: Ext.field.Spinner, value: number);

        /**
         * Fires when the value is changed via the spinner up button.
         */
        spinup(that: Ext.field.Spinner, value: number);
    }

    interface TextAreaConfig extends Ext.field.TextConfig {
        autoCapitalize?: any;

        component?: any;

        /**
         * The maximum number of lines made visible by the input.
         */
        maxRows?: number;

        ui?: any;
    }

    /**
     * Creates an HTML textarea field on the page. This is useful whenever you need the user to enter large amounts of text
     * (i.e. more than a few words). Typically, text entry on mobile devices is not a pleasant experience for the user so
     * it's good to limit your use of text areas to only those occasions when free form text is required or alternative
     * input methods like select boxes or radio buttons are not possible. Text Areas are usually created inside forms, like
     * this:
     *
     *     @example
     *     Ext.create('Ext.form.Panel', {
     *         fullscreen: true,
     *         items: [
     *             {
     *                 xtype: 'fieldset',
     *                 title: 'About you',
     *                 items: [
     *                     {
     *                         xtype: 'textfield',
     *                         label: 'Name',
     *                         name: 'name'
     *                     },
     *                     {
     *                         xtype: 'textareafield',
     *                         label: 'Bio',
     *                         maxRows: 4,
     *                         name: 'bio'
     *                     }
     *                 ]
     *             }
     *         ]
     *     });
     *
     * In the example above we're creating a form with a {@link Ext.field.Text text field} for the user's name and a text
     * area for their bio. We used the {@link #maxRows} configuration on the text area to tell it to grow to a maximum of 4
     * rows of text before it starts using a scroll bar inside the text area to scroll the text.
     *
     * We can also create a text area outside the context of a form, like this:
     *
     * This creates two text fields inside a form. Text Fields can also be created outside of a Form, like this:
     *
     *     Ext.create('Ext.field.TextArea', {
     *         label: 'About You',
     *         placeHolder: 'Tell us about yourself...'
     *     });
     */
    export class TextArea extends Ext.field.Text implements Ext.field.TextAreaConfig {
        /**
         * True to set the field's DOM element autocapitalize attribute to "on", false to set to "off".
         */
        autoCapitalize: boolean;

        /**
         * The inner component for this field, which defaults to an input text.
         */
        component: any;

        /**
         * The maximum number of lines made visible by the input.
         */
        maxRows: number;

        /**
         * The ui to be used on this Component
         */
        ui: string;

        /**
         * Creates new Component.
         * @param {Object} config The standard configuration object.
         */
        constructor(config: Ext.ButtonConfig);

        getAutoCapitalize();

        getComponent();

        getMaxRows();

        getUi();

        setAutoCapitalize();

        setComponent();

        setMaxRows();

        setUi();
    }

    export class TextAreaInput extends Ext.field.Input {
        /**
         * Creates new Component.
         * @param {Object} config The standard configuration object.
         */
        constructor(config: Ext.ButtonConfig);
    }

    interface TextConfig extends Ext.field.FieldConfig {
        /**
         * True to set the field's DOM element autocapitalize attribute to "on", false to set to "off".
         */
        autoCapitalize?: boolean;

        /**
         * True to set the field's DOM element autocomplete attribute to "on", false to set to "off".
         */
        autoComplete?: boolean;

        /**
         * True to set the field DOM element autocorrect attribute to "on", false to set to "off".
         */
        autoCorrect?: boolean;

        clearIcon?: any;

        /**
         * The inner component for this field, which defaults to an input text.
         */
        component?: any;

        /**
         * The maximum number of permitted input characters.
         */
        maxLength?: number;

        /**
         * A string value displayed in the input (if supported) when the control is empty.
         */
        placeHolder?: string;

        publishes?: any;

        /**
         * True to set the field DOM element readonly attribute to true.
         */
        readOnly?: boolean;

        twoWayBindable?: any;

        ui?: any;
    }

    /**
     * The text field is the basis for most of the input fields. It provides a baseline of shared
     * functionality such as input validation, standard events, state management and look and feel. Typically we create
     * text fields inside a form, like this:
     *
     *     @example
     *     Ext.create('Ext.form.Panel', {
     *         fullscreen: true,
     *         items: [
     *             {
     *                 xtype: 'fieldset',
     *                 title: 'Enter your name',
     *                 items: [
     *                     {
     *                         xtype: 'textfield',
     *                         label: 'First Name',
     *                         name: 'firstName'
     *                     },
     *                     {
     *                         xtype: 'textfield',
     *                         label: 'Last Name',
     *                         name: 'lastName'
     *                     }
     *                 ]
     *             }
     *         ]
     *     });
     *
     * This creates two text fields inside a form. Text Fields can also be created outside of a Form, like this:
     *
     *     Ext.create('Ext.field.Text', {
     *         label: 'Your Name',
     *         value: 'Ed Spencer'
     *     });
     *
     * ## Configuring
     *
     * Text field offers several configuration options, including {@link #placeHolder}, {@link #maxLength},
     * {@link #autoComplete}, {@link #autoCapitalize} and {@link #autoCorrect}. For example, here is how we would configure
     * a text field to have a maximum length of 10 characters, with placeholder text that disappears when the field is
     * focused:
     *
     *     Ext.create('Ext.field.Text', {
     *         label: 'Username',
     *         maxLength: 10,
     *         placeHolder: 'Enter your username'
     *     });
     *
     * The autoComplete, autoCapitalize and autoCorrect configs simply set those attributes on the text field and allow the
     * native browser to provide those capabilities. For example, to enable auto complete and auto correct, simply
     * configure your text field like this:
     *
     *     Ext.create('Ext.field.Text', {
     *         label: 'Username',
     *         autoComplete: true,
     *         autoCorrect: true
     *     });
     *
     * These configurations will be picked up by the native browser, which will enable the options at the OS level.
     *
     * Text field inherits from {@link Ext.field.Field}, which is the base class for all fields and provides
     * a lot of shared functionality for all fields, including setting values, clearing and basic validation. See the
     * {@link Ext.field.Field} documentation to see how to leverage its capabilities.
     */
    export class Text extends Ext.field.Field implements Ext.field.TextConfig {
        defaultBindProperty: any;

        /**
         * True to set the field's DOM element autocapitalize attribute to "on", false to set to "off".
         */
        autoCapitalize: boolean;

        /**
         * True to set the field's DOM element autocomplete attribute to "on", false to set to "off".
         */
        autoComplete: boolean;

        /**
         * True to set the field DOM element autocorrect attribute to "on", false to set to "off".
         */
        autoCorrect: boolean;

        /**
         * 'true' to use a clear icon in this field.
         */
        clearIcon: boolean;

        /**
         * The inner component for this field, which defaults to an input text.
         */
        component: any;

        /**
         * The maximum number of permitted input characters.
         */
        maxLength: number;

        /**
         * A string value displayed in the input (if supported) when the control is empty.
         */
        placeHolder: string;

        publishes: any;

        /**
         * True to set the field DOM element readonly attribute to true.
         */
        readOnly: boolean;

        twoWayBindable: any;

        /**
         * The ui to be used on this Component
         */
        ui: string;

        /**
         * Attempts to forcefully blur input focus for the field.
         * @return {Ext.field.Text} This field
         */
        blur(): Ext.field.Text;

        /**
         * Creates new Component.
         * @param {Object} config The standard configuration object.
         */
        constructor(config: Ext.ButtonConfig);

        /**
         * Attempts to set the field as the active input focus.
         * @return {Ext.field.Text} This field
         */
        focus(): Ext.field.Text;

        getAutoCapitalize();

        getAutoComplete();

        getAutoCorrect();

        getBubbleEvents();

        getClearIcon();

        getComponent();

        getMaxLength();

        getPlaceHolder();

        getReadOnly();

        getUi();

        resetOriginalValue();

        /**
         * Attempts to forcefully select all the contents of the input field.
         * @return {Ext.field.Text} this
         */
        select(): Ext.field.Text;

        setAutoCapitalize();

        setAutoComplete();

        setAutoCorrect();

        setBubbleEvents();

        setClearIcon();

        setComponent();

        setMaxLength();

        setPlaceHolder();

        setReadOnly();

        setUi();

        /**
         * Fires whenever the return key or go is pressed. FormPanel listeners
         * for this event, and submits itself whenever it fires. Also note
         * that this event bubbles up to parent containers.
         * @param {Ext.field.Text} this This field
         * @param {Mixed} e The key event object
         */
        action(that: Ext.field.Text, e: any);

        /**
         * Fires when the value has changed.
         * @param {Ext.field.Text} this This field
         * @param {String} newValue The new value
         * @param {String} oldValue The original value
         */
        change(that: Ext.field.Text, newValue: string, oldValue: string);

        /**
         * Fires when the clear icon is tapped
         * @param {Ext.field.Text} this This field
         * @param {Ext.field.Input} input The field's input component.
         */
        clearicontap(that: Ext.field.Text, input: Ext.field.Input, e: Ext.event.Event);

        /**
         * Fires when a key is released on the input element
         * @param {Ext.field.Text} this This field
         */
        keyup(that: Ext.field.Text, e: Ext.event.Event);

        /**
         * Fires when this field receives a mousedown
         * @param {Ext.field.Text} this This field
         */
        mousedown(that: Ext.field.Text, e: Ext.event.Event);

        /**
         * Fires when this field is pasted.
         * @param {Ext.field.Text} this This field
         */
        paste(that: Ext.field.Text, e: Ext.event.Event);
    }

    interface ToggleConfig extends Ext.field.SingleSliderConfig {
        /**
         * The label to add to the toggle field when it is toggled on.
         * Only available in the Blackberry theme.
         */
        activeLabel?: string;

        cls?: any;

        /**
         * The label to add to the toggle field when it is toggled off.
         * Only available in the Blackberry theme.
         */
        inactiveLabel?: string;

        /**
         * The position to render the label relative to the field input.
         * Available options are: 'top', 'left', 'bottom' and 'right'
         */
        labelAlign?: string;

        /**
         * See {@link Ext.slider.Toggle#maxValueCls}
         */
        maxValueCls?: string;

        /**
         * See {@link Ext.slider.Toggle#minValueCls}
         */
        minValueCls?: string;
    }

    /**
     * Specialized {@link Ext.field.Slider} with a single thumb which only supports two {@link #value values}.
     *
     * ## Examples
     *
     *     @example miniphone preview
     *     Ext.Viewport.add({
     *         xtype: 'togglefield',
     *         name: 'awesome',
     *         label: 'Are you awesome?',
     *         labelWidth: '40%'
     *     });
     *
     * Having a default value of 'toggled':
     *
     *     @example miniphone preview
     *     Ext.Viewport.add({
     *         xtype: 'togglefield',
     *         name: 'awesome',
     *         value: 1,
     *         label: 'Are you awesome?',
     *         labelWidth: '40%'
     *     });
     *
     * And using the {@link #value} {@link #toggle} method:
     *
     *     @example miniphone preview
     *     Ext.Viewport.add([
     *         {
     *             xtype: 'togglefield',
     *             name: 'awesome',
     *             value: 1,
     *             label: 'Are you awesome?',
     *             labelWidth: '40%'
     *         },
     *         {
     *             xtype: 'toolbar',
     *             docked: 'top',
     *             items: [
     *                 {
     *                     xtype: 'button',
     *                     text: 'Toggle',
     *                     flex: 1,
     *                     handler: function() {
     *                         Ext.ComponentQuery.query('togglefield')[0].toggle();
     *                     }
     *                 }
     *             ]
     *         }
     *     ]);
     */
    export class Toggle extends Ext.field.SingleSlider implements Ext.field.ToggleConfig {
        /**
         * The label to add to the toggle field when it is toggled on.
         * Only available in the Blackberry theme.
         */
        activeLabel: string;

        /**
         * The CSS class to add to this component's element, in
         * addition to the {@link #baseCls}. In many cases, this property will be specified
         * by the derived component class. See {@link #userCls} for adding additional CSS
         * classes to component instances (such as items in a {@link Ext.Container}).
         */
        cls: string;

        /**
         * The label to add to the toggle field when it is toggled off.
         * Only available in the Blackberry theme.
         */
        inactiveLabel: string;

        /**
         * The position to render the label relative to the field input.
         * Available options are: 'top', 'left', 'bottom' and 'right'
         */
        labelAlign: string;

        /**
         * See {@link Ext.slider.Toggle#maxValueCls}
         */
        maxValueCls: string;

        /**
         * See {@link Ext.slider.Toggle#minValueCls}
         */
        minValueCls: string;

        /**
         * Creates new Component.
         * @param {Object} config The standard configuration object.
         */
        constructor(config: Ext.ButtonConfig);

        getActiveLabel();

        getCls();

        getInactiveLabel();

        getLabelAlign();

        getMaxValueCls();

        getMinValueCls();

        getValue();

        setActiveLabel();

        setCls();

        setInactiveLabel();

        setLabelAlign();

        setMaxValueCls();

        setMinValueCls();

        setValue();

        /**
         * Toggles the value of this toggle field.
         * @return {Object} this
         */
        toggle(): any;
    }

    interface UrlConfig extends Ext.field.TextConfig {
        autoCapitalize?: any;

        component?: any;
    }

    /**
     * The Url field creates an HTML5 url input and is usually created inside a form. Because it creates an HTML url input
     * field, most browsers will show a specialized virtual keyboard for web address input. Aside from that, the url field
     * is just a normal text field. Here's an example of how to use it in a form:
     *
     *     @example
     *     Ext.create('Ext.form.Panel', {
     *         fullscreen: true,
     *         items: [
     *             {
     *                 xtype: 'fieldset',
     *                 title: 'Add Bookmark',
     *                 items: [
     *                     {
     *                         xtype: 'urlfield',
     *                         label: 'Url',
     *                         name: 'url'
     *                     }
     *                 ]
     *             }
     *         ]
     *     });
     *
     * Or on its own, outside of a form:
     *
     *     Ext.create('Ext.field.Url', {
     *         label: 'Web address',
     *         value: 'http://sencha.com'
     *     });
     *
     * Because url field inherits from {@link Ext.field.Text textfield} it gains all of the functionality that text fields
     * provide, including getting and setting the value at runtime, validations and various events that are fired as the
     * user interacts with the component. Check out the {@link Ext.field.Text} docs to see the additional functionality
     * available.
     */
    export class Url extends Ext.field.Text implements Ext.field.UrlConfig {
        /**
         * True to set the field's DOM element autocapitalize attribute to "on", false to set to "off".
         */
        autoCapitalize: boolean;

        /**
         * The inner component for this field, which defaults to an input text.
         */
        component: any;

        /**
         * Creates new Component.
         * @param {Object} config The standard configuration object.
         */
        constructor(config: Ext.ButtonConfig);

        getAutoCapitalize();

        getComponent();

        setAutoCapitalize();

        setComponent();
    }
}

declare module Ext.form {
    interface FieldSetConfig extends Ext.ContainerConfig {
        baseCls?: any;

        /**
         * Optional fieldset instructions, rendered just below the grouped fields.
         *
         * ## Example
         *
         *     Ext.create('Ext.form.Fieldset', {
         *         fullscreen: true,
         *
         *         instructions: 'Please enter your email address.',
         *
         *         items: [{
         *             xtype: 'textfield',
         *             label: 'Email'
         *         }]
         *     });
         */
        instructions?: string;

        /**
         * Optional fieldset title, rendered just above the grouped fields.
         *
         * ## Example
         *
         *     Ext.create('Ext.form.Fieldset', {
         *         fullscreen: true,
         *
         *         title: 'Login',
         *
         *         items: [{
         *             xtype: 'textfield',
         *             label: 'Email'
         *         }]
         *     });
         */
        title?: string;
    }

    /**
     * A FieldSet is a great way to visually separate elements of a form. It's normally used when you have a form with
     * fields that can be divided into groups - for example a customer's billing details in one fieldset and their shipping
     * address in another. A fieldset can be used inside a form or on its own elsewhere in your app. Fieldsets can
     * optionally have a title at the top and instructions at the bottom. Here's how we might create a FieldSet inside a
     * form:
     *
     *     @example
     *     Ext.create('Ext.form.Panel', {
     *         fullscreen: true,
     *         items: [
     *             {
     *                 xtype: 'fieldset',
     *                 title: 'About You',
     *                 instructions: 'Tell us all about yourself',
     *                 items: [
     *                     {
     *                         xtype: 'textfield',
     *                         name : 'firstName',
     *                         label: 'First Name'
     *                     },
     *                     {
     *                         xtype: 'textfield',
     *                         name : 'lastName',
     *                         label: 'Last Name'
     *                     }
     *                 ]
     *             }
     *         ]
     *     });
     *
     * Above we created a {@link Ext.form.Panel form} with a fieldset that contains two text fields. In this case, all
     * of the form fields are in the same fieldset, but for longer forms we may choose to use multiple fieldsets. We also
     * configured a {@link #title} and {@link #instructions} to give the user more information on filling out the form if
     * required.
     */
    export class FieldSet extends Ext.Container implements Ext.form.FieldSetConfig {
        /**
         * The base CSS class to apply to this component's element. This will also be prepended to
         * other elements within this component. To add specific styling for sub-classes, use the {@link #cls} config.
         */
        baseCls: string;

        /**
         * Optional fieldset instructions, rendered just below the grouped fields.
         *
         * ## Example
         *
         *     Ext.create('Ext.form.Fieldset', {
         *         fullscreen: true,
         *
         *         instructions: 'Please enter your email address.',
         *
         *         items: [{
         *             xtype: 'textfield',
         *             label: 'Email'
         *         }]
         *     });
         */
        instructions: string;

        /**
         * Optional fieldset title, rendered just above the grouped fields.
         *
         * ## Example
         *
         *     Ext.create('Ext.form.Fieldset', {
         *         fullscreen: true,
         *
         *         title: 'Login',
         *
         *         items: [{
         *             xtype: 'textfield',
         *             label: 'Email'
         *         }]
         *     });
         */
        title: string;

        constructor(config: Ext.ActionSheetConfig);

        getBaseCls();

        setBaseCls();

        setInstructions();

        setTitle();

        /**
         * A convenient method to disable all fields in this FieldSet
         * @return {Ext.form.FieldSet} This FieldSet
         */
        updateDisabled(): Ext.form.FieldSet;
    }

    interface PanelConfig extends Ext.PanelConfig {
        /**
         * If specified, load and submit actions will be loaded and submitted via Ext Direct.  Methods which have been imported by
         * {@link Ext.direct.Manager} can be specified here to load and submit forms. API methods may also be
         * specified as strings and will be parsed into the actual functions when the first submit or load has occurred. Such as the following:
         *
         *     api: {
         *         load: App.ss.MyProfile.load,
         *         submit: App.ss.MyProfile.submit
         *     }
         *
         *     api: {
         *         load: 'App.ss.MyProfile.load',
         *         submit: 'App.ss.MyProfile.submit'
         *     }
         *
         * Load actions can use {@link #paramOrder} or {@link #paramsAsHash} to customize how the load method
         * is invoked.  Submit actions will always use a standard form submit. The 'formHandler' configuration
         * (see Ext.direct.RemotingProvider#action) must be set on the associated server-side method which has
         * been imported by {@link Ext.direct.Manager}.
         */
        api?: any;

        baseCls?: string;

        /**
         * Optional hash of params to be sent (when 'standardSubmit' configuration is 'false') on every submit.
         */
        baseParams?: any;

        /**
         * The submission form is generated but never added to the dom. It is a submittable version of your form panel, allowing for fields
         * that are not simple textfields to be properly submitted to servers. It will also send values that are easier to parse
         * with server side code.
         *
         * If this is false we will attempt to subject the raw form inside the form panel.
         */
        enableSubmissionForm?: boolean;

        /**
         * The enctype attribute for the form, specifies how the form should be encoded when submitting
         */
        enctype?: string;

        /**
         * The method which this form will be submitted. 'post' or 'get'.
         */
        method?: string;

        /**
         * If this is enabled the form will automatically detect the need to use 'multipart/form-data' during submission.
         */
        multipartDetection?: boolean;

        /**
         * A list of params to be executed server side. Only used for the {@link #api} 'load'
         * configuration.
         *
         * Specify the params in the order in which they must be executed on the
         * server-side as either (1) an Array of String values, or (2) a String of params
         * delimited by either whitespace, comma, or pipe. For example,
         * any of the following would be acceptable:
         *
         *     paramOrder: ['param1','param2','param3']
         *     paramOrder: 'param1 param2 param3'
         *     paramOrder: 'param1,param2,param3'
         *     paramOrder: 'param1|param2|param'
         */
        paramOrder?: string;

        /**
         * Only used for the {@link #api} 'load' configuration. If true, parameters will be sent as a
         * single hash collection of named arguments. Providing a {@link #paramOrder} nullifies this
         * configuration.
         */
        paramsAsHash?: boolean;

        /**
         * The model instance of this form. Can by dynamically set at any time.
         */
        record?: Ext.data.Model;

        scrollable?: any;

        /**
         * Whether or not we want to perform a standard form submit.
         */
        standardSubmit?: boolean;

        /**
         * When this is set to 'true', the form will automatically submit itself whenever the 'action'
         * event fires on a field in this form. The action event usually fires whenever you press
         * go or enter inside a textfield.
         */
        submitOnAction?: any;

        /**
         * Timeout for form actions in seconds.
         */
        timeout?: number;

        /**
         * If set to true, {@link #reset}() resets to the last loaded or {@link #setValues}() data instead of
         * when the form was first created.
         */
        trackResetOnLoad?: boolean;

        /**
         * The default url for submit actions.
         */
        url?: string;
    }

    /**
     * The Form panel presents a set of form fields and provides convenient ways to load and save data. Usually a form
     * panel just contains the set of fields you want to display, ordered inside the items configuration like this:
     *
     *     @example
     *     var form = Ext.create('Ext.form.Panel', {
     *         fullscreen: true,
     *         items: [
     *             {
     *                 xtype: 'textfield',
     *                 name: 'name',
     *                 label: 'Name'
     *             },
     *             {
     *                 xtype: 'emailfield',
     *                 name: 'email',
     *                 label: 'Email'
     *             },
     *             {
     *                 xtype: 'passwordfield',
     *                 name: 'password',
     *                 label: 'Password'
     *             }
     *         ]
     *     });
     *
     * Here we just created a simple form panel which could be used as a registration form to sign up to your service. We
     * added a plain {@link Ext.field.Text text field} for the user's Name, an {@link Ext.field.Email email field} and
     * finally a {@link Ext.field.Password password field}. In each case we provided a {@link Ext.field.Field#name name}
     * config on the field so that we can identify it later on when we load and save data on the form.
     *
     * ##Loading data
     *
     * Using the form we created above, we can load data into it in a few different ways, the easiest is to use
     * {@link #setValues}:
     *
     *     form.setValues({
     *         name: 'Peter',
     *         email: 'peter.venkman@gb.com',
     *         password: 'secret'
     *     });
     *
     * It's also easy to load {@link Ext.data.Model Model} instances into a form - let's say we have a User model and want
     * to load a particular instance into our form:
     *
     *     Ext.define('MyApp.model.User', {
     *         extend: 'Ext.data.Model',
     *         config: {
     *             fields: ['name', 'email', 'password']
     *         }
     *     });
     *
     *     var ed = Ext.create('MyApp.model.User', {
     *         name: 'Peter',
     *         email: 'peter.venkman@gb.com',
     *         password: 'secret'
     *     });
     *
     *     form.setRecord(ed);
     *
     * ##Retrieving form data
     *
     * Getting data out of the form panel is simple and is usually achieve via the {@link #getValues} method:
     *
     *     var values = form.getValues();
     *
     *     //values now looks like this:
     *     {
     *         name: 'Peter',
     *         email: 'peter.venkman@gb.com',
     *         password: 'secret'
     *     }
     *
     * It's also possible to listen to the change events on individual fields to get more timely notification of changes
     * that the user is making. Here we expand on the example above with the User model, updating the model as soon as
     * any of the fields are changed:
     *
     *     var form = Ext.create('Ext.form.Panel', {
     *         listeners: {
     *             '> field': {
     *                 change: function(field, newValue, oldValue) {
     *                     ed.set(field.getName(), newValue);
     *                 }
     *             }
     *         },
     *         items: [
     *             {
     *                 xtype: 'textfield',
     *                 name: 'name',
     *                 label: 'Name'
     *             },
     *             {
     *                 xtype: 'emailfield',
     *                 name: 'email',
     *                 label: 'Email'
     *             },
     *             {
     *                 xtype: 'passwordfield',
     *                 name: 'password',
     *                 label: 'Password'
     *             }
     *         ]
     *     });
     *
     * The above attached a listener to the {@link Ext.field.Text#change change} event of each form
     * field that is a direct child of the form panel. Our listener gets the name of the field that fired the change event,
     * and updates our {@link Ext.data.Model Model} instance with the new value. For example, changing the email field
     * in the form will update the Model's email field.
     *
     * ##Submitting forms
     *
     * There are a few ways to submit form data. In our example above we have a Model instance that we have updated, giving
     * us the option to use the Model's {@link Ext.data.Model#save save} method to persist the changes back to our server,
     * without using a traditional form submission. Alternatively, we can send a normal browser form submit using the
     * {@link #method} method:
     *
     *     form.submit({
     *         url: 'url/to/submit/to',
     *         method: 'POST',
     *         success: function() {
     *             alert('form submitted successfully!');
     *         }
     *     });
     *
     * In this case we provided the 'url' to submit the form to inside the submit call - alternatively you can just set the
     * {@link #url} configuration when you create the form. We can specify other parameters (see {@link #method} for a
     * full list), including callback functions for success and failure, which are called depending on whether or not the
     * form submission was successful. These functions are usually used to take some action in your app after your data
     * has been saved to the server side.
     */
    export class Panel extends Ext.Panel implements Ext.form.PanelConfig {
        /**
         * If specified, load and submit actions will be loaded and submitted via Ext Direct.  Methods which have been imported by
         * {@link Ext.direct.Manager} can be specified here to load and submit forms. API methods may also be
         * specified as strings and will be parsed into the actual functions when the first submit or load has occurred. Such as the following:
         *
         *     api: {
         *         load: App.ss.MyProfile.load,
         *         submit: App.ss.MyProfile.submit
         *     }
         *
         *     api: {
         *         load: 'App.ss.MyProfile.load',
         *         submit: 'App.ss.MyProfile.submit'
         *     }
         *
         * Load actions can use {@link #paramOrder} or {@link #paramsAsHash} to customize how the load method
         * is invoked.  Submit actions will always use a standard form submit. The 'formHandler' configuration
         * (see Ext.direct.RemotingProvider#action) must be set on the associated server-side method which has
         * been imported by {@link Ext.direct.Manager}.
         */
        api: any;

        baseCls: string;

        /**
         * Optional hash of params to be sent (when 'standardSubmit' configuration is 'false') on every submit.
         */
        baseParams: any;

        /**
         * The submission form is generated but never added to the dom. It is a submittable version of your form panel, allowing for fields
         * that are not simple textfields to be properly submitted to servers. It will also send values that are easier to parse
         * with server side code.
         *
         * If this is false we will attempt to subject the raw form inside the form panel.
         */
        enableSubmissionForm: boolean;

        /**
         * The enctype attribute for the form, specifies how the form should be encoded when submitting
         */
        enctype: string;

        /**
         * The method which this form will be submitted. 'post' or 'get'.
         */
        method: string;

        /**
         * If this is enabled the form will automatically detect the need to use 'multipart/form-data' during submission.
         */
        multipartDetection: boolean;

        /**
         * A list of params to be executed server side. Only used for the {@link #api} 'load'
         * configuration.
         *
         * Specify the params in the order in which they must be executed on the
         * server-side as either (1) an Array of String values, or (2) a String of params
         * delimited by either whitespace, comma, or pipe. For example,
         * any of the following would be acceptable:
         *
         *     paramOrder: ['param1','param2','param3']
         *     paramOrder: 'param1 param2 param3'
         *     paramOrder: 'param1,param2,param3'
         *     paramOrder: 'param1|param2|param'
         */
        paramOrder: string;

        /**
         * Only used for the {@link #api} 'load' configuration. If true, parameters will be sent as a
         * single hash collection of named arguments. Providing a {@link #paramOrder} nullifies this
         * configuration.
         */
        paramsAsHash: boolean;

        /**
         * The model instance of this form. Can by dynamically set at any time.
         */
        record: Ext.data.Model;

        /**
         * Configuration options to make this Component scrollable. Acceptable values are:
         *
         * - 'true' to enable auto scrolling.
         * - 'false' (or 'null') to disable scrolling - this is the default.
         * - 'x' or 'horizontal' to enable horizontal scrolling only
         * - 'y' or 'vertical' to enable vertical scrolling only
         *
         * Also accepts a configuration object for a '{@link Ext.scroll.Scroller}' if
         * if advanced configuration is needed.
         *
         * The getter for this config returns the {@link Ext.scroll.Scroller Scroller}
         * instance.  You can use the Scroller API to read or manipulate the scroll position:
         *
         *     // scrolls the component to 5 on the x axis and 10 on the y axis
         *     component.getScrollable().scrollTo(5, 10);
         */
        scrollable: boolean|string|any;

        /**
         * Whether or not we want to perform a standard form submit.
         */
        standardSubmit: boolean;

        /**
         * When this is set to 'true', the form will automatically submit itself whenever the 'action'
         * event fires on a field in this form. The action event usually fires whenever you press
         * go or enter inside a textfield.
         */
        submitOnAction: any;

        /**
         * Timeout for form actions in seconds.
         */
        timeout: number;

        /**
         * If set to true, {@link #reset}() resets to the last loaded or {@link #setValues}() data instead of
         * when the form was first created.
         */
        trackResetOnLoad: boolean;

        /**
         * The default url for submit actions.
         */
        url: string;

        constructor(config: Ext.ActionSheetConfig);

        getApi();

        getBaseCls();

        getBaseParams();

        getEnableSubmissionForm();

        getEnctype();

        /**
         * Returns all {@link Ext.field.Field field} instances inside this form.
         * @param {Boolean} byName return only fields that match the given name, otherwise return all fields.
         * @return {Object/Array} All field instances, mapped by field name; or an array if 'byName' is passed.
         */
        getFields(byName: boolean): any|any[];

        getMethod();

        getMultipartDetection();

        getParamOrder();

        getParamsAsHash();

        getRecord();

        getScrollable();

        getStandardSubmit();

        getSubmitOnAction();

        getTimeout();

        getTrackResetOnLoad();

        getUrl();

        /**
         * Returns an object containing the value of each field in the form, keyed to the field's name.
         * For groups of checkbox fields with the same name, it will be arrays of values. For example:
         *
         *     {
         *         name: "Jacky Nguyen", // From a TextField
         *         favorites: [
         *             'pizza',
         *             'noodle',
         *             'cake'
         *         ]
         *     }
         *
         * @param {Boolean} [enabled] 'true' to return only enabled fields.
         * @param {Boolean} [all] 'true' to return all fields even if they don't have a
         * {@link Ext.field.Field#name name} configured.
         * @return {Object} Object mapping field name to its value.
         */
        getValues(enabled?: boolean, all?: boolean): any;

        /**
         * Hides a previously shown wait mask (See {@link #showMask}).
         * @return {Ext.form.Panel} this
         * @deprecated 2.0.0 Please use {@link #unmask} or {@link #setMasked} instead.
         */
        hideMask(): Ext.form.Panel;

        /**
         * Performs an Ajax or Ext Direct call to load values for this form.
         *
         * The configuration when loading this form.
         *
         * The following are the configurations when loading via Ajax only:
         *
         * The url for the action (defaults to the form's {@link #url}).
         *
         * The form method to use (defaults to the form's {@link #method}, or GET if not defined).
         *
         * Request headers to set for the action.
         *
         * The number is seconds the loading will timeout in.
         *
         * The following are the configurations when loading via Ajax or Direct:
         *
         * @param {Boolean} [options.autoAbort=false]
         * 'true' to abort any pending Ajax request prior to loading.
         *
         * The params to pass when submitting this form (defaults to this forms {@link #baseParams}).
         * Parameters are encoded as standard HTTP parameters using {@link Ext#urlEncode}.
         *
         * @param {String/Object} [options.waitMsg]
         * If specified, the value which is passed to the loading {@link #masked mask}. See {@link #masked} for
         * more information.
         *
         * The callback that will be invoked after a successful response. A response is successful if
         * a response is received from the server and is a JSON object where the 'success' property is set
         * to 'true', '{"success": true}'.
         *
         * The function is passed the following parameters and can be used for loading via Ajax or Direct:
         *
         * The {@link Ext.form.Panel} that requested the load.
         *
         * The result object returned by the server as a result of the load request. If the loading was done via Ext Direct,
         * will return the {@link Ext.direct.Event} instance, otherwise will return an Object.
         *
         * The parsed data returned by the server.
         *
         * The callback that will be invoked after a failed transaction attempt.
         *
         * The function is passed the following parameters and can be used for loading via Ajax or Direct:
         *
         * The {@link Ext.form.Panel} that requested the load.
         *
         * The failed response or result object returned by the server which performed the operation.
         *
         * The parsed data returned by the server.
         *
         * The scope in which to call the callback functions (The 'this' reference for the callback functions).
         *
         * @return {Ext.data.Connection} The request object.
         */
        load(options: any, options_url: string, options_method: string, options_headers: any, options_timeout: number, options_autoAbort?: boolean, options_params?: string|any, options_waitMsg?: string|any, options_success?: Function, options_success_form?: Ext.form.Panel, options_success_result?: any|Ext.direct.Event, options_success_data?: any, options_failure?: Function, options_failure_form?: Ext.form.Panel, options_failure_result?: Ext.form.Panel, options_scope?: any): Ext.data.Connection;

        /**
         * Resets all fields in the form back to their original values.
         * @return {Ext.form.Panel} This form.
         */
        reset(): Ext.form.Panel;

        setApi();

        setBaseCls();

        setBaseParams();

        setEnableSubmissionForm();

        setEnctype();

        setMethod();

        setMultipartDetection();

        setParamOrder();

        setParamsAsHash();

        setScrollable();

        setStandardSubmit();

        setSubmitOnAction();

        setTimeout();

        setTrackResetOnLoad();

        setUrl();

        /**
         * Sets the values of form fields in bulk. Example usage:
         *
         *     myForm.setValues({
         *         name: 'Ed',
         *         crazy: true,
         *         username: 'edspencer'
         *     });
         *
         * If there groups of checkbox fields with the same name, pass their values in an array. For example:
         *
         *     myForm.setValues({
         *         name: 'Jacky',
         *         crazy: false,
         *         hobbies: [
         *             'reading',
         *             'cooking',
         *             'gaming'
         *         ]
         *     });
         *
         * @param {Object} values field name => value mapping object.
         * @return {Ext.form.Panel} This form.
         */
        setValues(values: any): Ext.form.Panel;

        /**
         * Shows a generic/custom mask over a designated Element.
         * @param {String/Object} cfg Either a string message or a configuration object supporting
         * the following options:
         *
         *     {
         *         message : 'Please Wait',
         *         cls : 'form-mask'
         *     }
         *
         * @return {Ext.form.Panel} This form
         * @deprecated 2.0.0 Please use {@link #setMasked} instead.
         */
        showMask(cfg: string|any, target: any): Ext.form.Panel;

        /**
         * Performs a Ajax-based submission of form values (if {@link #standardSubmit} is false) or otherwise
         * executes a standard HTML Form submit action.
         *
         * **Notes**
         *
         *  1. Only the first parameter is implemented. Put all other parameters inside the first
         *  parameter:
         *
         *     submit({params: "" ,headers: "" etc.})
         *
         *  2. Submit example:
         *
         *     myForm.submit({
         *       url: 'PostMyData/To',
         *       method: 'Post',
         *       success: function() { Ext.Msg.alert("success"); },
         *       failure: function() { Ext.Msg.alert("error"); }
         *     });
         *
         *  3. Parameters and values only submit for a POST and not for a GET.
         *
         * The configuration when submitting this form.
         *
         * The following are the configurations when submitting via Ajax only:
         *
         * The url for the action (defaults to the form's {@link #url}).
         *
         * The form method to use (defaults to the form's {@link #method}, or POST if not defined).
         *
         * Request headers to set for the action.
         *
         * @param {Boolean} [options.autoAbort=false]
         * 'true' to abort any pending Ajax request prior to submission.
         * __Note:__ Has no effect when '{@link #standardSubmit}' is enabled.
         *
         * The number is seconds the loading will timeout in.
         *
         * The following are the configurations when loading via Ajax or Direct:
         *
         * The params to pass when submitting this form (defaults to this forms {@link #baseParams}).
         * Parameters are encoded as standard HTTP parameters using {@link Ext#urlEncode}.
         *
         * @param {Boolean} [options.submitDisabled=false]
         * 'true' to submit all fields regardless of disabled state.
         * __Note:__ Has no effect when '{@link #standardSubmit}' is enabled.
         *
         * @param {String/Object} [options.waitMsg]
         * If specified, the value which is passed to the loading {@link #masked mask}. See {@link #masked} for
         * more information.
         *
         * The callback that will be invoked after a successful response. A response is successful if
         * a response is received from the server and is a JSON object where the 'success' property is set
         * to 'true', '{"success": true}'.
         *
         * The function is passed the following parameters and can be used for submitting via Ajax or Direct:
         *
         * The {@link Ext.form.Panel} that requested the action.
         *
         * The result object returned by the server as a result of the submit request. If the submit is sent using Ext Direct,
         * this will return the {@link Ext.direct.Event} instance, otherwise will return an Object.
         *
         * The parsed data returned by the server.
         *
         * The callback that will be invoked after a failed transaction attempt.
         *
         * The function is passed the following parameters and can be used for submitting via Ajax or Direct:
         *
         * The {@link Ext.form.Panel} that requested the submit.
         *
         * The failed response or result object returned by the server which performed the operation.
         *
         * The parsed data returned by the server.
         *
         * The scope in which to call the callback functions (The 'this' reference for the callback functions).
         *
         * @return {Ext.data.Connection} The request object if the {@link #standardSubmit} config is false.
         * If the standardSubmit config is true, then the return value is undefined.
         */
        submit(options: any, options_url: string, options_method: string, options_headers: any, options_autoAbort?: boolean, options_timeout?: number, options_params?: string|any, options_submitDisabled?: boolean, options_waitMsg?: string|any, options_success?: Function, options_success_form?: Ext.form.Panel, options_success_result?: any|Ext.direct.Event, options_success_data?: any, options_failure?: Function, options_failure_form?: Ext.form.Panel, options_failure_result?: Ext.form.Panel, options_scope?: any): Ext.data.Connection;

        /**
         * A convenient method to disable all fields in this form.
         * @return {Ext.form.Panel} This form.
         */
        updateDisabled(): Ext.form.Panel;

        /**
         * Fires immediately preceding any Form submit action.
         * Implementations may adjust submitted form values or options prior to execution.
         * A return value of 'false' from this listener will abort the submission
         * attempt (regardless of 'standardSubmit' configuration).
         * @param {Ext.form.Panel} this This FormPanel.
         * @param {Object} values A hash collection of the qualified form values about to be submitted.
         * @param {Object} options Submission options hash (only available when 'standardSubmit' is 'false').
         * @param {Ext.event.Event} e The event object if the form was submitted via a HTML5 form submit event.
         */
        beforesubmit(that: Ext.form.Panel, values: any, options: any, e: Ext.event.Event);

        /**
         * Fires when either the Ajax HTTP request reports a failure OR the server returns a 'success:false'
         * response in the result payload.
         * @param {Ext.form.Panel} this This FormPanel.
         * @param {Object} result Either a failed Ext.data.Connection request object or a failed (logical) server.
         * response payload.
         */
        exception(that: Ext.form.Panel, result: any);
    }
}

declare module Ext.fx {
    interface AnimationConfig {
        /**
         * The type of animation to use. The possible values are:
         *
         *  - 'fade' - {@link Ext.fx.animation.Fade}
         *  - 'fadeOut' - {@link Ext.fx.animation.FadeOut}
         *  - 'flip' - {@link Ext.fx.animation.Flip}
         *  - 'pop' - {@link Ext.fx.animation.Pop}
         *  - 'popOut' - {@link Ext.fx.animation.PopOut}
         *  - 'slide' - {@link Ext.fx.animation.Slide}
         *  - 'slideOut' - {@link Ext.fx.animation.SlideOut}
         */
        type?: string;
    }

    /**
     * This class is a factory class that will create and return an animation class based on the {@link #type} configuration.
     */
    export class Animation extends Ext.Base implements Ext.fx.AnimationConfig {
        /**
         * The type of animation to use. The possible values are:
         *
         *  - 'fade' - {@link Ext.fx.animation.Fade}
         *  - 'fadeOut' - {@link Ext.fx.animation.FadeOut}
         *  - 'flip' - {@link Ext.fx.animation.Flip}
         *  - 'pop' - {@link Ext.fx.animation.Pop}
         *  - 'popOut' - {@link Ext.fx.animation.PopOut}
         *  - 'slide' - {@link Ext.fx.animation.Slide}
         *  - 'slideOut' - {@link Ext.fx.animation.SlideOut}
         */
        type: string;
    }

    export class Runner extends Ext.Base {
        constructor();
    }

    export class State extends Ext.Base {
        constructor(data: any);
    }
}

declare module Ext.fx.animation {
    interface AbstractConfig {
        /**
         * Before configuration.
         */
        before?: any;

        /**
         * Easing type.
         */
        easing?: any;
    }

    export class Abstract extends Ext.Evented implements Ext.fx.animation.AbstractConfig {
        /**
         * Before configuration.
         */
        before: any;

        /**
         * Easing type.
         */
        easing: any;

        constructor();

        destroy();

        getAfter();

        getBefore();

        getCallback();

        getDelay();

        getDirection();

        getDuration();

        getEasing();

        getElement();

        getIteration();

        getOnBeforeEnd();

        getOnBeforeStart();

        getOnEnd();

        getPreserveEndState();

        getReplacePrevious();

        getReverse();

        getScope();

        setAfter();

        setBefore();

        setCallback();

        setDelay();

        setDirection();

        setDuration();

        setEasing();

        setElement();

        setIteration();

        setName();

        setOnBeforeEnd();

        setOnBeforeStart();

        setOnEnd();

        setPreserveEndState();

        setReplacePrevious();

        setReverse();

        setScope();
    }

    interface CubeConfig extends Ext.fx.animation.AbstractConfig {
        before?: any;

        /**
         * The direction of which the slide animates
         */
        direction?: string;
    }

    export class Cube extends Ext.fx.animation.Abstract implements Ext.fx.animation.CubeConfig {
        /**
         * Before configuration.
         */
        before: any;

        /**
         * The direction of which the slide animates
         */
        direction: string;

        constructor();

        getAfter();

        getBefore();

        getDirection();

        getOut();

        setAfter();

        setBefore();

        setDirection();

        setOut();
    }

    interface FadeConfig extends Ext.fx.animation.AbstractConfig {
        before?: any;

        /**
         * True if you want to make this animation fade out, instead of fade in.
         */
        out?: boolean;
    }

    export class Fade extends Ext.fx.animation.Abstract implements Ext.fx.animation.FadeConfig {
        before: any;

        /**
         * True if you want to make this animation fade out, instead of fade in.
         */
        out: boolean;

        constructor();

        getAfter();

        getBefore();

        getOut();

        getReverse();

        setAfter();

        setBefore();

        setOut();

        setReverse();
    }

    interface FadeOutConfig extends Ext.fx.animation.FadeConfig {
        before?: any;
    }

    export class FadeOut extends Ext.fx.animation.Fade implements Ext.fx.animation.FadeOutConfig {
        before: any;

        constructor();

        getBefore();

        setBefore();
    }

    interface FlipConfig extends Ext.fx.animation.AbstractConfig {
        /**
         * The direction of which the slide animates
         */
        direction?: string;

        easing?: any;
    }

    export class Flip extends Ext.fx.animation.Abstract implements Ext.fx.animation.FlipConfig {
        /**
         * The direction of which the slide animates
         */
        direction: string;

        easing: any;

        constructor();

        getDirection();

        getEasing();

        getHalf();

        getOut();

        setDirection();

        setEasing();

        setHalf();

        setOut();
    }

    interface PopConfig extends Ext.fx.animation.AbstractConfig {
        before?: any;

        /**
         * True if you want to make this animation pop out, instead of pop in.
         */
        out?: boolean;
    }

    export class Pop extends Ext.fx.animation.Abstract implements Ext.fx.animation.PopConfig {
        before: any;

        /**
         * True if you want to make this animation pop out, instead of pop in.
         */
        out: boolean;

        constructor();

        getAfter();

        getBefore();

        getOut();

        setAfter();

        setBefore();

        setOut();
    }

    interface PopOutConfig extends Ext.fx.animation.PopConfig {
        before?: any;
    }

    export class PopOut extends Ext.fx.animation.Pop implements Ext.fx.animation.PopOutConfig {
        before: any;

        constructor();

        getBefore();

        setBefore();
    }

    interface SlideConfig extends Ext.fx.animation.AbstractConfig {
        /**
         * The direction of which the slide animates
         */
        direction?: string;

        easing?: any;

        /**
         * The offset that the animation should go offscreen before entering (or when exiting)
         */
        offset?: number;

        /**
         * True if you want to make this animation slide out, instead of slide in.
         */
        out?: boolean;
    }

    export class Slide extends Ext.fx.animation.Abstract implements Ext.fx.animation.SlideConfig {
        /**
         * The direction of which the slide animates
         */
        direction: string;

        /**
         * Easing type.
         */
        easing: any;

        /**
         * The offset that the animation should go offscreen before entering (or when exiting)
         */
        offset: number;

        /**
         * True if you want to make this animation slide out, instead of slide in.
         */
        out: boolean;

        constructor();

        getDirection();

        getEasing();

        getIsElementBoxFit();

        getOffset();

        getOut();

        getUseCssTransform();

        setContainerBox();

        setDirection();

        setEasing();

        setElementBox();

        setIsElementBoxFit();

        setOffset();

        setOut();

        setUseCssTransform();
    }

    export class SlideOut extends Ext.fx.animation.Slide {
        constructor();
    }

    interface WipeConfig extends Ext.fx.AnimationConfig {
        /**
         * The direction of which the slide animates
         */
        direction?: string;

        /**
         * Valid values are 'ease', 'linear', ease-in', 'ease-out', 'ease-in-out',
         * or a cubic-bezier curve as defined by CSS.
         */
        easing?: any;

        /**
         * True if you want to make this animation wipe out, instead of slide in.
         */
        out?: boolean;
    }

    export class Wipe extends Ext.fx.Animation implements Ext.fx.animation.WipeConfig {
        /**
         * The direction of which the slide animates
         */
        direction: string;

        /**
         * Valid values are 'ease', 'linear', ease-in', 'ease-out', 'ease-in-out',
         * or a cubic-bezier curve as defined by CSS.
         */
        easing: any;

        /**
         * True if you want to make this animation wipe out, instead of slide in.
         */
        out: boolean;

        getDirection();

        getEasing();

        getOut();

        setDirection();

        setEasing();

        setOut();
    }

    export class WipeOut extends Ext.fx.animation.Wipe {
    }
}

declare module Ext.fx.easing {
    export class Abstract extends Ext.Base {
        constructor(config: Ext.fx.easing.BoundMomentumConfig);

        getStartTime();

        getStartValue();

        setStartTime();

        setStartValue();
    }

    export class Bounce extends Ext.fx.easing.Abstract {
        constructor(config: Ext.fx.easing.BoundMomentumConfig);

        getAcceleration();

        getSpringTension();

        getStartVelocity();

        setAcceleration();

        setSpringTension();

        setStartVelocity();
    }

    interface BoundMomentumConfig {
        /**
         * A valid config object for {@link Ext.fx.easing.Bounce}
         */
        bounce?: any;

        /**
         * The minimum velocity to end this easing
         */
        minVelocity?: number;

        /**
         * A valid config object for {@link Ext.fx.easing.Momentum}
         */
        momentum?: any;

        /**
         * The start velocity
         */
        startVelocity?: number;
    }

    /**
     * This easing is typically used for {@link Ext.scroll.Scroller}. It's a combination of
     * {@link Ext.fx.easing.Momentum} and {@link Ext.fx.easing.Bounce}, which emulates deceleration when the animated element
     * is still within its boundary, then bouncing back (snapping) when it's out-of-bound.
     */
    export class BoundMomentum extends Ext.fx.easing.Abstract implements Ext.fx.easing.BoundMomentumConfig {
        /**
         * A valid config object for {@link Ext.fx.easing.Bounce}
         */
        bounce: any;

        /**
         * The minimum velocity to end this easing
         */
        minVelocity: number;

        /**
         * A valid config object for {@link Ext.fx.easing.Momentum}
         */
        momentum: any;

        /**
         * The start velocity
         */
        startVelocity: number;

        constructor(config: Ext.fx.easing.BoundMomentumConfig);

        getBounce();

        getMaxMomentumValue();

        getMinMomentumValue();

        getMinVelocity();

        getMomentum();

        getStartVelocity();

        setBounce();

        setMaxMomentumValue();

        setMinMomentumValue();

        setMinVelocity();

        setMomentum();

        setStartVelocity();
    }

    export class EaseIn extends Ext.fx.easing.Linear {
        constructor(config: Ext.fx.easing.BoundMomentumConfig);

        getDuration();

        getExponent();

        setDuration();

        setExponent();
    }

    export class EaseOut extends Ext.fx.easing.Linear {
        constructor(config: Ext.fx.easing.BoundMomentumConfig);

        getDuration();

        getExponent();

        setDuration();

        setExponent();
    }

    export class Easing extends Ext.Base {
        constructor(easing: any);
    }

    export class Linear extends Ext.fx.easing.Abstract {
        constructor(config: Ext.fx.easing.BoundMomentumConfig);

        getDuration();

        getEndValue();

        setDuration();

        setEndValue();
    }

    export class Momentum extends Ext.fx.easing.Abstract {
        constructor(config: Ext.fx.easing.BoundMomentumConfig);

        getAcceleration();

        getFriction();

        getStartVelocity();

        setAcceleration();

        setFriction();

        setStartVelocity();
    }
}

declare module Ext.fx.layout {
    export class Card extends Ext.Base {
        constructor(config: any);
    }
}

declare module Ext.fx.layout.card {
    export class Abstract extends Ext.Evented {
        constructor(config: Ext.util.GeolocationConfig);

        destroy();

        getDirection();

        getDuration();

        getLayout();

        getReverse();

        setDirection();

        setDuration();

        setLayout();

        setReverse();
    }

    export class Cover extends Ext.fx.layout.card.Style {
        constructor(config: any);

        getInAnimation();

        getOutAnimation();

        getReverse();

        setInAnimation();

        setOutAnimation();

        setReverse();
    }

    export class Cube extends Ext.fx.layout.card.Style {
        constructor(config: any);

        getInAnimation();

        getOutAnimation();

        getReverse();

        setInAnimation();

        setOutAnimation();

        setReverse();
    }

    export class Fade extends Ext.fx.layout.card.Style {
        constructor(config: any);

        getInAnimation();

        getOutAnimation();

        getReverse();

        setInAnimation();

        setOutAnimation();

        setReverse();
    }

    export class Flip extends Ext.fx.layout.card.Style {
        constructor(config: any);

        getDuration();

        getInAnimation();

        getOutAnimation();

        setDuration();

        setInAnimation();

        setOutAnimation();
    }

    export class Pop extends Ext.fx.layout.card.Style {
        constructor(config: any);

        getDuration();

        getInAnimation();

        getOutAnimation();

        setDuration();

        setInAnimation();

        setOutAnimation();
    }

    export class Reveal extends Ext.fx.layout.card.Style {
        constructor(config: any);

        getInAnimation();

        getOutAnimation();

        setInAnimation();

        setOutAnimation();
    }

    export class Scroll extends Ext.fx.layout.card.Abstract {
        constructor(config: any);

        getDuration();

        setDuration();
    }

    export class ScrollCover extends Ext.fx.layout.card.Scroll {
        constructor(config: any);
    }

    export class ScrollReveal extends Ext.fx.layout.card.Scroll {
        constructor(config: any);
    }

    export class Slide extends Ext.fx.layout.card.Style {
        constructor(config: any);

        getInAnimation();

        getOutAnimation();

        setInAnimation();

        setOutAnimation();
    }

    export class Style extends Ext.fx.layout.card.Abstract {
        constructor(config: any);

        destroy();

        getInAnimation();

        getOutAnimation();

        setInAnimation();

        setOutAnimation();
    }
}

declare module Ext.fx.runner {
    export class Css extends Ext.Evented {
        constructor();
    }

    export class CssAnimation extends Ext.fx.runner.Css {
        constructor();
    }

    export class CssTransition {
    }
}

declare module Ext.grid {
    interface GridConfig extends Ext.dataview.ListConfig {
        baseCls?: any;

        /**
         * (required)
         * An array of column definition objects which define all columns that appear in this grid.
         * Each column definition provides the header text for the column, and a definition of where
         * the data for that column comes from.
         *
         * This can also be a configuration object for a {Ext.grid.header.Container HeaderContainer}
         * which may override certain default configurations if necessary. For example, the special
         * layout may be overridden to use a simpler layout, or one can set default values shared
         * by all columns:
         *
         *      columns: {
         *          items: [
         *              {
         *                  text: "Column A"
         *                  dataIndex: "field_A",
         *                  width: 200
         *              },{
         *                  text: "Column B",
         *                  dataIndex: "field_B",
         *                  width: 150
         *              },
         *              ...
         *          ]
         *      }
         */
        columns?: Ext.grid.column.Column;

        /**
         * 'true' to hide the grid column headers.
         *
         * @since 6.0.1
         */
        hideHeaders?: boolean;

        itemCls?: any;

        scrollToTopOnRefresh?: any;

        /**
         * @inherit
         */
        striped?: boolean;

        /**
         * The title that will be displayed in the TitleBar at the top of this Grid.
         */
        title?: string;
    }

    /**
     * Grids are an excellent way of showing large amounts of tabular data on the client side.
     * Essentially a supercharged '<table>', Grid makes it easy to fetch, sort and filter large
     * amounts of data.
     *
     * Grids are composed of two main pieces - a {@link Ext.data.Store Store} full of data and
     * a set of columns to render.
     *
     * ## A Basic Grid
     *
     *     var store = Ext.create('Ext.data.Store', {
     *         fields: ['name', 'email', 'phone'],
     *         data: [
     *             { 'name': 'Lisa',  "email":"lisa@simpsons.com",  "phone":"555-111-1224"  },
     *             { 'name': 'Bart',  "email":"bart@simpsons.com",  "phone":"555-222-1234" },
     *             { 'name': 'Homer', "email":"home@simpsons.com",  "phone":"555-222-1244"  },
     *             { 'name': 'Marge', "email":"marge@simpsons.com", "phone":"555-222-1254"  }
     *         ]
     *     });
     *
     *     Ext.create('Ext.grid.Grid', {
     *         title: 'Simpsons',
     *
     *         store: store,
     *
     *         columns: [
     *             { text: 'Name',  dataIndex: 'name', width: 200 },
     *             { text: 'Email', dataIndex: 'email', width: 250 },
     *             { text: 'Phone', dataIndex: 'phone', width: 120 }
     *         ],
     *
     *         height: 200,
     *         layout: 'fit',
     *         fullscreen: true
     *     });
     *
     * The code above produces a simple grid with three columns. We specified a Store which will
     * load JSON data inline. In most apps we would be placing the grid inside another container
     * and wouldn't need to provide the {@link #height}, {@link #width} and
     * {@link #cfg-fullscreen} options but they are included here to for demonstration.
     *
     * The grid we created above will contain a header bar with a title ('Simpsons'), a row of
     * column headers directly underneath and finally the grid rows under the headers.
     *
     * ## Columns
     *
     * By default, each {@link Ext.grid.column.Column column} is sortable and toggles between
     * ascending and descending sorting when you click on its header. There are several basic
     * configs that can be applied to columns to change these behaviors. For example:
     *
     *     columns: [
     *         {
     *             text: 'Name',
     *             dataIndex: 'name',
     *             sortable: false,  // column cannot be sorted
     *             width: 250
     *         },
     *         {
     *             text: 'Email',
     *             dataIndex: 'email',
     *             hidden: true  // column is initially hidden
     *         },
     *         {
     *             text: 'Phone',
     *             dataIndex: 'phone',
     *             width: 100
     *         }
     *     ]
     *
     * We turned off sorting on the 'Name' column so clicking its header now has no effect. We
     * also made the Email column hidden by default (it can be shown again by using the
     * {@link Ext.grid.plugin.ViewOptions ViewOptions} plugin). See the
     * {@link Ext.grid.column.Column column class} for more details.
     *
     * A top-level column definition may contain a 'columns' configuration. This means that the
     * resulting header will be a group header, and will contain the child columns.
     *
     * ## Rows and Cells
     *
     * Grid extends the '{@link Ext.dataview.List List}' component and connects records in the
     * store to '{@link Ext.grid.Row row components}' for the list's items. The Row component
     * utilizes the configs of the grid's {@link Ext.grid.column.Column columns} to create the
     * appropriate type of {@link Ext.grid.cell.Base cells}. Essentially, a Row is a container
     * for {@link Ext.Widget Cell widgets}.
     *
     * For the most part, configuring a grid is about configuring the columns and their cells.
     * There are several built-in column types to display specific types of data:
     *
     *  - {@link Ext.grid.column.Boolean} for true/false values.
     *  - {@link Ext.grid.column.Date} for date/time values.
     *  - {@link Ext.grid.column.Number} for numeric values.
     *
     * These columns specify (via their {@link Ext.grid.column.Column#cell cell config}) one
     * of these basic cell widget types:
     *
     *  - {@link Ext.grid.cell.Boolean}
     *  - {@link Ext.grid.cell.Date}
     *  - {@link Ext.grid.cell.Number}
     *
     * In addition to the above basic cell types, there are two other useful cell types to
     * know about:
     *
     *  - {@link Ext.grid.cell.Text} is the base class for the boolean, date and number cell
     *    classes. It is useful when a cell contains only text.
     *  - {@link Ext.grid.cell.Widget} is a cell class that manages a single child item (either
     *    a {@link Ext.Component component} or a {@link Ext.Widget widget}). The child item is
     *    configured using the '{@link Ext.grid.cell.Widget#widget widget config}'. The most
     *    important part of this config is the 'xtype' of the child item to create.
     *
     * ## Cells and Binding
     *
     * One technique to controll cell content and styling is to use data binding to target
     * cell configs like {@link Ext.grid.cell.Base#cls} and {@link Ext.grid.cell.Base#innerCls}.
     * This is done by assigning a {@link Ext.app.ViewModel viewModel} to each Row like so:
     *
     *      itemConfig: {
     *          viewModel: true  // create default ViewModel for each item (i.e., Row)
     *      }
     *
     * Now that each Row has a ViewModel, cells can bind to the fields of the associated record
     * like so:
     *
     *      columns: [{
     *          ...
     *          cell: {
     *              bind: {
     *                  cls: '{record.someCls}'
     *              }
     *          }
     *      }]
     *
     * The "record" property in the ViewModel is managed by the Row. As Row instances are
     * recycled due to buffered rendering, the associated record instance simply changes over
     * time.
     *
     * ### Cell Widgets
     *
     * When using {@link Ext.grid.cell.Widget}, the contained widgets can also use binding to
     * configure themsleves using properties of the associated record.
     *
     *      columns: [{
     *          ...
     *          cell: {
     *              xtype: 'widgetcell',
     *              widget: {
     *                  xtype: 'button',
     *                  bind: {
     *                      text: 'Update {record.firstName}'
     *                  }
     *              }
     *          }
     *      }]
     *
     * ### Row ViewModels
     *
     * In some cases a custom ViewModel could be useful, for example to provide useful values
     * via {@link Ext.app.ViewModel#formulas formulas}.
     *
     *      itemConfig: {
     *          viewModel: {
     *              type: 'rowViewModel'
     *          }
     *      }
     *
     * ## Renderers and Templates
     *
     * Columns provide two other mechanisms to format their cell content:
     *
     *  - {@link Ext.grid.column.Column#renderer}
     *  - {@link Ext.grid.column.Column#tpl}
     *
     * These column configs are processed by the {@link Ext.grid.column.Cell default cell type}
     * for a column. These configs have some downsides compared to data binding but are provided
     * for compatibility with previous releases.
     *
     *  - Renderers and templates must update the cell content when _any_ field changes. They
     *    cannot assume that only changes to the dataIndex will affect the rendering. Using
     *    data binding, only the configs affected by the changed data will be updated.
     *  - Updates are processed synchronously in response to the record update notification.
     *    Contrast to ViewModels which provide a buffered update mechanism.
     *  - Constructing HTML blocks in code (even in a template) is a common cause of security
     *    problems such as XSS attacks.
     *
     * ## Sorting & Filtering
     *
     * Every grid is attached to a {@link Ext.data.Store Store}, which provides multi-sort and
     * filtering capabilities. It's easy to set up a grid to be sorted from the start:
     *
     *     var myGrid = Ext.create('Ext.grid.Panel', {
     *         store: {
     *             fields: ['name', 'email', 'phone'],
     *             sorters: ['name', 'phone']
     *         },
     *         columns: [
     *             { text: 'Name',  dataIndex: 'name' },
     *             { text: 'Email', dataIndex: 'email' }
     *         ]
     *     });
     *
     * Sorting at run time is easily accomplished by simply clicking each column header. If you
     * need to perform sorting on more than one field at run time it's easy to do so by adding
     * new sorters to the store:
     *
     *     myGrid.store.sort([
     *         { property: 'name',  direction: 'ASC' },
     *         { property: 'email', direction: 'DESC' }
     *     ]);
     *
     * See {@link Ext.data.Store} for examples of filtering.
     *
     * ## Plugins
     *
     * Grid supports addition of extra functionality through plugins:
     *
     * - {@link Ext.grid.plugin.ViewOptions ViewOptions} - adds the ability to show/hide
     *  columns and reorder them.
     *
     * - {@link Ext.grid.plugin.ColumnResizing ColumnResizing} - allows for the ability to
     *  resize columns.
     *
     * - {@link Ext.grid.plugin.Editable Editable} - editing grid contents one row at a time.
     *
     * - {@link Ext.grid.plugin.MultiSelection MultiSelection} - selecting and deleting several
     *   rows at a time.
     *
     * - {@link Ext.grid.plugin.PagingToolbar PagingToolbar} - adds a toolbar at the bottom of
     *   the grid that allows you to quickly navigate to another page of data.
     *
     * - {@link Ext.grid.plugin.SummaryRow SummaryRow} - adds and pins an additional row to the
     *   top of the grid that enables you to display summary data.
     */
    export class Grid extends Ext.dataview.List implements Ext.grid.GridConfig {
        /**
         * The base CSS class to apply to this component's element. This will also be prepended to
         * other elements within this component. To add specific styling for sub-classes, use the {@link #cls} config.
         */
        baseCls: string;

        /**
         * (required)
         * An array of column definition objects which define all columns that appear in this grid.
         * Each column definition provides the header text for the column, and a definition of where
         * the data for that column comes from.
         *
         * This can also be a configuration object for a {Ext.grid.header.Container HeaderContainer}
         * which may override certain default configurations if necessary. For example, the special
         * layout may be overridden to use a simpler layout, or one can set default values shared
         * by all columns:
         *
         *      columns: {
         *          items: [
         *              {
         *                  text: "Column A"
         *                  dataIndex: "field_A",
         *                  width: 200
         *              },{
         *                  text: "Column B",
         *                  dataIndex: "field_B",
         *                  width: 150
         *              },
         *              ...
         *          ]
         *      }
         */
        columns: Ext.grid.column.Column;

        /**
         * 'true' to hide the grid column headers.
         *
         * @since 6.0.1
         */
        hideHeaders: boolean;

        itemCls: string;

        scrollToTopOnRefresh: boolean;

        /**
         * @inherit
         */
        striped: boolean;

        /**
         * The title that will be displayed in the TitleBar at the top of this Grid.
         */
        title: string;

        constructor();

        destroy();

        getBaseCls();

        getDefaultType();

        getHeaderContainer();

        getHideHeaders();

        getItemCls();

        getScrollToTopOnRefresh();

        getStriped();

        getTitle();

        getTitleBar();

        protected initialize();

        setBaseCls();

        setColumns();

        setDefaultType();

        setHeaderContainer();

        setHideHeaders();

        setItemCls();

        setScrollToTopOnRefresh();

        setStriped();

        setTitle();

        setTitleBar();

        /**
         * Fires whenever a column is added to the Grid.
         * @param {Ext.grid.Grid} this The Grid instance.
         * @param {Ext.grid.column.Column} column The added column.
         * @param {Number} index The index of the added column.
         */
        columnadd(that: Ext.grid.Grid, column: Ext.grid.column.Column, index: number);

        /**
         * Fires whenever a column is hidden in the Grid.
         * @param {Ext.grid.Grid} this The Grid instance.
         * @param {Ext.grid.column.Column} column The shown column.
         */
        columnhide(that: Ext.grid.Grid, column: Ext.grid.column.Column);

        /**
         * Fires whenever a column is moved in the grid.
         * @param {Ext.grid.Grid} this The Grid instance.
         * @param {Ext.grid.column.Column} column The moved column.
         * @param {Number} fromIndex The index the column was moved from.
         * @param {Number} toIndex The index the column was moved to.
         */
        columnmove(that: Ext.grid.Grid, column: Ext.grid.column.Column, fromIndex: number, toIndex: number);

        /**
         * Fires whenever a column is removed from the Grid.
         * @param {Ext.grid.Grid} this The Grid instance.
         * @param {Ext.grid.column.Column} column The removed column.
         */
        columnremove(that: Ext.grid.Grid, column: Ext.grid.column.Column);

        /**
         * Fires whenever a column is resized in the Grid.
         * @param {Ext.grid.Grid} this The Grid instance.
         * @param {Ext.grid.column.Column} column The resized column.
         * @param {Number} width The new column width.
         */
        columnresize(that: Ext.grid.Grid, column: Ext.grid.column.Column, width: number);

        /**
         * Fires whenever a column is shown in the Grid.
         * @param {Ext.grid.Grid} this The Grid instance.
         * @param {Ext.grid.column.Column} column The shown column.
         */
        columnshow(that: Ext.grid.Grid, column: Ext.grid.column.Column);

        /**
         * Fires whenever a column is sorted in the Grid.
         * @param {Ext.grid.Grid} this The Grid instance.
         * @param {Ext.grid.column.Column} column The sorted column.
         * @param {String} direction The direction of the sort on this Column. Either 'asc' or 'desc'.
         */
        columnsort(that: Ext.grid.Grid, column: Ext.grid.column.Column, direction: string);
    }

    interface HeaderContainerConfig extends Ext.ContainerConfig {
        baseCls?: any;

        defaultType?: any;

        docked?: any;

        layout?: any;

        scrollable?: any;
    }

    /**
     * @extends Ext.Container
     * Description
     */
    export class HeaderContainer extends Ext.Container implements Ext.grid.HeaderContainerConfig {
        baseCls: string;

        defaultType: any;

        docked: string;

        layout: any|string;

        scrollable: boolean|string|any;

        constructor(config: Ext.ActionSheetConfig);

        destroy();

        getBaseCls();

        getDefaultType();

        getDocked();

        getGrid();

        getLayout();

        getScrollable();

        protected initialize();

        setBaseCls();

        setDefaultType();

        setDocked();

        setGrid();

        setLayout();

        setScrollable();
    }

    interface HeaderGroupConfig extends Ext.ContainerConfig {
        baseCls?: any;

        /**
         * The columns in this group.
         */
        columns?: any;

        defaultType?: any;

        items?: any;

        layout?: any;

        /**
         * The header text to be used as innerHTML (html tags are accepted) to display in the Grid.
         */
        text?: string;
    }

    export class HeaderGroup extends Ext.Container implements Ext.grid.HeaderGroupConfig {
        baseCls: string;

        /**
         * The columns in this group.
         */
        columns: any;

        defaultType: any;

        items: any[]|any;

        layout: any|string;

        /**
         * The header text to be used as innerHTML (html tags are accepted) to display in the Grid.
         */
        text: string;

        constructor(config: Ext.ActionSheetConfig);

        destroy();

        getBaseCls();

        getColumns();

        getDefaultType();

        getItems();

        getLayout();

        getText();

        protected initialize();

        setBaseCls();

        setColumns();

        setDefaultType();

        setItems();

        setLayout();

        setText();
    }

    interface RowConfig extends Ext.ComponentConfig {
        baseCls?: any;
    }

    /**
     * This class is created by a {@link Ext.grid.Grid grid} to manage each record. Rows act
     * as containers for {@link Ext.grid.cell.Base cells}.
     *
     * Row does not extend {@link Ext.Container} to keep overhead to a minimum. Application
     * code should not need to create instances of this class directly. Rows are created by
     * the {@link Ext.dataview.List} base as configured by {@link Ext.grid.Grid}.
     */
    export class Row extends Ext.Component implements Ext.grid.RowConfig {
        baseCls: string;

        constructor(config: Ext.grid.RowConfig);

        destroy();

        getBaseCls();

        getGrid();

        getHeader();

        setBaseCls();

        setGrid();

        setHeader();
    }
}

declare module Ext.grid.cell {
    interface BaseConfig extends Ext.WidgetConfig {
        /**
         * The value for the 'text-align' of the cell content.
         */
        align?: any;

        /**
         * An arbitrary CSS class to add to the cell's outermost element.
         */
        cls?: string;

        /**
         * The grid column that created this cell.
         * @readonly
         */
        column?: Ext.grid.column.Column;

        /**
         * An arbitrary CSS class to add to the cell's inner element (the element that
         * typically contains the cell's text).
         */
        innerCls?: string;

        /**
         * The currently associated record.
         * @readonly
         */
        record?: Ext.data.Model;

        /**
         * The value of the {@link Ext.grid.column.Column#dataIndex dataIndex} field of
         * the associated record. Application code should not need to set this value.
         */
        value?: any;
    }

    /**
     * This is the base class for {@link Ext.grid.Grid grid} cells.
     *
     * {@link Ext.grid.Row Rows} create cells based on the {@link Ext.grid.column.Column#cell}
     * config. Application code would rarely create cells directly.
     */
    export class Base extends Ext.Widget implements Ext.grid.cell.BaseConfig {
        protected defaultBindProperty: any;

        protected element: any;

        /**
         * The value for the 'text-align' of the cell content.
         */
        align: any;

        /**
         * An arbitrary CSS class to add to the cell's outermost element.
         */
        cls: string;

        /**
         * The grid column that created this cell.
         * @readonly
         */
        column: Ext.grid.column.Column;

        /**
         * An arbitrary CSS class to add to the cell's inner element (the element that
         * typically contains the cell's text).
         */
        innerCls: string;

        /**
         * The currently associated record.
         * @readonly
         */
        record: Ext.data.Model;

        /**
         * The value of the {@link Ext.grid.column.Column#dataIndex dataIndex} field of
         * the associated record. Application code should not need to set this value.
         */
        value: any;

        constructor(config: Ext.ProgressConfig);

        destroy();

        getAlign();

        getCls();

        getColumn();

        getInnerCls();

        getRecord();

        getValue();

        setAlign();

        setCls();

        setColumn();

        setInnerCls();

        setRecord();

        setValue();
    }

    interface BooleanConfig extends Ext.grid.cell.TextConfig {
        /**
         * The string to display when the value is falsey (but not undefined).
         */
        falseText?: string;

        /**
         * The string to display when the value is not falsey.
         */
        trueText?: string;

        /**
         * The string to display when the column value is 'undefined'.
         */
        undefinedText?: string;
    }

    /**
     * This class displays a boolean value in a {@link Ext.grid.Grid grid} cell. This cell type
     * is typically used by specifying {@link Ext.grid.column.Boolean} column type.
     *
     * {@link Ext.grid.Row Rows} create cells based on the {@link Ext.grid.column.Column#cell}
     * config. Application code would rarely create cells directly.
     */
    export class Boolean extends Ext.grid.cell.Text implements Ext.grid.cell.BooleanConfig {
        /**
         * The string to display when the value is falsey (but not undefined).
         */
        falseText: string;

        /**
         * The string to display when the value is not falsey.
         */
        trueText: string;

        /**
         * The string to display when the column value is 'undefined'.
         */
        undefinedText: string;

        constructor(config: Ext.ProgressConfig);

        getFalseText();

        getTrueText();

        getUndefinedText();

        setFalseText();

        setTrueText();

        setUndefinedText();
    }

    /**
     * This is the default cell class for {@link Ext.grid.Grid grid} cells. Use this class if
     * you use the {@link Ext.grid.column.Column#renderer} or {@link Ext.grid.column.Column#tpl}
     * configs for a column.
     *
     * {@link Ext.grid.Row Rows} create cells based on the {@link Ext.grid.column.Column#cell}
     * config. Application code would rarely create cells directly.
     */
    export class Cell extends Ext.grid.cell.Text {
        constructor(config: Ext.ProgressConfig);
    }

    interface DateConfig extends Ext.grid.cell.TextConfig {
        /**
         * A format string as used by {@link Ext.Date#format} to format values for this
         * column.
         */
        format?: string;
    }

    /**
     * This class displays a date value in a {@link Ext.grid.Grid grid} cell. This cell type
     * is typically used by specifying {@link Ext.grid.column.Date} column type.
     *
     * {@link Ext.grid.Row Rows} create cells based on the {@link Ext.grid.column.Column#cell}
     * config. Application code would rarely create cells directly.
     */
    export class Date extends Ext.grid.cell.Text implements Ext.grid.cell.DateConfig {
        /**
         * A format string as used by {@link Ext.Date#format} to format values for this
         * column.
         */
        format: string;

        constructor(config: Ext.ProgressConfig);

        getFormat();

        setFormat();
    }

    interface NumberConfig extends Ext.grid.cell.TextConfig {
        /**
         * A format string as used by {@link Ext.util.Format#number} to format values for
         * this column.
         */
        format?: string;
    }

    /**
     * This class displays a numeric value in a {@link Ext.grid.Grid grid} cell. This cell type
     * is typically used by specifying {@link Ext.grid.column.Number} column type.
     *
     * {@link Ext.grid.Row Rows} create cells based on the {@link Ext.grid.column.Column#cell}
     * config. Application code would rarely create cells directly.
     */
    export class Number extends Ext.grid.cell.Text implements Ext.grid.cell.NumberConfig {
        /**
         * A format string as used by {@link Ext.util.Format#number} to format values for
         * this column.
         */
        format: string;

        constructor(config: Ext.ProgressConfig);

        getFormat();

        setFormat();
    }

    interface TextConfig extends Ext.grid.cell.BaseConfig {
        /**
         * Specify 'false' to write HTML directly to the cell. Be aware that doing this
         * can expose your application to security issues if that content is not known to
         * be safe. User input can contain malicious content such as 'script' tags and
         * should be scrubbed before directly rendering that HTML.
         */
        encodeHtml?: boolean;
    }

    /**
     * This is the base class for {@link Ext.grid.Grid grid} cells that contain only text.
     *
     * {@link Ext.grid.Row Rows} create cells based on the {@link Ext.grid.column.Column#cell}
     * config. Application code would rarely create cells directly.
     */
    export class Text extends Ext.grid.cell.Base implements Ext.grid.cell.TextConfig {
        /**
         * Specify 'false' to write HTML directly to the cell. Be aware that doing this
         * can expose your application to security issues if that content is not known to
         * be safe. User input can contain malicious content such as 'script' tags and
         * should be scrubbed before directly rendering that HTML.
         */
        encodeHtml: boolean;

        /**
         * The text value of the cell. This value will be written to the cell differently
         * based on the {@link #encodeHtml} config. This config is automatically set as a
         * result of setting the {@link #value} config and is rarely set directly. This is
         * a separate config to avoid writting the same formatted result to the DOM.
         */
        protected rawValue: string;

        constructor(config: Ext.ProgressConfig);

        getEncodeHtml();

        protected getRawValue();

        setEncodeHtml();

        protected setRawValue();
    }

    interface WidgetConfig extends Ext.grid.cell.BaseConfig {
        /**
         * (required)
         * The config object for a {@link Ext.Component} or {@link Ext.Widget}.
         *
         * (required) The type of component or widget to create.
         */
        widget?: any;
    }

    /**
     * This class is used for {@link Ext.grid.Grid grid} cells that contain a child
     * {@link Ext.Component} or {@link Ext.Widget}. This cell type is typically used by
     * specifying {@link Ext.grid.column.Widget} column type.
     *
     * {@link Ext.grid.Row Rows} create cells based on the {@link Ext.grid.column.Column#cell}
     * config. Application code would rarely create cells directly.
     */
    export class Widget extends Ext.grid.cell.Base implements Ext.grid.cell.WidgetConfig {
        /**
         * (required)
         * The config object for a {@link Ext.Component} or {@link Ext.Widget}.
         *
         * (required) The type of component or widget to create.
         */
        widget: any;

        constructor(config: Ext.ProgressConfig);

        destroy();

        getWidget();

        setWidget();
    }
}

declare module Ext.grid.column {
    interface BooleanConfig extends Ext.grid.column.ColumnConfig {
        cell?: any;

        defaultEditor?: any;

        /**
         * The string returned by the renderer when the column value is falsey (but not undefined).
         */
        falseText?: string;

        /**
         * The string returned by the renderer when the column value is not falsey.
         */
        trueText?: string;

        /**
         * The string returned by the renderer when the column value is undefined.
         */
        undefinedText?: string;
    }

    /**
     * A Column definition class which renders boolean data fields.  See the {@link Ext.grid.column.Column#xtype xtype}
     * config option of {@link Ext.grid.column.Column} for more details.
     *
     *     @example
     *     Ext.create('Ext.data.Store', {
     *        storeId:'sampleStore',
     *        fields:[
     *            {name: 'framework', type: 'string'},
     *            {name: 'rocks', type: 'boolean'}
     *        ],
     *        data:{ items:[
     *            { framework: "Ext JS",     rocks: true  },
     *            { framework: "Ext GWT",    rocks: true  },
     *            { framework: "Other Guys", rocks: false }
     *        ]}
     *     });
     *
     *     Ext.create('Ext.grid.Grid', {
     *         store: Ext.data.StoreManager.lookup('sampleStore'),
     *         columns: [
     *             { text: 'Framework',  dataIndex: 'framework', flex: 1 },
     *             {
     *                 xtype: 'booleancolumn',
     *                 text: 'Rocks',
     *                 trueText: 'Yes',
     *                 falseText: 'No',
     *                 dataIndex: 'rocks'
     *             }
     *         ],
     *         height: 200,
     *         width: 400
     *     });
     */
    export class Boolean extends Ext.grid.column.Column implements Ext.grid.column.BooleanConfig {
        cell: any;

        defaultEditor: any;

        /**
         * The string returned by the renderer when the column value is falsey (but not undefined).
         */
        falseText: string;

        /**
         * The string returned by the renderer when the column value is not falsey.
         */
        trueText: string;

        /**
         * The string returned by the renderer when the column value is undefined.
         */
        undefinedText: string;

        /**
         * Creates new Component.
         * @param {Object} config The standard configuration object.
         */
        constructor(config: Ext.ButtonConfig);

        getCell();

        getFalseText();

        getTrueText();

        getUndefinedText();

        setCell();

        setFalseText();

        setTrueText();

        setUndefinedText();
    }

    interface ColumnConfig extends Ext.ComponentConfig {
        /**
         * Sets the alignment of the header and rendered columns.
         * Possible values are: ''left'', ''center'', and ''right''.
         */
        align?: string;

        baseCls?: any;

        /**
         * The config object used to create {@link Ext.grid.cell.Base cells} for this column.
         * By default, cells use the {@link Ext.grid.cell.Cell gridcell} 'xtype'. To create
         * a different type of cell, simply provide this config and the desired 'xtype'.
         */
        cell?: any;

        /**
         * The computed width for this column, may come from either
         * {@link #width} or {@link #flex}.
         * @readonly
         */
        computedWidth?: number;

        /**
         * The name of the field in the grid's {@link Ext.data.Store}'s {@link Ext.data.Model} definition from
         * which to draw the column's value. **Required.**
         */
        dataIndex?: string;

        /**
         * An optional config object that should not really be modified. This is used to create
         * a default editor used by the {@link Ext.grid.plugin.Editable Editable} plugin when no
         * {@link #editor} is specified.
         */
        defaultEditor?: any;

        /**
         * Set this to true to make this column editable.
         * Only applicable if the grid is using an {@link Ext.grid.plugin.Editable Editable} plugin.
         */
        editable?: boolean;

        /**
         * An optional xtype or config object for a {@link Ext.field.Field Field} to use for editing.
         * Only applicable if the grid is using an {@link Ext.grid.plugin.Editable Editable} plugin.
         * Note also that {@link #editable} has to be set to true if you want to make this column editable.
         * If this configuration is not set, and {@link #editable} is set to true, the {@link #defaultEditor} is used.
         */
        editor?: any|string;

        /**
         * If the grid is {@link Ext.grid.Grid#grouped grouped}, and uses a
         * {@link Ext.grid.plugin.ViewOptions ViewOptions} plugin this option may be used to
         * disable the option to group by this column. By default, the group option is enabled.
         */
        groupable?: boolean;

        /**
         * This configuration should be left alone in most cases. This is used to prevent certain columns
         * (like the MultiSelection plugin column) to show up in plugins (like the {@link Ext.grid.plugin.ViewOptions} plugin).
         */
        ignore?: boolean;

        minWidth?: any;

        /**
         * A renderer is a method which can be used to transform data (value, appearance, etc.)
         * before it is rendered.
         *
         * For example:
         *
         *      {
         *          text: 'Some column',
         *          dataIndex: 'fieldName',
         *
         *          renderer: function (value, record) {
         *              if (value === 1) {
         *                  return '1 person';
         *              }
         *              return value + ' people';
         *          }
         *      }
         *
         * If a string is supplied, it should be the name of a renderer method from the
         * appropriate {@link Ext.app.ViewController}.
         *
         * This config is only processed if the {@link #cell} type is the default of
         * {@link Ext.grid.cell.Cell gridcell}.
         *
         * **Note** See {@link Ext.grid.Grid} documentation for other, better alternatives
         * to rendering cell content.
         *
         * The data value for the current cell.
         * The record for the current row.
         * The dataIndex of the current column.
         * The current cell.
         * The current column.
         * The HTML string to be rendered.
         */
        renderer?: Function|string;

        /**
         * False to prevent the column from being resizable.
         * Note that this configuration only works when the {@link Ext.grid.plugin.ColumnResizing ColumnResizing} plugin
         * is enabled on the {@link Ext.grid.Grid Grid}.
         */
        resizable?: boolean;

        /**
         * The scope to use when calling the {@link #renderer} function.
         */
        scope?: any;

        /**
         * False to disable sorting of this column. Whether local/remote sorting is used is specified in
         * '{@link Ext.data.Store#remoteSort}'.
         */
        sortable?: boolean;

        /**
         * This summaryRenderer is called before displaying a value in the SummaryRow. The
         * function is optional, if not specified the default calculated value is shown. The
         * summaryRenderer is called with:
         *
         *  - value {Object} - The calculated value.
         *
         * Note that this configuration only works when the grid has the
         * {@link Ext.grid.plugin.SummaryRow SummaryRow} plugin enabled.
         */
        summaryRenderer?: string|Function;

        /**
         * This configuration specifies the type of summary. There are several built in
         * summary types. These call underlying methods on the store:
         *
         *  - {@link Ext.data.Store#count count}
         *  - {@link Ext.data.Store#sum sum}
         *  - {@link Ext.data.Store#min min}
         *  - {@link Ext.data.Store#max max}
         *  - {@link Ext.data.Store#average average}
         *
         * Any other name is assumed to be the name of a method on the associated
         * {@link Ext.app.ViewController view controller}.
         *
         * Note that this configuration only works when the grid has the
         * {@link Ext.grid.plugin.SummaryRow SummaryRow} plugin enabled.
         */
        summaryType?: string|Function;

        /**
         * The header text to be used as innerHTML (html tags are accepted) to display in the Grid.
         * **Note**: to have a clickable header with no text displayed you can use the default of '&#160;' aka '&nbsp;'.
         */
        text?: string;
    }

    /**
     * This class specifies the definition for a column inside a {@link Ext.grid.Grid}. It
     * encompasses both the grid header configuration as well as displaying data within the
     * grid itself.
     *
     * In general an array of column configurations will be passed to the grid:
     *
     *     @example
     *     Ext.create('Ext.data.Store', {
     *         storeId: 'employeeStore',
     *         fields: ['firstname', 'lastname', 'seniority', 'dep', 'hired'],
     *         data: [
     *             {firstname:"Michael", lastname:"Scott", seniority:7, dep:"Management", hired:"01/10/2004"},
     *             {firstname:"Dwight", lastname:"Schrute", seniority:2, dep:"Sales", hired:"04/01/2004"},
     *             {firstname:"Jim", lastname:"Halpert", seniority:3, dep:"Sales", hired:"02/22/2006"},
     *             {firstname:"Kevin", lastname:"Malone", seniority:4, dep:"Accounting", hired:"06/10/2007"},
     *             {firstname:"Angela", lastname:"Martin", seniority:5, dep:"Accounting", hired:"10/21/2008"}
     *         ]
     *     });
     *
     *     var grid = Ext.create('Ext.grid.Grid', {
     *         title: 'Column Demo',
     *         store: Ext.data.StoreManager.lookup('employeeStore'),
     *         columns: [
     *             {text: 'First Name',  dataIndex:'firstname'},
     *             {text: 'Last Name',  dataIndex:'lastname'},
     *             {text: 'Hired Month',  dataIndex:'hired', xtype:'datecolumn', format:'M'},
     *             {text: 'Department (Yrs)', xtype:'templatecolumn', tpl:'{dep} ({seniority})'}
     *         ],
     *         width: 400
     *     });
     *     Ext.ViewPort.add(grid);
     *
     * # Convenience Subclasses
     *
     * There are several column subclasses that provide default rendering for various data types
     *
     *  - {@link Ext.grid.column.Boolean}: Renders for boolean values
     *  - {@link Ext.grid.column.Date}: Renders for date values
     *  - {@link Ext.grid.column.Number}: Renders for numeric values
     *
     * For more information about configuring cell content, see {@link Ext.grid.Grid}.
     *
     * # Setting Sizes
     *
     * The columns can be only be given an explicit width value. If no width is specified the
     * grid will automatically the size the column to 20px.
     *
     * # Header Options
     *
     *  - {@link #text}: Sets the header text for the column
     *  - {@link #sortable}: Specifies whether the column can be sorted by clicking the header
     *    or using the column menu
     *
     * # Data Options
     *
     *  - {@link #dataIndex}: The dataIndex is the field in the underlying {@link Ext.data.Store}
     *    to use as the value for the column.
     *  - {@link #renderer}: Allows the underlying store value to be transformed before being
     *    displayed in the grid.
     */
    export class Column extends Ext.Component implements Ext.grid.column.ColumnConfig {
        /**
         * Sets the alignment of the header and rendered columns.
         * Possible values are: ''left'', ''center'', and ''right''.
         */
        align: string;

        baseCls: string;

        /**
         * The config object used to create {@link Ext.grid.cell.Base cells} for this column.
         * By default, cells use the {@link Ext.grid.cell.Cell gridcell} 'xtype'. To create
         * a different type of cell, simply provide this config and the desired 'xtype'.
         */
        cell: any;

        /**
         * The computed width for this column, may come from either
         * {@link #width} or {@link #flex}.
         * @readonly
         */
        computedWidth: number;

        /**
         * The name of the field in the grid's {@link Ext.data.Store}'s {@link Ext.data.Model} definition from
         * which to draw the column's value. **Required.**
         */
        dataIndex: string;

        /**
         * An optional config object that should not really be modified. This is used to create
         * a default editor used by the {@link Ext.grid.plugin.Editable Editable} plugin when no
         * {@link #editor} is specified.
         */
        defaultEditor: any;

        /**
         * Set this to true to make this column editable.
         * Only applicable if the grid is using an {@link Ext.grid.plugin.Editable Editable} plugin.
         */
        editable: boolean;

        /**
         * An optional xtype or config object for a {@link Ext.field.Field Field} to use for editing.
         * Only applicable if the grid is using an {@link Ext.grid.plugin.Editable Editable} plugin.
         * Note also that {@link #editable} has to be set to true if you want to make this column editable.
         * If this configuration is not set, and {@link #editable} is set to true, the {@link #defaultEditor} is used.
         */
        editor: any|string;

        /**
         * If the grid is {@link Ext.grid.Grid#grouped grouped}, and uses a
         * {@link Ext.grid.plugin.ViewOptions ViewOptions} plugin this option may be used to
         * disable the option to group by this column. By default, the group option is enabled.
         */
        groupable: boolean;

        /**
         * This configuration should be left alone in most cases. This is used to prevent certain columns
         * (like the MultiSelection plugin column) to show up in plugins (like the {@link Ext.grid.plugin.ViewOptions} plugin).
         */
        ignore: boolean;

        minWidth: number|string;

        /**
         * A renderer is a method which can be used to transform data (value, appearance, etc.)
         * before it is rendered.
         *
         * For example:
         *
         *      {
         *          text: 'Some column',
         *          dataIndex: 'fieldName',
         *
         *          renderer: function (value, record) {
         *              if (value === 1) {
         *                  return '1 person';
         *              }
         *              return value + ' people';
         *          }
         *      }
         *
         * If a string is supplied, it should be the name of a renderer method from the
         * appropriate {@link Ext.app.ViewController}.
         *
         * This config is only processed if the {@link #cell} type is the default of
         * {@link Ext.grid.cell.Cell gridcell}.
         *
         * **Note** See {@link Ext.grid.Grid} documentation for other, better alternatives
         * to rendering cell content.
         *
         * The data value for the current cell.
         * The record for the current row.
         * The dataIndex of the current column.
         * The current cell.
         * The current column.
         * The HTML string to be rendered.
         */
        renderer: Function|string;

        /**
         * False to prevent the column from being resizable.
         * Note that this configuration only works when the {@link Ext.grid.plugin.ColumnResizing ColumnResizing} plugin
         * is enabled on the {@link Ext.grid.Grid Grid}.
         */
        resizable: boolean;

        /**
         * The scope to use when calling the {@link #renderer} function.
         */
        scope: any;

        /**
         * False to disable sorting of this column. Whether local/remote sorting is used is specified in
         * '{@link Ext.data.Store#remoteSort}'.
         */
        sortable: boolean;

        /**
         * This summaryRenderer is called before displaying a value in the SummaryRow. The
         * function is optional, if not specified the default calculated value is shown. The
         * summaryRenderer is called with:
         *
         *  - value {Object} - The calculated value.
         *
         * Note that this configuration only works when the grid has the
         * {@link Ext.grid.plugin.SummaryRow SummaryRow} plugin enabled.
         */
        summaryRenderer: string|Function;

        /**
         * This configuration specifies the type of summary. There are several built in
         * summary types. These call underlying methods on the store:
         *
         *  - {@link Ext.data.Store#count count}
         *  - {@link Ext.data.Store#sum sum}
         *  - {@link Ext.data.Store#min min}
         *  - {@link Ext.data.Store#max max}
         *  - {@link Ext.data.Store#average average}
         *
         * Any other name is assumed to be the name of a method on the associated
         * {@link Ext.app.ViewController view controller}.
         *
         * Note that this configuration only works when the grid has the
         * {@link Ext.grid.plugin.SummaryRow SummaryRow} plugin enabled.
         */
        summaryType: string|Function;

        /**
         * The header text to be used as innerHTML (html tags are accepted) to display in the Grid.
         * **Note**: to have a clickable header with no text displayed you can use the default of '&#160;' aka '&nbsp;'.
         */
        text: string;

        /**
         * Creates new Component.
         * @param {Object} config The standard configuration object.
         */
        constructor(config: Ext.ButtonConfig);

        destroy();

        getAlign();

        getBaseCls();

        getCell();

        getDataIndex();

        /**
         * Returns the value of {@link #defaultEditor}
         *
         * **Note:** This method will only have an implementation if the
         * {@link Ext.grid.plugin.Editable Editing plugin} has been enabled on the grid.
         *
         * @return {Mixed} The defaultEditor value.
         */
        getDefaultEditor(): any;

        getEditable();

        /**
         * Returns the value of {@link #editor}
         *
         * **Note:** This method will only have an implementation if the
         * {@link Ext.grid.plugin.Editable Editing plugin} has been enabled on the grid.
         *
         * @return {Mixed} The editor value.
         */
        getEditor(): any;

        getGroupable();

        getIgnore();

        getMinWidth();

        getRenderer();

        getResizable();

        getScope();

        getSortable();

        getSortDirection();

        getSortedCls();

        getSummaryRenderer();

        getSummaryType();

        getText();

        getTpl();

        protected initialize();

        setAlign();

        setBaseCls();

        setCell();

        setComputedWidth();

        setDataIndex();

        /**
         * Sets the default form field to be used for editing.
         *
         * **Note:** This method will only have an implementation if the
         * {@link Ext.grid.plugin.Editable Editing plugin} has been enabled on the grid.
         *
         * @param {Object} field An object representing a field to be created. You must
         * include the column's dataIndex as the value of the field's name property when
         * setting the default editor field.
         *
         *     column.setDefaultEditor({
         *         xtype: 'textfield',
         *         name: column.getDataIndex()
         *     });
         *
         * @return {Ext.column.Column} this
         */
        setDefaultEditor(field: any): any;

        setEditable();

        /**
         * Sets the form field to be used for editing.
         *
         * **Note:** This method will only have an implementation if the
         * {@link Ext.grid.plugin.Editable Editing plugin} has been enabled on the grid.
         *
         * @param {Object} field An object representing a field to be created. You must
         * include the column's dataIndex as the value of the field's name property when
         * setting the editor field.
         *
         *     column.setEditor({
         *         xtype: 'textfield',
         *         name: column.getDataIndex()
         *     });
         *
         * @return {Ext.column.Column} this
         */
        setEditor(field: any): any;

        setGroupable();

        setIgnore();

        setMinWidth();

        setRenderer();

        setResizable();

        setScope();

        setSortable();

        setSortDirection();

        setSortedCls();

        setSummaryRenderer();

        setSummaryType();

        setText();

        setTpl();
    }

    interface DateConfig extends Ext.grid.column.ColumnConfig {
        cell?: any;

        /**
         * (required)
         * A format string as used by {@link Ext.Date#format} to format values for this
         * column.
         */
        format?: string;
    }

    /**
     * A Column definition class which renders a passed date according to the default locale, or a configured
     * {@link #format}.
     *
     *     @example
     *     var store = Ext.create('Ext.data.Store', {
     *         fields:[
     *             { name: 'symbol', type: 'string' },
     *             { name: 'date',   type: 'date' },
     *             { name: 'change', type: 'number' },
     *             { name: 'volume', type: 'number' },
     *             { name: 'topday', type: 'date' }
     *         ],
     *         data:[
     *             { symbol: "msft",   date: '2011/04/22', change: 2.43, volume: 61606325, topday: '04/01/2010' },
     *             { symbol: "goog",   date: '2011/04/22', change: 0.81, volume: 3053782,  topday: '04/11/2010' },
     *             { symbol: "apple",  date: '2011/04/22', change: 1.35, volume: 24484858, topday: '04/28/2010' },
     *             { symbol: "sencha", date: '2011/04/22', change: 8.85, volume: 5556351,  topday: '04/22/2010' }
     *         ]
     *     });
     *
     *     Ext.create('Ext.grid.Grid', {
     *         title: 'Date Column Demo',
     *         store: store,
     *         columns: [
     *             { text: 'Symbol',   dataIndex: 'symbol', flex: 1 },
     *             { text: 'Date',     dataIndex: 'date',   xtype: 'datecolumn',   format:'Y-m-d' },
     *             { text: 'Change',   dataIndex: 'change', xtype: 'numbercolumn', format:'0.00' },
     *             { text: 'Volume',   dataIndex: 'volume', xtype: 'numbercolumn', format:'0,000' },
     *             { text: 'Top Day',  dataIndex: 'topday', xtype: 'datecolumn',   format:'l' }
     *         ],
     *         height: 200,
     *         width: 450
     *     });
     */
    export class Date extends Ext.grid.column.Column implements Ext.grid.column.DateConfig {
        cell: any;

        /**
         * (required)
         * A format string as used by {@link Ext.Date#format} to format values for this
         * column.
         */
        format: string;

        /**
         * Creates new Component.
         * @param {Object} config The standard configuration object.
         */
        constructor(config: Ext.ButtonConfig);

        getCell();

        getFormat();

        setCell();

        setFormat();
    }

    interface NumberConfig extends Ext.grid.column.ColumnConfig {
        cell?: any;

        defaultEditor?: any;

        /**
         * A format string as used by {@link Ext.util.Format#number} to format values
         * for this column.
         */
        format?: string;
    }

    /**
     * A Column definition class which renders a numeric data field according to a {@link #format} string.
     *
     *     @example
     *     Ext.create('Ext.data.Store', {
     *        storeId:'sampleStore',
     *        fields:[
     *            { name: 'symbol', type: 'string' },
     *            { name: 'price',  type: 'number' },
     *            { name: 'change', type: 'number' },
     *            { name: 'volume', type: 'number' }
     *        ],
     *        data:[
     *            { symbol: "msft",   price: 25.76,  change: 2.43, volume: 61606325 },
     *            { symbol: "goog",   price: 525.73, change: 0.81, volume: 3053782  },
     *            { symbol: "apple",  price: 342.41, change: 1.35, volume: 24484858 },
     *            { symbol: "sencha", price: 142.08, change: 8.85, volume: 5556351  }
     *        ]
     *     });
     *
     *     Ext.create('Ext.grid.Grid', {
     *         title: 'Number Column Demo',
     *         store: Ext.data.StoreManager.lookup('sampleStore'),
     *         columns: [
     *             { text: 'Symbol',         dataIndex: 'symbol', width: 100},
     *             { text: 'Current Price',  dataIndex: 'price',  renderer: Ext.util.Format.usMoney },
     *             { text: 'Change',         dataIndex: 'change', xtype: 'numbercolumn', format:'0.00' },
     *             { text: 'Volume',         dataIndex: 'volume', xtype: 'numbercolumn', format:'0,000' }
     *         ],
     *         height: 200,
     *         width: 400
     *     });
     */
    export class Number extends Ext.grid.column.Column implements Ext.grid.column.NumberConfig {
        cell: any;

        defaultEditor: any;

        /**
         * A format string as used by {@link Ext.util.Format#number} to format values
         * for this column.
         */
        format: string;

        /**
         * Creates new Component.
         * @param {Object} config The standard configuration object.
         */
        constructor(config: Ext.ButtonConfig);

        getCell();

        getFormat();

        setCell();

        setFormat();
    }
}

declare module Ext.grid.plugin {
    interface ColumnResizingConfig extends Ext.ComponentConfig {
        /**
         * When true the whole column will resize in real-time as the user drags. When false only the header will resize
         * until the interaction is done.
         */
        realtime?: boolean;
    }

    /**
     * @extends Ext.Component
     * Description
     */
    export class ColumnResizing extends Ext.Component implements Ext.grid.plugin.ColumnResizingConfig {
        /**
         * When true the whole column will resize in real-time as the user drags. When false only the header will resize
         * until the interaction is done.
         */
        realtime: boolean;

        /**
         * Creates new Component.
         * @param {Object} config The standard configuration object.
         */
        constructor(config: Ext.ButtonConfig);

        getGrid();

        getRealtime();

        setGrid();

        setRealtime();
    }

    interface EditableConfig extends Ext.ComponentConfig {
        /**
         * Configures the default form appended to the editable panel.
         */
        defaultFormConfig?: any;

        /**
         *  Creates a delete button, which allows the user to delete the selected row.
         */
        enableDeleteButton?: any;

        /**
         * By changing the formConfig you can hardcode the form that gets created when editing a row.
         * Note that the fields are not set on this form, so you will have to define them yourself in this config.
         * If you want to alter certain form configurations, but still have the default editor fields applied, use
         * the defaultFormConfig instead.
         */
        formConfig?: any;

        /**
         * Configures the toolbar appended to the editable panel.
         */
        toolbarConfig?: any;

        /**
         * The event used to trigger the showing of the editor form.
         */
        triggerEvent?: string;
    }

    /**
     * The Editable plugin injects editing at a row level for Modern Toolkit's
     * Grid. Editing begins by double-tapping a row.  This can be set to any event, which we'll
     * discuss below. The editor consists of a small floating dialog that be shown on the right
     * side of your viewport.
     *
     * There is a button to save or cancel all changes for the edit in the toolbar, and the
     * row is deletable by default.
     *
     * The default editable grid can be defined like so:
     *
     *     @example
     *     Ext.create({
     *         xtype: 'grid',
     *         fullscreen: true,
     *         plugins: 'grideditable',
     *         store: {
     *             fields: [],
     *             data: [{
     *                 name: 'Jake'
     *             }, {
     *                 name: 'Finn'
     *             }]
     *         },
     *         columns: [{
     *             text: 'Name',
     *             dataIndex: 'name',
     *             flex: 1,
     *             editable: true
     *         }]
     *     });
     *
     * By opening up the plugins type as an object (or an array of objects), you can modify your
     * editor more significantly.  You can see the changeable bits below:
     *
     *     @example
     *     Ext.create({
     *         xtype: 'grid',
     *         fullscreen: true,
     *         plugins: {
     *             type: 'grideditable',
     *             triggerEvent: 'doubletap',
     *             enableDeleteButton: true,
     *             formConfig: null, // See more below
     *
     *             defaultFormConfig: {
     *                 xtype: 'formpanel',
     *                 modal: true,
     *                 scrollable: true,
     *                 items: {
     *                     xtype: 'fieldset'
     *                 }
     *             },
     *
     *             toolbarConfig: {
     *                 xtype: 'titlebar',
     *                 docked: 'top',
     *                 items: [{
     *                     xtype: 'button',
     *                     ui: 'decline',
     *                     text: 'Cancel',
     *                     align: 'left',
     *                     action: 'cancel'
     *                 }, {
     *                     xtype: 'button',
     *                     ui: 'confirm',
     *                     text: 'Submit',
     *                     align: 'right',
     *                     action: 'submit'
     *                 }]
     *             },
     *         },
     *         store: {
     *             fields: [],
     *             data: [{
     *                 name: 'Jake'
     *             }, {
     *                 name: 'Finn'
     *             }]
     *         },
     *         columns: [{
     *             text: 'Name',
     *             dataIndex: 'name',
     *             flex: 1,
     *             editable: true
     *         }]
     *     });
     *
     *  As you can see, you can easily modify nearly every bit of the editor window.  As mentioned
     *  above, the toolbar and delete button are the only components included by default.  That's
     *  where formConfig comes into play.
     *
     *  By adding formConfig, you can hardcode the form that gets created when editing a row.
     *  There are no fields set on the form initially, so you will need to define them
     *  yourself.  For example, if you had a "name" column, and you wanted it to be editable,
     *  you would do something like this in your plugins object:
     *
     *     formConfig: {
     *        items: [{
     *           xtype: 'textfield',
     *           name: 'name',
     *           label: 'Name'
     *        }]
     *     }
     *
     *  Now, upon opening the editor, you would see a textfield populated with the editable value from
     *  its corresponding record.
     *
     *  If you want to alter certain form configurations, but still have the default editor fields applied, use
     *  the defaultFormConfig instead.
     */
    export class Editable extends Ext.Component implements Ext.grid.plugin.EditableConfig {
        /**
         * Configures the default form appended to the editable panel.
         */
        defaultFormConfig: any;

        /**
         *  Creates a delete button, which allows the user to delete the selected row.
         */
        enableDeleteButton: any;

        /**
         * By changing the formConfig you can hardcode the form that gets created when editing a row.
         * Note that the fields are not set on this form, so you will have to define them yourself in this config.
         * If you want to alter certain form configurations, but still have the default editor fields applied, use
         * the defaultFormConfig instead.
         */
        formConfig: any;

        /**
         * Configures the toolbar appended to the editable panel.
         */
        toolbarConfig: any;

        /**
         * The event used to trigger the showing of the editor form.
         */
        triggerEvent: string;

        /**
         * Creates new Component.
         * @param {Object} config The standard configuration object.
         */
        constructor(config: Ext.ButtonConfig);

        getDefaultFormConfig();

        getEnableDeleteButton();

        getFormConfig();

        getToolbarConfig();

        getTriggerEvent();

        setDefaultFormConfig();

        setEnableDeleteButton();

        setFormConfig();

        setToolbarConfig();

        setTriggerEvent();
    }

    interface MultiSelectionConfig extends Ext.ComponentConfig {
        /**
         * The text of the button used to cancel the {@link #selectionColumn}.
         */
        cancelText?: any;

        /**
         * The text of the button used to delete selected rows.
         */
        deleteText?: any;

        /**
         * The default settings for the selection column.  You may create your
         * own selectionColumn config within your plugin object in order to:
         *
         * + Change column width
         * + Show the selectionColumn by default
         * + Change the default cls or cellCls
         * + Etc.
         */
        selectionColumn?: any;

        /**
         * The text of the button used to display the {@link #selectionColumn}.
         */
        triggerText?: any;

        /**
         * Determines whether or not the trigger button is show when the grid is loaded.
         * This most commonly be set to false if you wanted to have the selectionColumn
         * shown 100% of the time instead of hidden by default. You could show the {@link #selectionColumn}
         * by modifying its hidden value to be false.
         */
        useTriggerButton?: any;
    }

    /**
     * The MultiSelection plugin injects a multiselector for Modern Toolkit's Grid. Users may
     * activate MultiSelection by tapping the "Select" button in the top right corner of the header bar.
     *
     * This will show the previously hidden {@link #selectionColumn}. When the column becomes unhidden,
     * you'll see a new column in the grid's first position. This {@link #selectionColumn} contains a checkbox
     * for each row and the header contains a checkbox that allows selection of all rows at once.
     *
     * Once shown, you may select and delete rows, or cancel the {@link #selectionColumn}.
     *
     * To include the MultiSelection plugin, simply set plugins to 'gridmultiselection'
     * as seen below:
     *
     *     Ext.define('MyApp.view.SelectableGrid', {
     *        extend: 'Ext.grid.Grid',
     *
     *        plugins: 'gridmultiselection',
     *
     *        title: 'My Title',
     *
     *        store: store
     *        columns: [
     *            // columns
     *        ]
     *     );
     *
     * You can modify a few pieces of your MultiSelection tool by opening the plugins type as an object
     * (or an array of objects). You can see some of the changeable bits below:
     *
     *     Ext.define('MyApp.view.SelectableGrid', {
     *        extend: 'Ext.grid.Grid',
     *
     *        plugins: {
     *            type: 'gridmultiselection',
     *            triggerText: 'My Select Button',
     *            cancelText: 'Forget about it',
     *            deleteText: 'Get outta here'
     *        }
     *
     *        title: 'My Title',
     *
     *        store: store
     *        columns: [
     *            // columns
     *        ]
     *     );
     *
     * You can also modify the default settings for the selectionColumn by including your own
     * {@link #selectionColumn} config within your gridmultiselection definition. You might modify
     * the {@link #selectionColumn} in order to:
     *
     * + Change column width
     * + Show the selectionColumn by default
     * + Change the default cls or cellCls
     * + Etc.
     *
     * Here's an example that modifies the {@link #selectionColumn}:
     *
     *     Ext.define('MyApp.view.SelectableGrid', {
     *        extend: 'Ext.grid.Grid',
     *
     *        plugins: {
     *            type: 'gridmultiselection',
     *
     *            selectionColumn: {
     *                width:100  // Change column width from the default of 60px
     *            }
     *        }
     *
     *        title: 'My Title',
     *
     *        store: store
     *        columns: [
     *            // columns
     *        ]
     *     );
     */
    export class MultiSelection extends Ext.Component implements Ext.grid.plugin.MultiSelectionConfig {
        /**
         * The text of the button used to cancel the {@link #selectionColumn}.
         */
        cancelText: any;

        /**
         * The text of the button used to delete selected rows.
         */
        deleteText: any;

        /**
         * The default settings for the selection column.  You may create your
         * own selectionColumn config within your plugin object in order to:
         *
         * + Change column width
         * + Show the selectionColumn by default
         * + Change the default cls or cellCls
         * + Etc.
         */
        selectionColumn: any;

        /**
         * The text of the button used to display the {@link #selectionColumn}.
         */
        triggerText: any;

        /**
         * Determines whether or not the trigger button is show when the grid is loaded.
         * This most commonly be set to false if you wanted to have the selectionColumn
         * shown 100% of the time instead of hidden by default. You could show the {@link #selectionColumn}
         * by modifying its hidden value to be false.
         */
        useTriggerButton: any;

        /**
         * Creates new Component.
         * @param {Object} config The standard configuration object.
         */
        constructor(config: Ext.ButtonConfig);

        getCancelText();

        getDeleteText();

        getSelectionColumn();

        getTriggerText();

        getUseTriggerButton();

        setCancelText();

        setDeleteText();

        setSelectionColumn();

        setTriggerText();

        setUseTriggerButton();
    }

    export class PagingToolbar extends Ext.Component {
        /**
         * Creates new Component.
         * @param {Object} config The standard configuration object.
         */
        constructor(config: Ext.ButtonConfig);

        getCurrentPage();

        getGrid();

        getPageSize();

        getToolbar();

        getTotalCount();

        getTotalPages();

        setCurrentPage();

        setGrid();

        setPageSize();

        setToolbar();

        setTotalCount();

        setTotalPages();
    }

    interface SummaryRowConfig extends Ext.grid.RowConfig {
        cls?: any;

        docked?: any;
    }

    export class SummaryRow extends Ext.grid.Row implements Ext.grid.plugin.SummaryRowConfig {
        cls: string;

        docked: string;

        constructor(config: Ext.grid.RowConfig);

        destroy();

        getCls();

        getDocked();

        getEmptyCls();

        getEmptyText();

        getGrid();

        getTranslatable();

        setCls();

        setDocked();

        setEmptyCls();

        setEmptyText();

        setGrid();

        setTranslatable();
    }

    interface ViewOptionsConfig extends Ext.ComponentConfig {
        /**
         * The column's configuration
         */
        columnList?: any;

        /**
         * The CSS class responsible for displaying the grouping indicator.
         */
        groupIndicatorSelector?: any;

        /**
         * The configuration of the menu
         */
        sheet?: any;

        /**
         * The width of the menu
         */
        sheetWidth?: any;

        /**
         * The CSS class responsible for displaying the visibility indicator.
         */
        visibleIndicatorSelector?: any;
    }

    /**
     * The Modern Grid's ViewOptions plugin produces a menu that slides in from the right (by default)
     * when you drag your finger or cursor right-to-left over the grid's column headers. The
     * menu displays the column header names which represents the order of the grid's columns.
     * This allows users to easily reorder the grid's columns by reordering the rows. Items may
     * be dragged by grabbing the furthest left side of the row and moving the item vertically.
     *
     * Once the columns are ordered to your liking, you may then close the menu by tapping the
     * "Done" button.
     *
     *     @example
     *     var store = Ext.create('Ext.data.Store', {
     *         fields: ['name', 'email', 'phone'],
     *         data: [{
     *             name: 'Lisa',
     *             email: 'lisa@simpsons.com',
     *             phone: '555-111-1224'
     *         }, {
     *             name: 'Bart',
     *             email: 'bart@simpsons.com',
     *             phone: '555-111-1234'
     *         }, {
     *             name: 'Homer',
     *             email: 'homer@simpsons.com',
     *             phone: '555-222-1244'
     *         }, {
     *             name: 'Marge',
     *             email: 'marge@simpsons.com',
     *             phone: '555-222-1254'
     *         }]
     *     });
     *
     *     Ext.create('Ext.grid.Grid', {
     *         store: store,
     *         plugins: [{
     *             type: 'gridviewoptions'
     *         }],
     *         columns: [{
     *             text: 'Name',
     *             dataIndex: 'name',
     *             width: 200
     *         }, {
     *             text: 'Email',
     *             dataIndex: 'email',
     *             width: 250
     *         }, {
     *             text: 'Phone',
     *             dataIndex: 'phone',
     *             width: 120
     *         }],
     *         fullscreen: true
     *     });
     *
     * Developers may modify the menu and its contents by overriding {@link #sheet} and
     * {@link #columnList} respectively.
     */
    export class ViewOptions extends Ext.Component implements Ext.grid.plugin.ViewOptionsConfig {
        /**
         * Determines the menu's visibility when the grid is loaded.
         */
        sheetVisible: any;

        /**
         * The column's configuration
         */
        columnList: any;

        /**
         * The CSS class responsible for displaying the grouping indicator.
         */
        groupIndicatorSelector: any;

        /**
         * The configuration of the menu
         */
        sheet: any;

        /**
         * The width of the menu
         */
        sheetWidth: any;

        /**
         * The CSS class responsible for displaying the visibility indicator.
         */
        visibleIndicatorSelector: any;

        /**
         * Creates new Component.
         * @param {Object} config The standard configuration object.
         */
        constructor(config: Ext.ButtonConfig);

        getColumnList();

        getGroupIndicatorSelector();

        getSheet();

        getSheetWidth();

        getVisibleIndicatorSelector();

        setColumnList();

        setGroupIndicatorSelector();

        setSheet();

        setSheetWidth();

        setVisibleIndicatorSelector();
    }
}

declare module Ext.layout {
    export class Abstract extends Ext.Base {
        constructor(config: Ext.layout.BoxConfig);
    }

    interface BoxConfig extends Ext.layout.DefaultConfig {
        /**
         * Controls how the child items of the container are aligned. Acceptable configuration values for this property are:
         *
         * - ** start ** : child items are packed together at left side of container
         * - ** center ** : child items are packed together at mid-width of container
         * - ** end ** : child items are packed together at right side of container
         * - **stretch** : child items are stretched vertically to fill the height of the container
         */
        align?: string;

        /**
         * Controls how the child items of the container are packed together. Acceptable configuration values
         * for this property are:
         *
         * - ** start ** : child items are packed together at left side of container
         * - ** center ** : child items are packed together at mid-width of container
         * - ** end ** : child items are packed together at right side of container
         * - ** justify ** : child items are packed evenly across the container. Uses the 'justify-content: space-between' css property
         */
        pack?: string;
    }

    /**
     * Box is a superclass for the two box layouts:
     *
     * * {@link Ext.layout.HBox hbox}
     * * {@link Ext.layout.VBox vbox}
     *
     * Box itself is never used directly, but its subclasses provide flexible arrangement of child components
     * inside a {@link Ext.Container Container}.
     *
     * ## Horizontal Box
     *
     * HBox allows you to easily lay out child components horizontally. It can size items based on a fixed width or a
     * fraction of the total width available, enabling you to achieve flexible layouts that expand or contract to fill the
     * space available.
     *
     * See the {@link Ext.layout.HBox HBox layout docs} for more information on using hboxes.
     *
     * ## Vertical Box
     *
     * VBox allows you to easily lay out child components vertically. It can size items based on a fixed height or a
     * fraction of the total height available, enabling you to achieve flexible layouts that expand or contract to fill the
     * space available.
     *
     * See the {@link Ext.layout.VBox VBox layout docs} for more information on using vboxes.
     */
    export class Box extends Ext.layout.Default implements Ext.layout.BoxConfig {
        /**
         * Controls how the child items of the container are aligned. Acceptable configuration values for this property are:
         *
         * - ** start ** : child items are packed together at left side of container
         * - ** center ** : child items are packed together at mid-width of container
         * - ** end ** : child items are packed together at right side of container
         * - **stretch** : child items are stretched vertically to fill the height of the container
         */
        align: string;

        /**
         * Controls how the child items of the container are packed together. Acceptable configuration values
         * for this property are:
         *
         * - ** start ** : child items are packed together at left side of container
         * - ** center ** : child items are packed together at mid-width of container
         * - ** end ** : child items are packed together at right side of container
         * - ** justify ** : child items are packed evenly across the container. Uses the 'justify-content: space-between' css property
         */
        pack: string;

        constructor(config: Ext.layout.BoxConfig);

        getAlign();

        getOrient();

        getPack();

        setAlign();

        setOrient();

        setPack();
    }

    /**
     * Sometimes you want to show several screens worth of information but you've only got a small screen to work with.
     * TabPanels and Carousels both enable you to see one screen of many at a time, and underneath they both use a Card
     * Layout.
     *
     * Card Layout takes the size of the Container it is applied to and sizes the currently active item to fill the
     * Container completely. It then hides the rest of the items, allowing you to change which one is currently visible but
     * only showing one at once.
     *
     * Here the gray box is our Container, and the blue box inside it is the currently active card. The three other cards
     * are hidden from view, but can be swapped in later. While it's not too common to create Card layouts directly, you
     * can do so like this:
     *
     *     var panel = Ext.create('Ext.Panel', {
     *         layout: 'card',
     *         items: [
     *             {
     *                 html: "First Item"
     *             },
     *             {
     *                 html: "Second Item"
     *             },
     *             {
     *                 html: "Third Item"
     *             },
     *             {
     *                 html: "Fourth Item"
     *             }
     *         ]
     *     });
     *
     *     panel.setActiveItem(1);
     *
     * Here we create a Panel with a Card Layout and later set the second item active (the active item index is zero-based,
     * so 1 corresponds to the second item). Normally you're better off using a {@link Ext.tab.Panel tab panel} or a
     * {@link Ext.carousel.Carousel carousel}.
     */
    export class Card extends Ext.layout.Default {
        constructor(config: Ext.layout.BoxConfig);

        destroy();

        /**
         * Fires when an card is made active
         * @param {Ext.layout.Card} this The layout instance
         * @param {Mixed} newActiveItem The new active item
         * @param {Mixed} oldActiveItem The old active item
         */
        activeitemchange(that: Ext.layout.Card, newActiveItem: any, oldActiveItem: any);
    }

    interface DefaultConfig {
        /**
         * Layout animation configuration
         * Controls how layout transitions are animated.  Currently only available for
         * Card Layouts.
         *
         * Possible values are:
         *
         * - cover
         * - cube
         * - fade
         * - flip
         * - pop
         * - reveal
         * - scroll
         * - slide
         */
        animation?: Ext.fx.layout.Card;
    }

    export class Default extends Ext.layout.Abstract implements Ext.layout.DefaultConfig {
        /**
         * Layout animation configuration
         * Controls how layout transitions are animated.  Currently only available for
         * Card Layouts.
         *
         * Possible values are:
         *
         * - cover
         * - cube
         * - fade
         * - flip
         * - pop
         * - reveal
         * - scroll
         * - slide
         */
        animation: Ext.fx.layout.Card;

        constructor(config: Ext.layout.BoxConfig);

        destroy();

        getAnimation();

        /**
         * @param {Boolean} [destroying]
         */
        onItemInnerStateChange(item: Ext.Component, isInner: boolean, destroying?: boolean);

        setAnimation();
    }

    export class Fit extends Ext.layout.Default {
        constructor(config: Ext.layout.BoxConfig);
    }

    interface FlexBoxConfig extends Ext.layout.BoxConfig {
        align?: any;
    }

    /**
     * AbstractBox is a superclass for the two box layouts:
     *
     * * {@link Ext.layout.HBox hbox}
     * * {@link Ext.layout.VBox vbox}
     *
     * FlexBox itself is never used directly, but its subclasses provide flexible arrangement of child components
     * inside a {@link Ext.Container Container}.
     *
     * ## Horizontal Box
     *
     * HBox allows you to easily lay out child components horizontally. It can size items based on a fixed width or a
     * fraction of the total width available, enabling you to achieve flexible layouts that expand or contract to fill the
     * space available.
     *
     * {@img ../guides/layouts/hbox.jpg}
     *
     * See the {@link Ext.layout.HBox HBox layout docs} for more information on using hboxes.
     *
     * ## Vertical Box
     *
     * VBox allows you to easily lay out child components verticaly. It can size items based on a fixed height or a
     * fraction of the total height available, enabling you to achieve flexible layouts that expand or contract to fill the
     * space available.
     *
     * See the {@link Ext.layout.VBox VBox layout docs} for more information on using vboxes.
     */
    export class FlexBox extends Ext.layout.Box implements Ext.layout.FlexBoxConfig {
        align: string;

        constructor(config: Ext.layout.BoxConfig);

        getAlign();

        setAlign();

        /**
         * Sets the flex of an item in this box layout.
         * @param {Ext.Component} item The item of this layout which you want to update the flex of.
         * @param {Number} flex The flex to set on this method
         */
        setItemFlex(item: Ext.Component, flex: number);
    }

    export class Float extends Ext.layout.Default {
        constructor(config: Ext.layout.BoxConfig);

        getDirection();

        setDirection();
    }

    /**
     * The HBox (short for horizontal box) layout makes it easy to position items horizontally in a
     * {@link Ext.Container Container}. It can size items based on a fixed width or a fraction of the total width
     * available.
     *
     * For example, an email client might have a list of messages pinned to the left, taking say one third of the available
     * width, and a message viewing panel in the rest of the screen. We can achieve this with hbox layout's *flex* config:
     *
     *     @example
     *     Ext.create('Ext.Container', {
     *         fullscreen: true,
     *         layout: 'hbox',
     *         items: [
     *             {
     *                 html: 'message list',
     *                 style: 'background-color: #5E99CC;',
     *                 flex: 1
     *             },
     *             {
     *                 html: 'message preview',
     *                 style: 'background-color: #759E60;',
     *                 flex: 2
     *             }
     *         ]
     *     });
     *
     * This will give us two boxes - one that's one third of the available width, the other being two thirds of the
     * available width.
     *
     * We can also specify fixed widths for child items, or mix fixed widths and flexes. For example, here we have 3 items
     * - one on each side with flex: 1, and one in the center with a fixed width of 100px:
     *
     *     @example
     *     Ext.create('Ext.Container', {
     *         fullscreen: true,
     *         layout: 'hbox',
     *         items: [
     *             {
     *                 html: 'Left item',
     *                 style: 'background-color: #759E60;',
     *                 flex: 1
     *             },
     *             {
     *                 html: 'Center item',
     *                 width: 100
     *             },
     *             {
     *                 html: 'Right item',
     *                 style: 'background-color: #5E99CC;',
     *                 flex: 1
     *             }
     *         ]
     *     });
     */
    export class HBox extends Ext.layout.FlexBox {
        constructor(config: Ext.layout.BoxConfig);
    }

    /**
     * The VBox (short for vertical box) layout makes it easy to position items horizontally in a
     * {@link Ext.Container Container}. It can size items based on a fixed height or a fraction of the total height
     * available.
     *
     * For example, let's say we want a banner to take one third of the available height, and an information panel in the
     * rest of the screen. We can achieve this with vbox layout's *flex* config:
     *
     *     @example
     *     Ext.create('Ext.Container', {
     *         fullscreen: true,
     *         layout: 'vbox',
     *         items: [
     *             {
     *                 html: 'Awesome banner',
     *                 style: 'background-color: #759E60;',
     *                 flex: 1
     *             },
     *             {
     *                 html: 'Some wonderful information',
     *                 style: 'background-color: #5E99CC;',
     *                 flex: 2
     *             }
     *         ]
     *     });
     *
     * This will give us two boxes - one that's one third of the available height, the other being two thirds of the
     * available height.
     *
     * We can also specify fixed heights for child items, or mix fixed heights and flexes. For example, here we have 3
     * items - one at the top and bottom with flex: 1, and one in the center with a fixed width of 100px:
     *
     *     @example preview portrait
     *     Ext.create('Ext.Container', {
     *         fullscreen: true,
     *         layout: 'vbox',
     *         items: [
     *             {
     *                 html: 'Top item',
     *                 style: 'background-color: #5E99CC;',
     *                 flex: 1
     *             },
     *             {
     *                 html: 'Center item',
     *                 height: 100
     *             },
     *             {
     *                 html: 'Bottom item',
     *                 style: 'background-color: #759E60;',
     *                 flex: 1
     *             }
     *         ]
     *     });
     */
    export class VBox extends Ext.layout.FlexBox {
        constructor(config: Ext.layout.BoxConfig);

        getOrient();

        setOrient();
    }
}

declare module Ext.layout.wrapper {
    export class BoxDock extends Ext.Base {
        constructor(config: any);

        destroy();

        getBodyElement();

        getContainer();

        getDirection();

        getElement();

        getInnerWrapper();

        getSizeState();

        setBodyElement();

        setContainer();

        setDirection();

        setElement();

        setInnerWrapper();

        setSizeState();
    }

    export class Dock extends Ext.Base {
        constructor(config: any);

        destroy();

        getBodyElement();

        getContainer();

        getDirection();

        getElement();

        getInnerWrapper();

        getSizeState();

        setBodyElement();

        setContainer();

        setDirection();

        setElement();

        setInnerWrapper();

        setSizeState();
    }

    export class Inner extends Ext.Base {
        constructor(config: any);

        getContainer();

        getSizeState();

        setContainer();

        setSizeState();
    }
}

declare module Ext.list {
    interface AbstractTreeItemConfig extends Ext.WidgetConfig {
        /**
         * 'true' if this item is expandable. This value is taken from
         * the underlying {@link #node}.
         */
        expandable?: boolean;

        /**
         * 'true' if this item is expanded. This value is taken from
         * the underlying {@link #node}.
         */
        expanded?: boolean;

        /**
         * 'true' if this item is current floated. This mode applies when the owning
         * '{@link Ext.list.Tree treelist}' is in '{@link Ext.list.Tree#micro micro}'
         * mode and the sub-tree under this item should be presented as a floating
         * element.
         */
        floated?: boolean;

        iconCls?: string;

        /**
         * The property from the {@link #node} to map for the {@link #iconCls} config.
         */
        iconClsProperty?: string;

        /**
         * 'true' if this item is a leaf. This value is taken from
         * the underlying {@link #node}.
         */
        leaf?: boolean;

        /**
         * 'true' if this item is currently loading data. This value is taken from
         * the underlying {@link #node}.
         */
        loading?: boolean;

        /**
         * The backing node for this item.
         */
        node?: Ext.data.TreeModel;

        /**
         * One of three possible values:
         *
         *   - 0 if mouse is not over this item or any of its descendants.
         *   - 1 if mouse is not over this item but is over one of this item's descendants.
         *   - 2 if mouse is directly over this item.
         */
        over?: number;

        /**
         * The owning list for this container.
         */
        owner?: Ext.list.Tree;

        /**
         * The parent item for this item.
         */
        parentItem?: Ext.list.AbstractTreeItem;

        /**
         * 'true' if this is the selected item in the tree.
         */
        selected?: boolean;

        /**
         * 'true' if this item contains the {@link #selected} item in the tree.
         */
        selectedParent?: boolean;

        /**
         * The text for this item. This value is taken from
         * the underlying {@link #node}.
         */
        text?: string;

        /**
         * The property from the {@link #node} to map for the {@link #text} config.
         */
        textProperty?: string;
    }

    /**
     * The base class for all items in the '{@link Ext.list.Tree treelist}'.
     * @since 6.0.0
     */
    export class AbstractTreeItem extends Ext.Widget implements Ext.list.AbstractTreeItemConfig {
        /**
         * 'true' if this item is expandable. This value is taken from
         * the underlying {@link #node}.
         */
        expandable: boolean;

        /**
         * 'true' if this item is expanded. This value is taken from
         * the underlying {@link #node}.
         */
        expanded: boolean;

        /**
         * 'true' if this item is current floated. This mode applies when the owning
         * '{@link Ext.list.Tree treelist}' is in '{@link Ext.list.Tree#micro micro}'
         * mode and the sub-tree under this item should be presented as a floating
         * element.
         */
        floated: boolean;

        iconCls: string;

        /**
         * The property from the {@link #node} to map for the {@link #iconCls} config.
         */
        iconClsProperty: string;

        /**
         * 'true' if this item is a leaf. This value is taken from
         * the underlying {@link #node}.
         */
        leaf: boolean;

        /**
         * 'true' if this item is currently loading data. This value is taken from
         * the underlying {@link #node}.
         */
        loading: boolean;

        /**
         * The backing node for this item.
         */
        node: Ext.data.TreeModel;

        /**
         * One of three possible values:
         *
         *   - 0 if mouse is not over this item or any of its descendants.
         *   - 1 if mouse is not over this item but is over one of this item's descendants.
         *   - 2 if mouse is directly over this item.
         */
        over: number;

        /**
         * The owning list for this container.
         */
        owner: Ext.list.Tree;

        /**
         * The parent item for this item.
         */
        parentItem: Ext.list.AbstractTreeItem;

        /**
         * 'true' if this is the selected item in the tree.
         */
        selected: boolean;

        /**
         * 'true' if this item contains the {@link #selected} item in the tree.
         */
        selectedParent: boolean;

        /**
         * The text for this item. This value is taken from
         * the underlying {@link #node}.
         */
        text: string;

        /**
         * The property from the {@link #node} to map for the {@link #text} config.
         */
        textProperty: string;

        /**
         * Collapse this item. Does nothing if already collapsed.
         */
        collapse();

        constructor(config: Ext.ProgressConfig);

        destroy();

        /**
         * Expand this item. Does nothing if already expanded.
         */
        expand();

        getExpandable();

        getExpanded();

        getFloated();

        getIconCls();

        getIconClsProperty();

        getIndent();

        getLeaf();

        getLoading();

        getNode();

        getOver();

        getOwner();

        getParentItem();

        getSelected();

        getSelectedParent();

        getText();

        getTextProperty();

        /**
         * Gets the element to be used for the tree when it is in
         * {@link Ext.list.Tree#micro micro} mode.
         * @return {Ext.dom.Element} The element.
         */
        protected getToolElement(): Ext.dom.Element;

        /**
         * Append a new child item to the DOM.
         * @param {Ext.list.AbstractTreeItem} item The item to insert.
         * @param {Ext.list.AbstractTreeItem} refItem The item the node is to
         * be inserted before. 'null' if the item is to be added to the end.
         */
        protected insertItem(item: Ext.list.AbstractTreeItem, refItem: Ext.list.AbstractTreeItem);

        /**
         * Check if the current item is expanded.
         * @return {Boolean} 'true' if this item is expanded.
         */
        isExpanded(): boolean;

        /**
         * Checks whether the event is an event that should select this node.
         * @param {Ext.event.Event} e The event object.
         * @return {Boolean} 'true' if the event should select this node.
         */
        protected isSelectionEvent(e: Ext.event.Event): boolean;

        /**
         * Checks whether the event is an event that should toggle the expand/collapse state.
         * @param {Ext.event.Event} e The event object.
         * @return {Boolean} 'true' if the event should toggle the expand/collapsed state.
         */
        protected isToggleEvent(e: Ext.event.Event): boolean;

        /**
         * Handle this node being collapsed.
         * @param {Ext.data.TreeModel} node  The node being collapsed.
         */
        protected nodeCollapse(node: Ext.data.TreeModel);

        /**
         * Handle this node being expanded.
         * @param {Ext.data.TreeModel} node  The node being expanded.
         */
        protected nodeExpand(node: Ext.data.TreeModel);

        /**
         * Handle a node being inserted as a child of this item.
         * @param {Ext.data.TreeModel} node  The node being inserted.
         * @param {Ext.data.TreeModel} refNode The node that is to be inserted before. 'null'
         * if this operation is an append.
         */
        protected nodeInsert(node: Ext.data.TreeModel, refNode: Ext.data.TreeModel);

        /**
         * Handle a node being removed as a child of this item.
         * @param {Ext.data.TreeModel} node  The node being removed.
         */
        protected nodeRemove(node: Ext.data.TreeModel);

        /**
         * Handle this node having fields changed.
         *
         * @param {Ext.data.TreeModel} node The node.
         * @param {String[]} modifiedFieldNames The modified field names, if known.
         */
        protected nodeUpdate(node: Ext.data.TreeModel, modifiedFieldNames: string);

        /**
         * Remove a child item from the DOM.
         * @param {Ext.list.AbstractTreeItem} item The item to remove.
         */
        protected removeItem(item: Ext.list.AbstractTreeItem);

        setExpandable();

        setExpanded();

        setFloated();

        setIconCls();

        setIconClsProperty();

        setIndent();

        setLeaf();

        setLoading();

        setNode();

        setOver();

        setOwner();

        setParentItem();

        setSelected();

        setSelectedParent();

        setText();

        setTextProperty();

        /**
         * @param {Ext.list.Tree} sender The 'treelist' that fired this event.
         *
         * @param {Ext.event.Event} info.event The DOM event that precipitated this
         * event.
         * @param {Ext.list.AbstractTreeItem} info.item The tree node that was clicked.
         * @param {Ext.list.Tree} info.tree The 'treelist' that fired this event.
         * @param {Boolean} info.select On input this is value is the result of the
         *   {@link #isSelectionEvent} method. On return from event handlers (assuming a
         *   'false' return does not cancel things) this property is used to determine
         *   if the clicked node should be selected.
         * @param {Boolean} info.toggle On input this is value is the result of the
         *   {@link #isToggleEvent} method. On return from event handlers (assuming a
         *   'false' return does not cancel things) this property is used to determine
         *   if the clicked node's expand/collapse state should be toggled.
         *
         * @since 6.0.1
         */
        itemclick(sender: Ext.list.Tree, info: any, info_event: Ext.event.Event, info_item: Ext.list.AbstractTreeItem, info_tree: Ext.list.Tree, info_select: boolean, info_toggle: boolean);
    }

    /**
     * This class implements the top-level node in a '{@link Ext.list.Tree treelist}'. Unlike
     * other nodes, this item is only a container for other items. It does not correspond to
     * a data record.
     *
     * @since 6.0.0
     */
    export class RootTreeItem extends Ext.list.AbstractTreeItem {
        protected element: any;

        /**
         * This property is 'true' to allow type checking for this or derived class.
         * @readonly
         */
        isRootListItem: boolean;

        constructor(config: Ext.ProgressConfig);
    }

    interface TreeConfig extends Ext.WidgetConfig {
        /**
         * The default configuration for the widgets created for tree items.
         *
         * The type of item to create. By default, items are '{@link Ext.list.TreeItem treelistitem}'
         * instances. This can be customized but this 'xtype' must reference a class that
         * ultimately derives from the '{@link Ext.list.AbstractTreeItem}' base class.
         *
         * Optional
         */
        defaults?: any;

        /**
         * 'true' to expand only on the click of the expander element. Setting this to
         * 'false' will allow expansion on click of any part of the element.
         */
        expanderOnly?: boolean;

        publishes?: any;

        /**
         * 'true' to select the node when clicking the expander.
         */
        selectOnExpander?: boolean;

        /**
         * The current selected node.
         */
        selection?: Ext.data.TreeModel;

        /**
         * 'true' if only 1 node per branch may be expanded.
         *
         * Optional, Defaults to: false
         */
        singleExpand?: boolean;

        /**
         * The data source to which this component is bound.
         */
        store?: any;

        twoWayBindable?: any;
    }

    /**
     * A lightweight component to display data in a simple tree structure.
     * @since 6.0.0
     */
    export class Tree extends Ext.Widget implements Ext.list.TreeConfig {
        protected defaultBindProperty: any;

        protected element: any;

        /**
         * The default configuration for the widgets created for tree items.
         *
         * The type of item to create. By default, items are '{@link Ext.list.TreeItem treelistitem}'
         * instances. This can be customized but this 'xtype' must reference a class that
         * ultimately derives from the '{@link Ext.list.AbstractTreeItem}' base class.
         *
         * Optional
         */
        defaults: any;

        /**
         * 'true' to expand only on the click of the expander element. Setting this to
         * 'false' will allow expansion on click of any part of the element.
         */
        expanderOnly: boolean;

        publishes: any;

        /**
         * The current selected node.
         */
        selection: Ext.data.TreeModel;

        /**
         * 'true' to select the node when clicking the expander.
         */
        selectOnExpander: boolean;

        /**
         * 'true' if only 1 node per branch may be expanded.
         *
         * Optional, Defaults to: false
         */
        singleExpand: boolean;

        /**
         * The data source to which this component is bound.
         */
        store: any;

        twoWayBindable: any;

        constructor(config: Ext.list.TreeConfig);

        destroy();

        getAnimation();

        getDefaults();

        getExpanderFirst();

        getExpanderOnly();

        getHighlightPath();

        getIconSize();

        getIndent();

        /**
         * Get a child {@link Ext.list.AbstractTreeItem item} by node.
         * @param {Ext.data.TreeModel} node The node.
         * @return {Ext.list.AbstractTreeItem} The item. 'null' if not found.
         */
        getItem(node: Ext.data.TreeModel): Ext.list.AbstractTreeItem;

        /**
         * This method is called to populate and return a config object for new nodes. This
         * can be overridden by derived classes to manipulate properties or 'xtype' of the
         * returned object. Upon return, the object is passed to '{@link Ext#create}' and the
         * reference is stored as part of this tree.
         *
         * The base class implementation will apply any configured '{@link #defaults}' to the
         * object it returns.
         *
         * @param {Ext.data.TreeModel} node The node backing the item.
         * @param {Ext.list.AbstractTreeItem} parent The parent item. This is never 'null' but
         * may be an instance of '{@link Ext.list.RootTreeItem}'.
         * @return {Object} The config object to pass to '{@link Ext#create}' for the item.
         */
        getItemConfig(node: Ext.data.TreeModel, parent: Ext.list.AbstractTreeItem): any;

        getMicro();

        getOverItem();

        getSelection();

        getSelectOnExpander();

        getSingleExpand();

        getStore();

        getUi();

        setAnimation();

        setDefaults();

        setExpanderFirst();

        setExpanderOnly();

        setHighlightPath();

        setIconSize();

        setIndent();

        setMicro();

        setOverItem();

        setSelection();

        setSelectOnExpander();

        setSingleExpand();

        setStore();

        setUi();
    }

    interface TreeItemConfig extends Ext.list.AbstractTreeItemConfig {
        /**
         * One or more CSS classes to add to the tree item's logical "row" element. This
         * element fills from left-to-right of the line.
         * @since 6.0.1
         */
        rowCls?: string;

        /**
         * The name of the associated record's field to map to the {@link #rowCls} config.
         * @since 6.0.1
         *
         * Optional, Defaults to: "rowCls"
         */
        rowClsProperty?: string;
    }

    /**
     * The default implementation of the class used for '{@link Ext.list.Tree}'.
     *
     * This class can only be used in conjunction with {@link Ext.list.Tree}.
     * @since 6.0.0
     */
    export class TreeItem extends Ext.list.AbstractTreeItem implements Ext.list.TreeItemConfig {
        protected element: any;

        /**
         * This property is 'true' to allow type checking for this or derived class.
         * @readonly
         */
        isTreeListItem: boolean;

        /**
         * One or more CSS classes to add to the tree item's logical "row" element. This
         * element fills from left-to-right of the line.
         * @since 6.0.1
         */
        rowCls: string;

        /**
         * The name of the associated record's field to map to the {@link #rowCls} config.
         * @since 6.0.1
         *
         * Optional, Defaults to: "rowCls"
         */
        rowClsProperty: string;

        constructor(config: Ext.list.TreeItemConfig);

        getRowCls();

        setRowCls();
    }
}

declare module Ext.mixin {
    interface AccessibleConfig {
        /**
         * An object containing ARIA attributes to be set
         * on this Component's ARIA element. Use this to set the attributes that cannot be
         * determined by the Component's state, such as 'aria-live', 'aria-flowto', etc.
         *
         * **Note** that this config is only meaningful at the Component rendering time,
         * and setting it after that will do nothing.
         */
        ariaAttributes?: any;

        /**
         * DOM selector for a child element that is to be used
         * as description for this Component, set in 'aria-describedby' attribute.
         * The selector works the same way as {@link #ariaLabelledBy}.
         *
         * Optional
         */
        ariaDescribedBy?: string;

        /**
         * ARIA label for this Component. It is best to use
         * {@link #ariaLabelledBy} option instead, because screen readers prefer
         * 'aria-labelledby' attribute to 'aria-label'. {@link #ariaLabel} and
         * {@link #ariaLabelledBy} config options are mutually exclusive.
         *
         * Optional
         */
        ariaLabel?: string;

        /**
         * DOM selector for a child element that is to be used
         * as label for this Component, set in 'aria-labelledby' attribute.
         * If the selector is by '#id', the label element can be any existing element,
         * not necessarily a child of the main Component element.
         *
         * {@link #ariaLabelledBy} and {@link #ariaLabel} config options are
         * mutually exclusive, and 'ariaLabelledBy' has the higher precedence.
         *
         * Optional
         */
        ariaLabelledBy?: string;
    }

    /**
     * This mixin defines certain config options, properties, and APIs to be used
     * by Components that implement accessible traits according to WAI-ARIA 1.0 specification.
     */
    export class Accessible extends Ext.Mixin implements Ext.mixin.AccessibleConfig {
        /**
         * ARIA role for this Component, defaults to no role.
         * With no role, no other ARIA attributes are set.
         *
         * @readonly
         *
         * Optional
         */
        ariaRole: string;

        /**
         * An object containing ARIA attributes to be set
         * on this Component's ARIA element. Use this to set the attributes that cannot be
         * determined by the Component's state, such as 'aria-live', 'aria-flowto', etc.
         *
         * **Note** that this config is only meaningful at the Component rendering time,
         * and setting it after that will do nothing.
         */
        ariaAttributes: any;

        /**
         * DOM selector for a child element that is to be used
         * as description for this Component, set in 'aria-describedby' attribute.
         * The selector works the same way as {@link #ariaLabelledBy}.
         *
         * Optional
         */
        ariaDescribedBy: string;

        /**
         * ARIA label for this Component. It is best to use
         * {@link #ariaLabelledBy} option instead, because screen readers prefer
         * 'aria-labelledby' attribute to 'aria-label'. {@link #ariaLabel} and
         * {@link #ariaLabelledBy} config options are mutually exclusive.
         *
         * Optional
         */
        ariaLabel: string;

        /**
         * DOM selector for a child element that is to be used
         * as label for this Component, set in 'aria-labelledby' attribute.
         * If the selector is by '#id', the label element can be any existing element,
         * not necessarily a child of the main Component element.
         *
         * {@link #ariaLabelledBy} and {@link #ariaLabel} config options are
         * mutually exclusive, and 'ariaLabelledBy' has the higher precedence.
         *
         * Optional
         */
        ariaLabelledBy: string;

        getAriaAttributes();

        setAriaAttributes();
    }

    interface BindableConfig {
        /**
         * Setting this config option adds or removes data bindings for other configs.
         * For example, to bind the 'title' config:
         *
         *      var panel = Ext.create({
         *          xtype: 'panel',
         *          bind: {
         *              title: 'Hello {user.name}'
         *          }
         *      });
         *
         * To dynamically add bindings:
         *
         *      panel.setBind({
         *          title: 'Greetings {user.name}!'
         *      });
         *
         * To remove bindings:
         *
         *      panel.setBind({
         *          title: null
         *      });
         *
         * The bind expressions are presented to '{@link Ext.app.ViewModel#bind}'. The
         * 'ViewModel' instance is determined by 'lookupViewModel'.
         *
         * Optional
         */
        bind?: any;

        /**
         * A string alias, a configuration object or an instance of a 'ViewController' for
         * this container. Sample usage:
         *
         *     Ext.define('MyApp.UserController', {
         *         alias: 'controller.user'
         *     });
         *
         *     Ext.define('UserContainer', {
         *         extend: 'Ext.container.container',
         *         controller: 'user'
         *     });
         *     // Or
         *     Ext.define('UserContainer', {
         *         extend: 'Ext.container.container',
         *         controller: {
         *             type: 'user',
         *             someConfig: true
         *         }
         *     });
         *
         *     // Can also instance at runtime
         *     var ctrl = new MyApp.UserController();
         *     var view = new UserContainer({
         *         controller: ctrl
         *     });
         */
        controller?: string|any|Ext.app.ViewController;

        /**
         * If 'true', this component will be the default scope (this pointer) for events
         * specified with string names so that the scope can be dynamically resolved. The
         * component will automatically become the defaultListenerScope if a
         * {@link #controller} is specified.
         *
         * See the introductory docs for {@link Ext.container.Container} for some sample
         * usages.
         *
         * **NOTE**: This value can only be reliably set at construction time. Setting it
         * after that time may not correctly rewire all of the potentially effected
         * listeners.
         */
        defaultListenerScope?: boolean;

        /**
         * One or more names of config properties that this component should publish
         * to its ViewModel. Generally speaking, only properties defined in a class config
         * block (including ancestor config blocks and mixins) are eligible for publishing
         * to the viewModel. Some components override this and publish their most useful
         * configs by default.
         *
         * **Note:** We'll discuss publishing properties **not** found in the config block below.
         *
         * Values determined to be invalid by component (often form fields and model validations)
         * will not be published to the ViewModel.
         *
         * This config uses the '{@link #cfg-reference}' to determine the name of the data
         * object to place in the 'ViewModel'. If 'reference' is not set then this config
         * is ignored.
         *
         * By using this config and '{@link #cfg-reference}' you can bind configs between
         * components. For example:
         *
         *      ...
         *          items: [{
         *              xtype: 'textfield',
         *              reference: 'somefield',  // component's name in the ViewModel
         *              publishes: 'value' // value is not published by default
         *          },{
         *              ...
         *          },{
         *              xtype: 'displayfield',
         *              bind: 'You have entered "{somefield.value}"'
         *          }]
         *      ...
         *
         * Classes must provide this config as an Object:
         *
         *      Ext.define('App.foo.Bar', {
         *          publishes: {
         *              foo: true,
         *              bar: true
         *          }
         *      });
         *
         * This is required for the config system to properly merge values from derived
         * classes.
         *
         * For instances this value can be specified as a value as show above or an array
         * or object as follows:
         *
         *      {
         *          xtype: 'textfield',
         *          reference: 'somefield',
         *          publishes: [
         *              'value',
         *              'rawValue',
         *              'dirty'
         *          ]
         *      }
         *
         *      // This achieves the same result as the above array form.
         *      {
         *          xtype: 'textfield',
         *          reference: 'somefield',
         *          publishes: {
         *              value: true,
         *              rawValue: true,
         *              dirty: true
         *          }
         *      }
         *
         * In some cases, users may want to publish a property to the viewModel that is not found in a class
         * config block. In these situations, you may utilize {@link #publishState} if the property has a
         * setter method.  Let's use {@link Ext.form.Labelable#setFieldLabel setFieldLabel} as an example:
         *
         *       setFieldLabel: function(fieldLabel) {
         *           this.callParent(arguments);
         *           this.publishState('fieldLabel', fieldLabel);
         *       }
         *
         * With the above chunk of code, fieldLabel may now be published to the viewModel.
         *
         * @since 5.0.0
         */
        publishes?: string|any;

        /**
         * Specifies a name for this component inside its component hierarchy. This name
         * must be unique within its {@link Ext.container.Container#referenceHolder view}
         * or its {@link Ext.app.ViewController ViewController}. See the documentation in
         * {@link Ext.container.Container} for more information about references.
         *
         * **Note**: Valid identifiers start with a letter or underscore and are followed
         * by zero or more additional letters, underscores or digits. References are case
         * sensitive.
         */
        reference?: string;

        /**
         * If provided this creates a new 'Session' instance for this component. If this
         * is a 'Container', this will then be inherited by all child components.
         *
         * To create a new session you can specify 'true':
         *
         *      Ext.create({
         *          xtype: 'viewport',
         *          session: true,
         *
         *          items: [{
         *              ...
         *          }]
         *      });
         *
         * Alternatively, a config object can be provided:
         *
         *      Ext.create({
         *          xtype: 'viewport',
         *          session: {
         *              ...
         *          },
         *
         *          items: [{
         *              ...
         *          }]
         *      });
         *
         * Optional, Defaults to: null
         */
        session?: boolean|any|Ext.data.Session;

        /**
         * This object holds a map of 'config' properties that will update their binding
         * as they are modified. For example, 'value' is a key added by form fields. The
         * form of this config is the same as '{@link #publishes}'.
         *
         * This config is defined so that updaters are not created and added for all
         * bound properties since most cannot be modified by the end-user and hence are
         * not appropriate for two-way binding.
         */
        twoWayBindable?: string|any;

        /**
         * The 'ViewModel' is a data provider for this component and its children. The
         * data contained in the 'ViewModel' is typically used by adding 'bind' configs
         * to the components that want present or edit this data.
         *
         * When set, the 'ViewModel' is created and links to any inherited 'viewModel'
         * instance from an ancestor container as the "parent". The 'ViewModel' hierarchy,
         * once established, only supports creation or destruction of children. The
         * parent of a 'ViewModel' cannot be changed on the fly.
         *
         * If this is a root-level 'ViewModel', the data model connection is made to this
         * component's associated '{@link Ext.data.Session Data Session}'. This is
         * determined by calling 'getInheritedSession'.
         */
        viewModel?: string|any|Ext.app.ViewModel;
    }

    /**
     * This class is intended as a mixin for classes that want to provide a "bind" config that
     * connects to a 'ViewModel'.
     * @since 5.0.0
     */
    export class Bindable extends Ext.Base implements Ext.mixin.BindableConfig {
        /**
         * This property is used to determine the property of a 'bind' config that is just
         * the value. For example, if 'defaultBindProperty="value"', then this shorthand
         * 'bind' config:
         *
         *      bind: '{name}'
         *
         * Is equivalent to this object form:
         *
         *      bind: {
         *          value: '{name}'
         *      }
         *
         * The 'defaultBindProperty' is set to "value" for form fields and to "store" for
         * grids and trees.
         *
         * Optional
         */
        protected defaultBindProperty: string;

        /**
         * Setting this config option adds or removes data bindings for other configs.
         * For example, to bind the 'title' config:
         *
         *      var panel = Ext.create({
         *          xtype: 'panel',
         *          bind: {
         *              title: 'Hello {user.name}'
         *          }
         *      });
         *
         * To dynamically add bindings:
         *
         *      panel.setBind({
         *          title: 'Greetings {user.name}!'
         *      });
         *
         * To remove bindings:
         *
         *      panel.setBind({
         *          title: null
         *      });
         *
         * The bind expressions are presented to '{@link Ext.app.ViewModel#bind}'. The
         * 'ViewModel' instance is determined by 'lookupViewModel'.
         *
         * Optional
         */
        bind: any;

        /**
         * A string alias, a configuration object or an instance of a 'ViewController' for
         * this container. Sample usage:
         *
         *     Ext.define('MyApp.UserController', {
         *         alias: 'controller.user'
         *     });
         *
         *     Ext.define('UserContainer', {
         *         extend: 'Ext.container.container',
         *         controller: 'user'
         *     });
         *     // Or
         *     Ext.define('UserContainer', {
         *         extend: 'Ext.container.container',
         *         controller: {
         *             type: 'user',
         *             someConfig: true
         *         }
         *     });
         *
         *     // Can also instance at runtime
         *     var ctrl = new MyApp.UserController();
         *     var view = new UserContainer({
         *         controller: ctrl
         *     });
         */
        controller: string|any|Ext.app.ViewController;

        /**
         * If 'true', this component will be the default scope (this pointer) for events
         * specified with string names so that the scope can be dynamically resolved. The
         * component will automatically become the defaultListenerScope if a
         * {@link #controller} is specified.
         *
         * See the introductory docs for {@link Ext.container.Container} for some sample
         * usages.
         *
         * **NOTE**: This value can only be reliably set at construction time. Setting it
         * after that time may not correctly rewire all of the potentially effected
         * listeners.
         */
        defaultListenerScope: boolean;

        /**
         * One or more names of config properties that this component should publish
         * to its ViewModel. Generally speaking, only properties defined in a class config
         * block (including ancestor config blocks and mixins) are eligible for publishing
         * to the viewModel. Some components override this and publish their most useful
         * configs by default.
         *
         * **Note:** We'll discuss publishing properties **not** found in the config block below.
         *
         * Values determined to be invalid by component (often form fields and model validations)
         * will not be published to the ViewModel.
         *
         * This config uses the '{@link #cfg-reference}' to determine the name of the data
         * object to place in the 'ViewModel'. If 'reference' is not set then this config
         * is ignored.
         *
         * By using this config and '{@link #cfg-reference}' you can bind configs between
         * components. For example:
         *
         *      ...
         *          items: [{
         *              xtype: 'textfield',
         *              reference: 'somefield',  // component's name in the ViewModel
         *              publishes: 'value' // value is not published by default
         *          },{
         *              ...
         *          },{
         *              xtype: 'displayfield',
         *              bind: 'You have entered "{somefield.value}"'
         *          }]
         *      ...
         *
         * Classes must provide this config as an Object:
         *
         *      Ext.define('App.foo.Bar', {
         *          publishes: {
         *              foo: true,
         *              bar: true
         *          }
         *      });
         *
         * This is required for the config system to properly merge values from derived
         * classes.
         *
         * For instances this value can be specified as a value as show above or an array
         * or object as follows:
         *
         *      {
         *          xtype: 'textfield',
         *          reference: 'somefield',
         *          publishes: [
         *              'value',
         *              'rawValue',
         *              'dirty'
         *          ]
         *      }
         *
         *      // This achieves the same result as the above array form.
         *      {
         *          xtype: 'textfield',
         *          reference: 'somefield',
         *          publishes: {
         *              value: true,
         *              rawValue: true,
         *              dirty: true
         *          }
         *      }
         *
         * In some cases, users may want to publish a property to the viewModel that is not found in a class
         * config block. In these situations, you may utilize {@link #publishState} if the property has a
         * setter method.  Let's use {@link Ext.form.Labelable#setFieldLabel setFieldLabel} as an example:
         *
         *       setFieldLabel: function(fieldLabel) {
         *           this.callParent(arguments);
         *           this.publishState('fieldLabel', fieldLabel);
         *       }
         *
         * With the above chunk of code, fieldLabel may now be published to the viewModel.
         *
         * @since 5.0.0
         */
        publishes: string|any;

        /**
         * Specifies a name for this component inside its component hierarchy. This name
         * must be unique within its {@link Ext.container.Container#referenceHolder view}
         * or its {@link Ext.app.ViewController ViewController}. See the documentation in
         * {@link Ext.container.Container} for more information about references.
         *
         * **Note**: Valid identifiers start with a letter or underscore and are followed
         * by zero or more additional letters, underscores or digits. References are case
         * sensitive.
         */
        reference: string;

        /**
         * If provided this creates a new 'Session' instance for this component. If this
         * is a 'Container', this will then be inherited by all child components.
         *
         * To create a new session you can specify 'true':
         *
         *      Ext.create({
         *          xtype: 'viewport',
         *          session: true,
         *
         *          items: [{
         *              ...
         *          }]
         *      });
         *
         * Alternatively, a config object can be provided:
         *
         *      Ext.create({
         *          xtype: 'viewport',
         *          session: {
         *              ...
         *          },
         *
         *          items: [{
         *              ...
         *          }]
         *      });
         *
         * Optional, Defaults to: null
         */
        session: boolean|any|Ext.data.Session;

        /**
         * This object holds a map of 'config' properties that will update their binding
         * as they are modified. For example, 'value' is a key added by form fields. The
         * form of this config is the same as '{@link #publishes}'.
         *
         * This config is defined so that updaters are not created and added for all
         * bound properties since most cannot be modified by the end-user and hence are
         * not appropriate for two-way binding.
         */
        twoWayBindable: string|any;

        /**
         * The 'ViewModel' is a data provider for this component and its children. The
         * data contained in the 'ViewModel' is typically used by adding 'bind' configs
         * to the components that want present or edit this data.
         *
         * When set, the 'ViewModel' is created and links to any inherited 'viewModel'
         * instance from an ancestor container as the "parent". The 'ViewModel' hierarchy,
         * once established, only supports creation or destruction of children. The
         * parent of a 'ViewModel' cannot be changed on the fly.
         *
         * If this is a root-level 'ViewModel', the data model connection is made to this
         * component's associated '{@link Ext.data.Session Data Session}'. This is
         * determined by calling 'getInheritedSession'.
         */
        viewModel: string|any|Ext.app.ViewModel;

        getBind();

        /**
         * Returns the {@link Ext.app.ViewController} instance associated with this
         * component via the {@link #controller} config or {@link #setController} method.
         * @return {Ext.app.ViewController} Returns this component's ViewController or
         * null if one was not configured
         */
        getController(): Ext.app.ViewController;

        getDefaultListenerScope();

        getPublishes();

        getReference();

        getSession();

        getTwoWayBindable();

        getViewModel();

        /**
         * Called by 'getInherited' to initialize the inheritedState the first time it is
         * requested.
         */
        protected initInheritedState();

        /**
         * Checks if a particular binding is synchronizing the value.
         * @param {String} name The name of the property being bound to.
         * @return {Boolean} 'true' if the binding is syncing.
         */
        protected isSyncing(name: string): boolean;

        /**
         * Gets the controller that controls this view. May be a controller that belongs
         * to a view higher in the hierarchy.
         *
         * @param {Boolean} [skipThis=false] 'true' to not consider the controller directly attached
         * to this view (if it exists).
         * @return {Ext.app.ViewController} The controller. 'null' if no controller is found.
         *
         * @since 5.0.1
         */
        lookupController(skipThis?: boolean): Ext.app.ViewController;

        /**
         * Returns the 'Ext.data.Session' for this instance. This property may come
         * from this instance's '{@link #session}' or be inherited from this object's parent.
         * @param {Boolean} [skipThis=false] Pass 'true' to ignore a 'session' configured on
         * this instance and only consider an inherited session.
         * @return {Ext.data.Session}
         * @since 5.0.0
         */
        lookupSession(skipThis?: boolean): Ext.data.Session;

        /**
         * Returns the 'Ext.app.ViewModel' for this instance. This property may come from this
         * this instance's '{@link #viewModel}' or be inherited from this object's parent.
         * @param {Boolean} [skipThis=false] Pass 'true' to ignore a 'viewModel' configured on
         * this instance and only consider an inherited view model.
         * @return {Ext.app.ViewModel}
         * @since 5.0.0
         */
        lookupViewModel(skipThis?: boolean): Ext.app.ViewModel;

        /**
         * Publish this components state to the 'ViewModel'. If no arguments are given (or if
         * this is the first call), the entire state is published. This state is determined by
         * the 'publishes' property.
         *
         * This method is called only by component authors.
         *
         * @param {String} [property] The name of the property to update.
         * @param {Object} [value] The value of 'property'. Only needed if 'property' is given.
         * @since 5.0.0
         */
        protected publishState(property?: string, value?: any);

        setBind();

        setController();

        setDefaultListenerScope();

        setPublishes();

        setReference();

        setSession();

        setTwoWayBindable();

        setViewModel();
    }

    /**
     * A mixin that gives Ext.Component and Ext.Widget the ability to process the "delegate"
     * event option.
     */
    export class ComponentDelegation extends Ext.Mixin {
    }

    interface ContainerConfig {
        /**
         * If 'true', this container will be marked as being a point in the hierarchy where
         * references to items with a specified 'reference' config will be held. The container
         * will automatically become a referenceHolder if a {@link #controller} is specified.
         *
         * See the introductory docs for {@link Ext.container.Container} for more information
         * about references & reference holders.
         */
        referenceHolder?: boolean;
    }

    /**
     * Common methods for both classic & modern containers
     */
    export class Container extends Ext.Mixin implements Ext.mixin.ContainerConfig {
        /**
         * 'true' in this class to identify an object as an instantiated Container, or subclass thereof.
         */
        isContainer: boolean;

        /**
         * If 'true', this container will be marked as being a point in the hierarchy where
         * references to items with a specified 'reference' config will be held. The container
         * will automatically become a referenceHolder if a {@link #controller} is specified.
         *
         * See the introductory docs for {@link Ext.container.Container} for more information
         * about references & reference holders.
         */
        referenceHolder: boolean;

        getReferenceHolder();

        /**
         * Returns an object holding the descendants of this view keyed by their
         * '{@link Ext.Component#cfg-reference reference}'. This object should not be held
         * past the scope of the function calling this method. It will not be valid if items
         * are added or removed from this or any sub-container.
         *
         * The intended usage is shown here (assume there are 3 components with reference
         * values of "foo", "bar" and "baz" at some level below this container):
         *
         *      onClick: function () {
         *          var refs = this.getReferences();
         *
         *          // using "refs" we can access any descendant by its "reference"
         *
         *          refs.foo.getValue() + refs.bar.getValue() + refs.baz.getValue();
         *      }
         *
         * If 'this' component has a '{@link Ext.Component#cfg-reference reference}' assigned
         * to it, that is **not** included in this object. That reference is understood to
         * belong to the ancestor container configured as the 'referenceHolder'.
         *
         * @return {Object} An object with each child reference. This will be 'null' if this
         * container has no descendants with a '{@link Ext.Component#cfg-reference reference}'
         * specified.
         * @since 5.0.0
         */
        getReferences(): any;

        /**
         * Gets a reference to the component with the specified {@link #reference} value.
         *
         * The method is a short-hand for the {@link #lookupReference} method.
         *
         * @param {String} key The name of the reference to lookup.
         * @return {Ext.Component} The referenced component or 'null' if it is not found.
         * @since 6.0.1
         */
        lookup(key: string): Ext.Component;

        /**
         * Gets a reference to the component with the specified {@link #reference} value.
         *
         * The {@link #lookup} method is a short-hand version of this method.
         *
         * @param {String} key The name of the reference to lookup.
         * @return {Ext.Component} The referenced component or 'null' if it is not found.
         * @since 5.0
         */
        lookupReference(key: string): Ext.Component;

        setReferenceHolder();
    }

    /**
     * This mixin automates use of 'Ext.Factory'. When mixed in to a class, the 'alias' of the
     * class is retrieved and combined with an optional 'factoryConfig' property on that class
     * to produce the configuration to pass to 'Ext.Factory'.
     *
     * The factory method created by 'Ext.Factory' is also added as a static method to the
     * target class.
     *
     * Given a class declared like so:
     *
     *      Ext.define('App.bar.Thing', {
     *          mixins: [
     *              'Ext.mixin.Factoryable'
     *          ],
     *
     *          alias: 'bar.thing',  // this is detected by Factoryable
     *
     *          factoryConfig: {
     *              defaultType: 'thing',  // this is the default deduced from the alias
     *              // other configs
     *          },
     *
     *          ...
     *      });
     *
     * The produced factory function can be used to create instances using the following
     * forms:
     *
     *      var obj;
     *
     *      obj = App.bar.Thing.create('thing'); // same as "new App.bar.Thing()"
     *
     *      obj = App.bar.Thing.create({
     *          type: 'thing'       // same as above
     *      });
     *
     *      obj = App.bar.Thing.create({
     *          xclass: 'App.bar.Thing'  // same as above
     *      });
     *
     *      var obj2 = App.bar.Thing.create(obj);
     *      // obj === obj2  (passing an instance returns the instance)
     *
     * Alternatively the produced factory is available as a static method of 'Ext.Factory'.
     *
     * @since 5.0.0
     */
    export class Factoryable extends Ext.Base {
        /**
         * If this property is specified by the target class of this mixin its properties are
         * used to configure the created 'Ext.Factory'.
         *
         * Optional
         */
        factoryConfig: any;
    }

    export class Hookable extends Ext.Mixin {
    }

    /**
     * An Identifiable mixin.
     */
    export class Identifiable extends Ext.Base {
        /**
         * Retrieves the id of this component. Will autogenerate an id if one has not already been set.
         * @return {String} id
         */
        getId(): string;
    }

    /**
     * A mixin that provides the functionality for inheritable configs. This allows linking
     * components and containers via a prototype-chained object for accessing inherited
     * values.
     *
     * ## Getting Inherited Properties
     *
     * A component's inherited state is used to keep track of aspects of a component's state
     * that might be influenced by its ancestors like "collapsed" and "hidden". For example:
     *
     *      var hidden = this.getInheritedConfig('hidden');
     *
     * The above will produce 'true' if this or any ancestor component has its 'hidden' config
     * set to 'true'.
     *
     * ## Chained Objects
     *
     * Inheritable properties are implemented by chaining each component's inherited state
     * object to its parent container's inherited state object via the prototype. The result
     * is such that if a component's 'inheritedState' does not have it's own property, it
     * inherits the property from the nearest ancestor that does.
     *
     * In the case of a Container, two state objects are created. The primary ("outer") object
     * is used for reading inherited properties. It is also what a child will prototype chain
     * to if that child is not part of the container's 'items' collection. Anything in the
     * 'items' collection will chain to the inheritedStateInner object instead. This object is
     * prototype chained to inheritedState but allows for Container's layout to set inherited
     * properties that specifically apply only to children of the container. This inner object
     * is unlikely to be needed by user code.
     *
     * ## Publishing Inherited Properties
     *
     * The first step to publishing inherited properties is to override 'initInheritedState'
     * and add properties that have inheritable values.
     *
     *      initInheritedState: function (inheritedState) {
     *          this.callParent(arguments);
     *
     *          if (this.getHidden()) {
     *              inheritedState.hidden = true;
     *          }
     *      }
     *
     * The above is important because 'initInheritedState' is called whenever the object needs
     * to be repopulated. As you can see, only 'true' values are added to 'inheritedState' in
     * this case because 'false' would mask a 'hidden' value of 'true' from an ancestor.
     *
     * If these values change dynamically, these properties must be maintained. For example:
     *
     *      updateHidden: function (hidden) {
     *          var inherited = this.getInherited();
     *
     *          if (hidden) {
     *              inherited.hidden = true;
     *          } else {
     *              // Unmask whatever may be inherited:
     *              delete inherited.hidden;
     *          }
     *      }
     *
     * ## Proper Usage
     *
     * ALWAYS access inherited state using 'getInherited' or 'getInheritedConfig', not by
     * accessing 'inheritedState' directly.
     *
     * The 'inheritedState' property does not exist until the first call to 'getInherited'. At
     * that point 'getInherited' walks up the component tree to establish the 'inheritedState'
     * prototype chain. Additionally the 'inheritedState' property should NOT be relied upon
     * even after the initial call to 'getInherited' because it is possible for it to become
     * invalid.
     *
     * Invalidation typically happens when a component is moved to a new container. In such a
     * case the 'inheritedState' remains invalid until the next time 'getInherited' is called
     * on the component or one of its descendants.
     * @since 5.0.0
     */
    export class Inheritable extends Ext.Mixin {
        /**
         * This method returns an object containing the inherited properties for this instance.
         *
         * @param {Boolean} [inner=false] Pass 'true' to return 'inheritedStateInner' instead
         * of the normal 'inheritedState' object. This is only needed internally and should
         * not be passed by user code.
         *
         * @return {Object} The 'inheritedState' object containing inherited properties.
         * @since 5.0.0
         */
        getInherited(inner?: boolean): any;

        /**
         * This method returns the value of a config property that may be inherited from some
         * ancestor.
         *
         * In some cases, a config may be explicitly set on a component with the intent of
         * *only* being presented to its children while that component should act upon the
         * inherited value (see 'referenceHolder' for example). In these cases the 'skipThis'
         * parameter should be specified as 'true'.
         *
         * @param {String} property The name of the config property to return.
         * @param {Boolean} [skipThis=false] Pass 'true' if the property should be ignored if
         * found on this instance. In other words, 'true' means the property must be inherited
         * and not explicitly set on this instance.
         * @return {Mixed} The value of the requested 'property'.
         * @since 5.0.0
         */
        getInheritedConfig(property: string, skipThis?: boolean): any;

        /**
         * Used by {@link Ext.ComponentQuery ComponentQuery}, and the {@link Ext.Component#up up}
         * method to find the owning Component in the linkage hierarchy.
         *
         * By default this returns the Container which contains this Component.
         *
         * This may be overridden by Component authors who implement ownership hierarchies
         * which are not based upon ownerCt, such as BoundLists being owned by Fields or Menus
         * being owned by Buttons.
         */
        protected getRefOwner();

        /**
         * This method is called to initialize the 'inheritedState' objects for this instance.
         * This amounts to typically copying certain properties from the instance to the given
         * object.
         *
         * @param {Object} inheritedState The state object for this instance.
         * @param {Object} [inheritedStateInner] This object is only provided for containers.
         * @since 5.0.0
         */
        protected initInheritedState(inheritedState: any, inheritedStateInner?: any);

        /**
         * Called when this Inheritable is added to a parent
         */
        onInheritedAdd(instanced: boolean);

        /**
         * Called when this inheritable is removed from a parent
         * @param {Boolean} destroying 'true' if this item will be destroyed by it's container
         */
        onInheritedRemove(destroying: boolean);

        /**
         * Gets the Controller or Component that is used as the event root for this view.
         *
         * @param {Object} [defaultScope=this] The default scope to return if none is found.
         * @return {Ext.app.ViewController/Ext.container.Container} The default listener scope.
         *
         * @since 5.0.0
         */
        protected resolveListenerScope(defaultScope?: any): Ext.app.ViewController|Ext.Container;

        /**
         * Returns the default listener scope for a "satellite" of this component.
         * Used for resolving scope for observable objects that are not part of the normal
         * Container/Component hierarchy (for example, plugins)
         *
         * @param {Object} [defaultScope]
         * @return {Object} The listener scope
         * @since 5.1.1
         */
        protected resolveSatelliteListenerScope(satellite: Ext.mixin.Observable, defaultScope?: any): any;
    }

    /**
     * This mixin allows users to easily require external scripts in their classes. This load
     * process delays application launch ('Ext.onReady') until all such scripts are loaded
     * ensuring that your class will have access to its required scripts from the start.
     *
     * For example:
     *
     *      Ext.define('Feed', {
     *          mixins: 'Ext.mixin.Mashup',
     *
     *          requiredScripts: [
     *              'http://www.foo.com/code/bar.js'
     *          ],
     *
     *          // The code in "bar.js" will be available at application launch
     *      });
     *
     * @since 5.0.0
     * @cmd.optimizer.requires.async
     */
    export class Mashup extends Ext.Base {
    }

    interface ObservableConfig {
        /**
         * A config object containing one or more event handlers to be added to this object during initialization. This
         * should be a valid listeners config object as specified in the
         * {@link Ext.util.Observable#addListener addListener} example for attaching
         * multiple handlers at once.
         *
         * **DOM events from Ext JS {@link Ext.Component Components}**
         *
         * While _some_ Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
         * only done when extra value can be added. For example the {@link Ext.view.View DataView}'s **'{@link
         * Ext.view.View#itemclick itemclick}'** event passing the node clicked on. To access DOM events directly from a
         * child element of a Component, we need to specify the 'element' option to identify the Component property to add a
         * DOM listener to:
         *
         *     new Ext.panel.Panel({
         *         width: 400,
         *         height: 200,
         *         dockedItems: [{
         *             xtype: 'toolbar'
         *         }],
         *         listeners: {
         *             click: {
         *                 element: 'el', //bind to the underlying el property on the panel
         *                 fn: function(){ console.log('click el'); }
         *             },
         *             dblclick: {
         *                 element: 'body', //bind to the underlying body property on the panel
         *                 fn: function(){ console.log('dblclick body'); }
         *             }
         *         }
         *     });
         */
        listeners?: any;
    }

    /**
     * Base class that provides a common interface for publishing events. Subclasses are
     * expected to have a property "events" which is populated as event listeners register,
     * and, optionally, a property "listeners" with configured listeners defined.
     *
     * *Note*: This mixin requires the constructor to be called, which is typically done
     * during the construction of your object. The Observable constructor will call
     * {@link #initConfig}, so it does not need to be called a second time.
     *
     * For example:
     *
     *     Ext.define('Employee', {
     *         mixins: ['Ext.mixin.Observable'],
     *
     *         config: {
     *             name: ''
     *         },
     *
     *         constructor: function (config) {
     *             // The 'listeners' property is processed to add listeners and the config
     *             // is applied to the object.
     *             this.mixins.observable.constructor.call(this, config);
     *             // Config has been initialized
     *             console.log(this.getEmployeeName());
     *         }
     *     });
     *
     * This could then be used like this:
     *
     *     var newEmployee = new Employee({
     *         name: employeeName,
     *         listeners: {
     *             quit: function() {
     *                 // By default, "this" will be the object that fired the event.
     *                 alert(this.getName() + " has quit!");
     *             }
     *         }
     *     });
     */
    export class Observable extends Ext.Base implements Ext.mixin.ObservableConfig {
        /**
         * @readonly
         * This object holds a key for any event that has a listener. The listener may be set
         * directly on the instance, or on its class or a super class (via {@link #observe}) or
         * on the {@link Ext.app.EventBus MVC EventBus}. The values of this object are truthy
         * (a non-zero number) and falsy (0 or undefined). They do not represent an exact count
         * of listeners. The value for an event is truthy if the event must be fired and is
         * falsy if there is no need to fire the event.
         *
         * The intended use of this property is to avoid the expense of fireEvent calls when
         * there are no listeners. This can be particularly helpful when one would otherwise
         * have to call fireEvent hundreds or thousands of times. It is used like this:
         *
         *      if (this.hasListeners.foo) {
         *          this.fireEvent('foo', this, arg1);
         *      }
         */
        hasListeners: any;

        /**
         * 'true' in this class to identify an object as an instantiated Observable, or subclass thereof.
         */
        isObservable: boolean;

        /**
         * A config object containing one or more event handlers to be added to this object during initialization. This
         * should be a valid listeners config object as specified in the
         * {@link Ext.util.Observable#addListener addListener} example for attaching
         * multiple handlers at once.
         *
         * **DOM events from Ext JS {@link Ext.Component Components}**
         *
         * While _some_ Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
         * only done when extra value can be added. For example the {@link Ext.view.View DataView}'s **'{@link
         * Ext.view.View#itemclick itemclick}'** event passing the node clicked on. To access DOM events directly from a
         * child element of a Component, we need to specify the 'element' option to identify the Component property to add a
         * DOM listener to:
         *
         *     new Ext.panel.Panel({
         *         width: 400,
         *         height: 200,
         *         dockedItems: [{
         *             xtype: 'toolbar'
         *         }],
         *         listeners: {
         *             click: {
         *                 element: 'el', //bind to the underlying el property on the panel
         *                 fn: function(){ console.log('click el'); }
         *             },
         *             dblclick: {
         *                 element: 'body', //bind to the underlying body property on the panel
         *                 fn: function(){ console.log('dblclick body'); }
         *             }
         *         }
         *     });
         */
        listeners: any;

        /**
         * Alias for {@link #onAfter}.
         */
        addAfterListener();

        /**
         * Alias for {@link #onBefore}.
         */
        addBeforeListener();

        /**
         * The {@link #on} method is shorthand for
         * {@link Ext.util.Observable#addListener addListener}.
         *
         * Appends an event handler to this object.  For example:
         *
         *     myGridPanel.on("itemclick", this.onItemClick, this);
         *
         * The method also allows for a single argument to be passed which is a config object
         * containing properties which specify multiple events. For example:
         *
         *     myGridPanel.on({
         *         cellclick: this.onCellClick,
         *         select: this.onSelect,
         *         viewready: this.onViewReady,
         *         scope: this // Important. Ensure "this" is correct during handler execution
         *     });
         *
         * One can also specify options for each event handler separately:
         *
         *     myGridPanel.on({
         *         cellclick: {fn: this.onCellClick, scope: this, single: true},
         *         viewready: {fn: panel.onViewReady, scope: panel}
         *     });
         *
         * *Names* of methods in a specified scope may also be used:
         *
         *     myGridPanel.on({
         *         cellclick: {fn: 'onCellClick', scope: this, single: true},
         *         viewready: {fn: 'onViewReady', scope: panel}
         *     });
         *
         * @param {String/Object} eventName The name of the event to listen for.
         * May also be an object who's property names are event names.
         *
         * @param {Function/String} [fn] The method the event invokes or the *name* of
         * the method within the specified 'scope'.  Will be called with arguments
         * given to {@link Ext.util.Observable#fireEvent} plus the 'options' parameter described
         * below.
         *
         * @param {Object} [scope] The scope ('this' reference) in which the handler function is
         * executed. **If omitted, defaults to the object which fired the event.**
         *
         * @param {Object} [options] An object containing handler configuration.
         *
         * **Note:** The options object will also be passed as the last argument to every
         * event handler.
         *
         * This object may contain any of the following properties:
         *
         *   The scope ('this' reference) in which the handler function is executed. **If omitted,
         *   defaults to the object which fired the event.**
         *
         *   The number of milliseconds to delay the invocation of the handler after the event
         *   fires.
         *
         *   True to add a handler to handle just the next firing of the event, and then remove
         *   itself.
         *
         *   Causes the handler to be scheduled to run in an {@link Ext.util.DelayedTask} delayed
         *   by the specified number of milliseconds. If the event fires again within that time,
         *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
         *
         *   Causes the handler to be scheduled to run at the next
         *   {@link Ext.Function#requestAnimationFrame animation frame event}. If the
         *   event fires again before that time, the handler is not rescheduled - the handler
         *   will only be called once when the next animation frame is fired, with the last set
         *   of arguments passed.
         *
         *   Only call the handler if the event was fired on the target Observable, _not_ if the
         *   event was bubbled up from a child Observable.
         *
         *   **This option is only valid for listeners bound to {@link Ext.Component Components}.**
         *   The name of a Component property which references an {@link Ext.dom.Element element}
         *   to add a listener to.
         *
         *   This option is useful during Component construction to add DOM event listeners to
         *   elements of {@link Ext.Component Components} which will exist only after the
         *   Component is rendered.
         *
         *   For example, to add a click listener to a Panel's body:
         *
         *       var panel = new Ext.panel.Panel({
         *           title: 'The title',
         *           listeners: {
         *               click: this.handlePanelClick,
         *               element: 'body'
         *           }
         *       });
         *
         * In order to remove listeners attached using the element, you'll need to reference
         * the element itself as seen below.
         *
         *      panel.body.un(...)
         *
         * @param {String} [options.delegate]
         *   A simple selector to filter the event target or look for a descendant of the target.
         *
         *   The "delegate" option is only available on Ext.dom.Element instances (or
         *   when attaching a listener to a Ext.dom.Element via a Component using the
         *   element option).
         *
         *   See the *delegate* example below.
         *
         * @param {Boolean} [options.stopPropagation]
         *   **This option is only valid for listeners bound to {@link Ext.dom.Element Elements}.**
         *   'true' to call {@link Ext.event.Event#stopPropagation stopPropagation} on the event object
         *   before firing the handler.
         *
         * @param {Boolean} [options.preventDefault]
         *   **This option is only valid for listeners bound to {@link Ext.dom.Element Elements}.**
         *   'true' to call {@link Ext.event.Event#preventDefault preventDefault} on the event object
         *   before firing the handler.
         *
         * @param {Boolean} [options.stopEvent]
         *   **This option is only valid for listeners bound to {@link Ext.dom.Element Elements}.**
         *   'true' to call {@link Ext.event.Event#stopEvent stopEvent} on the event object
         *   before firing the handler.
         *
         * @param {Array} [options.args]
         *   Optional arguments to pass to the handler function. Any additional arguments
         *   passed to {@link Ext.util.Observable#fireEvent fireEvent} will be appended
         *   to these arguments.
         *
         * @param {Boolean} [options.destroyable=false]
         *   When specified as 'true', the function returns a 'destroyable' object. An object
         *   which implements the 'destroy' method which removes all listeners added in this call.
         *   This syntax can be a helpful shortcut to using {@link #un}; particularly when
         *   removing multiple listeners.  *NOTE* - not compatible when using the _element_
         *   option.  See {@link #un} for the proper syntax for removing listeners added using the
         *   _element_ config.
         *
         * @param {Number} [options.priority]
         *   An optional numeric priority that determines the order in which event handlers
         *   are run. Event handlers with no priority will be run as if they had a priority
         *   of 0. Handlers with a higher priority will be prioritized to run sooner than
         *   those with a lower priority.  Negative numbers can be used to set a priority
         *   lower than the default. Internally, the framework uses a range of 1000 or
         *   greater, and -1000 or lesser for handlers that are intended to run before or
         *   after all others, so it is recommended to stay within the range of -999 to 999
         *   when setting the priority of event handlers in application-level code.
         *   A priority must be an integer to be valid.  Fractional values are reserved for
         *   internal framework use.
         *
         * @param {String} [options.order='current']
         *   A legacy option that is provided for backward compatibility.
         *   It is recommended to use the 'priority' option instead.  Available options are:
         *
         *   - ''before'': equal to a priority of '100'
         *   - ''current'': equal to a priority of '0' or default priority
         *   - ''after'': equal to a priority of '-100'
         *
         * @param {String} [order='current']
         *   A shortcut for the 'order' event option.  Provided for backward compatibility.
         *   Please use the 'priority' event option instead.
         *
         *
         * **Combining Options**
         *
         * Using the options argument, it is possible to combine different types of listeners:
         *
         * A delayed, one-time listener.
         *
         *     myPanel.on('hide', this.handleClick, this, {
         *         single: true,
         *         delay: 100
         *     });
         *
         * **Attaching multiple handlers in 1 call**
         *
         * The method also allows for a single argument to be passed which is a config object
         * containing properties which specify multiple handlers and handler configs.
         *
         *     grid.on({
         *         itemclick: 'onItemClick',
         *         itemcontextmenu: grid.onItemContextmenu,
         *         destroy: {
         *             fn: function () {
         *                 // function called within the 'altCmp' scope instead of grid
         *             },
         *             scope: altCmp // unique scope for the destroy handler
         *         },
         *         scope: grid       // default scope - provided for example clarity
         *     });
         *
         * **Delegate**
         *
         * This is a configuration option that you can pass along when registering a handler for
         * an event to assist with event delegation. By setting this configuration option
         * to a simple selector, the target element will be filtered to look for a
         * descendant of the target. For example:
         *
         *     var panel = Ext.create({
         *         xtype: 'panel',
         *         renderTo: document.body,
         *         title: 'Delegate Handler Example',
         *         frame: true,
         *         height: 220,
         *         width: 220,
         *         html: '<h1 class="myTitle">BODY TITLE</h1>Body content'
         *     });
         *
         *     // The click handler will only be called when the click occurs on the
         *     // delegate: h1.myTitle ("h1" tag with class "myTitle")
         *     panel.on({
         *         click: function (e) {
         *             console.log(e.getTarget().innerHTML);
         *         },
         *         element: 'body',
         *         delegate: 'h1.myTitle'
         *      });
         *
         * @return {Object} **Only when the 'destroyable' option is specified. **
         *
         *  A 'Destroyable' object. An object which implements the 'destroy' method which removes
         *  all listeners added in this call. For example:
         *
         *     this.btnListeners =  = myButton.on({
         *         destroyable: true
         *         mouseover:   function() { console.log('mouseover'); },
         *         mouseout:    function() { console.log('mouseout'); },
         *         click:       function() { console.log('click'); }
         *     });
         *
         * And when those listeners need to be removed:
         *
         *     Ext.destroy(this.btnListeners);
         *
         * or
         *
         *     this.btnListeners.destroy();
         */
        addListener(eventName: string|any, fn?: Function|string, scope?: any, options?: any, options_scope?: any, options_delay?: number, options_single?: boolean, options_buffer?: number, options_onFrame?: number, options_target?: Ext.util.Observable, options_element?: string, options_delegate?: string, options_stopPropagation?: boolean, options_preventDefault?: boolean, options_stopEvent?: boolean, options_args?: any[], options_destroyable?: boolean, options_priority?: number, options_order?: string, order?: string): any;

        /**
         * The addManagedListener method is used when some object (call it "A") is listening
         * to an event on another observable object ("B") and you want to remove that listener
         * from "B" when "A" is destroyed. This is not an issue when "B" is destroyed because
         * all of its listeners will be removed at that time.
         *
         * Example:
         *
         *     Ext.define('Foo', {
         *         extend: 'Ext.Component',
         *
         *         initComponent: function () {
         *             this.addManagedListener(MyApp.SomeGlobalSharedMenu, 'show', this.doSomething);
         *             this.callParent();
         *         }
         *     });
         *
         * As you can see, when an instance of Foo is destroyed, it ensures that the 'show'
         * listener on the menu ('MyApp.SomeGlobalSharedMenu') is also removed.
         *
         * As of version 5.1 it is no longer necessary to use this method in most cases because
         * listeners are automatically managed if the scope object provided to
         * {@link Ext.util.Observable#addListener addListener} is an Observable instance.
         * However, if the observable instance and scope are not the same object you
         * still need to use 'mon' or 'addManagedListener' if you want the listener to be
         * managed.
         *
         * @param {Ext.util.Observable/Ext.dom.Element} item The item to which to add a listener/listeners.
         * @param {Object/String} ename The event name, or an object containing event name properties.
         * @param {Function/String} fn (optional) If the 'ename' parameter was an event
         * name, this is the handler function or the name of a method on the specified
         * 'scope'.
         * @param {Object} scope (optional) If the 'ename' parameter was an event name, this is the scope ('this' reference)
         * in which the handler function is executed.
         * @param {Object} options (optional) If the 'ename' parameter was an event name, this is the
         * {@link Ext.util.Observable#addListener addListener} options.
         * @return {Object} **Only when the 'destroyable' option is specified. **
         *
         *  A 'Destroyable' object. An object which implements the 'destroy' method which removes all listeners added in this call. For example:
         *
         *     this.btnListeners = myButton.mon({
         *         destroyable: true
         *         mouseover:   function() { console.log('mouseover'); },
         *         mouseout:    function() { console.log('mouseout'); },
         *         click:       function() { console.log('click'); }
         *     });
         *
         * And when those listeners need to be removed:
         *
         *     Ext.destroy(this.btnListeners);
         *
         * or
         *
         *     this.btnListeners.destroy();
         */
        addManagedListener(item: Ext.util.Observable|Ext.dom.Element, ename: any|string, fn: Function|string, scope: any, options: any): any;

        /**
         * Removes all listeners for this object including the managed listeners
         */
        clearListeners();

        /**
         * Removes all managed listeners for this object.
         */
        clearManagedListeners();

        /**
         * Enables events fired by this Observable to bubble up an owner hierarchy by calling 'this.getBubbleTarget()' if
         * present. There is no implementation in the Observable base class.
         *
         * This is commonly used by Ext.Components to bubble events to owner Containers.
         * See {@link Ext.Component#getBubbleTarget}. The default implementation in Ext.Component returns the
         * Component's immediate owner. But if a known target is required, this can be overridden to access the
         * required target more quickly.
         *
         * Example:
         *
         *     Ext.define('Ext.overrides.form.field.Base', {
         *         override: 'Ext.form.field.Base',
         *
         *         //  Add functionality to Field's initComponent to enable the change event to bubble
         *         initComponent: function () {
         *             this.callParent();
         *             this.enableBubble('change');
         *         }
         *     });
         *
         *     var myForm = Ext.create('Ext.form.Panel', {
         *         title: 'User Details',
         *         items: [{
         *             ...
         *         }],
         *         listeners: {
         *             change: function() {
         *                 // Title goes red if form has been modified.
         *                 myForm.header.setStyle('color', 'red');
         *             }
         *         }
         *     });
         *
         * @param {String/String[]} eventNames The event name to bubble, or an Array of event names.
         */
        enableBubble(eventNames: string);

        /**
         * Fires the specified event with the passed parameters and executes a function (action).
         * By default, the action function will be executed after any "before" event handlers
         * (as specified using the 'order' option of
         * '{@link Ext.util.Observable#addListener addListener}'), but before any other
         * handlers are fired.  This gives the "before" handlers an opportunity to
         * cancel the event by returning 'false', and prevent the action function from
         * being called.
         *
         * The action can also be configured to run after normal handlers, but before any "after"
         * handlers (as specified using the 'order' event option) by passing ''after''
         * as the 'order' parameter.  This configuration gives any event handlers except
         * for "after" handlers the opportunity to cancel the event and prevent the action
         * function from being called.
         *
         * @param {String} eventName The name of the event to fire.
         * @param {Array} args Arguments to pass to handlers and to the action function.
         * @param {Function} fn The action function.
         * @param {Object} [scope] The scope ('this' reference) in which the handler function is
         * executed. **If omitted, defaults to the object which fired the event.**
         * @param {Object} [options] Event options for the action function.  Accepts any
         * of the options of '{@link Ext.util.Observable#addListener addListener}'
         * @param {String} [order='before'] The order to call the action function relative
         * too the event handlers (''before'' or ''after'').  Note that this option is
         * simply used to sort the action function relative to the event handlers by "priority".
         * An order of ''before'' is equivalent to a priority of '99.5', while an order of
         * ''after'' is equivalent to a priority of '-99.5'.  See the 'priority' option
         * of '{@link Ext.util.Observable#addListener addListener}' for more details.
         * @deprecated 5.5 Use {@link #fireEventAction} instead.
         */
        fireAction(eventName: string, args: any[], fn: Function, scope?: any, options?: any, order?: string);

        /**
         * Fires the specified event with the passed parameters (minus the event name, plus the 'options' object passed
         * to {@link Ext.util.Observable#addListener addListener}).
         *
         * An event may be set to bubble up an Observable parent hierarchy (See {@link Ext.Component#getBubbleTarget}) by
         * calling {@link #enableBubble}.
         *
         * @param {String} eventName The name of the event to fire.
         * @param {Object...} args Variable number of parameters are passed to handlers.
         * @return {Boolean} returns false if any of the handlers return false otherwise it returns true.
         */
        fireEvent(eventName: string, args: any): boolean;

        /**
         * Fires the specified event with the passed parameter list.
         *
         * An event may be set to bubble up an Observable parent hierarchy (See {@link Ext.Component#getBubbleTarget}) by
         * calling {@link #enableBubble}.
         *
         * @param {String} eventName The name of the event to fire.
         * @param {Object[]} args An array of parameters which are passed to handlers.
         * @return {Boolean} returns false if any of the handlers return false otherwise it returns true.
         */
        fireEventArgs(eventName: string, args: any): boolean;

        /**
         * Fires the specified event with the passed parameters and executes a function (action).
         * Evented Actions will automatically dispatch a 'before' event passing. This event will
         * be given a special controller that allows for pausing/resuming of the event flow.
         *
         * By pausing the controller the updater and events will not run until resumed. Pausing,
         * however, will not stop the processing of any other before events.
         *
         * @param {String} eventName The name of the event to fire.
         * @param {Array} args Arguments to pass to handlers and to the action function.
         * @param {Function/String} fn The action function.
         * @param {Object} [scope] The scope ('this' reference) in which the handler function is
         * executed. **If omitted, defaults to the object which fired the event.**
         * @param {Array/Boolean} [fnArgs] Optional arguments for the action 'fn'. If not
         * given, the normal 'args' will be used to call 'fn'. If 'false' is passed, the
         * 'args' are used but if the first argument is this instance it will be removed
         * from the args passed to the action function.
         */
        fireEventedAction(eventName: string, args: any[], fn: Function|string, scope?: any, fnArgs?: any[]|boolean);

        /**
         * Checks to see if this object has any listeners for a specified event, or whether the event bubbles. The answer
         * indicates whether the event needs firing or not.
         *
         * @param {String} eventName The name of the event to check for
         * @return {Boolean} 'true' if the event is being listened for or bubbles, else 'false'
         */
        hasListener(eventName: string): boolean;

        /**
         * Checks if all events, or a specific event, is suspended.
         * @param {String} [event] The name of the specific event to check
         * @return {Boolean} 'true' if events are suspended
         */
        isSuspended(event?: string): boolean;

        /**
         * Shorthand for {@link #addManagedListener}.
         */
        mon();

        /**
         * Shorthand for {@link #removeManagedListener}.
         */
        mun();

        on();

        /**
         * Appends an after-event handler.
         *
         * Same as {@link Ext.util.Observable#addListener addListener} with 'order' set
         * to ''after''.
         *
         * @param {String/String[]/Object} eventName The name of the event to listen for.
         * @param {Function/String} fn The method the event invokes.
         * @param {Object} [scope] The scope for 'fn'.
         * @param {Object} [options] An object containing handler configuration.
         */
        onAfter(eventName: string|any, fn: Function|string, scope?: any, options?: any);

        /**
         * Appends a before-event handler.  Returning 'false' from the handler will stop the event.
         *
         * Same as {@link Ext.util.Observable#addListener addListener} with 'order' set
         * to ''before''.
         *
         * @param {String/String[]/Object} eventName The name of the event to listen for.
         * @param {Function/String} fn The method the event invokes.
         * @param {Object} [scope] The scope for 'fn'.
         * @param {Object} [options] An object containing handler configuration.
         */
        onBefore(eventName: string|any, fn: Function|string, scope?: any, options?: any);

        /**
         * Relays selected events from the specified Observable as if the events were fired by 'this'.
         *
         * For example if you are extending Grid, you might decide to forward some events from store.
         * So you can do this inside your initComponent:
         *
         *     this.relayEvents(this.getStore(), ['load']);
         *
         * The grid instance will then have an observable 'load' event which will be passed
         * the parameters of the store's load event and any function fired with the grid's
         * load event would have access to the grid using the this keyword (unless the event
         * is handled by a controller's control/listen event listener in which case 'this'
         * will be the controller rather than the grid).
         *
         * @param {Object} origin The Observable whose events this object is to relay.
         * @param {String[]/Object} events Array of event names to relay or an Object with key/value
         * pairs translating to ActualEventName/NewEventName respectively. For example:
         *     this.relayEvents(this, {add:'push', remove:'pop'});
         *
         * Would now redispatch the add event of this as a push event and the remove event as a pop event.
         *
         * @param {String} [prefix] A common prefix to prepend to the event names. For example:
         *
         *     this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
         *
         * Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
         *
         * @return {Object} A 'Destroyable' object. An object which implements the 'destroy' method which, when destroyed, removes all relayers. For example:
         *
         *     this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
         *
         * Can be undone by calling
         *
         *     Ext.destroy(this.storeRelayers);
         *
         * or
         *     this.store.relayers.destroy();
         */
        relayEvents(origin: any, events: string|any, prefix?: string): any;

        /**
         * Alias for {@link #unAfter}.
         */
        removeAfterListener();

        /**
         * Alias for {@link #unBefore}.
         */
        removeBeforeListener();

        /**
         * Removes an event handler.
         *
         * @param {String} eventName The type of event the handler was associated with.
         * @param {Function} fn The handler to remove. **This must be a reference to the function
         * passed into the
         * {@link Ext.util.Observable#addListener addListener} call.**
         * @param {Object} scope (optional) The scope originally specified for the handler. It
         * must be the same as the scope argument specified in the original call to
         * {@link Ext.util.Observable#addListener} or the listener will not be removed.
         *
         * **Convenience Syntax**
         *
         * You can use the {@link Ext.util.Observable#addListener addListener}
         * 'destroyable: true' config option in place of calling un().  For example:
         *
         *     var listeners = cmp.on({
         *         scope: cmp,
         *         afterrender: cmp.onAfterrender,
         *         beforehide: cmp.onBeforeHide,
         *         destroyable: true
         *     });
         *
         *     // Remove listeners
         *     listeners.destroy();
         *     // or
         *     cmp.un(
         *         scope: cmp,
         *         afterrender: cmp.onAfterrender,
         *         beforehide: cmp.onBeforeHide
         *     );
         *
         * **Exception - DOM event handlers using the element config option**
         *
         * You must go directly through the element to detach an event handler attached using
         * the {@link Ext.util.Observable#addListener addListener} _element_ option.
         *
         *     panel.on({
         *         element: 'body',
         *         click: 'onBodyCLick'
         *     });
         *
         *     panel.body.un({
         *         click: 'onBodyCLick'
         *     });
         */
        removeListener(eventName: string, fn: Function, scope: any);

        /**
         * Removes listeners that were added by the {@link #mon} method.
         *
         * @param {Ext.util.Observable/Ext.dom.Element} item The item from which to remove a listener/listeners.
         * @param {Object/String} ename The event name, or an object containing event name properties.
         * @param {Function} fn (optional) If the 'ename' parameter was an event name, this is the handler function.
         * @param {Object} scope (optional) If the 'ename' parameter was an event name, this is the scope ('this' reference)
         * in which the handler function is executed.
         */
        removeManagedListener(item: Ext.util.Observable|Ext.dom.Element, ename: any|string, fn: Function, scope: any);

        /**
         * Gets the default scope for firing late bound events (string names with
         * no scope attached) at runtime.
         * @param {Object} [defaultScope=this] The default scope to return if none is found.
         * @return {Object} The default event scope
         */
        protected resolveListenerScope(defaultScope?: any): any;

        /**
         * Resumes firing of the named event(s).
         *
         * After calling this method to resume events, the events will fire when requested to fire.
         *
         * **Note that if the {@link #suspendEvent} method is called multiple times for a certain event,
         * this converse method will have to be called the same number of times for it to resume firing.**
         */
        resumeEvent();

        /**
         * Resumes firing events (see {@link #suspendEvents}).
         *
         * If events were suspended using the 'queueSuspended' parameter, then all events fired
         * during event suspension will be sent to any listeners now.
         *
         * @param {Boolean} [discardQueue] 'true' to prevent any previously queued events from firing
         * while we were suspended. See {@link #suspendEvents}.
         */
        resumeEvents(discardQueue?: boolean);

        /**
         * An alias for {@link Ext.util.Observable#addListener addListener}.  In
         * versions prior to 5.1, {@link #listeners} had a generated setter which could
         * be called to add listeners.  In 5.1 the listeners config is not processed
         * using the config system and has no generated setter, so this method is
         * provided for backward compatibility.  The preferred way of adding listeners
         * is to use the {@link #on} method.
         * @param {Object} listeners The listeners
         */
        setListeners(listeners: any);

        /**
         * Suspends firing of the named event(s).
         *
         * After calling this method to suspend events, the events will no longer fire when requested to fire.
         *
         * **Note that if this is called multiple times for a certain event, the converse method
         * {@link #resumeEvent} will have to be called the same number of times for it to resume firing.**
         */
        suspendEvent();

        /**
         * Suspends the firing of all events. (see {@link #resumeEvents})
         *
         * @param {Boolean} queueSuspended 'true' to queue up suspended events to be fired
         * after the {@link #resumeEvents} call instead of discarding all suspended events.
         */
        suspendEvents(queueSuspended: boolean);

        /**
         * Shorthand for {@link #removeListener}.
         */
        un();

        /**
         * Removes a before-event handler.
         *
         * Same as {@link #removeListener} with 'order' set to ''after''.
         *
         * @param {String/String[]/Object} eventName The name of the event the handler was associated with.
         * @param {Function/String} fn The handler to remove.
         * @param {Object} [scope] The scope originally specified for 'fn'.
         * @param {Object} [options] Extra options object.
         */
        unAfter(eventName: string|any, fn: Function|string, scope?: any, options?: any);

        /**
         * Removes a before-event handler.
         *
         * Same as {@link #removeListener} with 'order' set to ''before''.
         *
         * @param {String/String[]/Object} eventName The name of the event the handler was associated with.
         * @param {Function/String} fn The handler to remove.
         * @param {Object} [scope] The scope originally specified for 'fn'.
         * @param {Object} [options] Extra options object.
         */
        unBefore(eventName: string|any, fn: Function|string, scope?: any, options?: any);

        /**
         * Starts capture on the specified Observable. All events will be passed to the supplied function with the event
         * name + standard signature of the event **before** the event is fired. If the supplied function returns false,
         * the event will not fire.
         *
         * @param {Ext.util.Observable} o The Observable to capture events from.
         * @param {Function} fn The function to call when an event is fired.
         * @param {Object} scope (optional) The scope ('this' reference) in which the function is executed. Defaults to
         * the Observable firing the event.
         */
        static capture(o: Ext.util.Observable, fn: Function, scope: any);

        /**
         * Sets observability on the passed class constructor.
         *
         * This makes any event fired on any instance of the passed class also fire a single event through
         * the **class** allowing for central handling of events on many instances at once.
         *
         * Usage:
         *
         *     Ext.util.Observable.observe(Ext.data.Connection);
         *     Ext.data.Connection.on('beforerequest', function(con, options) {
         *         console.log('Ajax request made to ' + options.url);
         *     });
         *
         * @param {Function} c The class constructor to make observable.
         * @param {Object} listeners An object containing a series of listeners to
         * add. See {@link Ext.util.Observable#addListener addListener}.
         */
        static observe(c: Function, listeners: any);

        /**
         * Removes **all** added captures from the Observable.
         *
         * @param {Ext.util.Observable} o The Observable to release
         */
        static releaseCapture(o: Ext.util.Observable);
    }

    interface ProgressableConfig {
        /**
         * When false this indicator will only receive progressStart and progressEnd commands, no progressUpdate commands will be sent.
         */
        dynamic?: boolean;

        /**
         * Maximum input value for this indicator
         */
        maxProgressInput?: number;

        /**
         * Maximum output value for this indicator
         */
        maxProgressOutput?: number;

        /**
         * Minimum input value for this indicator
         */
        minProgressInput?: number;

        /**
         * Minimum output value for this indicator
         */
        minProgressOutput?: number;

        /**
         * Current state of the progressIndicator. Should be used for switching progress states like download to upload.
         */
        state?: string;
    }

    /**
     * A Traversable mixin.
     */
    export class Progressable extends Ext.Mixin implements Ext.mixin.ProgressableConfig {
        /**
         * When false this indicator will only receive progressStart and progressEnd commands, no progressUpdate commands will be sent.
         */
        dynamic: boolean;

        /**
         * Maximum input value for this indicator
         */
        maxProgressInput: number;

        /**
         * Maximum output value for this indicator
         */
        maxProgressOutput: number;

        /**
         * Minimum input value for this indicator
         */
        minProgressInput: number;

        /**
         * Minimum output value for this indicator
         */
        minProgressOutput: number;

        /**
         * Current state of the progressIndicator. Should be used for switching progress states like download to upload.
         */
        state: string;

        getDynamic();

        getMaxProgressInput();

        getMaxProgressOutput();

        getMinProgressInput();

        getMinProgressOutput();

        getState();

        setDynamic();

        setMaxProgressInput();

        setMaxProgressOutput();

        setMinProgressInput();

        setMinProgressOutput();

        setState();
    }

    /**
     * A mixin for providing query related methods for {@link Ext.ComponentQuery} for classes that
     * implement getRefItems.
     */
    export class Queryable extends Ext.Base {
        /**
         * Retrieves the first direct child of this container which matches the passed selector or component.
         * The passed in selector must comply with an Ext.ComponentQuery selector, or it can be an actual Ext.Component.
         * @param {String/Ext.Component} [selector] An Ext.ComponentQuery selector. If no selector is
         * specified, the first child will be returned.
         * @return {Ext.Component} The matching child Ext.Component (or 'null' if no match was found).
         */
        child(selector?: string|Ext.Component): Ext.Component;

        /**
         * Retrieves the first descendant of this container which matches the passed selector.
         * The passed in selector must comply with an Ext.ComponentQuery selector, or it can be an actual Ext.Component.
         * @param {String/Ext.Component} [selector] An Ext.ComponentQuery selector or Ext.Component. If no selector is
         * specified, the first child will be returned.
         * @return {Ext.Component} The matching descendant Ext.Component (or 'null' if no match was found).
         */
        down(selector?: string|Ext.Component): Ext.Component;

        /**
         * Retrieves all descendant components which match the passed selector.
         * Executes an Ext.ComponentQuery.query using this container as its root.
         * @param {String} [selector] Selector complying to an Ext.ComponentQuery selector.
         * If no selector is specified all items will be returned.
         * @return {Ext.Component[]} Components which matched the selector
         */
        query(selector?: string): Ext.Component;

        /**
         * Retrieves all descendant components which match the passed function.
         * The function should return false for components that are to be
         * excluded from the selection.
         * @param {Function} fn The matcher function. It will be called with a single argument,
         * the component being tested.
         * @param {Object} [scope] The scope in which to run the function. If not specified,
         * it will default to the active component.
         * @return {Ext.Component[]} Components matched by the passed function
         */
        queryBy(fn: Function, scope?: any): Ext.Component;

        /**
         * Finds a component at any level under this container matching the id/itemId.
         * This is a shorthand for calling ct.down('#' + id);
         * @param {String} id The id to find
         * @return {Ext.Component} The matching id, null if not found
         */
        queryById(id: string): Ext.Component;

        /**
         * Traverses the tree rooted at this node in post-order mode, calling the passed function on the nodes at each level.
         * That is the function is called upon each node **after** being called on its children).
         *
         * This method is used at each level down the cascade. Currently {@link Ext.Component Component}s
         * and {@link Ext.data.TreeModel TreeModel}s are queryable.
         *
         * If you have tree-structured data, you can make your nodes queryable, and use ComponentQuery on them.
         *
         * @param {Object} selector A ComponentQuery selector used to filter candidate nodes before calling the function.
         * An empty string matches any node.
         * @param {Function} fn The function to call. Return 'false' to aborl the traverse.
         * @param {Object} fn.node The node being visited.
         * @param {Object} [scope] The context ('this' reference) in which the function is executed.
         * @param {Array} [extraArgs] A set of arguments to be appended to the function's argument list to pass down extra data known to the caller
         * **after** the node being visited.
         */
        visitPostOrder(selector: any, fn: Function, fn_node: any, scope?: any, extraArgs?: any[]);

        /**
         * Traverses the tree rooted at this node in pre-order mode, calling the passed function on the nodes at each level.
         * That is the function is called upon each node **before** being called on its children).
         *
         * This method is used at each level down the cascade. Currently {@link Ext.Component Component}s
         * and {@link Ext.data.TreeModel TreeModel}s are queryable.
         *
         * If you have tree-structured data, you can make your nodes queryable, and use ComponentQuery on them.
         *
         * @param {Object} selector A ComponentQuery selector used to filter candidate nodes before calling the function.
         * An empty string matches any node.
         * @param {Function} fn The function to call. Return 'false' to aborl the traverse.
         * @param {Object} fn.node The node being visited.
         * @param {Object} [scope] The context ('this' reference) in which the function is executed.
         * @param {Array} [extraArgs] A set of arguments to be appended to the function's argument list to pass down extra data known to the caller
         * **after** the node being visited.
         */
        visitPreOrder(selector: any, fn: Function, fn_node: any, scope?: any, extraArgs?: any[]);
    }

    interface ResponsiveConfig {
        /**
         * This object consists of keys that represent the conditions on which configs
         * will be applied. For example:
         *
         *      responsiveConfig: {
         *          landscape: {
         *              region: 'west'
         *          },
         *          portrait: {
         *              region: 'north'
         *          }
         *      }
         *
         * In this case the keys ("landscape" and "portrait") are the criteria (or "rules")
         * and the object to their right contains the configs that will apply when that
         * rule is true.
         *
         * These rules can be any valid JavaScript expression but the following values
         * are considered in scope:
         *
         *  * 'landscape' - True if the device orientation is landscape (always 'true' on
         *   desktop devices).
         *  * 'portrait' - True if the device orientation is portrait (always 'false' on
         *   desktop devices).
         *  * 'tall' - True if 'width' < 'height' regardless of device type.
         *  * 'wide' - True if 'width' > 'height' regardless of device type.
         *  * 'width' - The width of the viewport in pixels.
         *  * 'height' - The height of the viewport in pixels.
         *  * 'platform' - An object containing various booleans describing the platform
         *  (see '{@link Ext#platformTags Ext.platformTags}'). The properties of this
         *  object are also available implicitly (without "platform." prefix) but this
         *  sub-object may be useful to resolve ambiguity (for example, if one of the
         *  '{@link #responsiveFormulas}' overlaps and hides any of these properties).
         *  Previous to Ext JS 5.1, the 'platformTags' were only available using this
         *  prefix.
         *
         * A more complex example:
         *
         *      responsiveConfig: {
         *          'desktop || width > 800': {
         *              region: 'west'
         *          },
         *
         *          '!(desktop || width > 800)': {
         *              region: 'north'
         *          }
         *      }
         *
         * **NOTE**: If multiple rules set a single config (like above), it is important
         * that the rules be mutually exclusive. That is, only one rule should set each
         * config. If multiple rules are actively setting a single config, the order of
         * these (and therefore the config's value) is unspecified.
         *
         * For a config to participate as a 'responsiveConfig' it must have a "setter"
         * method. In the above example, a "setRegion" method must exist.
         *
         * @since 5.0.0
         */
        responsiveConfig?: any;

        /**
         * It is common when using 'responsiveConfig' to have recurring expressions that
         * make for complex configurations. Using 'responsiveFormulas' allows you to cut
         * down on this repetition by adding new properties to the "scope" for the rules
         * in a 'responsiveConfig'.
         *
         * For example:
         *
         *      Ext.define('MyApp.view.main.Main', {
         *          extend: 'Ext.container.Container',
         *
         *          mixins: [
         *              'Ext.mixin.Responsive'
         *          ],
         *
         *          responsiveFormulas: {
         *              small: 'width < 600',
         *
         *              medium: 'width >= 600 && width < 800',
         *
         *              large: 'width >= 800',
         *
         *              tuesday: function (context) {
         *                  return (new Date()).getDay() === 2;
         *              }
         *          }
         *      });
         *
         * With the above declaration, any 'responsiveConfig' can now use these values
         * like so:
         *
         *      responsiveConfig: {
         *          small: {
         *              hidden: true
         *          },
         *          'medium && !tuesday': {
         *              hidden: false,
         *              region: 'north'
         *          },
         *          large: {
         *              hidden: false,
         *              region: 'west'
         *          }
         *      }
         *
         * @since 5.0.1
         */
        responsiveFormulas?: any;
    }

    /**
     * This mixin provides its user with a 'responsiveConfig' config that allows the class
     * to conditionally control config properties.
     *
     * For example:
     *
     *      Ext.define('ResponsiveClass', {
     *          mixin: [
     *              'Ext.mixin.Responsive'
     *          ],
     *
     *          responsiveConfig: {
     *              portrait: {
     *              },
     *
     *              landscape: {
     *              }
     *          }
     *      });
     *
     * For a config to participate as a responsiveConfig it must have a "setter" method. In
     * the below example, a "setRegion" method must exist.
     *
     *      Ext.create({
     *          xtype: 'viewport',
     *          layout: 'border',
     *
     *          items: [{
     *              title: 'Some Title',
     *              plugins: 'responsive',
     *
     *              responsiveConfig: {
     *                  'width < 800': {
     *                      region: 'north'
     *                  },
     *                  'width >= 800': {
     *                      region: 'west'
     *                  }
     *              }
     *          }]
     *      });
     *
     * To use responsiveConfig the class must be defined using the Ext.mixin.Responsive mixin.
     *
     *      Ext.define('App.view.Foo', {
     *          extend: 'Ext.panel.Panel',
     *          xtype: 'foo',
     *          mixins: [
     *               'Ext.mixin.Responsive'
     *          ],
     *          ...
     *      });
     *
     * Otherwise, you will need to use the responsive plugin if the class is not one you authored.
     *
     *      Ext.create('Ext.panel.Panel', {
     *          renderTo: document.body,
     *          plugins: 'responsive',
     *          ...
     *      });
     *
     *  _Note:_ There is the exception of 'Ext.container.Viewport' or other classes using 'Ext.plugin.Viewport'.
     *  In those cases, the viewport plugin inherits from 'Ext.plugin.Responsive'.
     *
     * For details see '{@link #responsiveConfig}'.
     * @since 5.0.0
     */
    export class Responsive extends Ext.Base implements Ext.mixin.ResponsiveConfig {
        /**
         * This object consists of keys that represent the conditions on which configs
         * will be applied. For example:
         *
         *      responsiveConfig: {
         *          landscape: {
         *              region: 'west'
         *          },
         *          portrait: {
         *              region: 'north'
         *          }
         *      }
         *
         * In this case the keys ("landscape" and "portrait") are the criteria (or "rules")
         * and the object to their right contains the configs that will apply when that
         * rule is true.
         *
         * These rules can be any valid JavaScript expression but the following values
         * are considered in scope:
         *
         *  * 'landscape' - True if the device orientation is landscape (always 'true' on
         *   desktop devices).
         *  * 'portrait' - True if the device orientation is portrait (always 'false' on
         *   desktop devices).
         *  * 'tall' - True if 'width' < 'height' regardless of device type.
         *  * 'wide' - True if 'width' > 'height' regardless of device type.
         *  * 'width' - The width of the viewport in pixels.
         *  * 'height' - The height of the viewport in pixels.
         *  * 'platform' - An object containing various booleans describing the platform
         *  (see '{@link Ext#platformTags Ext.platformTags}'). The properties of this
         *  object are also available implicitly (without "platform." prefix) but this
         *  sub-object may be useful to resolve ambiguity (for example, if one of the
         *  '{@link #responsiveFormulas}' overlaps and hides any of these properties).
         *  Previous to Ext JS 5.1, the 'platformTags' were only available using this
         *  prefix.
         *
         * A more complex example:
         *
         *      responsiveConfig: {
         *          'desktop || width > 800': {
         *              region: 'west'
         *          },
         *
         *          '!(desktop || width > 800)': {
         *              region: 'north'
         *          }
         *      }
         *
         * **NOTE**: If multiple rules set a single config (like above), it is important
         * that the rules be mutually exclusive. That is, only one rule should set each
         * config. If multiple rules are actively setting a single config, the order of
         * these (and therefore the config's value) is unspecified.
         *
         * For a config to participate as a 'responsiveConfig' it must have a "setter"
         * method. In the above example, a "setRegion" method must exist.
         *
         * @since 5.0.0
         */
        responsiveConfig: any;

        /**
         * It is common when using 'responsiveConfig' to have recurring expressions that
         * make for complex configurations. Using 'responsiveFormulas' allows you to cut
         * down on this repetition by adding new properties to the "scope" for the rules
         * in a 'responsiveConfig'.
         *
         * For example:
         *
         *      Ext.define('MyApp.view.main.Main', {
         *          extend: 'Ext.container.Container',
         *
         *          mixins: [
         *              'Ext.mixin.Responsive'
         *          ],
         *
         *          responsiveFormulas: {
         *              small: 'width < 600',
         *
         *              medium: 'width >= 600 && width < 800',
         *
         *              large: 'width >= 800',
         *
         *              tuesday: function (context) {
         *                  return (new Date()).getDay() === 2;
         *              }
         *          }
         *      });
         *
         * With the above declaration, any 'responsiveConfig' can now use these values
         * like so:
         *
         *      responsiveConfig: {
         *          small: {
         *              hidden: true
         *          },
         *          'medium && !tuesday': {
         *              hidden: false,
         *              region: 'north'
         *          },
         *          large: {
         *              hidden: false,
         *              region: 'west'
         *          }
         *      }
         *
         * @since 5.0.1
         */
        responsiveFormulas: any;

        /**
         * This method removes this instance from the Responsive collection.
         */
        destroy();
    }

    interface SelectableConfig {
        /**
         * Allow users to deselect a record in a DataView, List or Grid. Only applicable when the Selectable's 'mode' is
         * ''SINGLE''.
         */
        allowDeselect?: boolean;

        /**
         * 'true' to deselect current selection when the container body is
         * clicked.
         */
        deselectOnContainerClick?: boolean;

        /**
         * 'true' to disable selection.
         * This configuration will lock the selection model that the DataView uses.
         */
        disableSelection?: boolean;

        /**
         * @deprecated 2.0.0 Please use {@link #disableSelection} instead.
         */
        locked?: boolean;

        /**
         * Modes of selection.
         * Valid values are ''SINGLE'', ''SIMPLE'', and ''MULTI''.
         */
        mode?: string;

        /**
         * The selected record.
         */
        selection?: Ext.data.Model;
    }

    /**
     * Tracks what records are currently selected in a databound widget. This class is mixed in to
     * {@link Ext.view.View dataview} and all subclasses.
     */
    export class Selectable extends Ext.Mixin implements Ext.mixin.SelectableConfig {
        /**
         * Allow users to deselect a record in a DataView, List or Grid. Only applicable when the Selectable's 'mode' is
         * ''SINGLE''.
         */
        allowDeselect: boolean;

        /**
         * 'true' to deselect current selection when the container body is
         * clicked.
         */
        deselectOnContainerClick: boolean;

        /**
         * 'true' to disable selection.
         * This configuration will lock the selection model that the DataView uses.
         */
        disableSelection: boolean;

        /**
         * @deprecated 2.0.0 Please use {@link #disableSelection} instead.
         */
        locked: boolean;

        /**
         * Modes of selection.
         * Valid values are ''SINGLE'', ''SIMPLE'', and ''MULTI''.
         */
        mode: string;

        /**
         * The selected record.
         */
        selection: Ext.data.Model;

        /**
         * Deselects any currently selected records and clears all stored selections.
         * @deprecated 2.0.0 Please use {@link #deselectAll} instead.
         */
        clearSelections();

        constructor();

        /**
         * Deselects the given record(s). If many records are currently selected, it will only deselect those you pass in.
         * @param {Number/Array/Ext.data.Model} records The record(s) to deselect. Can also be a number to reference by index.
         * @param {Boolean} suppressEvent If 'true' the 'deselect' event will not be fired.
         */
        deselect(records: number|any[]|Ext.data.Model, suppressEvent: boolean);

        /**
         * Deselects all records.
         */
        deselectAll();

        /**
         * Deselects a record instance by record instance or index.
         * @param {Ext.data.Model/Number} records An array of records or an index.
         * @param {Boolean} suppressEvent Set to 'false' to not fire a deselect event.
         * @deprecated 2.0.0 Please use {@link #deselect} instead.
         */
        doDeselect(records: Ext.data.Model|number, suppressEvent: boolean);

        /**
         * Selects a record instance by record instance or index.
         * @param {Ext.data.Model/Number} records An array of records or an index.
         * @param {Boolean} suppressEvent Set to 'false' to not fire a select event.
         * @deprecated 2.0.0 Please use {@link #select} instead.
         */
        doSelect(records: Ext.data.Model|number, keepExisting: boolean, suppressEvent: boolean);

        getAllowDeselect();

        /**
         * Returns the number of selections.
         * @return {Number}
         * @deprecated 2.0.0 Please use {@link #getSelectionCount} instead.
         */
        getCount(): number;

        getDeselectOnContainerClick();

        getDisableSelection();

        /**
         * Returns the array of previously selected items.
         * @return {Array} The previous selection.
         * @deprecated 2.0.0
         */
        getLastSelected(): any[];

        getMode();

        getPublishes();

        getSelection();

        /**
         * Returns the number of selections.
         * @return {Number}
         */
        getSelectionCount(): number;

        /**
         * Returns the selection mode currently used by this Selectable.
         * @return {String} The current mode.
         * @deprecated 2.0.0 Please use {@link #getMode} instead.
         */
        getSelectionMode(): string;

        /**
         * Returns the currently selected records.
         * @return {Ext.data.Model[]} The selected records.
         */
        getSelections(): Ext.data.Model;

        getTwoWayBindable();

        /**
         * Returns 'true' if there is a selected record.
         * @return {Boolean}
         */
        hasSelection(): boolean;

        /**
         * Returns 'true' if the Selectable is currently locked.
         * @return {Boolean} True if currently locked
         * @deprecated 2.0.0 Please use {@link #getDisableSelection} instead.
         */
        isLocked(): boolean;

        /**
         * Returns 'true' if the specified row is selected.
         * @param {Ext.data.Model/Number} record The record or index of the record to check.
         * @return {Boolean}
         */
        isSelected(record: Ext.data.Model|number): boolean;

        /**
         * Adds the given records to the currently selected set.
         * @param {Ext.data.Model/Array/Number} records The records to select.
         * @param {Boolean} keepExisting If 'true', the existing selection will be added to (if not, the old selection is replaced).
         * @param {Boolean} suppressEvent If 'true', the 'select' event will not be fired.
         */
        select(records: Ext.data.Model|any[]|number, keepExisting: boolean, suppressEvent: boolean);

        /**
         * Selects all records.
         * @param {Boolean} silent 'true' to suppress all select events.
         */
        selectAll(silent: boolean);

        /**
         * Selects a range of rows if the selection model {@link Ext.mixin.Selectable#getDisableSelection} is not locked.
         * All rows in between 'startRecord' and 'endRecord' are also selected.
         * @param {Number} startRecord The index of the first row in the range.
         * @param {Number} endRecord The index of the last row in the range.
         * @param {Boolean} [keepExisting] 'true' to retain existing selections.
         */
        selectRange(startRecord: number, endRecord: number, keepExisting?: boolean);

        setAllowDeselect();

        setDeselectOnContainerClick();

        setDisableSelection();

        /**
         * This was an internal function accidentally exposed in 1.x and now deprecated. Calling it has no effect
         * @deprecated 2.0.0
         */
        setLastFocused();

        setMode();

        setPublishes();

        setSelection();

        setTwoWayBindable();

        /**
         * Sets a record as the last focused record. This does NOT mean
         * that the record has been selected.
         */
        updateLastFocused(newRecord: Ext.data.Model, oldRecord: Ext.data.Model);

        /**
         * Fires before an item is selected.
         * @deprecated 2.0.0 Please listen to the {@link #selectionchange} event with an order of 'before' instead.
         */
        beforeselectionchange(that: Ext.mixin.Selectable);

        /**
         * Fires when a selection changes.
         * @param {Ext.data.Model[]} records The records whose selection has changed.
         */
        selectionchange(that: Ext.mixin.Selectable, records: Ext.data.Model);
    }

    export class Templatable extends Ext.Mixin {
    }

    /**
     * A Traversable mixin.
     */
    export class Traversable extends Ext.Mixin {
        /**
         * Returns the parent of this component, if it has one.
         * @return {Ext.Component} The parent of this component.
         */
        getParent(): Ext.Component;

        /**
         * Returns 'true' if this component has a parent.
         * @return {Boolean} 'true' if this component has a parent.
         */
        hasParent(): boolean;
    }
}

declare module Ext.navigation {
    interface BarConfig extends Ext.TitleBarConfig {
        /**
         * Optionally enable CSS transforms on Android 2
         * for NavigationBar animations.  Note that this may cause flickering if the
         * NavigationBar is hidden.
         */
        androidAnimation?: boolean;

        baseCls?: any;

        cls?: any;

        /**
         * Style options for Toolbar. Either 'light' or 'dark'.
         */
        ui?: string;
    }

    /**
     * This component is used in {@link Ext.navigation.View} to control animations in the toolbar. You should never need to
     * interact with the component directly, unless you are subclassing it.
     */
    export class Bar extends Ext.TitleBar implements Ext.navigation.BarConfig {
        /**
         * Optionally enable CSS transforms on Android 2
         * for NavigationBar animations.  Note that this may cause flickering if the
         * NavigationBar is hidden.
         */
        androidAnimation: boolean;

        /**
         * The base CSS class to apply to this component's element. This will also be prepended to
         * other elements within this component. To add specific styling for sub-classes, use the {@link #cls} config.
         */
        baseCls: string;

        /**
         * The CSS class to add to this component's element, in
         * addition to the {@link #baseCls}. In many cases, this property will be specified
         * by the derived component class. See {@link #userCls} for adding additional CSS
         * classes to component instances (such as items in a {@link Ext.Container}).
         */
        cls: string;

        /**
         * Style options for Toolbar. Either 'light' or 'dark'.
         */
        ui: string;

        constructor(config: Ext.ActionSheetConfig);

        getAndroidAnimation();

        getBaseCls();

        getCls();

        getUi();

        setAndroidAnimation();

        setBaseCls();

        setCls();

        setUi();

        /**
         * Fires when the back button was tapped.
         * @param {Ext.navigation.Bar} this This bar
         */
        back(that: Ext.navigation.Bar);
    }

    interface ViewConfig extends Ext.ContainerConfig {
        baseCls?: any;

        /**
         * The text to be displayed on the back button if:
         *
         * - The previous view does not have a title.
         * - The {@link #useTitleForBackButtonText} configuration is 'true'.
         */
        defaultBackButtonText?: string;

        /**
         * The child items to add to this NavigationView. This is usually an array of Component
         * configurations or instances, for example:
         *
         *     Ext.create('Ext.Container', {
         *         items: [
         *             {
         *                 xtype: 'panel',
         *                 title: 'My title',
         *                 html: 'This is an item'
         *             }
         *         ]
         *     });
         *
         * If you want a title to be displayed in the {@link #navigationBar}, you must specify a 'title' configuration in your
         * view, like above.
         *
         * __Note:__ Only one view will be visible at a time. If you want to change to another view, use the {@link #method-push} or
         * {@link #setActiveItem} methods.
         */
        items?: any[]|any;

        /**
         * Layout used in this navigation view, type must be set to 'card'.
         * **Android NOTE:** Older Android devices have poor animation performance. It is recommended to set the animation to null, for example:
         *
         *      layout: {
         *          type: 'card',
         *          animation: null
         *      }
         */
        layout?: any;

        /**
         * The NavigationBar used in this navigation view. It defaults to be docked to the top.
         *
         * You can just pass in a normal object if you want to customize the NavigationBar. For example:
         *
         *     navigationBar: {
         *         ui: 'dark',
         *         docked: 'bottom'
         *     }
         *
         * You **cannot** specify a *title* property in this configuration. The title of the navigationBar is taken
         * from the configuration of this views children:
         *
         *     view.push({
         *         title: 'This views title which will be shown in the navigation bar',
         *         html: 'Some HTML'
         *     });
         */
        navigationBar?: boolean|any;

        /**
         * Set to 'false' if you always want to display the {@link #defaultBackButtonText} as the text
         * on the back button. 'true' if you want to use the previous views title.
         */
        useTitleForBackButtonText?: boolean;
    }

    /**
     * NavigationView is basically a {@link Ext.Container} with a {@link Ext.layout.Card card} layout, so only one view
     * can be visible at a time. However, NavigationView also adds extra functionality on top of this to allow
     * you to 'push' and 'pop' views at any time. When you do this, your NavigationView will automatically animate
     * between your current active view, and the new view you want to 'push', or the previous view you want to 'pop'.
     *
     * Using the NavigationView is very simple. Here is a basic example of it in action:
     *
     *     @example
     *     var view = Ext.create('Ext.NavigationView', {
     *         fullscreen: true,
     *
     *         items: [{
     *             title: 'First',
     *             items: [{
     *                 xtype: 'button',
     *                 text: 'Push a new view!',
     *                 handler: function() {
     *                     // use the push() method to push another view. It works much like
     *                     // add() or setActiveItem(). it accepts a view instance, or you can give it
     *                     // a view config.
     *                     view.push({
     *                         title: 'Second',
     *                         html: 'Second view!'
     *                     });
     *                 }
     *             }]
     *         }]
     *     });
     *
     * Now, here comes the fun part: you can push any view/item into the NavigationView, at any time, and it will
     * automatically handle the animations between the two views, including adding a back button (if necessary)
     * and showing the new title.
     *
     *     view.push({
     *         title: 'A new view',
     *         html: 'Some new content'
     *     });
     *
     * As you can see, it is as simple as calling the {@link #method-push} method, with a new view (instance or object). Done.
     *
     * You can also 'pop' a view at any time. This will remove the top-most view from the NavigationView, and animate back
     * to the previous view. You can do this using the {@link #method-pop} method (which requires no arguments).
     *
     *     view.pop();
     *
     *  Applications that need compatibility with ##Older Android## devices will want to see the {@link #layout} config for details on
     *  disabling navigation view animations as these devices have poor animation support and performance.
     */
    export class View extends Ext.Container implements Ext.navigation.ViewConfig {
        /**
         * The base CSS class to apply to this component's element. This will also be prepended to
         * other elements within this component. To add specific styling for sub-classes, use the {@link #cls} config.
         */
        baseCls: string;

        /**
         * The text to be displayed on the back button if:
         *
         * - The previous view does not have a title.
         * - The {@link #useTitleForBackButtonText} configuration is 'true'.
         */
        defaultBackButtonText: string;

        /**
         * The child items to add to this NavigationView. This is usually an array of Component
         * configurations or instances, for example:
         *
         *     Ext.create('Ext.Container', {
         *         items: [
         *             {
         *                 xtype: 'panel',
         *                 title: 'My title',
         *                 html: 'This is an item'
         *             }
         *         ]
         *     });
         *
         * If you want a title to be displayed in the {@link #navigationBar}, you must specify a 'title' configuration in your
         * view, like above.
         *
         * __Note:__ Only one view will be visible at a time. If you want to change to another view, use the {@link #method-push} or
         * {@link #setActiveItem} methods.
         */
        items: any[]|any;

        /**
         * Layout used in this navigation view, type must be set to 'card'.
         * **Android NOTE:** Older Android devices have poor animation performance. It is recommended to set the animation to null, for example:
         *
         *      layout: {
         *          type: 'card',
         *          animation: null
         *      }
         */
        layout: any|string;

        /**
         * The NavigationBar used in this navigation view. It defaults to be docked to the top.
         *
         * You can just pass in a normal object if you want to customize the NavigationBar. For example:
         *
         *     navigationBar: {
         *         ui: 'dark',
         *         docked: 'bottom'
         *     }
         *
         * You **cannot** specify a *title* property in this configuration. The title of the navigationBar is taken
         * from the configuration of this views children:
         *
         *     view.push({
         *         title: 'This views title which will be shown in the navigation bar',
         *         html: 'Some HTML'
         *     });
         */
        navigationBar: boolean|any;

        /**
         * Set to 'false' if you always want to display the {@link #defaultBackButtonText} as the text
         * on the back button. 'true' if you want to use the previous views title.
         */
        useTitleForBackButtonText: boolean;

        constructor(config: Ext.ActionSheetConfig);

        getBaseCls();

        getDefaultBackButtonText();

        getItems();

        getLayout();

        getNavigationBar();

        /**
         * Returns the previous item, if one exists.
         * @return {Mixed} The previous view
         */
        getPreviousItem(): any;

        getUseTitleForBackButtonText();

        /**
         * Removes the current active view from the stack and sets the previous view using the default animation
         * of this view. You can also pass a {@link Ext.ComponentQuery} selector to target what inner item to pop to.
         * @param {Number/String/Object} count If a Number, the number of views you want to pop. If a String, the pops to a matching
         * component query. If an Object, the pops to a matching view instance.
         * @return {Ext.Component} The new active item
         */
        pop(count: number|string|any): Ext.Component;

        /**
         * Pushes a new view into this navigation view using the default animation that this view has.
         * @param {Object} view The view to push.
         * @return {Ext.Component} The new item you just pushed.
         */
        push(view: any): Ext.Component;

        /**
         * Resets the view by removing all items between the first and last item.
         * @return {Ext.Component} The view that is now active
         */
        reset(): Ext.Component;

        setBaseCls();

        setDefaultBackButtonText();

        setItems();

        setLayout();

        setNavigationBar();

        setUseTitleForBackButtonText();

        /**
         * Fires when the back button in the navigation view was tapped.
         * @param {Ext.navigation.View} this The component instance\
         */
        back(that: Ext.navigation.View);
    }
}

declare module Ext.panel {
    interface HeaderConfig extends Ext.ContainerConfig {
        baseCls?: any;

        /**
         * A numeric unicode character code to use as the icon.  The default font-family
         * for glyphs can be set globally using
         * {@link Ext.app.Application#glyphFontFamily glyphFontFamily} application
         * config or the {@link Ext#setGlyphFontFamily Ext.setGlyphFontFamily()} method.
         *
         * The following shows how to set the glyph using the font icons provided in the
         * SDK (assuming the font-family has been configured globally):
         *
         *     // assumes the glyphFontFamily is "FontAwesome"
         *     glyph: 'xf005'     // the "home" icon
         *
         *     // assumes the glyphFontFamily is "Pictos"
         *     glyph: 'H'         // the "home" icon
         *
         * Alternatively, this config option accepts a string with the charCode and
         * font-family separated by the '@' symbol.
         *
         *     // using Font Awesome
         *     glyph: 'xf005@FontAwesome'     // the "home" icon
         *
         *     // using Pictos
         *     glyph: 'H@Pictos'              // the "home" icon
         *
         * Depending on the theme you're using, you may need include the font icon
         * packages in your application in order to use the icons included in the
         * SDK.  For more information see:
         *
         *  - [Font Awesome icons](http://fortawesome.github.io/Font-Awesome/cheatsheet/)
         *  - [Pictos icons](http://docs.sencha.com/extjs/6.0/core_concepts/font_ext.html)
         *  - [Theming Guide](http://docs.sencha.com/extjs/6.0/core_concepts/theming.html)
         */
        glyph?: number|string;

        /**
         * Path to an image to use as an icon.
         *
         * For instructions on how you can use icon fonts including those distributed in
         * the SDK see {@link #iconCls}.
         */
        icon?: string;

        /**
         * The side of the title to render the icon.
         *
         * Optional, Defaults to: 'left'
         */
        iconAlign?: any;

        /**
         * One or more space separated CSS classes to be applied to the icon element.
         * The CSS rule(s) applied should specify a background image to be used as the
         * icon.
         *
         * An example of specifying a custom icon class would be something like:
         *
         *     // specify the property in the config for the class:
         *     iconCls: 'my-home-icon'
         *
         *     // css rule specifying the background image to be used as the icon image:
         *     .my-home-icon {
         *         background-image: url(../images/my-home-icon.gif) !important;
         *     }
         *
         * In addition to specifying your own classes, you can use the font icons
         * provided in the SDK using the following syntax:
         *
         *     // using Font Awesome
         *     iconCls: 'x-fa fa-home'
         *
         *     // using Pictos
         *     iconCls: 'pictos pictos-home'
         *
         * Depending on the theme you're using, you may need include the font icon
         * packages in your application in order to use the icons included in the
         * SDK.  For more information see:
         *
         *  - [Font Awesome icons](http://fortawesome.github.io/Font-Awesome/cheatsheet/)
         *  - [Pictos icons](http://docs.sencha.com/extjs/6.0/core_concepts/font_ext.html)
         *  - [Theming Guide](http://docs.sencha.com/extjs/6.0/core_concepts/theming.html)
         */
        iconCls?: string;

        layout?: any;

        /**
         * The title text or config object for the {@link Ext.panel.Title Title} component.
         */
        title?: any;

        /**
         * The alignment of the title text within the available space between the
         * icon and the tools.
         *
         * Optional, Defaults to: 'left'
         */
        titleAlign?: any;
    }

    /**
     * This container class is used to manage the items (such as title and tools) for 'Ext.Panel'.
     *
     * @since 6.0.1
     */
    export class Header extends Ext.Container implements Ext.panel.HeaderConfig {
        /**
         * 'true' in this class to identify an object as an instantiated Header, or a subclass
         * thereof.
         * @readonly
         */
        isPanelHeader: boolean;

        baseCls: string;

        /**
         * A numeric unicode character code to use as the icon.  The default font-family
         * for glyphs can be set globally using
         * {@link Ext.app.Application#glyphFontFamily glyphFontFamily} application
         * config or the {@link Ext#setGlyphFontFamily Ext.setGlyphFontFamily()} method.
         *
         * The following shows how to set the glyph using the font icons provided in the
         * SDK (assuming the font-family has been configured globally):
         *
         *     // assumes the glyphFontFamily is "FontAwesome"
         *     glyph: 'xf005'     // the "home" icon
         *
         *     // assumes the glyphFontFamily is "Pictos"
         *     glyph: 'H'         // the "home" icon
         *
         * Alternatively, this config option accepts a string with the charCode and
         * font-family separated by the '@' symbol.
         *
         *     // using Font Awesome
         *     glyph: 'xf005@FontAwesome'     // the "home" icon
         *
         *     // using Pictos
         *     glyph: 'H@Pictos'              // the "home" icon
         *
         * Depending on the theme you're using, you may need include the font icon
         * packages in your application in order to use the icons included in the
         * SDK.  For more information see:
         *
         *  - [Font Awesome icons](http://fortawesome.github.io/Font-Awesome/cheatsheet/)
         *  - [Pictos icons](http://docs.sencha.com/extjs/6.0/core_concepts/font_ext.html)
         *  - [Theming Guide](http://docs.sencha.com/extjs/6.0/core_concepts/theming.html)
         */
        glyph: number|string;

        /**
         * Path to an image to use as an icon.
         *
         * For instructions on how you can use icon fonts including those distributed in
         * the SDK see {@link #iconCls}.
         */
        icon: string;

        /**
         * The side of the title to render the icon.
         *
         * Optional, Defaults to: 'left'
         */
        iconAlign: any;

        /**
         * One or more space separated CSS classes to be applied to the icon element.
         * The CSS rule(s) applied should specify a background image to be used as the
         * icon.
         *
         * An example of specifying a custom icon class would be something like:
         *
         *     // specify the property in the config for the class:
         *     iconCls: 'my-home-icon'
         *
         *     // css rule specifying the background image to be used as the icon image:
         *     .my-home-icon {
         *         background-image: url(../images/my-home-icon.gif) !important;
         *     }
         *
         * In addition to specifying your own classes, you can use the font icons
         * provided in the SDK using the following syntax:
         *
         *     // using Font Awesome
         *     iconCls: 'x-fa fa-home'
         *
         *     // using Pictos
         *     iconCls: 'pictos pictos-home'
         *
         * Depending on the theme you're using, you may need include the font icon
         * packages in your application in order to use the icons included in the
         * SDK.  For more information see:
         *
         *  - [Font Awesome icons](http://fortawesome.github.io/Font-Awesome/cheatsheet/)
         *  - [Pictos icons](http://docs.sencha.com/extjs/6.0/core_concepts/font_ext.html)
         *  - [Theming Guide](http://docs.sencha.com/extjs/6.0/core_concepts/theming.html)
         */
        iconCls: string;

        layout: any|string;

        /**
         * The title text or config object for the {@link Ext.panel.Title Title} component.
         */
        title: any;

        /**
         * The alignment of the title text within the available space between the
         * icon and the tools.
         *
         * Optional, Defaults to: 'left'
         */
        titleAlign: any;

        constructor(config: Ext.ActionSheetConfig);

        getGlyph();

        getIcon();

        getIconAlign();

        getIconCls();

        getLayout();

        getTitle();

        getTitleAlign();

        setGlyph();

        setIcon();

        setIconAlign();

        setIconCls();

        setLayout();

        setTitle();

        setTitleAlign();
    }

    interface TitleConfig extends Ext.ComponentConfig {
        baseCls?: any;

        glyph?: any;

        icon?: any;

        /**
         * alignment of the icon
         *
         * Optional, Defaults to: 'left'
         */
        iconAlign?: any;

        iconCls?: any;

        /**
         * The title's text (can contain html tags/entities)
         */
        text?: any;

        textAlign?: any;
    }

    /**
     * A basic title component for a Panel Header.
     *
     * @since 6.0.1
     */
    export class Title extends Ext.Component implements Ext.panel.TitleConfig {
        protected element: any;

        baseCls: string;

        glyph: any;

        icon: any;

        /**
         * alignment of the icon
         *
         * Optional, Defaults to: 'left'
         */
        iconAlign: any;

        iconCls: any;

        /**
         * The title's text (can contain html tags/entities)
         */
        text: any;

        textAlign: any;

        /**
         * Creates new Component.
         * @param {Object} config The standard configuration object.
         */
        constructor(config: Ext.ButtonConfig);

        getGlyph();

        getIcon();

        getIconAlign();

        getIconCls();

        getText();

        getTextAlign();

        setGlyph();

        setIcon();

        setIconAlign();

        setIconCls();

        setText();

        setTextAlign();
    }

    interface ToolConfig extends Ext.ComponentConfig {
        baseCls?: any;

        disabledCls?: any;

        /**
         * A function to execute when the tool is clicked.
         *
         * The logical owner of the tool. In a typical usage
         * this will be an 'Ext.Panel' (as specified by the 'toolOwner' config).
         * The tool that is calling.
         * The click event.
         * @controllable
         */
        handler?: Function|string;

        /**
         * An alternative to the standard list of {@link #type types}.
         */
        iconCls?: string;

        /**
         * The scope to execute the {@link #handler} function. Defaults to the tool.
         */
        scope?: any;

        /**
         * Specify as false to allow click event to propagate.
         */
        stopEvent?: boolean;

        /**
         * The owner to report to the 'handler' method. Default is 'null' for the 'parent'.
         * This is automatically set to the owning 'Ext.Panel' when a tool is created as a
         * member of a panel's 'tools'.
         */
        toolOwner?: Ext.Component;

        /**
         * The type of tool to render. The following types are available:
         *
         * ##Neptune Theme
         * - <img style="vertical-align:sub;margin-right:4px;" width="16" height="16" title="" alt="" src="data:image/gif;base64,R0lGODlhEAAQAMQfAGZmZqamptbW1nNzc9nZ2eXl5ampqfv7+2pqanR0dNjY2H5+fnh4eGdnZ2xsbG5ubtfX129vb2hoaObm5qWlpaqqqvr6+qSkpI+Pj21tbY6OjoCAgH19fWlpaX9/f////yH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpDRTk3OUEzMjlBQTQxMUU0OEVCNUNFMTgyMDM3Mzc3MSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpDRTk3OUEzMzlBQTQxMUU0OEVCNUNFMTgyMDM3Mzc3MSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkNFOTc5QTMwOUFBNDExRTQ4RUI1Q0UxODIwMzczNzcxIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkNFOTc5QTMxOUFBNDExRTQ4RUI1Q0UxODIwMzczNzcxIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkEAQAAHwAsAAAAABAAEAAABYLgJ35TtSCIV03jeAQNIM/NZbnYrM/aIQYARyChSwQcgMCnIAFQPoSBbED4UACSgkHGqCoiEQWUITMsZgPIRyD4QKSyk+7RXj90qHldcJ9lzlNqbG5wABtbAF0fX2FjZUxJUHBUH0BZlUFDRUeRHwc5Ozo9LjChNTctSwYcHRmHBS0hADs=" /> close
         * - <img style="vertical-align:sub;margin-right:4px;" width="16" height="16" title="" alt="" src="data:image/gif;base64,R0lGODlhEAAQAMQUAGZmZqampqmpqfv7++Xl5Wpqan5+fmdnZ2hoaObm5o+Pj21tbaSkpI6Ojqqqqvr6+oCAgGlpaX19fX9/f////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo0Qzg2QTQzQjlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo0Qzg2QTQzQzlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkNFOTc5QTM0OUFBNDExRTQ4RUI1Q0UxODIwMzczNzcxIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjRDODZBNDNBOUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkEAQAAFAAsAAAAABAAEAAABVAgJVKJYxTF5CTjOAQHIM8H87jKrM/NIAa7ICBAISCEOwRBgAwKDM3dSdaqUmQoqnUkW0CjMwgTLBMYyUoKEEykDHLNngsWrN2qS0lkISa0QgA7" /> minimize
         * - <img style="vertical-align:sub;margin-right:4px;" width="16" height="16" title="" alt="" src="data:image/gif;base64,R0lGODlhEAAQAMQYAGZmZm9vb6mpqeXl5fv7+6ampt3d3Wpqat7e3n5+fmhoaGdnZ9/f321tbY6OjqqqqoCAgPr6+qSkpObm5o+Pj319fWlpaX9/f////wAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo0Qzg2QTQzRjlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo0Qzg2QTQ0MDlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjRDODZBNDNEOUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjRDODZBNDNFOUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkEAQAAGAAsAAAAABAAEAAABWogJmLTkxzH9UzjSBQLIM+LFLnUrM8OIRa7IKCAGShmAUYLI1MMBEhAsjUTJGaGgFQpmp1mmKwU0ZWhwGFtgDxrXGUj8XoGgcLj6qrxPkJomwMYQEI6RBgEOYQAPS4wQTU3S08VFg11gSMhADs=" /> maximize
         * - <img style="vertical-align:sub;margin-right:4px;" width="16" height="16" title="" alt="" src="data:image/gif;base64,R0lGODlhEAAQAMQWAGZmZvv7++Xl5ampqaamprKysrOzs2pqamdnZ2hoaH5+fvr6+oCAgI+Pj46Ojqqqqubm5m1tbaSkpH19fX9/f2lpaf///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo0Qzg2QTQ0MzlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo0Qzg2QTQ0NDlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjRDODZBNDQxOUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjRDODZBNDQyOUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkEAQAAFgAsAAAAABAAEAAABWCgJVrQoxwH9UDjGBAIIM+ItLjNLBe6E4gEnczCmxEsgoQQICoCEoLBktmcDRTTVvGU1QJQAEPLMo1gw60pQyoTi6aD5My9hFqCc7LwaAnk5kI+LjBLNTdjURMVEWsCLSEAOw==" /> restore
         * - <img style="vertical-align:sub;margin-right:4px;" width="16" height="16" title="" alt="" src="data:image/gif;base64,R0lGODlhEAAQANUkAGZmZmpqaqmpqaampvv7++Xl5WhoaGdnZ35+fubm5qqqqo+Pj6SkpPr6+oCAgH19fW1tbY6Oju7u7re3t39/f/X19cfHx/7+/sjIyG5ubuTk5MDAwHd3d2lpabW1tYGBgZeXl29vb9fX1/b29v///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo2RUQwMTJEQTlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo2RUQwMTJEQjlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjZFRDAxMkQ4OUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjZFRDAxMkQ5OUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkEAQAAJAAsAAAAABAAEAAABnFAkpCUUCACAYoiMRwSBgeAdHpgNJyLqXYaIQgH2zBgQCoYth/LeWooCLYcCcmzFSC0Ic0QpD1OAyJNIw9/AVIHGE1CCRlSEHcAE4okFxUbUg5vYmECZptabSRgn1JkJARZn11OUGFVV4puDx0QmQVNQQA7" /> toggle
         * - <img style="vertical-align:sub;margin-right:4px;" width="16" height="16" title="" alt="" src="data:image/gif;base64,R0lGODlhEAAQANUqAGZmZvf394mJifX19WhoaGdnZ2tra/b29n9/f4yMjNLS0u/v7+np6Y2NjfDw8KCgoJeXl+bm5m9vb8bGxnd3d/Ly8uLi4mpqapiYmJqamvT09L6+vnh4ePHx8bCwsLi4uOjo6Le3t62trW1tbdPT06+vr3l5ebGxsePj47y8vP///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo2RUQwMTJERTlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo2RUQwMTJERjlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjZFRDAxMkRDOUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjZFRDAxMkREOUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkEAQAAKgAsAAAAABAAEAAABoxAlXB4AAAOw6QqoFChPMaSReUIDAMCgsDILTw4AqtqQeGauYSm8MGVQCASbmIIKhgTA+EgYSwwVAMhRgYVSRUGRh8DZg1KKg1nXAKOW1wDKUYEf0MMBEYbeR2IAAgRQhEIRhcLQxhdCAh2RiJDJJ6RXBSsSwImJyNmBhlaYksOKhoTRhN5CsVKRUeOQQA7" /> gear
         * - <img style="vertical-align:sub;margin-right:4px;" width="16" height="16" title="" alt="" src="data:image/gif;base64,R0lGODlhEAAQANUkAGZmZmpqaqmpqaampvv7++Xl5WhoaGdnZ35+fubm5qqqqo+Pj6SkpPr6+oCAgH19fW1tbY6Oju7u7re3t39/f/X19cfHx/7+/sjIyG5ubuTk5MDAwHd3d2lpabW1tYGBgZeXl29vb9fX1/b29v///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo2RUQwMTJFMjlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo4NTk0OEQzQzlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjZFRDAxMkUwOUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjZFRDAxMkUxOUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkEAQAAJAAsAAAAABAAEAAABnJAkpCUUFACAYQiMRw2GAeAdHoYEIaEyHQ7XVxJAy7gMNkOSAUDN4AhbQ0FATckEnIFiC1HM+QiAlMfEk1rEFMWTW5bAQ5TBh6EWwhyWyAjJBd3aVwPCRVvBWBiGRtmQlliW15OUGJVX01xDhAdDwKhQ0EAOw==" /> prev
         * - <img style="vertical-align:sub;margin-right:4px;" width="16" height="16" title="" alt="" src="data:image/gif;base64,R0lGODlhEAAQANUkAGZmZmpqaqmpqaampvv7++Xl5WhoaGdnZ35+fubm5qqqqo+Pj6SkpPr6+oCAgH19fW1tbY6Oju7u7re3t39/f/X19cfHx/7+/sjIyG5ubuTk5MDAwHd3d2lpabW1tYGBgZeXl29vb9fX1/b29v///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo4NTk0OEQzRjlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo4NTk0OEQ0MDlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjg1OTQ4RDNEOUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjg1OTQ4RDNFOUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkEAQAAJAAsAAAAABAAEAAABnJAkpCUUFACAYQiMRw2GAeAdHoYEIaEyHQ7XVxJg+0kyh2QCoYtCRPgGgoCrlAU4goQcqGGs0W01UMSH1MBEHlDFoQOhyQeaVIIcVsXJCMgdmhbFQkPbgVgWxsZXABmJFmkW15OUKRVX01wDhAdDwKfQ0EAOw==" /> next
         * - <img style="vertical-align:sub;margin-right:4px;" width="10" height="16" title="" alt="" src="data:image/gif;base64,R0lGODlhCgAQAMQZAGZmZvT09NHR0XNzc729vW5ubo2NjWpqavX19bCwsL6+vtLS0vz8/Pf395SUlLGxsXJycry8vMnJybi4uG1tbfr6+rKysnx8fH19ff///wAAAAAAAAAAAAAAAAAAAAAAACH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo4NTk0OEQ0MzlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo4NTk0OEQ0NDlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjg1OTQ4RDQxOUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjg1OTQ4RDQyOUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkEAQAAGQAsAAAAAAoAEAAABVNglgkGRRmCmCVA6yYjcBABQhwACURqNgGGAiDQCwAKg2ERMHDsej+HREZA2HCSCsTlglQyD27LIgoIXQWiKPzqNZLMRi+jaCnmGcYFw8BnFgs9IQA7" /> pin
         * - <img style="vertical-align:sub;margin-right:4px;" width="10" height="16" title="" alt="" src="data:image/gif;base64,R0lGODlhCgAQAMQbAGZmZvT09L29vff3942NjWpqanNzc21tbfX19XBwcLi4uJSUlNLS0ry8vNHR0bCwsNDQ0Pv7+3V1dX19fcnJyfz8/Lm5uW5ubr6+vrGxsbKysv///wAAAAAAAAAAAAAAACH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpCNTcyRjZBNjlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpCNTcyRjZBNzlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjg1OTQ4RDQ1OUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjg1OTQ4RDQ2OUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkEAQAAGwAsAAAAAAoAEAAABVXgJm4MM57VNFWniAEA1g4GbAynBsPZOCQ7QAK3sQRhlk1EcgRIIhRAQRBACAoAygLQOCkAi1rgFABcLoDxqHwgcL0AgkMqQFixjs2j+RhBCAdtECIhADs=" /> unpin
         * - <img style="vertical-align:sub;margin-right:4px;" width="16" height="16" title="" alt="" src="data:image/gif;base64,R0lGODlhEAAQANUgAGZmZvv7++Xl5ampqaampmhoaGpqan5+fmdnZ+bm5pWVlfr6+pGRkaenp6SkpLu7u5mZmbKyssXFxY+Pj46Ojm1tbaysrICAgPn5+aqqqsPDw7e3t2lpaX19fX9/f7a2tv///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpCNTcyRjZBQTlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpCNTcyRjZBQjlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkI1NzJGNkE4OUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkI1NzJGNkE5OUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkEAQAAIAAsAAAAABAAEAAABnBAkBCUyHgMhkMmMRwuHAiAdIogBIYBynQ7nVxBhGlB0+ACCCBBYSoRWrgFwWAL+Ua4gwNX8f1sDwZmDBhCD1MGFYKEIIZSBhd7Xxt/c1N1QndbA2psbnACYGJkZmggWWZbXk5QZlVfTXIXFRwdm01BADs=" /> right
         * - <img style="vertical-align:sub;margin-right:4px;" width="16" height="16" title="" alt="" src="data:image/gif;base64,R0lGODlhEAAQANUgAGZmZvv7++Xl5ampqaampmhoaGpqan5+fmdnZ+bm5pWVlfr6+pGRkaenp6SkpLu7u5mZmbKyssXFxY+Pj46Ojm1tbaysrICAgPn5+aqqqsPDw7e3t2lpaX19fX9/f7a2tv///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpCNTcyRjZBRTlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpCNTcyRjZBRjlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkI1NzJGNkFDOUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkI1NzJGNkFEOUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkEAQAAIAAsAAAAABAAEAAABnRAkBCUyHgMhkMmMRwuHAiAdIogBIYBynQ7nVxBBC6goSlMCSCBeWsRSqYFwYAbEQYg28Fhu7EruAcGUw9CGAxiBhWDhYdcBhdbH36Ac1t1IHd5alxtIG9ScWBiZGsAaJhaYl1fIE9RXFWsQ3IXFRwdAwJNQQA7" /> left
         * - <img style="vertical-align:sub;margin-right:4px;" width="16" height="16" title="" alt="" src="data:image/gif;base64,R0lGODlhEAAQANUgAGZmZvv7++Xl5ampqaampmhoaGpqan5+fmdnZ+bm5pWVlfr6+pGRkaenp6SkpLu7u5mZmbKyssXFxY+Pj46Ojm1tbaysrICAgPn5+aqqqsPDw7e3t2lpaX19fX9/f7a2tv///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpENUNDODdFNzlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpENUNDODdFODlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkI1NzJGNkIwOUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkQ1Q0M4N0U2OUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkEAQAAIAAsAAAAABAAEAAABntAkBAkGHQ4lctAMBwGCAiAdIpwLJyTqXZKCQgJ2zCAQCyIt4WitCCBaCESM2BwkGpAAYVU4dVILwZSDUIBDAxeIA1SFYFSFkIYGEIWUwZ1UxFNEVoHA1sbQh9bS3JTDw9oTGBnU2R4WaxdTlBhVVdNIAkZBwYGHhkJTUEAOw==" /> down
         * - <img style="vertical-align:sub;margin-right:4px;" width="16" height="16" title="" alt="" src="data:image/gif;base64,R0lGODlhEAAQANUgAGZmZvv7++Xl5ampqaampmhoaGpqan5+fmdnZ+bm5pWVlfr6+pGRkaenp6SkpLu7u5mZmbKyssXFxY+Pj46Ojm1tbaysrICAgPn5+aqqqsPDw7e3t2lpaX19fX9/f7a2tv///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpENUNDODdFQjlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpENUNDODdFQzlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkQ1Q0M4N0U5OUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkQ1Q0M4N0VBOUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkEAQAAIAAsAAAAABAAEAAABnpAkBCUyBwMBk8mMRwGCAiAdIpwLJyTqXZKCQgJ2zCAABIUto/HtiAYbDfCz3Zw0EaaEe1xahFiMEIWU0hSDUIBDAxeIA1SFXUAGiABClIKXhpSF24ABRIQWhASZwADZmJrAiBgqFNkk1mtXU5QYVVXTWUDHRwVm6pDQQA7" /> up
         * - <img style="vertical-align:sub;margin-right:4px;" width="16" height="16" title="" alt="" src="data:image/gif;base64,R0lGODlhEAAQANUuAGZmZq2trfv7+2dnZ3p6empqamhoaLOzs6ampqmpqX5+fqSkpPr6+ubm5s7OzrKysvj4+Kenp39/f+Xl5bCwsI6Ojq+vr/39/YuLi8zMzIODg+Tk5Pz8/NDQ0GlpadHR0ZOTk4+Pj6qqqqWlpWtra/n5+Xd3d66urr29vX19ff7+/tnZ2aysrMrKyv///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpENUNDODdFRjlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpENUNDODdGMDlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkQ1Q0M4N0VEOUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkQ1Q0M4N0VFOUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkEAQAALgAsAAAAABAAEAAABoVAl9DVEEkKBQWiMTwIGSMDYEo1RDgHgEsQmhIODgcKNAAQpq4IYHASDIUfKmAifbyFEIw8YXa/83IAEgAUdy4dAYmKBQAZho+Mjo93CoSTd3wEfoYXKkJ0AHaPDxorQghrFpsuFyxlC0ICFV5gLRYmUxUlQwwLZYEDCwyGDQkpHiRKG29BADs=" /> refresh
         * - <img style="vertical-align:sub;margin-right:4px;" width="16" height="16" title="" alt="" src="data:image/gif;base64,R0lGODlhEAAQAMQVAGZmZmhoaKmpqfv7+2pqaqampubm5uXl5X9/f4+Pj6enp6qqqn5+fmdnZ21tbfr6+oCAgI6OjqWlpWlpaX19ff///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpGNUEwNjdFMjlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpGNUEwNjdFMzlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkY1QTA2N0UwOUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkY1QTA2N0UxOUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkEAQAAFQAsAAAAABAAEAAABVxgJVbGghAEshjj+BQBIM+BMoxDMu9zclcKnohXqBxiu+EucBDwAMqdAPGMzhgEWWtbkaG03JHMwah2eRCn8Cw9rnnMSuG9K1YGkefO55I0ng02XAYCFBMOaSwjIQA7" /> plus
         * - <img style="vertical-align:sub;margin-right:4px;" width="16" height="16" title="" alt="" src="data:image/gif;base64,R0lGODlhEAAQAMQVAGZmZmhoaKmpqfv7+2pqaqampubm5uXl5aenp4+Pj39/f4CAgKqqqm1tbX5+fmdnZ/r6+n19faWlpWlpaY6Ojv///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpGNUEwNjdFNjlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpGNUEwNjdFNzlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkY1QTA2N0U0OUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkY1QTA2N0U1OUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkEAQAAFQAsAAAAABAAEAAABVRgJVYGoxCEwhjjCBUBIM8BMoxDMu9zclcInhBQqBxiw13gIEgKBQonz0GQta4VGcqKHckaDulu0RTLBEfzslIwFysDitTnkjyEDxvWIIhMGmQsIyEAOw==" /> minus
         * - <img style="vertical-align:sub;margin-right:4px;" width="16" height="16" title="" alt="" src="data:image/gif;base64,R0lGODlhEAAQANU7AGZmZmdnZ8vLy8DAwLS0tGpqavv7+8rKyoCAgJaWlv7+/vX19cHBwbOzs+3t7bm5uWxsbI6OjsLCwpmZmbq6upiYmN3d3eHh4b29vbW1tZ2dnX19faqqqvPz8/39/WlpaYeHh4WFhezs7ImJiYuLi7i4uO/v74ODg+jo6Pj4+Hl5eeXl5e7u7uPj48TExPb29np6euTk5NDQ0I2NjZSUlGhoaLCwsG1tbYaGhnNzc2tra////wAAAAAAAAAAAAAAACH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpGNUEwNjdFQTlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDowRTE4NTU0NDlBQTYxMUU0OEVCNUNFMTgyMDM3Mzc3MSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkY1QTA2N0U4OUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkY1QTA2N0U5OUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkEAQAAOwAsAAAAABAAEAAABn7AnVBocCyGSGQroQMAEBJFUigoADaVmTVhSK4KN8HQMQJwkhPAIflSfUxDDwQ23ZUAriELQKvLAA1DKQEgdQwAGEg4NShTEQAXSAcAIR1IFE9TGgA5NgISJE4ABEkKDRCiABEZAaNTCwIPDDFCA62kdUm2AA+5ugEnvkkWIkEAOw==" /> search
         * - <img style="vertical-align:sub;margin-right:4px;" width="16" height="13" title="" alt="" src="data:image/gif;base64,R0lGODlhEAANANUtAGZmZvv7+/39/XNzc+vr629vb3d3d9/f33Fxcaqqqurq6pWVle7u7ufn52xsbHR0dKioqOPj46ysrPLy8uXl5aKioujo6O/v79fX17q6umdnZ5iYmKCgoIyMjHBwcNra2q+vr3l5eZycnJeXl9vb23x8fH9/f6enp7CwsJqamuLi4rOzs5aWlv///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowRTE4NTU0NzlBQTYxMUU0OEVCNUNFMTgyMDM3Mzc3MSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDowRTE4NTU0ODlBQTYxMUU0OEVCNUNFMTgyMDM3Mzc3MSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjBFMTg1NTQ1OUFBNjExRTQ4RUI1Q0UxODIwMzczNzcxIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjBFMTg1NTQ2OUFBNjExRTQ4RUI1Q0UxODIwMzczNzcxIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkEAQAALQAsAAAAABAADQAABljAlnBIFAZYn6KyFVgACoflUJACWDtSIccKME2EBOWJW7oIE4gIUcINMYQo66AhXHENYSHorshwHxZFEFwDGnIUSxVcVh4qUgIiXFBZLQIjAA4klEYbGFlBADs=" /> save
         * - <img style="vertical-align:sub;margin-right:4px;" width="16" height="16" title="" alt="" src="data:image/gif;base64,R0lGODlhEAAQANUqAGZmZmhoaKmpqfv7+2pqaqampvr6+uXl5ebm5qenp4+Pj39/f46Ojn5+fqqqqvb29oCAgO7u7m1tbbS0tNvb2/39/WdnZ8/Pz+vr63t7e6Ojo6WlpcjIyLKyss7Ozn19fWlpafT09NnZ2YODg9DQ0Jubm7y8vHBwcIaGht3d3f///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowRTE4NTU0QjlBQTYxMUU0OEVCNUNFMTgyMDM3Mzc3MSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDowRTE4NTU0QzlBQTYxMUU0OEVCNUNFMTgyMDM3Mzc3MSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjBFMTg1NTQ5OUFBNjExRTQ4RUI1Q0UxODIwMzczNzcxIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjBFMTg1NTRBOUFBNjExRTQ4RUI1Q0UxODIwMzczNzcxIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkEAQAAKgAsAAAAABAAEAAABn9AlVCFcCwIhIUDMRwaCgGAdBpIDIYDxXQ7VVxVCarp8eCcpgXVISrtqEQYlYd6EGwjJEBGZdgKFlsaKAAMKhFbDQRcACMhFSVbSIspBgxcEg2LFReLEHaLoAJrXBMTXAEHKgVcFBRcaSoDlqBSXk4bFosWVk1CCAIfIBKeTENBADs=" /> help
         * - <img style="vertical-align:sub;margin-right:4px;" width="16" height="14" title="" alt="" src="data:image/gif;base64,R0lGODlhEAAOAKIFAGZmZnV1ddPT03R0dHZ2dv///wAAAAAAACH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozNTFFNEY3QzlBQTYxMUU0OEVCNUNFMTgyMDM3Mzc3MSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozNTFFNEY3RDlBQTYxMUU0OEVCNUNFMTgyMDM3Mzc3MSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjBFMTg1NTREOUFBNjExRTQ4RUI1Q0UxODIwMzczNzcxIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjBFMTg1NTRFOUFBNjExRTQ4RUI1Q0UxODIwMzczNzcxIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkEAQAABQAsAAAAABAADgAAAyxYCtyusLgJor1RBEqD5twGjhW2TBKXPmVUUSvaiNL1AoMw3DBACC6bCRRJAAA7" /> print
         * - <img style="vertical-align:sub;margin-right:4px;" width="16" height="16" title="" alt="" src="data:image/gif;base64,R0lGODlhEAAQAIABAGZmZv///yH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozNTFFNEY4MDlBQTYxMUU0OEVCNUNFMTgyMDM3Mzc3MSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozNTFFNEY4MTlBQTYxMUU0OEVCNUNFMTgyMDM3Mzc3MSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjM1MUU0RjdFOUFBNjExRTQ4RUI1Q0UxODIwMzczNzcxIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjM1MUU0RjdGOUFBNjExRTQ4RUI1Q0UxODIwMzczNzcxIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkEAQAAAQAsAAAAABAAEAAAAh+EHakbh8wcgNHRJW/UvDcPQlNIflTGodP6SaOGwk4BADs=" /> expand
         * - <img style="vertical-align:sub;margin-right:4px;" width="16" height="14" title="" alt="" src="data:image/gif;base64,R0lGODlhEAAOAIABAGZmZv///yH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozNTFFNEY4NDlBQTYxMUU0OEVCNUNFMTgyMDM3Mzc3MSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozNTFFNEY4NTlBQTYxMUU0OEVCNUNFMTgyMDM3Mzc3MSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjM1MUU0RjgyOUFBNjExRTQ4RUI1Q0UxODIwMzczNzcxIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjM1MUU0RjgzOUFBNjExRTQ4RUI1Q0UxODIwMzczNzcxIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkEAQAAAQAsAAAAABAADgAAAhyEHakbh8wcAq1SSeGSuvsPhmLkgNyHWWqKll8BADs=" /> collapse
         */
        type?: string;
    }

    /**
     * This class is used to display small visual icons in the header of a panel. There are a set of
     * 25 icons that can be specified by using the {@link #type} config. The {@link #handler} config
     * can be used to provide a function that will respond to any click events. In general, this class
     * will not be instantiated directly, rather it will be created by specifying the {@link Ext.Panel#tools}
     * configuration on the Panel itself.
     *
     *     @example
     *     Ext.create('Ext.Panel', {
     *         title: 'A Panel',
     *         fullscreen: true,
     *
     *         tools: [{
     *             type: 'help',
     *             handler: function() {
     *                 // show help here
     *             }
     *         }, {
     *             itemId: 'refresh',
     *             type: 'refresh',
     *             hidden: true,
     *             handler: function () {
     *                 // do refresh
     *             }
     *         }, {
     *             type: 'search',
     *             handler: function (panel) {
     *                 // do search
     *                 panel.down('#refresh').show();
     *             }
     *         }]
     *     });
     *
     * @since 6.0.1
     */
    export class Tool extends Ext.Component implements Ext.panel.ToolConfig {
        protected element: any;

        /**
         * 'true' in this class to identify an object as an instantiated Tool, or subclass thereof.
         * @readonly
         */
        isPanelTool: boolean;

        baseCls: string;

        disabledCls: string;

        /**
         * A function to execute when the tool is clicked.
         *
         * The logical owner of the tool. In a typical usage
         * this will be an 'Ext.Panel' (as specified by the 'toolOwner' config).
         * The tool that is calling.
         * The click event.
         * @controllable
         */
        handler: Function|string;

        /**
         * An alternative to the standard list of {@link #type types}.
         */
        iconCls: string;

        /**
         * The scope to execute the {@link #handler} function. Defaults to the tool.
         */
        scope: any;

        /**
         * Specify as false to allow click event to propagate.
         */
        stopEvent: boolean;

        /**
         * The owner to report to the 'handler' method. Default is 'null' for the 'parent'.
         * This is automatically set to the owning 'Ext.Panel' when a tool is created as a
         * member of a panel's 'tools'.
         */
        toolOwner: Ext.Component;

        /**
         * The type of tool to render. The following types are available:
         *
         * ##Neptune Theme
         * - <img style="vertical-align:sub;margin-right:4px;" width="16" height="16" title="" alt="" src="data:image/gif;base64,R0lGODlhEAAQAMQfAGZmZqamptbW1nNzc9nZ2eXl5ampqfv7+2pqanR0dNjY2H5+fnh4eGdnZ2xsbG5ubtfX129vb2hoaObm5qWlpaqqqvr6+qSkpI+Pj21tbY6OjoCAgH19fWlpaX9/f////yH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpDRTk3OUEzMjlBQTQxMUU0OEVCNUNFMTgyMDM3Mzc3MSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpDRTk3OUEzMzlBQTQxMUU0OEVCNUNFMTgyMDM3Mzc3MSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkNFOTc5QTMwOUFBNDExRTQ4RUI1Q0UxODIwMzczNzcxIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkNFOTc5QTMxOUFBNDExRTQ4RUI1Q0UxODIwMzczNzcxIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkEAQAAHwAsAAAAABAAEAAABYLgJ35TtSCIV03jeAQNIM/NZbnYrM/aIQYARyChSwQcgMCnIAFQPoSBbED4UACSgkHGqCoiEQWUITMsZgPIRyD4QKSyk+7RXj90qHldcJ9lzlNqbG5wABtbAF0fX2FjZUxJUHBUH0BZlUFDRUeRHwc5Ozo9LjChNTctSwYcHRmHBS0hADs=" /> close
         * - <img style="vertical-align:sub;margin-right:4px;" width="16" height="16" title="" alt="" src="data:image/gif;base64,R0lGODlhEAAQAMQUAGZmZqampqmpqfv7++Xl5Wpqan5+fmdnZ2hoaObm5o+Pj21tbaSkpI6Ojqqqqvr6+oCAgGlpaX19fX9/f////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo0Qzg2QTQzQjlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo0Qzg2QTQzQzlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkNFOTc5QTM0OUFBNDExRTQ4RUI1Q0UxODIwMzczNzcxIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjRDODZBNDNBOUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkEAQAAFAAsAAAAABAAEAAABVAgJVKJYxTF5CTjOAQHIM8H87jKrM/NIAa7ICBAISCEOwRBgAwKDM3dSdaqUmQoqnUkW0CjMwgTLBMYyUoKEEykDHLNngsWrN2qS0lkISa0QgA7" /> minimize
         * - <img style="vertical-align:sub;margin-right:4px;" width="16" height="16" title="" alt="" src="data:image/gif;base64,R0lGODlhEAAQAMQYAGZmZm9vb6mpqeXl5fv7+6ampt3d3Wpqat7e3n5+fmhoaGdnZ9/f321tbY6OjqqqqoCAgPr6+qSkpObm5o+Pj319fWlpaX9/f////wAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo0Qzg2QTQzRjlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo0Qzg2QTQ0MDlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjRDODZBNDNEOUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjRDODZBNDNFOUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkEAQAAGAAsAAAAABAAEAAABWogJmLTkxzH9UzjSBQLIM+LFLnUrM8OIRa7IKCAGShmAUYLI1MMBEhAsjUTJGaGgFQpmp1mmKwU0ZWhwGFtgDxrXGUj8XoGgcLj6qrxPkJomwMYQEI6RBgEOYQAPS4wQTU3S08VFg11gSMhADs=" /> maximize
         * - <img style="vertical-align:sub;margin-right:4px;" width="16" height="16" title="" alt="" src="data:image/gif;base64,R0lGODlhEAAQAMQWAGZmZvv7++Xl5ampqaamprKysrOzs2pqamdnZ2hoaH5+fvr6+oCAgI+Pj46Ojqqqqubm5m1tbaSkpH19fX9/f2lpaf///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo0Qzg2QTQ0MzlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo0Qzg2QTQ0NDlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjRDODZBNDQxOUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjRDODZBNDQyOUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkEAQAAFgAsAAAAABAAEAAABWCgJVrQoxwH9UDjGBAIIM+ItLjNLBe6E4gEnczCmxEsgoQQICoCEoLBktmcDRTTVvGU1QJQAEPLMo1gw60pQyoTi6aD5My9hFqCc7LwaAnk5kI+LjBLNTdjURMVEWsCLSEAOw==" /> restore
         * - <img style="vertical-align:sub;margin-right:4px;" width="16" height="16" title="" alt="" src="data:image/gif;base64,R0lGODlhEAAQANUkAGZmZmpqaqmpqaampvv7++Xl5WhoaGdnZ35+fubm5qqqqo+Pj6SkpPr6+oCAgH19fW1tbY6Oju7u7re3t39/f/X19cfHx/7+/sjIyG5ubuTk5MDAwHd3d2lpabW1tYGBgZeXl29vb9fX1/b29v///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo2RUQwMTJEQTlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo2RUQwMTJEQjlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjZFRDAxMkQ4OUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjZFRDAxMkQ5OUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkEAQAAJAAsAAAAABAAEAAABnFAkpCUUCACAYoiMRwSBgeAdHpgNJyLqXYaIQgH2zBgQCoYth/LeWooCLYcCcmzFSC0Ic0QpD1OAyJNIw9/AVIHGE1CCRlSEHcAE4okFxUbUg5vYmECZptabSRgn1JkJARZn11OUGFVV4puDx0QmQVNQQA7" /> toggle
         * - <img style="vertical-align:sub;margin-right:4px;" width="16" height="16" title="" alt="" src="data:image/gif;base64,R0lGODlhEAAQANUqAGZmZvf394mJifX19WhoaGdnZ2tra/b29n9/f4yMjNLS0u/v7+np6Y2NjfDw8KCgoJeXl+bm5m9vb8bGxnd3d/Ly8uLi4mpqapiYmJqamvT09L6+vnh4ePHx8bCwsLi4uOjo6Le3t62trW1tbdPT06+vr3l5ebGxsePj47y8vP///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo2RUQwMTJERTlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo2RUQwMTJERjlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjZFRDAxMkRDOUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjZFRDAxMkREOUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkEAQAAKgAsAAAAABAAEAAABoxAlXB4AAAOw6QqoFChPMaSReUIDAMCgsDILTw4AqtqQeGauYSm8MGVQCASbmIIKhgTA+EgYSwwVAMhRgYVSRUGRh8DZg1KKg1nXAKOW1wDKUYEf0MMBEYbeR2IAAgRQhEIRhcLQxhdCAh2RiJDJJ6RXBSsSwImJyNmBhlaYksOKhoTRhN5CsVKRUeOQQA7" /> gear
         * - <img style="vertical-align:sub;margin-right:4px;" width="16" height="16" title="" alt="" src="data:image/gif;base64,R0lGODlhEAAQANUkAGZmZmpqaqmpqaampvv7++Xl5WhoaGdnZ35+fubm5qqqqo+Pj6SkpPr6+oCAgH19fW1tbY6Oju7u7re3t39/f/X19cfHx/7+/sjIyG5ubuTk5MDAwHd3d2lpabW1tYGBgZeXl29vb9fX1/b29v///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo2RUQwMTJFMjlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo4NTk0OEQzQzlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjZFRDAxMkUwOUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjZFRDAxMkUxOUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkEAQAAJAAsAAAAABAAEAAABnJAkpCUUFACAYQiMRw2GAeAdHoYEIaEyHQ7XVxJAy7gMNkOSAUDN4AhbQ0FATckEnIFiC1HM+QiAlMfEk1rEFMWTW5bAQ5TBh6EWwhyWyAjJBd3aVwPCRVvBWBiGRtmQlliW15OUGJVX01xDhAdDwKhQ0EAOw==" /> prev
         * - <img style="vertical-align:sub;margin-right:4px;" width="16" height="16" title="" alt="" src="data:image/gif;base64,R0lGODlhEAAQANUkAGZmZmpqaqmpqaampvv7++Xl5WhoaGdnZ35+fubm5qqqqo+Pj6SkpPr6+oCAgH19fW1tbY6Oju7u7re3t39/f/X19cfHx/7+/sjIyG5ubuTk5MDAwHd3d2lpabW1tYGBgZeXl29vb9fX1/b29v///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo4NTk0OEQzRjlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo4NTk0OEQ0MDlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjg1OTQ4RDNEOUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjg1OTQ4RDNFOUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkEAQAAJAAsAAAAABAAEAAABnJAkpCUUFACAYQiMRw2GAeAdHoYEIaEyHQ7XVxJg+0kyh2QCoYtCRPgGgoCrlAU4goQcqGGs0W01UMSH1MBEHlDFoQOhyQeaVIIcVsXJCMgdmhbFQkPbgVgWxsZXABmJFmkW15OUKRVX01wDhAdDwKfQ0EAOw==" /> next
         * - <img style="vertical-align:sub;margin-right:4px;" width="10" height="16" title="" alt="" src="data:image/gif;base64,R0lGODlhCgAQAMQZAGZmZvT09NHR0XNzc729vW5ubo2NjWpqavX19bCwsL6+vtLS0vz8/Pf395SUlLGxsXJycry8vMnJybi4uG1tbfr6+rKysnx8fH19ff///wAAAAAAAAAAAAAAAAAAAAAAACH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo4NTk0OEQ0MzlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo4NTk0OEQ0NDlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjg1OTQ4RDQxOUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjg1OTQ4RDQyOUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkEAQAAGQAsAAAAAAoAEAAABVNglgkGRRmCmCVA6yYjcBABQhwACURqNgGGAiDQCwAKg2ERMHDsej+HREZA2HCSCsTlglQyD27LIgoIXQWiKPzqNZLMRi+jaCnmGcYFw8BnFgs9IQA7" /> pin
         * - <img style="vertical-align:sub;margin-right:4px;" width="10" height="16" title="" alt="" src="data:image/gif;base64,R0lGODlhCgAQAMQbAGZmZvT09L29vff3942NjWpqanNzc21tbfX19XBwcLi4uJSUlNLS0ry8vNHR0bCwsNDQ0Pv7+3V1dX19fcnJyfz8/Lm5uW5ubr6+vrGxsbKysv///wAAAAAAAAAAAAAAACH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpCNTcyRjZBNjlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpCNTcyRjZBNzlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjg1OTQ4RDQ1OUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjg1OTQ4RDQ2OUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkEAQAAGwAsAAAAAAoAEAAABVXgJm4MM57VNFWniAEA1g4GbAynBsPZOCQ7QAK3sQRhlk1EcgRIIhRAQRBACAoAygLQOCkAi1rgFABcLoDxqHwgcL0AgkMqQFixjs2j+RhBCAdtECIhADs=" /> unpin
         * - <img style="vertical-align:sub;margin-right:4px;" width="16" height="16" title="" alt="" src="data:image/gif;base64,R0lGODlhEAAQANUgAGZmZvv7++Xl5ampqaampmhoaGpqan5+fmdnZ+bm5pWVlfr6+pGRkaenp6SkpLu7u5mZmbKyssXFxY+Pj46Ojm1tbaysrICAgPn5+aqqqsPDw7e3t2lpaX19fX9/f7a2tv///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpCNTcyRjZBQTlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpCNTcyRjZBQjlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkI1NzJGNkE4OUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkI1NzJGNkE5OUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkEAQAAIAAsAAAAABAAEAAABnBAkBCUyHgMhkMmMRwuHAiAdIogBIYBynQ7nVxBhGlB0+ACCCBBYSoRWrgFwWAL+Ua4gwNX8f1sDwZmDBhCD1MGFYKEIIZSBhd7Xxt/c1N1QndbA2psbnACYGJkZmggWWZbXk5QZlVfTXIXFRwdm01BADs=" /> right
         * - <img style="vertical-align:sub;margin-right:4px;" width="16" height="16" title="" alt="" src="data:image/gif;base64,R0lGODlhEAAQANUgAGZmZvv7++Xl5ampqaampmhoaGpqan5+fmdnZ+bm5pWVlfr6+pGRkaenp6SkpLu7u5mZmbKyssXFxY+Pj46Ojm1tbaysrICAgPn5+aqqqsPDw7e3t2lpaX19fX9/f7a2tv///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpCNTcyRjZBRTlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpCNTcyRjZBRjlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkI1NzJGNkFDOUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkI1NzJGNkFEOUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkEAQAAIAAsAAAAABAAEAAABnRAkBCUyHgMhkMmMRwuHAiAdIogBIYBynQ7nVxBBC6goSlMCSCBeWsRSqYFwYAbEQYg28Fhu7EruAcGUw9CGAxiBhWDhYdcBhdbH36Ac1t1IHd5alxtIG9ScWBiZGsAaJhaYl1fIE9RXFWsQ3IXFRwdAwJNQQA7" /> left
         * - <img style="vertical-align:sub;margin-right:4px;" width="16" height="16" title="" alt="" src="data:image/gif;base64,R0lGODlhEAAQANUgAGZmZvv7++Xl5ampqaampmhoaGpqan5+fmdnZ+bm5pWVlfr6+pGRkaenp6SkpLu7u5mZmbKyssXFxY+Pj46Ojm1tbaysrICAgPn5+aqqqsPDw7e3t2lpaX19fX9/f7a2tv///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpENUNDODdFNzlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpENUNDODdFODlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkI1NzJGNkIwOUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkQ1Q0M4N0U2OUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkEAQAAIAAsAAAAABAAEAAABntAkBAkGHQ4lctAMBwGCAiAdIpwLJyTqXZKCQgJ2zCAQCyIt4WitCCBaCESM2BwkGpAAYVU4dVILwZSDUIBDAxeIA1SFYFSFkIYGEIWUwZ1UxFNEVoHA1sbQh9bS3JTDw9oTGBnU2R4WaxdTlBhVVdNIAkZBwYGHhkJTUEAOw==" /> down
         * - <img style="vertical-align:sub;margin-right:4px;" width="16" height="16" title="" alt="" src="data:image/gif;base64,R0lGODlhEAAQANUgAGZmZvv7++Xl5ampqaampmhoaGpqan5+fmdnZ+bm5pWVlfr6+pGRkaenp6SkpLu7u5mZmbKyssXFxY+Pj46Ojm1tbaysrICAgPn5+aqqqsPDw7e3t2lpaX19fX9/f7a2tv///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpENUNDODdFQjlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpENUNDODdFQzlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkQ1Q0M4N0U5OUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkQ1Q0M4N0VBOUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkEAQAAIAAsAAAAABAAEAAABnpAkBCUyBwMBk8mMRwGCAiAdIpwLJyTqXZKCQgJ2zCAABIUto/HtiAYbDfCz3Zw0EaaEe1xahFiMEIWU0hSDUIBDAxeIA1SFXUAGiABClIKXhpSF24ABRIQWhASZwADZmJrAiBgqFNkk1mtXU5QYVVXTWUDHRwVm6pDQQA7" /> up
         * - <img style="vertical-align:sub;margin-right:4px;" width="16" height="16" title="" alt="" src="data:image/gif;base64,R0lGODlhEAAQANUuAGZmZq2trfv7+2dnZ3p6empqamhoaLOzs6ampqmpqX5+fqSkpPr6+ubm5s7OzrKysvj4+Kenp39/f+Xl5bCwsI6Ojq+vr/39/YuLi8zMzIODg+Tk5Pz8/NDQ0GlpadHR0ZOTk4+Pj6qqqqWlpWtra/n5+Xd3d66urr29vX19ff7+/tnZ2aysrMrKyv///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpENUNDODdFRjlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpENUNDODdGMDlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkQ1Q0M4N0VEOUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkQ1Q0M4N0VFOUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkEAQAALgAsAAAAABAAEAAABoVAl9DVEEkKBQWiMTwIGSMDYEo1RDgHgEsQmhIODgcKNAAQpq4IYHASDIUfKmAifbyFEIw8YXa/83IAEgAUdy4dAYmKBQAZho+Mjo93CoSTd3wEfoYXKkJ0AHaPDxorQghrFpsuFyxlC0ICFV5gLRYmUxUlQwwLZYEDCwyGDQkpHiRKG29BADs=" /> refresh
         * - <img style="vertical-align:sub;margin-right:4px;" width="16" height="16" title="" alt="" src="data:image/gif;base64,R0lGODlhEAAQAMQVAGZmZmhoaKmpqfv7+2pqaqampubm5uXl5X9/f4+Pj6enp6qqqn5+fmdnZ21tbfr6+oCAgI6OjqWlpWlpaX19ff///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpGNUEwNjdFMjlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpGNUEwNjdFMzlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkY1QTA2N0UwOUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkY1QTA2N0UxOUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkEAQAAFQAsAAAAABAAEAAABVxgJVbGghAEshjj+BQBIM+BMoxDMu9zclcKnohXqBxiu+EucBDwAMqdAPGMzhgEWWtbkaG03JHMwah2eRCn8Cw9rnnMSuG9K1YGkefO55I0ng02XAYCFBMOaSwjIQA7" /> plus
         * - <img style="vertical-align:sub;margin-right:4px;" width="16" height="16" title="" alt="" src="data:image/gif;base64,R0lGODlhEAAQAMQVAGZmZmhoaKmpqfv7+2pqaqampubm5uXl5aenp4+Pj39/f4CAgKqqqm1tbX5+fmdnZ/r6+n19faWlpWlpaY6Ojv///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpGNUEwNjdFNjlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpGNUEwNjdFNzlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkY1QTA2N0U0OUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkY1QTA2N0U1OUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkEAQAAFQAsAAAAABAAEAAABVRgJVYGoxCEwhjjCBUBIM8BMoxDMu9zclcInhBQqBxiw13gIEgKBQonz0GQta4VGcqKHckaDulu0RTLBEfzslIwFysDitTnkjyEDxvWIIhMGmQsIyEAOw==" /> minus
         * - <img style="vertical-align:sub;margin-right:4px;" width="16" height="16" title="" alt="" src="data:image/gif;base64,R0lGODlhEAAQANU7AGZmZmdnZ8vLy8DAwLS0tGpqavv7+8rKyoCAgJaWlv7+/vX19cHBwbOzs+3t7bm5uWxsbI6OjsLCwpmZmbq6upiYmN3d3eHh4b29vbW1tZ2dnX19faqqqvPz8/39/WlpaYeHh4WFhezs7ImJiYuLi7i4uO/v74ODg+jo6Pj4+Hl5eeXl5e7u7uPj48TExPb29np6euTk5NDQ0I2NjZSUlGhoaLCwsG1tbYaGhnNzc2tra////wAAAAAAAAAAAAAAACH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpGNUEwNjdFQTlBQTUxMUU0OEVCNUNFMTgyMDM3Mzc3MSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDowRTE4NTU0NDlBQTYxMUU0OEVCNUNFMTgyMDM3Mzc3MSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkY1QTA2N0U4OUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkY1QTA2N0U5OUFBNTExRTQ4RUI1Q0UxODIwMzczNzcxIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkEAQAAOwAsAAAAABAAEAAABn7AnVBocCyGSGQroQMAEBJFUigoADaVmTVhSK4KN8HQMQJwkhPAIflSfUxDDwQ23ZUAriELQKvLAA1DKQEgdQwAGEg4NShTEQAXSAcAIR1IFE9TGgA5NgISJE4ABEkKDRCiABEZAaNTCwIPDDFCA62kdUm2AA+5ugEnvkkWIkEAOw==" /> search
         * - <img style="vertical-align:sub;margin-right:4px;" width="16" height="13" title="" alt="" src="data:image/gif;base64,R0lGODlhEAANANUtAGZmZvv7+/39/XNzc+vr629vb3d3d9/f33Fxcaqqqurq6pWVle7u7ufn52xsbHR0dKioqOPj46ysrPLy8uXl5aKioujo6O/v79fX17q6umdnZ5iYmKCgoIyMjHBwcNra2q+vr3l5eZycnJeXl9vb23x8fH9/f6enp7CwsJqamuLi4rOzs5aWlv///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowRTE4NTU0NzlBQTYxMUU0OEVCNUNFMTgyMDM3Mzc3MSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDowRTE4NTU0ODlBQTYxMUU0OEVCNUNFMTgyMDM3Mzc3MSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjBFMTg1NTQ1OUFBNjExRTQ4RUI1Q0UxODIwMzczNzcxIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjBFMTg1NTQ2OUFBNjExRTQ4RUI1Q0UxODIwMzczNzcxIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkEAQAALQAsAAAAABAADQAABljAlnBIFAZYn6KyFVgACoflUJACWDtSIccKME2EBOWJW7oIE4gIUcINMYQo66AhXHENYSHorshwHxZFEFwDGnIUSxVcVh4qUgIiXFBZLQIjAA4klEYbGFlBADs=" /> save
         * - <img style="vertical-align:sub;margin-right:4px;" width="16" height="16" title="" alt="" src="data:image/gif;base64,R0lGODlhEAAQANUqAGZmZmhoaKmpqfv7+2pqaqampvr6+uXl5ebm5qenp4+Pj39/f46Ojn5+fqqqqvb29oCAgO7u7m1tbbS0tNvb2/39/WdnZ8/Pz+vr63t7e6Ojo6WlpcjIyLKyss7Ozn19fWlpafT09NnZ2YODg9DQ0Jubm7y8vHBwcIaGht3d3f///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowRTE4NTU0QjlBQTYxMUU0OEVCNUNFMTgyMDM3Mzc3MSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDowRTE4NTU0QzlBQTYxMUU0OEVCNUNFMTgyMDM3Mzc3MSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjBFMTg1NTQ5OUFBNjExRTQ4RUI1Q0UxODIwMzczNzcxIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjBFMTg1NTRBOUFBNjExRTQ4RUI1Q0UxODIwMzczNzcxIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkEAQAAKgAsAAAAABAAEAAABn9AlVCFcCwIhIUDMRwaCgGAdBpIDIYDxXQ7VVxVCarp8eCcpgXVISrtqEQYlYd6EGwjJEBGZdgKFlsaKAAMKhFbDQRcACMhFSVbSIspBgxcEg2LFReLEHaLoAJrXBMTXAEHKgVcFBRcaSoDlqBSXk4bFosWVk1CCAIfIBKeTENBADs=" /> help
         * - <img style="vertical-align:sub;margin-right:4px;" width="16" height="14" title="" alt="" src="data:image/gif;base64,R0lGODlhEAAOAKIFAGZmZnV1ddPT03R0dHZ2dv///wAAAAAAACH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozNTFFNEY3QzlBQTYxMUU0OEVCNUNFMTgyMDM3Mzc3MSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozNTFFNEY3RDlBQTYxMUU0OEVCNUNFMTgyMDM3Mzc3MSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjBFMTg1NTREOUFBNjExRTQ4RUI1Q0UxODIwMzczNzcxIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjBFMTg1NTRFOUFBNjExRTQ4RUI1Q0UxODIwMzczNzcxIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkEAQAABQAsAAAAABAADgAAAyxYCtyusLgJor1RBEqD5twGjhW2TBKXPmVUUSvaiNL1AoMw3DBACC6bCRRJAAA7" /> print
         * - <img style="vertical-align:sub;margin-right:4px;" width="16" height="16" title="" alt="" src="data:image/gif;base64,R0lGODlhEAAQAIABAGZmZv///yH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozNTFFNEY4MDlBQTYxMUU0OEVCNUNFMTgyMDM3Mzc3MSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozNTFFNEY4MTlBQTYxMUU0OEVCNUNFMTgyMDM3Mzc3MSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjM1MUU0RjdFOUFBNjExRTQ4RUI1Q0UxODIwMzczNzcxIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjM1MUU0RjdGOUFBNjExRTQ4RUI1Q0UxODIwMzczNzcxIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkEAQAAAQAsAAAAABAAEAAAAh+EHakbh8wcgNHRJW/UvDcPQlNIflTGodP6SaOGwk4BADs=" /> expand
         * - <img style="vertical-align:sub;margin-right:4px;" width="16" height="14" title="" alt="" src="data:image/gif;base64,R0lGODlhEAAOAIABAGZmZv///yH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS41LWMwMjEgNzkuMTU1NzcyLCAyMDE0LzAxLzEzLTE5OjQ0OjAwICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxNCAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozNTFFNEY4NDlBQTYxMUU0OEVCNUNFMTgyMDM3Mzc3MSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozNTFFNEY4NTlBQTYxMUU0OEVCNUNFMTgyMDM3Mzc3MSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjM1MUU0RjgyOUFBNjExRTQ4RUI1Q0UxODIwMzczNzcxIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjM1MUU0RjgzOUFBNjExRTQ4RUI1Q0UxODIwMzczNzcxIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkEAQAAAQAsAAAAABAADgAAAhyEHakbh8wcAq1SSeGSuvsPhmLkgNyHWWqKll8BADs=" /> collapse
         */
        type: string;

        /**
         * Creates new Component.
         * @param {Object} config The standard configuration object.
         */
        constructor(config: Ext.ButtonConfig);

        getIconCls();

        getType();

        setIconCls();

        setType();

        /**
         * Fires when the tool is clicked
         * @param {Ext.event.Event} e The event object
         * @param {Ext.Component} owner The logical owner of the tool. In a typical
         * 'Ext.panel.Panel', this is set to the owning panel. This value comes from the
         * 'toolOwner' config.
         * @since 5.0.0
         */
        click(that: Ext.panel.Tool, e: Ext.event.Event, owner: Ext.Component);
    }
}

declare module Ext.perf {
    export class Accumulator extends Ext.Base {
    }

    export class Monitor {
    }
}

declare module Ext.picker {
    interface DateConfig extends Ext.picker.PickerConfig {
        /**
         * The label to show for the day column.
         */
        dayText?: string;

        /**
         * Can be either:
         *
         * - A {String} text to be used on the Done button.
         * - An {Object} as config for {@link Ext.Button}.
         * - 'false' or 'null' to hide it.
         */
        doneButton?: string|any;

        /**
         * The label to show for the month column.
         */
        monthText?: string;

        /**
         * An array of strings that specifies the order of the slots.
         */
        slotOrder?: any[];

        /**
         * The start year for the date picker. If {@link #yearFrom} is greater than
         * {@link #yearTo} then the order of years will be reversed.
         */
        yearFrom?: number;

        /**
         * The label to show for the year column.
         */
        yearText?: string;

        /**
         * The last year for the date picker. If {@link #yearFrom} is greater than
         * {@link #yearTo} then the order of years will be reversed.
         *
         * Optional, Defaults to: new Date().getFullYear()
         */
        yearTo?: number;
    }

    /**
     * A date picker component which shows a Date Picker on the screen. This class extends from {@link Ext.picker.Picker}
     * and {@link Ext.Sheet} so it is a popup.
     *
     * This component has no required configurations.
     *
     * ## Examples
     *
     *     @example miniphone preview
     *     var datePicker = Ext.create('Ext.picker.Date');
     *     Ext.Viewport.add(datePicker);
     *     datePicker.show();
     *
     * You may want to adjust the {@link #yearFrom} and {@link #yearTo} properties:
     *
     *     @example miniphone preview
     *     var datePicker = Ext.create('Ext.picker.Date', {
     *         yearFrom: 2000,
     *         yearTo  : 2015
     *     });
     *     Ext.Viewport.add(datePicker);
     *     datePicker.show();
     *
     * You can set the value of the {@link Ext.picker.Date} to the current date using 'new Date()':
     *
     *     @example miniphone preview
     *     var datePicker = Ext.create('Ext.picker.Date', {
     *         value: new Date()
     *     });
     *     Ext.Viewport.add(datePicker);
     *     datePicker.show();
     *
     * And you can hide the titles from each of the slots by using the {@link #useTitles} configuration:
     *
     *     @example miniphone preview
     *     var datePicker = Ext.create('Ext.picker.Date', {
     *         useTitles: false
     *     });
     *     Ext.Viewport.add(datePicker);
     *     datePicker.show();
     */
    export class Date extends Ext.picker.Picker implements Ext.picker.DateConfig {
        /**
         * The label to show for the day column.
         */
        dayText: string;

        /**
         * Can be either:
         *
         * - A {String} text to be used on the Done button.
         * - An {Object} as config for {@link Ext.Button}.
         * - 'false' or 'null' to hide it.
         */
        doneButton: string|any;

        /**
         * The label to show for the month column.
         */
        monthText: string;

        /**
         * An array of strings that specifies the order of the slots.
         */
        slotOrder: any[];

        /**
         * The start year for the date picker. If {@link #yearFrom} is greater than
         * {@link #yearTo} then the order of years will be reversed.
         */
        yearFrom: number;

        /**
         * The label to show for the year column.
         */
        yearText: string;

        /**
         * The last year for the date picker. If {@link #yearFrom} is greater than
         * {@link #yearTo} then the order of years will be reversed.
         *
         * Optional, Defaults to: new Date().getFullYear()
         */
        yearTo: number;

        constructor(config: Ext.ActionSheetConfig);

        getDayText();

        getDoneButton();

        getMonthText();

        getSlotOrder();

        getYearFrom();

        getYearText();

        getYearTo();

        protected initialize();

        setDayText();

        setDoneButton();

        setMonthText();

        setSlotOrder();

        setYearFrom();

        setYearText();

        setYearTo();

        /**
         * Updates the {@link #dayText} configuration.
         */
        updateDayText();

        /**
         * Updates the monthText configuration
         */
        updateMonthText();

        /**
         * Updates the yearFrom configuration
         */
        updateYearFrom();

        /**
         * Updates the yearText configuration
         */
        updateYearText();

        /**
         * Updates the yearTo configuration
         */
        updateYearTo();
    }

    interface PickerConfig extends Ext.SheetConfig {
        baseCls?: any;

        bottom?: any;

        /**
         * Can be either:
         *
         * - A {String} text to be used on the Cancel button.
         * - An {Object} as config for {@link Ext.Button}.
         * - 'false' or 'null' to hide it.
         */
        cancelButton?: string|any;

        /**
         * Can be either:
         *
         * - A {String} text to be used on the Done button.
         * - An {Object} as config for {@link Ext.Button}.
         * - 'false' or 'null' to hide it.
         */
        doneButton?: string|any;

        layout?: any;

        left?: any;

        right?: any;

        /**
         * An array of slot configurations.
         *
         * - 'name' {String} - Name of the slot
         * - 'data' {Array} - An array of text/value pairs in the format '{text: 'myKey', value: 'myValue'}'
         * - 'title' {String} - Title of the slot. This is used in conjunction with 'useTitles: true'.
         */
        slots?: any[];

        /**
         * The toolbar which contains the {@link #doneButton} and {@link #cancelButton} buttons.
         * You can override this if you wish, and add your own configurations. Just ensure that you take into account
         * the {@link #doneButton} and {@link #cancelButton} configurations.
         *
         * The default xtype is a {@link Ext.TitleBar}:
         *
         *     toolbar: {
         *         items: [
         *             {
         *                 xtype: 'button',
         *                 text: 'Left',
         *                 align: 'left'
         *             },
         *             {
         *                 xtype: 'button',
         *                 text: 'Right',
         *                 align: 'left'
         *             }
         *         ]
         *     }
         *
         * Or to use a {@link Ext.Toolbar instead}:
         *
         *     toolbar: {
         *         xtype: 'toolbar',
         *         items: [
         *             {
         *                 xtype: 'button',
         *                 text: 'Left'
         *             },
         *             {
         *                 xtype: 'button',
         *                 text: 'Left Two'
         *             }
         *         ]
         *     }
         */
        toolbar?: Ext.TitleBar|Ext.Toolbar|any;

        /**
         * Generate a title header for each individual slot and use
         * the title configuration of the slot.
         */
        useTitles?: boolean;

        /**
         * The value to initialize the picker with.
         */
        value?: string|number;
    }

    /**
     * A general picker class. {@link Ext.picker.Slot}s are used to organize multiple scrollable slots into a single picker. {@link #slots} is
     * the only necessary configuration.
     *
     * The {@link #slots} configuration with a few key values:
     *
     * - 'name': The name of the slot (will be the key when using {@link #getValues} in this {@link Ext.picker.Picker}).
     * - 'title': The title of this slot (if {@link #useTitles} is set to 'true').
     * - 'data'/'store': The data or store to use for this slot.
     *
     * Remember, {@link Ext.picker.Slot} class extends from {@link Ext.dataview.DataView}.
     *
     * ## Examples
     *
     *     @example miniphone preview
     *     var picker = Ext.create('Ext.Picker', {
     *         slots: [
     *             {
     *                 name : 'limit_speed',
     *                 title: 'Speed',
     *                 data : [
     *                     {text: '50 KB/s', value: 50},
     *                     {text: '100 KB/s', value: 100},
     *                     {text: '200 KB/s', value: 200},
     *                     {text: '300 KB/s', value: 300}
     *                 ]
     *             }
     *         ]
     *     });
     *     Ext.Viewport.add(picker);
     *     picker.show();
     *
     * You can also customize the top toolbar on the {@link Ext.picker.Picker} by changing the {@link #doneButton} and {@link #cancelButton} configurations:
     *
     *     @example miniphone preview
     *     var picker = Ext.create('Ext.Picker', {
     *         doneButton: 'I\'m done!',
     *         cancelButton: false,
     *         slots: [
     *             {
     *                 name : 'limit_speed',
     *                 title: 'Speed',
     *                 data : [
     *                     {text: '50 KB/s', value: 50},
     *                     {text: '100 KB/s', value: 100},
     *                     {text: '200 KB/s', value: 200},
     *                     {text: '300 KB/s', value: 300}
     *                 ]
     *             }
     *         ]
     *     });
     *     Ext.Viewport.add(picker);
     *     picker.show();
     *
     * Or by passing a custom {@link #toolbar} configuration:
     *
     *     @example miniphone preview
     *     var picker = Ext.create('Ext.Picker', {
     *         doneButton: false,
     *         cancelButton: false,
     *         toolbar: {
     *             ui: 'light',
     *             title: 'My Picker!'
     *         },
     *         slots: [
     *             {
     *                 name : 'limit_speed',
     *                 title: 'Speed',
     *                 data : [
     *                     {text: '50 KB/s', value: 50},
     *                     {text: '100 KB/s', value: 100},
     *                     {text: '200 KB/s', value: 200},
     *                     {text: '300 KB/s', value: 300}
     *                 ]
     *             }
     *         ]
     *     });
     *     Ext.Viewport.add(picker);
     *     picker.show();
     */
    export class Picker extends Ext.Sheet implements Ext.picker.PickerConfig {
        baseCls: string;

        /**
         * The absolute bottom position of this Component; must be a valid CSS length value, e.g: '300', '100px', '30%', etc.
         * Explicitly setting this value will make this Component become 'floating', which means its layout will no
         * longer be affected by the Container that it resides in.
         */
        bottom: number|string;

        /**
         * Can be either:
         *
         * - A {String} text to be used on the Cancel button.
         * - An {Object} as config for {@link Ext.Button}.
         * - 'false' or 'null' to hide it.
         */
        cancelButton: string|any;

        /**
         * Can be either:
         *
         * - A {String} text to be used on the Done button.
         * - An {Object} as config for {@link Ext.Button}.
         * - 'false' or 'null' to hide it.
         */
        doneButton: string|any;

        /**
         * Configuration for this Container's layout. Example:
         *
         *     Ext.create('Ext.Container', {
         *         layout: {
         *             type: 'hbox',
         *             align: 'middle'
         *         },
         *         items: [
         *             {
         *                 xtype: 'panel',
         *                 flex: 1,
         *                 style: 'background-color: red;'
         *             },
         *             {
         *                 xtype: 'panel',
         *                 flex: 2,
         *                 style: 'background-color: green'
         *             }
         *         ]
         *     });
         */
        layout: any|string;

        /**
         * The absolute left position of this Component; must be a valid CSS length value, e.g: '300', '100px', '30%', etc.
         * Explicitly setting this value will make this Component become 'floating', which means its layout will no
         * longer be affected by the Container that it resides in.
         */
        left: number|string;

        /**
         * The absolute right position of this Component; must be a valid CSS length value, e.g: '300', '100px', '30%', etc.
         * Explicitly setting this value will make this Component become 'floating', which means its layout will no
         * longer be affected by the Container that it resides in.
         */
        right: number|string;

        /**
         * An array of slot configurations.
         *
         * - 'name' {String} - Name of the slot
         * - 'data' {Array} - An array of text/value pairs in the format '{text: 'myKey', value: 'myValue'}'
         * - 'title' {String} - Title of the slot. This is used in conjunction with 'useTitles: true'.
         */
        slots: any[];

        /**
         * The toolbar which contains the {@link #doneButton} and {@link #cancelButton} buttons.
         * You can override this if you wish, and add your own configurations. Just ensure that you take into account
         * the {@link #doneButton} and {@link #cancelButton} configurations.
         *
         * The default xtype is a {@link Ext.TitleBar}:
         *
         *     toolbar: {
         *         items: [
         *             {
         *                 xtype: 'button',
         *                 text: 'Left',
         *                 align: 'left'
         *             },
         *             {
         *                 xtype: 'button',
         *                 text: 'Right',
         *                 align: 'left'
         *             }
         *         ]
         *     }
         *
         * Or to use a {@link Ext.Toolbar instead}:
         *
         *     toolbar: {
         *         xtype: 'toolbar',
         *         items: [
         *             {
         *                 xtype: 'button',
         *                 text: 'Left'
         *             },
         *             {
         *                 xtype: 'button',
         *                 text: 'Left Two'
         *             }
         *         ]
         *     }
         */
        toolbar: Ext.TitleBar|Ext.Toolbar|any;

        /**
         * Generate a title header for each individual slot and use
         * the title configuration of the slot.
         */
        useTitles: boolean;

        /**
         * The value to initialize the picker with.
         */
        value: string|number;

        /**
         * Updates the {@link #cancelButton} configuration. Will change it into a button when appropriate, or just update the text if needed.
         * @return {Object}
         */
        applyCancelButton(config: Ext.picker.PickerConfig): any;

        /**
         * Updates the {@link #doneButton} configuration. Will change it into a button when appropriate, or just update the text if needed.
         * @return {Object}
         */
        applyDoneButton(config: Ext.picker.PickerConfig): any;

        constructor(config: Ext.ActionSheetConfig);

        destroy();

        getBaseCls();

        getBottom();

        getCancelButton();

        getDoneButton();

        getHeight();

        getLayout();

        getLeft();

        getRight();

        getSlots();

        getToolbar();

        getToolbarPosition();

        getUseTitles();

        /**
         * Returns the values of each of the pickers slots
         * @return {Object} The values of the pickers slots
         */
        getValue(): any;

        /**
         * Returns the values of each of the pickers slots.
         * @return {Object} The values of the pickers slots.
         */
        getValues(): any;

        protected initialize();

        setBaseCls();

        setBottom();

        setCancelButton();

        setDoneButton();

        setHeight();

        setLayout();

        setLeft();

        setRight();

        setSlots();

        setToolbar();

        setToolbarPosition();

        setUseTitles();

        /**
         * Sets the values of the pickers slots.
         * @param {Object} values The values in a {name:'value'} format.
         * @param {Boolean} animated 'true' to animate setting the values.
         * @return {Ext.Picker} this This picker.
         */
        setValue(values: any, animated: boolean): Ext.picker.Picker;

        /**
         * Fired when the cancel button is tapped and the values are reverted back to
         * what they were.
         * @param {Ext.Picker} this This Picker.
         */
        cancel(that: Ext.picker.Picker);

        /**
         * Fired when the value of this picker has changed the Done button has been pressed.
         * @param {Ext.picker.Picker} this This Picker.
         * @param {Object} values The values of this picker's slots, in '{name:'value'}' format.
         */
        change(that: Ext.picker.Picker, values: any);

        /**
         * Fired when a slot has been picked
         * @param {Ext.Picker} this This Picker.
         * @param {Object} values The values of this picker's slots, in '{name:'value'}' format.
         * @param {Ext.picker.Slot} slot An instance of Ext.Picker.Slot that has been picked.
         */
        pick(that: Ext.picker.Picker, values: any, slot: Ext.picker.Slot);
    }

    interface SlotConfig extends Ext.dataview.DataViewConfig {
        /**
         * The horizontal alignment of the slot's contents.
         *
         * Valid values are: "left", "center", and "right".
         */
        align?: string;

        /**
         * The display field in the store.
         */
        displayField?: string;

        /**
         * (required) The name of this slot.
         */
        name?: string;

        /**
         * The title to use for this slot, or 'null' for no title.
         */
        title?: string;

        /**
         * The value of this slot
         */
        value?: number;

        /**
         * The value field in the store.
         */
        valueField?: string;
    }

    /**
     * A general {@link Ext.picker.Picker} slot class.  Slots are used to organize multiple scrollable slots into
     * a single {@link Ext.picker.Picker}.
     *
     *     {
     *         name : 'limit_speed',
     *         title: 'Speed Limit',
     *         data : [
     *             {text: '50 KB/s', value: 50},
     *             {text: '100 KB/s', value: 100},
     *             {text: '200 KB/s', value: 200},
     *             {text: '300 KB/s', value: 300}
     *         ]
     *     }
     *
     * See the {@link Ext.picker.Picker} documentation on how to use slots.
     */
    export class Slot extends Ext.dataview.DataView implements Ext.picker.SlotConfig {
        /**
         * The horizontal alignment of the slot's contents.
         *
         * Valid values are: "left", "center", and "right".
         */
        align: string;

        /**
         * The display field in the store.
         */
        displayField: string;

        /**
         * (required) The name of this slot.
         */
        name: string;

        /**
         * The title to use for this slot, or 'null' for no title.
         */
        title: string;

        /**
         * The value of this slot
         */
        value: number;

        /**
         * The value field in the store.
         */
        valueField: string;

        /**
         * Looks at the {@link #data} configuration and turns it into {@link #store}.
         * @return {Object}
         */
        applyData(data: any): any;

        /**
         * Sets the title for this dataview by creating element.
         * @return {String}
         */
        applyTitle(title: string): string;

        constructor();

        getAlign();

        getDisplayField();

        getItemTpl();

        getTitle();

        getValueField();

        setAlign();

        setDisplayField();

        setItemTpl();

        setName();

        setTitle();

        setValueField();

        /**
         * Updates the {@link #align} configuration
         */
        updateAlign();

        /**
         * Fires whenever an slot is picked
         * @param {Mixed} value The value of the pick
         * @param {HTMLElement} node The node element of the pick
         */
        slotpick(that: Ext.picker.Slot, value: any, node: HTMLElement);
    }
}

declare module Ext.plugin {
    interface AbstractConfig {
        /**
         * A name for the plugin that can be set at creation time to then retrieve the plugin
         * through {@link Ext.Component#getPlugin getPlugin} method.  For example:
         *
         *     var grid = Ext.create('Ext.grid.Panel', {
         *         plugins: [{
         *             ptype: 'cellediting',
         *             clicksToEdit: 2,
         *             pluginId: 'cellplugin'
         *         }]
         *     });
         *
         *     // later on:
         *     var plugin = grid.getPlugin('cellplugin');
         */
        pluginId?: string;
    }

    /**
     * The AbstractPlugin class is the base class from which user-implemented plugins should inherit.
     *
     * This class defines the essential API of plugins as used by Components by defining the following methods:
     *
     *   - 'init' : The plugin initialization method which the owning Component calls at Component initialization time.
     *
     *     The Component passes itself as the sole parameter.
     *
     *     Subclasses should set up bidirectional links between the plugin and its client Component here.
     *
     *   - 'destroy' : The plugin cleanup method which the owning Component calls at Component destruction time.
     *
     *     Use this method to break links between the plugin and the Component and to free any allocated resources.
     */
    export class Abstract extends Ext.Base implements Ext.plugin.AbstractConfig {
        /**
         * 'true' in this class to identify an object as an instantiated Plugin, or subclass thereof.
         */
        isPlugin: boolean;

        /**
         * A name for the plugin that can be set at creation time to then retrieve the plugin
         * through {@link Ext.Component#getPlugin getPlugin} method.  For example:
         *
         *     var grid = Ext.create('Ext.grid.Panel', {
         *         plugins: [{
         *             ptype: 'cellediting',
         *             clicksToEdit: 2,
         *             pluginId: 'cellplugin'
         *         }]
         *     });
         *
         *     // later on:
         *     var plugin = grid.getPlugin('cellplugin');
         */
        pluginId: string;

        /**
         * Creates clone of the plugin.
         * @param {Object} [overrideCfg] Additional config for the derived plugin.
         */
        clonePlugin(overrideCfg?: any);

        /**
         * Instantiates the plugin.
         * @param {Object} [config] Configuration object.
         */
        constructor(config?: Ext.chart.plugin.ItemEventsConfig);

        /**
         * The destroy method is invoked by the owning Component at the time the Component is
         * being destroyed.
         */
        destroy();

        /**
         * Returns the component to which this plugin is attached.
         * @return {Ext.Component} Owner component.
         */
        getCmp(): Ext.Component;

        /**
         * The init method is invoked after initComponent method has been run for the client Component.
         *
         * The supplied implementation is empty. Subclasses should perform plugin initialization, and set up bidirectional
         * links between the plugin and its client Component in their own implementation of this method.
         * @param {Ext.Component} client The client Component which owns this plugin.
         */
        init(client: Ext.Component);

        /**
         * Sets the component to which this plugin is attached.
         * @param {Ext.Component} cmp Owner component.
         */
        setCmp(cmp: Ext.Component);
    }

    /**
     * This plugin defers the execution cost of the instantiation and initialization of child components of un-rendered items.
     *
     * For example, in a {@link Ext.tab.Panel#deferredRender deferredRender} {@link Ext.tab.Panel TabPanel}, the un-rendered tabs
     * do not have to incur the cost of instantiating and initializing their descendant components until render.
     *
     * This plugin allows that.
     *
     * Add the items to the plugin:
     *
     *     {
     *         xtype: 'tabpanel',
     *         items: [{
     *             title: 'Tab One',
     *             plugins: {
     *                 ptype: 'lazyitems',
     *                 items: [... tab child items...]
     *             }
     *         }, {
     *             title: 'Tab One',
     *             plugins: {
     *                 ptype: 'lazyitems',
     *                 items: [... tab child items...]
     *             }
     *         }]
     *     }
     */
    export class LazyItems extends Ext.plugin.Abstract {
        /**
         * Instantiates the plugin.
         * @param {Object} [config] Configuration object.
         */
        constructor(config?: Ext.chart.plugin.ItemEventsConfig);
    }

    interface ListPagingConfig extends Ext.ComponentConfig {
        /**
         * True to automatically load the next page when you scroll to the bottom of the list.
         */
        autoPaging?: boolean;

        /**
         * The text used as the label of the Load More button.
         */
        loadMoreText?: string;

        /**
         * The text used as the label of the Load More button when the Store's
         * {@link Ext.data.Store#totalCount totalCount} indicates that all of the records available on the server are
         * already loaded
         */
        noMoreRecordsText?: string;
    }

    /**
     * Adds a Load More button at the bottom of the list. When the user presses this button,
     * the next page of data will be loaded into the store and appended to the List.
     *
     * By specifying '{@link #autoPaging}: true', an 'infinite scroll' effect can be achieved,
     * i.e., the next page of content will load automatically when the user scrolls to the
     * bottom of the list.
     *
     * ## Example
     *
     *     Ext.create('Ext.dataview.List', {
     *
     *         store: Ext.create('TweetStore'),
     *
     *         plugins: [
     *             {
     *                 xclass: 'Ext.plugin.ListPaging',
     *                 autoPaging: true
     *             }
     *         ],
     *
     *         itemTpl: [
     *             '<img src="{profile_image_url}" />',
     *             '<div class="tweet">{text}</div>'
     *         ]
     *     });
     */
    export class ListPaging extends Ext.Component implements Ext.plugin.ListPagingConfig {
        /**
         * True to automatically load the next page when you scroll to the bottom of the list.
         */
        autoPaging: boolean;

        /**
         * The text used as the label of the Load More button.
         */
        loadMoreText: string;

        /**
         * The text used as the label of the Load More button when the Store's
         * {@link Ext.data.Store#totalCount totalCount} indicates that all of the records available on the server are
         * already loaded
         */
        noMoreRecordsText: string;

        /**
         * Creates new Component.
         * @param {Object} config The standard configuration object.
         */
        constructor(config: Ext.ButtonConfig);

        getAutoPaging();

        getLoadMoreText();

        getNoMoreRecordsText();

        setAutoPaging();

        setLoadMoreText();

        setNoMoreRecordsText();

        /**
         * when the Load More component is added to the list. Fires on the List.
         * @param {Ext.plugin.ListPaging} this The list paging plugin
         * @param {Ext.List} list The list
         */
        loadmorecmpadded(that: Ext.plugin.ListPaging, list: Ext.dataview.List);
    }

    interface PullRefreshConfig extends Ext.ComponentConfig {
        /**
         * Determines whether the pulldown should automatically snap back after data has been loaded.
         * If false call {@link #snapBack}() to manually snap the pulldown back.
         */
        autoSnapBack?: boolean;

        /**
         * The format to be used on the last updated date.
         */
        lastUpdatedDateFormat?: string;

        /**
         * The text to be shown in front of the last updated time.
         */
        lastUpdatedText?: string;

        /**
         * The list to which this PullRefresh plugin is connected.
         * This will usually by set automatically when configuring the list with this plugin.
         */
        list?: Ext.dataview.List;

        /**
         * The text that will be when data has been loaded.
         */
        loadedText?: string;

        /**
         * The text that will be shown while the list is refreshing.
         */
        loadingText?: string;

        /**
         * The duration for snapping back when pulldown has been lowered further then its height.
         */
        overpullSnapBackDuration?: number;

        /**
         * The text that will be shown while you are pulling down.
         */
        pullText?: string;

        /**
         * The template being used for the pull to refresh markup.
         * Will be passed a config object with properties state, message and updated
         */
        pullTpl?: Ext.XTemplate|string|any[];

        /**
         * The text that will be shown after you have pulled down enough to show the release message.
         */
        releaseText?: string;

        /**
         * Determines whether the attached scroller should automatically track size changes of its container.
         * Enabling this will have performance impacts but will be necessary if your list size changes dynamically. For example if your list contains images
         * that will be loading and have unspecified heights.
         */
        scrollerAutoRefresh?: boolean;

        /**
         * The duration for snapping back animation after the data has been refreshed
         */
        snappingAnimationDuration?: number;

        width?: any;
    }

    /**
     * This plugin adds pull to refresh functionality to the List.
     *
     * ## Example
     *
     *     @example
     *     var store = Ext.create('Ext.data.Store', {
     *         fields: ['name', 'img', 'text'],
     *         data: [
     *             {
     *                 name: 'rdougan',
     *                 img: 'https://www.sencha.com/forum/images/statusicon/forum_new-48.png',
     *                 text: 'JavaScript development'
     *             }
     *         ]
     *     });
     *
     *     Ext.create('Ext.dataview.List', {
     *         fullscreen: true,
     *
     *         store: store,
     *
     *         plugins: [
     *             {
     *                 xclass: 'Ext.plugin.PullRefresh',
     *                 pullText: 'Pull down for more new Tweets!'
     *             }
     *         ],
     *
     *         itemTpl: [
     *             '<img src="{img}" alt="{name} photo" />',
     *             '<div class="tweet"><b>{name}:</b> {text}</div>'
     *         ]
     *     });
     */
    export class PullRefresh extends Ext.Component implements Ext.plugin.PullRefreshConfig {
        /**
         * Determines whether the pulldown should automatically snap back after data has been loaded.
         * If false call {@link #snapBack}() to manually snap the pulldown back.
         */
        autoSnapBack: boolean;

        /**
         * The format to be used on the last updated date.
         */
        lastUpdatedDateFormat: string;

        /**
         * The text to be shown in front of the last updated time.
         */
        lastUpdatedText: string;

        /**
         * The list to which this PullRefresh plugin is connected.
         * This will usually by set automatically when configuring the list with this plugin.
         */
        list: Ext.dataview.List;

        /**
         * The text that will be when data has been loaded.
         */
        loadedText: string;

        /**
         * The text that will be shown while the list is refreshing.
         */
        loadingText: string;

        /**
         * The duration for snapping back when pulldown has been lowered further then its height.
         */
        overpullSnapBackDuration: number;

        /**
         * The text that will be shown while you are pulling down.
         */
        pullText: string;

        /**
         * The template being used for the pull to refresh markup.
         * Will be passed a config object with properties state, message and updated
         */
        pullTpl: Ext.XTemplate|string|any[];

        /**
         * The text that will be shown after you have pulled down enough to show the release message.
         */
        releaseText: string;

        /**
         * Determines whether the attached scroller should automatically track size changes of its container.
         * Enabling this will have performance impacts but will be necessary if your list size changes dynamically. For example if your list contains images
         * that will be loading and have unspecified heights.
         */
        scrollerAutoRefresh: boolean;

        /**
         * The duration for snapping back animation after the data has been refreshed
         */
        snappingAnimationDuration: number;

        width: number|string;

        /**
         * Creates new Component.
         * @param {Object} config The standard configuration object.
         */
        constructor(config: Ext.ButtonConfig);

        getAutoSnapBack();

        getLastUpdatedDateFormat();

        getLastUpdatedText();

        getList();

        getLoadedText();

        getLoadingText();

        getOverpullSnapBackDuration();

        getPullText();

        getPullTpl();

        getReleaseText();

        getScrollerAutoRefresh();

        getSnappingAnimationDuration();

        getTranslatable();

        getWidth();

        setAutoSnapBack();

        setLastUpdatedDateFormat();

        setLastUpdatedText();

        setList();

        setLoadedText();

        setLoadingText();

        setOverpullSnapBackDuration();

        setPullText();

        setPullTpl();

        setReleaseText();

        setScrollerAutoRefresh();

        setSnappingAnimationDuration();

        setTranslatable();

        setWidth();

        /**
         * Snaps the List back to the top after a pullrefresh is complete
         * @param {Boolean} force Force the snapback to occur regardless of state {optional}
         */
        snapBack(force: boolean);
    }

    /**
     * This plugin can be added to component instances to process a 'responsiveConfig'. For
     * example:
     *
     *      Ext.create({
     *          xtype: 'panel',
     *          layout: 'hbox',
     *
     *          items: [{
     *              xtype: 'component',
     *              plugins: 'responsive',
     *
     *              responsiveConfig: {
     *                  'width < 800': {
     *                      hidden: true
     *                  },
     *
     *                  'width >= 800': {
     *                      hidden: false
     *                  }
     *              }
     *          },
     *          ...]
     *      });
     *
     * For details see '{@link Ext.mixin.Responsive#responsiveConfig responsiveConfig}'.
     */
    export class Responsive extends Ext.mixin.Responsive {
        constructor(config: any);
    }

    /**
     * @extends Ext.Component
     * The SortableList plugin gives your list items the ability to be reordered by tapping and
     * dragging elements within the item.
     *
     * The list-sortablehandle is not added to your tpl by default, so it's important that you
     * manually include it. It's also important to recognize that list-items are not draggable
     * themselves.  You must add an element to the itemTpl for it to be dragged.
     *
     *     Ext.Viewport.add({
     *          xtype: 'list',
     *          infinite: true,
     *          plugins: 'sortablelist',
     *          itemTpl: '<span class="myStyle ' + Ext.baseCSSPrefix + 'list-sortablehandle"></span>{text}',
     *          data: [{
     *              text: 'Item 1'
     *          }, {
     *              text: 'Item 2'
     *          }, {
     *              text: 'Item 3'
     *          }]
     *     });
     *
     * The CSS for MyStyle can be anything that creates an element to tap and drag.  For this
     * example we made a simple rectangle like so:
     *
     *      .myStyle{
     *          width:30px;
     *          height:20px;
     *          background:gray;
     *          float:left;
     *      }
     *
     * Note: You must have infinite set to 'true' when using the SortableList plugin.
     */
    export class SortableList extends Ext.Component {
        /**
         * Creates new Component.
         * @param {Object} config The standard configuration object.
         */
        constructor(config: Ext.ButtonConfig);

        getHandleSelector();

        getList();

        setHandleSelector();

        setList();
    }
}

declare module Ext.plugin.field {
    interface PlaceHolderLabelConfig extends Ext.plugin.AbstractConfig {
        /**
         * The CSS class to be applied on the form field.
         *
         * Optional, Defaults to: x-placeholderlabel
         */
        cls?: string;

        /**
         * A boolean value whether the label is shown or hidden.
         * The label should only be shown if the form field has a value.
         *
         * Optional, Defaults to: false
         */
        labelVisible?: boolean;

        /**
         * The CSS class to be applied on the form field when the label
         * is to be shown.
         *
         * Optional, Defaults to: x-show-label
         */
        showCls?: string;
    }

    /**
     * A plugin to be used on form fields to show the field's label as the placeHolder text
     * when the field has no value. When the field has a value, the label will show above the field
     * with an animation.
     *
     *     @example
     *     Ext.Viewport.add({
     *         items : [
     *             {
     *                 xtype       : 'textfield',
     *                 placeHolder : 'Company',
     *                 name        : 'company',
     *                 value       : 'Sencha Inc.',
     *                 plugins     : [
     *                     {
     *                         type : 'placeholderlabel'
     *                     }
     *                 ]
     *             },
     *             {
     *                 xtype       : 'textareafield',
     *                 placeHolder : 'Description',
     *                 name        : 'description',
     *                 plugins     : [
     *                     {
     *                         type : 'placeholderlabel'
     *                     }
     *                 ]
     *             }
     *         ]
     *      });
     */
    export class PlaceHolderLabel extends Ext.plugin.Abstract implements Ext.plugin.field.PlaceHolderLabelConfig {
        /**
         * The CSS class to be applied on the form field.
         *
         * Optional, Defaults to: x-placeholderlabel
         */
        cls: string;

        /**
         * A boolean value whether the label is shown or hidden.
         * The label should only be shown if the form field has a value.
         *
         * Optional, Defaults to: false
         */
        labelVisible: boolean;

        /**
         * The CSS class to be applied on the form field when the label
         * is to be shown.
         *
         * Optional, Defaults to: x-show-label
         */
        showCls: string;

        constructor(config: Ext.plugin.field.PlaceHolderLabelConfig);

        getCls();

        getLabelVisible();

        getShowCls();

        setCls();

        setLabelVisible();

        setShowCls();
    }
}

declare module Ext.promise {
    /**
     * Consequences are used internally by a Deferred to capture and notify callbacks, and
     * propagate their transformed results as fulfillment or rejection.
     *
     * Developers never directly interact with a Consequence.
     *
     * A Consequence forms a chain between two Deferreds, where the result of the first
     * Deferred is transformed by the corresponding callback before being applied to the
     * second Deferred.
     *
     * Each time a Deferred's 'then' method is called, it creates a new Consequence that will
     * be triggered once its originating Deferred has been fulfilled or rejected. A Consequence
     * captures a pair of optional onFulfilled and onRejected callbacks.
     *
     * Each Consequence has its own Deferred (which in turn has a Promise) that is resolved or
     * rejected when the Consequence is triggered. When a Consequence is triggered by its
     * originating Deferred, it calls the corresponding callback and propagates the transformed
     * result to its own Deferred; resolved with the callback return value or rejected with any
     * error thrown by the callback.
     *
     * @since 6.0.0
     */
    export class Consequence extends Ext.Base {
        /**
         * Promise of the future value of this Consequence.
         */
        promise: any;

        /**
         * @param {Function} onFulfilled Callback to execute to transform a fulfillment value.
         * @param {Function} onRejected Callback to execute to transform a rejection reason.
         */
        constructor(onFulfilled: Function, onRejected: Function);

        /**
         * Trigger this Consequence with the specified action and value.
         *
         * @param {String} action Completion action (i.e. fulfill or reject).
         * @param {Mixed} value Fulfillment value or rejection reason.
         */
        trigger(action: string, value: any);

        /**
         * Update this Consequence with the specified progress value.
         *
         * @param {Mixed} value Progress value.
         */
        update(value: any);
    }

    /**
     * Deferreds are the mechanism used to create new Promises. A Deferred has a single
     * associated Promise that can be safely returned to external consumers to ensure they do
     * not interfere with the resolution or rejection of the deferred operation.
     *
     * A Deferred is typically used within the body of a function that performs an asynchronous
     * operation. When that operation succeeds, the Deferred should be resolved; if that
     * operation fails, the Deferred should be rejected.
     *
     * Each Deferred has an associated Promise. A Promise delegates 'then' calls to its
     * Deferred's 'then' method. In this way, access to Deferred operations are divided between
     * producer (Deferred) and consumer (Promise) roles.
     *
     * When a Deferred's 'resolve' method is called, it fulfills with the optionally specified
     * value. If 'resolve' is called with a then-able (i.e.a Function or Object with a 'then'
     * function, such as another Promise) it assimilates the then-able's result; the Deferred
     * provides its own 'resolve' and 'reject' methods as the onFulfilled or onRejected
     * arguments in a call to that then-able's 'then' function. If an error is thrown while
     * calling the then-able's 'then' function (prior to any call back to the specified
     * 'resolve' or 'reject' methods), the Deferred rejects with that error. If a Deferred's
     * 'resolve' method is called with its own Promise, it rejects with a TypeError.
     *
     * When a Deferred's 'reject' method is called, it rejects with the optionally specified
     * reason.
     *
     * Each time a Deferred's 'then' method is called, it captures a pair of optional
     * onFulfilled and onRejected callbacks and returns a Promise of the Deferred's future
     * value as transformed by those callbacks.
     *
     * @since 6.0.0
     */
    export class Deferred extends Ext.Base {
        /**
         * Promise of the future value of this Deferred.
         */
        promise: Ext.promise.Promise;

        constructor();

        /**
         * Reject this Deferred with the specified reason.
         *
         * Once a Deferred has been rejected, it is considered to be complete
         * and subsequent calls to 'resolve' or 'reject' are ignored.
         *
         * @param {Error} reason Rejection reason.
         */
        reject(reason: Error);

        /**
         * Resolve this Deferred with the (optional) specified value.
         *
         * If called with a then-able (i.e.a Function or Object with a 'then'
         * function, such as another Promise) it assimilates the then-able's
         * result; the Deferred provides its own 'resolve' and 'reject' methods
         * as the onFulfilled or onRejected arguments in a call to that
         * then-able's 'then' function.  If an error is thrown while calling
         * the then-able's 'then' function (prior to any call back to the
         * specified 'resolve' or 'reject' methods), the Deferred rejects with
         * that error. If a Deferred's 'resolve' method is called with its own
         * Promise, it rejects with a TypeError.
         *
         * Once a Deferred has been fulfilled or rejected, it is considered to be complete
         * and subsequent calls to 'resolve' or 'reject' are ignored.
         *
         * @param {Mixed} value Value to resolve as either a fulfillment value or rejection
         * reason.
         */
        resolve(value: any);

        /**
         * Used to specify onFulfilled and onRejected callbacks that will be
         * notified when the future value becomes available.
         *
         * Those callbacks can subsequently transform the value that was
         * fulfilled or the error that was rejected. Each call to 'then'
         * returns a new Promise of that transformed value; i.e., a Promise
         * that is fulfilled with the callback return value or rejected with
         * any error thrown by the callback.
         *
         * @param {Function} [onFulfilled] Callback to execute to transform a fulfillment value.
         * @param {Function} [onRejected] Callback to execute to transform a rejection reason.
         * @param {Function} [onProgress] Callback to execute to transform a progress value.
         *
         * @return Promise that is fulfilled with the callback return value or rejected with
         * any error thrown by the callback.
         */
        then(onFulfilled?: Function, onRejected?: Function, onProgress?: Function);

        /**
         * Updates progress for this Deferred, if it is still pending, triggering it to
         * execute the 'onProgress' callback and propagate the resulting transformed progress
         * value to Deferreds that originate from this Deferred.
         *
         * @param {Mixed} progress The progress value.
         */
        update(progress: any);
    }

    /**
     * Promises represent a future value; i.e., a value that may not yet be available.
     *
     * Users should **not** create instances of this class directly. Instead user code should
     * use 'new {@link Ext.Promise}()' or 'new {@link Ext.Deferred}()' to create and manage
     * promises. If the browser supports the standard 'Promise' constructor, this class will
     * not be used by 'Ext.Promise'. This class will always be used by 'Ext.Deferred' in order
     * to provide enhanced capabilities beyond standard promises.
     *
     * A Promise's '{@link #then then()}' method is used to specify onFulfilled and onRejected
     * callbacks that will be notified when the future value becomes available. Those callbacks
     * can subsequently transform the value that was resolved or the reason that was rejected.
     * Each call to 'then' returns a new Promise of that transformed value; i.e., a Promise
     * that is resolved with the callback return value or rejected with any error thrown by
     * the callback.
     *
     * ## Basic Usage
     *
     *      this.companyService.loadCompanies().then(
     *          function (records) {
     *              // Do something with result.
     *          },
     *          function (error) {
     *              // Do something on failure.
     *          }).
     *      always(function () {
     *          // Do something whether call succeeded or failed
     *      });
     *
     * The above code uses the 'Promise' returned from the 'companyService.loadCompanies()'
     * method and uses 'then()' to attach success and failure handlers. Finally, an 'always()'
     * method call is chained onto the returned promise. This specifies a callback function
     * that will run whether the underlying call succeeded or failed.
     *
     * See '{@link Ext.Deferred}' for an example of using the returned Promise.
     *
     * [1]: http://wiki.ecmascript.org/doku.php?id=harmony:specification_drafts#april_14_2015_rev_38_final_draft
     *
     * @since 6.0.0
     */
    export class Promise extends Ext.Base {
        /**
         * Attaches an onCompleted callback that will be notified when this Promise is completed.
         *
         * Similar to 'finally' in 'try... catch... finally'.
         *
         * NOTE: The specified callback does not affect the resulting Promise's outcome; any
         * return value is ignored and any Error is rethrown.
         *
         * @param {Function} onCompleted Callback to execute when the Promise is resolved or
         * rejected.
         * @param {Object} scope Optional scope for the callback.
         * @return {Ext.promise.Promise} A new "pass-through" Promise that is resolved with
         * the original value or rejected with the original reason.
         */
        always(onCompleted: Function, scope: any): Ext.promise.Promise;

        /**
         * Cancels this Promise if it is still pending, triggering a rejection with a
         * '{@link #CancellationError}' that will propagate to any Promises originating from
         * this Promise.
         *
         * NOTE: Cancellation only propagates to Promises that branch from the target Promise.
         * It does not traverse back up to parent branches, as this would reject nodes from
         * which other Promises may have branched, causing unintended side-effects.
         *
         * @param {Error} reason Cancellation reason.
         */
        cancel(reason: Error);

        /**
         * Terminates a Promise chain, ensuring that unhandled rejections will be rethrown as
         * Errors.
         *
         * One of the pitfalls of interacting with Promise-based APIs is the tendency for
         * important errors to be silently swallowed unless an explicit rejection handler is
         * specified.
         *
         * For example:
         *
         *      promise.then(function () {
         *          // logic in your callback throws an error and it is interpreted as a
         *          // rejection. throw new Error("Boom!");
         *      });
         *
         *      // The Error was not handled by the Promise chain and is silently swallowed.
         *
         * This problem can be addressed by terminating the Promise chain with the done()
         * method:
         *
         *      promise.then(function () {
         *          // logic in your callback throws an error and it is interpreted as a
         *          // rejection. throw new Error("Boom!");
         *      }).done();
         *
         *     // The Error was not handled by the Promise chain and is rethrown by done() on
         *     // the next tick.
         *
         * The 'done()' method ensures that any unhandled rejections are rethrown as Errors.
         */
        done();

        /**
         * Logs the resolution or rejection of this Promise with the specified category and
         * optional identifier. Messages are logged via all registered custom logger functions.
         *
         * @param {String} identifier An optional identifier to incorporate into the
         * resulting log entry.
         *
         * @return {Ext.promise.Promise} A new "pass-through" Promise that is resolved with
         * the original value or rejected with the original reason.
         */
        log(identifier: string): Ext.promise.Promise;

        /**
         * Attaches an onRejected callback that will be notified if this Promise is rejected.
         *
         * The callback can subsequently transform the reason that was rejected. Each call to
         * 'otherwise' returns a new Promise of that transformed value; i.e., a Promise that
         * is resolved with the original resolved value, or resolved with the callback return
         * value or rejected with any error thrown by the callback.
         *
         * @param {Function} onRejected Callback to execute to transform a rejection reason.
         * @param {Object} scope Optional scope for the callback.
         * @return {Ext.promise.Promise} Promise of the transformed future value.
         */
        otherwise(onRejected: Function, scope: any): Ext.promise.Promise;

        /**
         * Attaches onFulfilled and onRejected callbacks that will be notified when the future
         * value becomes available.
         *
         * Those callbacks can subsequently transform the value that was fulfilled or the error
         * that was rejected. Each call to 'then' returns a new Promise of that transformed
         * value; i.e., a Promise that is fulfilled with the callback return value or rejected
         * with any error thrown by the callback.
         *
         * @param {Function} onFulfilled Optional callback to execute to transform a
         * fulfillment value.
         * @param {Function} onRejected Optional callback to execute to transform a rejection
         * reason.
         * @param {Function} onProgress Optional callback function to be called with progress
         * updates.
         * @param {Object} scope Optional scope for the callback(s).
         * @return {Ext.promise.Promise} Promise that is fulfilled with the callback return
         * value or rejected with any error thrown by the callback.
         */
        then(onFulfilled: Function, onRejected: Function, onProgress: Function, scope: any): Ext.promise.Promise;

        /**
         * The type of 'Error' propagated by the '{@link #method-cancel}' method. If
         * the browser provides a native 'CancellationError' then that type is used. If
         * not, a basic 'Error' type is used.
         */
        static CancellationError: any;
    }
}

declare module Ext.scroll {
    export class DomScroller extends Ext.scroll.Scroller {
        constructor(config: Ext.scroll.ScrollerConfig);

        getPosition();
    }

    interface IndicatorConfig extends Ext.WidgetConfig {
        /**
         * Number of milliseconds to delay hiding Indicators when scrolling ends.
         */
        hideDelay?: number;

        /**
         * The minimum length for the indicator. Defaults to the
         * indicator's "size" (the width of vertical or height of horizontal indicators)
         */
        minLength?: number;
    }

    /**
     * Provides a visual indicator of scroll position while scrolling using a {@link
     * Ext.scroll.TouchScroller TouchScroller}.  This class should not be created directly.
     * To configure scroll indicators please use the {@link Ext.scroll.Scroller#indicators
     * indicators} config of the Scroller.
     */
    export class Indicator extends Ext.Widget implements Ext.scroll.IndicatorConfig {
        /**
         * Number of milliseconds to delay hiding Indicators when scrolling ends.
         */
        hideDelay: number;

        /**
         * The minimum length for the indicator. Defaults to the
         * indicator's "size" (the width of vertical or height of horizontal indicators)
         */
        minLength: number;

        constructor(config: Ext.scroll.IndicatorConfig);

        destroy();

        getHideDelay();

        getMinLength();

        /**
         * Hides this scroll indicator
         */
        hide();

        setHideDelay();

        setMinLength();

        /**
         * Sets the value of this scroll indicator.
         * @param {Number} value The scroll position on the configured {@link #axis}
         */
        setValue(value: number);

        /**
         * Shows this scroll indicator
         */
        show();
    }

    interface ScrollerConfig {
        /**
         * @deprecated 5.1.0 use {@link #x} and {@link #y} instead
         *
         * Optional, Defaults to: 'auto'
         */
        direction?: any;

        /**
         * 'true' to lock the direction of the scroller when the user starts scrolling.
         * Only applicable when interacting with the Scroller via touch-screen.
         */
        directionLock?: boolean;

        /**
         * 'true' to disable this scroller.
         * Only applicable when using a {@link Ext.scroll.TouchScroller TouchScroller}
         */
        disabled?: boolean;

        /**
         * The element to make scrollable.
         */
        element?: any;

        /**
         * 'false' to hide scroll indicators while scrolling, 'true' to show scroll indicators,
         * or a config object for {@link Ext.scroll.Indicator} to configure the scroll indicators.
         *
         * May also be an object with 'x' and 'y' properties for configuring the vertical
         * and horizontal indicators separately. For example, to show only the vertical
         * indicator, but not the horizontal indicator:
         *
         *     {
         *         x: false,
         *         y: true
         *     }
         *
         * Only applicable when using a {@link Ext.scroll.TouchScroller TouchScroller}
         *
         * Optional, Defaults to: true
         */
        indicators?: boolean|any;

        /**
         * A {@link Ext.fx.easing.BoundMomentum} config object for configuring the momentum
         * of the Scroller.  Only applicable when interacting with the Scroller via
         * touch-screen.
         */
        momentumEasing?: any;

        /**
         * The size of each slot to snap to in 'px', can be either an object with 'x' and 'y' values, i.e:
         *
         *      {
         *          x: 50,
         *          y: 100
         *      }
         *
         * or a number value to be used for both directions. For example, a value of '50' will be treated as:
         *
         *      {
         *          x: 50,
         *          y: 50
         *      }
         *
         * *Note*: Only applicable when using {@link Ext.scroll.TouchScroller}.
         */
        slotSnapSize?: number|any;

        /**
         * - 'true' or ''auto'' to enable horizontal auto-scrolling. In auto-scrolling mode
         * scrolling is only enabled when the {@link #element} has overflowing content.
         * - 'false' to disable horizontal scrolling
         * - ''scroll'' to always enable horizontal scrolling regardless of content size.
         */
        x?: any;

        /**
         * - 'true' or ''auto'' to enable vertical auto-scrolling. In auto-scrolling mode
         * scrolling is only enabled when the {@link #element} has overflowing content.
         * - 'false' to disable vertical scrolling
         * - ''scroll'' to always enable vertical scrolling regardless of content size.
         */
        y?: any;
    }

    /**
     * Ext.scroll.Scroller allows any element to have scrollable content, both on desktop and
     * touch-screen devices, and defines a set of useful methods for manipulating the scroll
     * position and controlling the scrolling behavior.  Ext.scroll.Scroller should not be
     * directly instantiated.  Always use the static '{@link #create}' method to create a
     * Scroller instance:
     *
     *     Ext.scroll.Scroller.create({
     *         element: 'myElementId'
     *     });
     *
     * The '{@link #create}' method instantiates an appropriate Scroller subclass, depending on
     * platform.  For standard desktop devices, it returns a
     * '{@link Ext.scroll.DomScroller DomScroller}', while on touch-enabled devices it returns
     * a '{@link Ext.scroll.TouchScroller TouchScroller}.
     */
    export class Scroller extends Ext.Evented implements Ext.scroll.ScrollerConfig {
        factoryConfig: any;

        /**
         * @deprecated 5.1.0 use {@link #x} and {@link #y} instead
         *
         * Optional, Defaults to: 'auto'
         */
        direction: any;

        /**
         * 'true' to lock the direction of the scroller when the user starts scrolling.
         * Only applicable when interacting with the Scroller via touch-screen.
         */
        directionLock: boolean;

        /**
         * 'true' to disable this scroller.
         * Only applicable when using a {@link Ext.scroll.TouchScroller TouchScroller}
         */
        disabled: boolean;

        /**
         * The element to make scrollable.
         */
        element: any;

        /**
         * 'false' to hide scroll indicators while scrolling, 'true' to show scroll indicators,
         * or a config object for {@link Ext.scroll.Indicator} to configure the scroll indicators.
         *
         * May also be an object with 'x' and 'y' properties for configuring the vertical
         * and horizontal indicators separately. For example, to show only the vertical
         * indicator, but not the horizontal indicator:
         *
         *     {
         *         x: false,
         *         y: true
         *     }
         *
         * Only applicable when using a {@link Ext.scroll.TouchScroller TouchScroller}
         *
         * Optional, Defaults to: true
         */
        indicators: boolean|any;

        /**
         * A {@link Ext.fx.easing.BoundMomentum} config object for configuring the momentum
         * of the Scroller.  Only applicable when interacting with the Scroller via
         * touch-screen.
         */
        momentumEasing: any;

        /**
         * The size of each slot to snap to in 'px', can be either an object with 'x' and 'y' values, i.e:
         *
         *      {
         *          x: 50,
         *          y: 100
         *      }
         *
         * or a number value to be used for both directions. For example, a value of '50' will be treated as:
         *
         *      {
         *          x: 50,
         *          y: 50
         *      }
         *
         * *Note*: Only applicable when using {@link Ext.scroll.TouchScroller}.
         */
        slotSnapSize: number|any;

        /**
         * - 'true' or ''auto'' to enable horizontal auto-scrolling. In auto-scrolling mode
         * scrolling is only enabled when the {@link #element} has overflowing content.
         * - 'false' to disable horizontal scrolling
         * - ''scroll'' to always enable horizontal scrolling regardless of content size.
         */
        x: any;

        /**
         * - 'true' or ''auto'' to enable vertical auto-scrolling. In auto-scrolling mode
         * scrolling is only enabled when the {@link #element} has overflowing content.
         * - 'false' to disable vertical scrolling
         * - ''scroll'' to always enable vertical scrolling regardless of content size.
         */
        y: any;

        /**
         * Returns the the amount of space this scroller's scrollbar on a given axis currently
         * occupies in the DOM.
         * @param {String} axis The axis of the scroller.
         * @return {Number} With axis 'y', the width of the vertical scrollbar. With axis 'x',
         * the height of the horizontal scrollbar. '0' if the scrollbar does not consume space.
         */
        _(axis: string): number;

        /**
         * Adds a "partner" scroller.  Partner scrollers reflect each other's scroll position
         * at all times - if either scroller is scrolled, the scroll position of its partner
         * will be be automatically synchronized.
         *
         * A scroller may have multiple partners.
         *
         * @param {String} [axis='both'] The axis to synchronize (''x'', ''y'', or ''both'')
         */
        addPartner(partner: Ext.scroll.Scroller, axis?: string);

        constructor(config: Ext.scroll.ScrollerConfig);

        destroy();

        /**
         * Gets the 'clientWidth' and 'clientHeight' of the {@link #element} for this scroller.
         * @return {Object} An object with 'x' and 'y' properties.
         */
        getClientSize(): any;

        getDirection();

        getDirectionLock();

        getDisabled();

        getElement();

        getIndicators();

        /**
         * Returns the maximum scroll position for this scroller
         * @return {Object} position
         * @return {Number} position.x The maximum scroll position on the x axis
         * @return {Number} position.y The maximum scroll position on the y axis
         */
        getMaxPosition(): any;

        /**
         * Returns the maximum scroll position for this scroller for scrolling that is initiated
         * by the user via mouse or touch.  This differs from getMaxPosition in that getMaxPosition
         * returns the true maximum scroll position regardless of which axes are enabled for
         * user scrolling.
         * @return {Object} position
         * @return {Number} position.x The maximum scroll position on the x axis
         * @return {Number} position.y The maximum scroll position on the y axis
         */
        getMaxUserPosition(): any;

        getMomentumEasing();

        getPosition();

        /**
         * Returns the amount of space consumed by scrollbars in the DOM
         * @return {Object} size An object containing the scrollbar sizes.
         * @return {Number} size.width The width of the vertical scrollbar.
         * @return {Number} size.height The height of the horizontal scrollbar.
         */
        getScrollbarSize(): any;

        /**
         * Returns this scroller.
         *
         * In Sencha Touch 2, access to a Component's Scroller was provided via
         * a Ext.scroll.View class that was returned from the Component's getScrollable()
         * method:
         *
         *     component.getScrollable().getScroller();
         *
         * in 5.0 all the functionality of Ext.scroll.View has been rolled into
         * Ext.scroll.Scroller, and Ext.scroll.View has been removed.  Component's
         * getScrollable() method now returns a Ext.scroll.Scroller.  This method is
         * provided for compatibility.
         * @deprecated 5.0
         */
        getScroller();

        /**
         * Returns the size of the scrollable content
         * @return {Object} size
         * @return {Number} size.x The width of the scrollable content
         * @return {Number} size.y The height of the scrollable content
         */
        getSize(): any;

        getSlotSnapSize();

        getSpacerXY();

        getX();

        getY();

        /**
         * Determines if the passed element is within the visible x and y scroll viewport.
         * @param {String/HTMLElement/Ext.dom.Element} el The dom node, Ext.dom.Element, or
         * id (string) of the dom element that is to be verified to be in view
         * @return {Object} Which ranges the element is in.
         * @return {Boolean} return.x 'true' if the passed element is within the x visible range.
         * @return {Boolean} return.y 'true' if the passed element is within the y visible range.
         */
        isInView(el: string|HTMLElement|Ext.dom.Element): any;

        /**
         * Refreshes the scroller size and maxPosition.
         * @param {Boolean} immediate 'true' to refresh immediately. By default refreshes
         * are deferred until the next {@link Ext.GlobalEvents#event-idle idle} event to
         * ensure any pending writes have been flushed to the dom and any reflows have
         * taken place.
         * @return {Ext.scroll.Scroller} this
         */
        refresh(immediate: boolean): Ext.scroll.Scroller;

        /**
         * Scrolls by the passed delta values, optionally animating.
         *
         * All of the following are equivalent:
         *
         *      scroller.scrollBy(10, 10, true);
         *      scroller.scrollBy([10, 10], true);
         *      scroller.scrollBy({ x: 10, y: 10 }, true);
         *
         * A null value for either 'x' or 'y' will result in no scrolling on the given axis,
         * for example:
         *
         *     scroller.scrollBy(null, 10);
         *
         * will scroll by 10 on the y axis and leave the x axis at its current scroll position
         *
         * @param {Number/Number[]/Object} deltaX Either the x delta, an Array specifying x
         * and y deltas or an object with "x" and "y" properties.
         * @param {Number/Boolean/Object} deltaY Either the y delta, or an animate flag or
         * config object.
         * @param {Boolean/Object} animate Animate flag/config object if the delta values were
         * passed separately.
         */
        scrollBy(deltaX: number|any, deltaY: number|boolean|any, animate: boolean|any);

        /**
         * Scrolls to the given position.
         *
         * All of the following are equivalent:
         *
         *      scroller.scrollTo(10, 10, true);
         *      scroller.scrollTo([10, 10], true);
         *      scroller.scrollTo({ x: 10, y: 10 }, true);
         *
         * A null value for either 'x' or 'y' will result in no scrolling on the given axis,
         * for example:
         *
         *     scroller.scrollTo(null, 10);
         *
         * will scroll to 10 on the y axis and leave the x axis at its current scroll position
         *
         * A negative value for either 'x' or 'y' represents an offset from the maximum scroll
         * position on the given axis:
         *
         *     // scrolls to 10px from the maximum x scroll position and 20px from maximum y
         *     scroller.scrollTo(-10, -20);
         *
         * A value of Infinity on either axis will scroll to the maximum scroll position on
         * that axis:
         *
         *     // scrolls to the maximum position on both axes
         *     scroller.scrollTo(Infinity, Infinity);
         *
         * @param {Number} x The scroll position on the x axis.
         * @param {Number} y The scroll position on the y axis.
         * @param {Boolean/Object} animation (optional) Whether or not to animate the scrolling to the new position.
         *
         * @return {Ext.scroll.Scroller} this
         */
        scrollTo(x: number, y: number, animation: boolean|any): Ext.scroll.Scroller;

        setDirection();

        setDirectionLock();

        setDisabled();

        setElement();

        setIndicators();

        setMomentumEasing();

        setSlotSnapSize();

        setSpacerXY();

        setX();

        setY();

        /**
         * Fires whenever the Scroller is scrolled.
         * @param {Number} x The new x position.
         * @param {Number} y The new y position.
         */
        scroll(that: Ext.scroll.Scroller, x: number, y: number);

        /**
         * Fires whenever the scrolling is ended.
         * @param {Number} x The current x position.
         * @param {Number} y The current y position.
         */
        scrollend(that: Ext.scroll.Scroller, x: number, y: number);

        /**
         * Fires whenever the scrolling is started.
         * @param {Number} x The current x position.
         * @param {Number} y The current y position.
         */
        scrollstart(that: Ext.scroll.Scroller, x: number, y: number);
    }

    interface TouchScrollerConfig extends Ext.scroll.ScrollerConfig {
        indicators?: any;

        /**
         * The default value is:
         *
         *     {
         *         momentum: {
         *             acceleration: 30,
         *             friction: 0.5
         *         },
         *         bounce: {
         *             acceleration: 30,
         *             springTension: 0.3
         *         }
         *     }
         *
         * Note that supplied object will be recursively merged with the default object. For example, you can simply
         * pass this to change the momentum acceleration only:
         *
         *     {
         *         momentum: {
         *             acceleration: 10
         *         }
         *     }
         */
        momentumEasing?: any;
    }

    /**
     * Momentum scrolling is one of the most important parts of the user experience on touch-screen
     * devices.  Depending on the device and browser, Ext JS will select one of several different
     * scrolling implementations for best performance.
     *
     * Scroller settings can be changed using the {@link Ext.Container#scrollable scrollable}
     * configuration on {@link Ext.Component}. Here is a simple example of how to adjust the
     * scroller settings when using a Component (or anything that extends it).
     *
     *     @example
     *     Ext.create('Ext.Component', {
     *         renderTo: Ext.getBody(),
     *         height: 100,
     *         width: 100,
     *         // this component is scrollable vertically but not horizontally
     *         scrollable: 'y',
     *         html: 'Lorem ipsum dolor sit amet, consectetur adipiscing elit. Quisque convallis lorem et magna tempus fermentum.'
     *     });
     */
    export class TouchScroller extends Ext.scroll.Scroller implements Ext.scroll.TouchScrollerConfig {
        indicators: boolean|any;

        /**
         * The default value is:
         *
         *     {
         *         momentum: {
         *             acceleration: 30,
         *             friction: 0.5
         *         },
         *         bounce: {
         *             acceleration: 30,
         *             springTension: 0.3
         *         }
         *     }
         *
         * Note that supplied object will be recursively merged with the default object. For example, you can simply
         * pass this to change the momentum acceleration only:
         *
         *     {
         *         momentum: {
         *             acceleration: 10
         *         }
         *     }
         */
        momentumEasing: any;

        constructor(config: Ext.scroll.TouchScrollerConfig);

        destroy();

        getIndicators();

        getMomentumEasing();

        setIndicators();

        setMomentumEasing();
    }
}

declare module Ext.slider {
    interface SliderConfig extends Ext.ContainerConfig {
        /**
         * Whether or not to allow multiple thumbs to overlap each other.
         * Setting this to true guarantees the ability to select every possible value in between {@link #minValue}
         * and {@link #maxValue} that satisfies {@link #increment}
         */
        allowThumbsOverlapping?: boolean;

        /**
         * The animation to use when moving the slider. Possible properties are:
         *
         * - duration
         * - easingX
         * - easingY
         */
        animation?: boolean|any;

        baseCls?: any;

        /**
         * The increment by which to snap each thumb when its value changes. Any thumb movement
         * will be snapped to the nearest value that is a multiple of the increment (e.g. if increment is 10 and the user
         * tries to move the thumb to 67, it will be snapped to 70 instead)
         */
        increment?: number;

        /**
         * The highest value any thumb on this slider can be set to.
         */
        maxValue?: number;

        /**
         * The lowest value any thumb on this slider can be set to.
         */
        minValue?: number;

        /**
         * Will make this field read only, meaning it cannot be changed with used interaction.
         */
        readOnly?: boolean;

        /**
         * The config object to factory {@link Ext.slider.Thumb} instances
         */
        thumbConfig?: any;

        /**
         * The value(s) of this slider's thumbs. If you pass
         * a number, it will assume you have just 1 thumb.
         */
        value?: number;

        /**
         * Alias to {@link #value}
         */
        values?: number;
    }

    /**
     * Utility class used by Ext.field.Slider.
     */
    export class Slider extends Ext.Container implements Ext.slider.SliderConfig {
        /**
         * Whether or not to allow multiple thumbs to overlap each other.
         * Setting this to true guarantees the ability to select every possible value in between {@link #minValue}
         * and {@link #maxValue} that satisfies {@link #increment}
         */
        allowThumbsOverlapping: boolean;

        /**
         * The animation to use when moving the slider. Possible properties are:
         *
         * - duration
         * - easingX
         * - easingY
         */
        animation: boolean|any;

        baseCls: string;

        /**
         * The increment by which to snap each thumb when its value changes. Any thumb movement
         * will be snapped to the nearest value that is a multiple of the increment (e.g. if increment is 10 and the user
         * tries to move the thumb to 67, it will be snapped to 70 instead)
         */
        increment: number;

        /**
         * The highest value any thumb on this slider can be set to.
         */
        maxValue: number;

        /**
         * The lowest value any thumb on this slider can be set to.
         */
        minValue: number;

        /**
         * Will make this field read only, meaning it cannot be changed with used interaction.
         */
        readOnly: boolean;

        /**
         * The config object to factory {@link Ext.slider.Thumb} instances
         */
        thumbConfig: any;

        /**
         * The value(s) of this slider's thumbs. If you pass
         * a number, it will assume you have just 1 thumb.
         */
        value: number;

        /**
         * Alias to {@link #value}
         */
        values: number;

        /**
         * Sets the {@link #increment} configuration.
         * @return {Number}
         */
        applyIncrement(increment: number): number;

        constructor(config: Ext.slider.SliderConfig);

        getAllowThumbsOverlapping();

        getAnimation();

        getBaseCls();

        getIncrement();

        getMaxValue();

        getMinValue();

        getReadOnly();

        /**
         * Returns the Thumb instance bound to this Slider
         * @param {Number} [index=0] The index of Thumb to return.
         * @return {Ext.slider.Thumb} The thumb instance
         */
        getThumb(index?: number): Ext.slider.Thumb;

        getThumbConfig();

        /**
         * Returns the Thumb instances bound to this Slider
         * @return {Ext.slider.Thumb[]} The thumb instances
         */
        getThumbs(): Ext.slider.Thumb;

        getValue();

        /**
         * Convenience method. Calls {@link #getValue}.
         * @return {Object}
         */
        getValues(): any;

        setAllowThumbsOverlapping();

        setAnimation();

        setBaseCls();

        setIncrement();

        setMaxValue();

        setMinValue();

        setReadOnly();

        setThumbConfig();

        setValue();

        /**
         * Convenience method. Calls {@link #setValue}.
         */
        setValues();

        /**
         * Updates the sliders thumbs with their new value(s)
         */
        updateValue();

        /**
         * Fires when the value changes
         * @param {Ext.slider.Thumb} thumb The thumb being changed
         * @param {Number} newValue The new value
         * @param {Number} oldValue The old value
         */
        change(that: Ext.slider.Slider, thumb: Ext.slider.Thumb, newValue: number, oldValue: number);

        /**
         * Fires when the slider thumb starts a drag
         * @param {Ext.slider.Thumb} thumb The thumb being dragged
         */
        drag(that: Ext.slider.Slider, thumb: Ext.slider.Thumb, e: any);

        /**
         * Fires when the slider thumb starts a drag
         * @param {Ext.slider.Thumb} thumb The thumb being dragged
         * @param {Array} value The end value
         */
        dragend(that: Ext.slider.Slider, thumb: Ext.slider.Thumb, value: any[], e: any);

        /**
         * Fires when the slider thumb starts a drag
         * @param {Ext.slider.Thumb} thumb The thumb being dragged
         * @param {Array} value The start value
         */
        dragstart(that: Ext.slider.Slider, thumb: Ext.slider.Thumb, value: any[], e: any);
    }

    interface ThumbConfig extends Ext.ComponentConfig {
        baseCls?: any;

        draggable?: any;

        /**
         * The CSS class to add to the Slider when it is pressed.
         */
        pressedCls?: string;
    }

    /**
     * Utility class used by Ext.slider.Slider - should never need to be used directly.
     */
    export class Thumb extends Ext.Component implements Ext.slider.ThumbConfig {
        /**
         * The base CSS class to apply to this component's element. This will also be prepended to
         * other elements within this component. To add specific styling for sub-classes, use the {@link #cls} config.
         */
        baseCls: string;

        /**
         * Configuration options to make this Component draggable
         */
        draggable: any;

        /**
         * The CSS class to add to the Slider when it is pressed.
         */
        pressedCls: string;

        /**
         * Creates new Component.
         * @param {Object} config The standard configuration object.
         */
        constructor(config: Ext.ButtonConfig);

        getBaseCls();

        getDraggable();

        getPressedCls();

        protected initialize();

        setBaseCls();

        setDraggable();

        setPressedCls();
    }

    interface ToggleConfig extends Ext.slider.SliderConfig {
        baseCls?: any;

        /**
         * CSS class added to the field when toggled to its maxValue
         */
        maxValueCls?: string;

        /**
         * CSS class added to the field when toggled to its minValue
         */
        minValueCls?: string;
    }

    export class Toggle extends Ext.slider.Slider implements Ext.slider.ToggleConfig {
        baseCls: string;

        /**
         * CSS class added to the field when toggled to its maxValue
         */
        maxValueCls: string;

        /**
         * CSS class added to the field when toggled to its minValue
         */
        minValueCls: string;

        constructor(config: Ext.slider.SliderConfig);

        getBaseCls();

        getMaxValueCls();

        getMinValueCls();

        setBaseCls();

        setMaxValueCls();

        setMinValueCls();
    }
}

declare module Ext.tab {
    interface BarConfig extends Ext.ToolbarConfig {
        /**
         * The initially activated tab. Can be specified as numeric index,
         * component ID or as the component instance itself.
         */
        activeTab?: number|string|Ext.Component;

        baseCls?: any;

        /**
         * A default {@link Ext.Component#ui ui} to use for {@link Ext.tab.Tab Tab} items.
         */
        defaultTabUI?: any;
    }

    /**
     * Ext.tab.Bar is used internally by {@link Ext.tab.Panel} to create the bar of tabs that appears at the top of the tab
     * panel. It's unusual to use it directly, instead see the {@link Ext.tab.Panel tab panel docs} for usage instructions.
     *
     * Used in the {@link Ext.tab.Panel} component to display {@link Ext.tab.Tab} components.
     */
    export class Bar extends Ext.Toolbar implements Ext.tab.BarConfig {
        /**
         * The initially activated tab. Can be specified as numeric index,
         * component ID or as the component instance itself.
         */
        activeTab: number|string|Ext.Component;

        /**
         * The base CSS class to apply to this component's element. This will also be prepended to
         * other elements within this component. To add specific styling for sub-classes, use the {@link #cls} config.
         */
        baseCls: string;

        /**
         * A default {@link Ext.Component#ui ui} to use for {@link Ext.tab.Tab Tab} items.
         */
        defaultTabUI: any;

        constructor(config: Ext.ToolbarConfig);

        getActiveTab();

        getBaseCls();

        getDefaultTabUI();

        setActiveTab();

        setBaseCls();

        setDefaultTabUI();

        activetabchange();

        /**
         * Fired when active tab changes.
         * @param {Ext.tab.Tab} newTab The new Tab
         * @param {Ext.tab.Tab} oldTab The old Tab
         */
        tabchange(that: Ext.tab.Bar, newTab: Ext.tab.Tab, oldTab: Ext.tab.Tab);
    }

    interface PanelConfig extends Ext.ContainerConfig {
        cls?: any;

        layout?: any;

        scroll?: boolean|string|any;

        /**
         * An Ext.tab.Bar configuration.
         */
        tabBar?: any;

        /**
         * The docked position for the {@link #tabBar} instance.
         * Possible values are 'top' and 'bottom'.
         */
        tabBarPosition?: string;
    }

    /**
     * Tab Panels are a great way to allow the user to switch between several pages that are all full screen. Each
     * Component in the Tab Panel gets its own Tab, which shows the Component when tapped on. Tabs can be positioned at
     * the top or the bottom of the Tab Panel, and can optionally accept title and icon
     * configurations (see {@link Ext.Button#iconCls iconCls} for additional information).
     *
     * Here's how we can set up a simple Tab Panel with tabs at the bottom. Use the controls at the top left of the example
     * to toggle between code mode and live preview mode (you can also edit the code and see your changes in the live
     * preview):
     *
     *     @example miniphone preview
     *     Ext.create('Ext.TabPanel', {
     *         fullscreen: true,
     *         tabBarPosition: 'bottom',
     *
     *         defaults: {
     *             styleHtmlContent: true
     *         },
     *
     *         items: [
     *             {
     *                 title: 'Home',
     *                 iconCls: 'home',
     *                 html: 'Home Screen'
     *             },
     *             {
     *                 title: 'Contact',
     *                 iconCls: 'user',
     *                 html: 'Contact Screen'
     *             }
     *         ]
     *     });
     * One tab was created for each of the {@link Ext.Panel panels} defined in the items array. Each tab automatically uses
     * the title and icon defined on the item configuration, and switches to that item when tapped on. We can also position
     * the tab bar at the top, which makes our Tab Panel look like this:
     *
     *     @example miniphone preview
     *     Ext.create('Ext.TabPanel', {
     *         fullscreen: true,
     *
     *         defaults: {
     *             styleHtmlContent: true
     *         },
     *
     *         items: [
     *             {
     *                 title: 'Home',
     *                 html: 'Home Screen'
     *             },
     *             {
     *                 title: 'Contact',
     *                 html: 'Contact Screen'
     *             }
     *         ]
     *     });
     */
    export class Panel extends Ext.Container implements Ext.tab.PanelConfig {
        /**
         * The CSS class to add to this component's element, in
         * addition to the {@link #baseCls}. In many cases, this property will be specified
         * by the derived component class. See {@link #userCls} for adding additional CSS
         * classes to component instances (such as items in a {@link Ext.Container}).
         */
        cls: string;

        /**
         * Configuration for this Container's layout. Example:
         *
         *     Ext.create('Ext.Container', {
         *         layout: {
         *             type: 'hbox',
         *             align: 'middle'
         *         },
         *         items: [
         *             {
         *                 xtype: 'panel',
         *                 flex: 1,
         *                 style: 'background-color: red;'
         *             },
         *             {
         *                 xtype: 'panel',
         *                 flex: 2,
         *                 style: 'background-color: green'
         *             }
         *         ]
         *     });
         */
        layout: any|string;

        scroll: boolean|string|any;

        /**
         * An Ext.tab.Bar configuration.
         */
        tabBar: any;

        /**
         * The docked position for the {@link #tabBar} instance.
         * Possible values are 'top' and 'bottom'.
         */
        tabBarPosition: string;

        constructor(config: Ext.ActionSheetConfig);

        /**
         * Updates this container with the new active item.
         * @return {Boolean}
         */
        doTabChange(tabBar: any, newTab: any): boolean;

        getCls();

        getLayout();

        getTabBar();

        getTabBarPosition();

        protected initialize();

        setCls();

        setLayout();

        setTabBar();

        setTabBarPosition();

        /**
         * Updates the Ui for this component and the {@link #tabBar}.
         */
        updateUi();
    }

    interface TabConfig extends Ext.ButtonConfig {
        /**
         * Set this to 'true' to have the tab be active by default.
         */
        active?: boolean;

        /**
         * The CSS class to be applied to a Tab when it is active.
         * Providing your own CSS for this class enables you to customize the active state.
         */
        activeCls?: string;

        baseCls?: any;

        /**
         * The CSS class to be applied to a Tab when it is pressed.
         * Providing your own CSS for this class enables you to customize the pressed state.
         */
        pressedCls?: string;

        /**
         * The title of the card that this tab is bound to.
         */
        title?: string;
    }

    /**
     * Used in the {@link Ext.tab.Bar} component. This shouldn't be used directly, instead use
     * {@link Ext.tab.Bar} or {@link Ext.tab.Panel}.
     */
    export class Tab extends Ext.Button implements Ext.tab.TabConfig {
        /**
         * Set this to 'true' to have the tab be active by default.
         */
        active: boolean;

        /**
         * The CSS class to be applied to a Tab when it is active.
         * Providing your own CSS for this class enables you to customize the active state.
         */
        activeCls: string;

        /**
         * The base CSS class to apply to this component's element. This will also be prepended to
         * other elements within this component. To add specific styling for sub-classes, use the {@link #cls} config.
         */
        baseCls: string;

        /**
         * The CSS class to be applied to a Tab when it is pressed.
         * Providing your own CSS for this class enables you to customize the pressed state.
         */
        pressedCls: string;

        /**
         * The title of the card that this tab is bound to.
         */
        title: string;

        /**
         * Creates new Component.
         * @param {Object} config The standard configuration object.
         */
        constructor(config: Ext.ButtonConfig);

        getActive();

        getActiveCls();

        getBaseCls();

        getPressedCls();

        getTitle();

        setActive();

        setActiveCls();

        setBaseCls();

        setPressedCls();

        setTitle();

        /**
         * Fires when a tab is activated
         */
        activate(that: Ext.tab.Tab);

        /**
         * Fires when a tab is deactivated
         */
        deactivate(that: Ext.tab.Tab);
    }
}

declare module Ext.util {
    interface AbstractMixedCollectionConfig {
        /**
         * Specify <code>true</code> if the {@link #addAll}
         * function should add function references to the collection. Defaults to
         * <code>false</code>.
         * @since 3.4.0
         */
        allowFunctions?: boolean;
    }

    export class AbstractMixedCollection extends Ext.Base implements Ext.util.AbstractMixedCollectionConfig {
        /**
         * 'true' in this class to identify an object as an instantiated MixedCollection, or subclass thereof.
         */
        isMixedCollection: boolean;

        /**
         * Specify <code>true</code> if the {@link #addAll}
         * function should add function references to the collection. Defaults to
         * <code>false</code>.
         * @since 3.4.0
         */
        allowFunctions: boolean;

        /**
         * Adds an item to the collection. Fires the {@link #event-add} event when complete.
         *
         * @param {String/Object} key The key to associate with the item, or the new item.
         *
         * If a {@link #getKey} implementation was specified for this MixedCollection,
         * or if the key of the stored items is in a property called 'id',
         * the MixedCollection will be able to *derive* the key for the new item.
         * In this case just pass the new item in this parameter.
         *
         * @param {Object} [obj] The item to add.
         *
         * Note that when adding a value that is iterable, it must be wrapped in brackets, i.e.:
         *
         *     c.add([[1, 2]]);
         *
         * This will be needed for any value that is iterable, i.e., an array, arguments object,
         * HTML collections, etc.
         *
         * @return {Object} The item added.
         * @since 1.1.0
         */
        add(key: string|any, obj?: any): any;

        /**
         * Adds all elements of an Array or an Object to the collection.
         * @param {Object/Array} objs An Object containing properties which will be added
         * to the collection, or an Array of values, each of which are added to the collection.
         * Functions references will be added to the collection if '{@link #allowFunctions}'
         * has been set to 'true'.
         * @since 1.1.0
         */
        addAll(objs: any|any[]);

        /**
         * Removes all items from the collection.  Fires the {@link #event-clear} event when complete.
         * @since 1.1.0
         */
        clear();

        /**
         * Creates a shallow copy of this collection
         * @return {Ext.util.MixedCollection}
         * @since 1.1.0
         */
        clone(): Ext.util.MixedCollection;

        /**
         * Collects unique values of a particular property in this MixedCollection
         * @param {String} property The property to collect on
         * @param {String} root (optional) 'root' property to extract the first argument from. This is used mainly when
         * summing fields in records, where the fields are all stored inside the 'data' object
         * @param {Boolean} allowBlank (optional) Pass true to allow null, undefined or empty string values
         * @return {Array} The unique values
         */
        collect(property: string, root: string, allowBlank: boolean): any[];

        constructor(allowFunctions: any, keyFn: any);

        /**
         * Returns true if the collection contains the passed Object as an item.
         * @param {Object} o  The Object to look for in the collection.
         * @return {Boolean} True if the collection contains the Object as an item.
         * @since 1.1.0
         */
        contains(o: any): boolean;

        /**
         * Returns true if the collection contains the passed Object as a key.
         * @param {String} key The key to look for in the collection.
         * @return {Boolean} True if the collection contains the Object as a key.
         * @since 1.1.0
         */
        containsKey(key: string): boolean;

        destroy();

        /**
         * Executes the specified function once for every item in the collection.
         * The function should return a boolean value.
         * Returning false from the function will stop the iteration.
         *
         * @param {Function} fn The function to execute for each item.
         * @param {Mixed} fn.item The collection item.
         * @param {Number} fn.index The index of item.
         * @param {Number} fn.len Total length of collection.
         * @param {Object} scope (optional) The scope (<code>this</code> reference)
         * in which the function is executed. Defaults to the current item in the iteration.
         *
         * @since 1.1.0
         */
        each(fn: Function, fn_item: any, fn_index: number, fn_len: number, scope: any);

        /**
         * Executes the specified function once for every key in the collection, passing each
         * key, and its associated item as the first two parameters.
         * @param {Function} fn The function to execute for each item.
         * @param {String} fn.key The key of collection item.
         * @param {Mixed} fn.item The collection item.
         * @param {Number} fn.index The index of item.
         * @param {Number} fn.len Total length of collection.
         * @param {Object} scope (optional) The scope (<code>this</code> reference) in which the
         * function is executed. Defaults to the browser window.
         *
         * @since 1.1.0
         */
        eachKey(fn: Function, fn_key: string, fn_item: any, fn_index: number, fn_len: number, scope: any);

        /**
         * <p>Filters the objects in this collection by a set of {@link Ext.util.Filter Filter}s, or by a single
         * property/value pair with optional parameters for substring matching and case sensitivity. See
         * {@link Ext.util.Filter Filter} for an example of using Filter objects (preferred). Alternatively,
         * MixedCollection can be easily filtered by property like this:</p>
         *
         *     //create a simple store with a few people defined
         *     var people = new Ext.util.MixedCollection();
         *     people.addAll([
         *         {id: 1, age: 25, name: 'Ed'},
         *         {id: 2, age: 24, name: 'Tommy'},
         *         {id: 3, age: 24, name: 'Arne'},
         *         {id: 4, age: 26, name: 'Aaron'}
         *     ]);
         *
         *     //a new MixedCollection containing only the items where age == 24
         *     var middleAged = people.filter('age', 24);
         *
         * @param {Ext.util.Filter[]/String} property A property on your objects, or an array of {@link Ext.util.Filter Filter} objects
         * @param {String/RegExp} value Either string that the property values
         * should start with or a RegExp to test against the property
         * @param {Boolean} [anyMatch=false] True to match any part of the string, not just the beginning
         * @param {Boolean} [caseSensitive=false] True for case sensitive comparison.
         * @return {Ext.util.MixedCollection} The new filtered collection
         * @since 1.1.0
         */
        filter(property: Ext.util.Filter|string, value: string|RegExp, anyMatch?: boolean, caseSensitive?: boolean): Ext.util.MixedCollection;

        /**
         * Filter by a function. Returns a <i>new</i> collection that has been filtered.
         * The passed function will be called with each object in the collection.
         * If the function returns true, the value is included otherwise it is filtered.
         * @param {Function} fn The function to be called.
         * @param {Mixed} fn.item The collection item.
         * @param {String} fn.key The key of collection item.
         * @param {Object} scope (optional) The scope (<code>this</code> reference) in
         * which the function is executed. Defaults to this MixedCollection.
         * @return {Ext.util.MixedCollection} The new filtered collection
         * @since 1.1.0
         */
        filterBy(fn: Function, fn_item: any, fn_key: string, scope: any): Ext.util.MixedCollection;

        /**
         * Returns the first item in the collection which elicits a true return value from the passed selection function.
         * @deprecated 4.0 Use {@link #findBy} instead.
         * @since 1.1.0
         */
        find();

        /**
         * Returns the first item in the collection which elicits a true return value from the
         * passed selection function.
         * @param {Function} fn The selection function to execute for each item.
         * @param {Mixed} fn.item The collection item.
         * @param {String} fn.key The key of collection item.
         * @param {Object} scope (optional) The scope (<code>this</code> reference) in which the
         * function is executed. Defaults to the browser window.
         * @return {Object} The first item in the collection which returned true from the selection
         * function, or null if none was found.
         */
        findBy(fn: Function, fn_item: any, fn_key: string, scope: any): any;

        /**
         * Finds the index of the first matching object in this collection by a specific property/value.
         * @param {String} property The name of a property on your objects.
         * @param {String/RegExp} value A string that the property values
         * should start with or a RegExp to test against the property.
         * @param {Number} [start=0] The index to start searching at.
         * @param {Boolean} [anyMatch=false] True to match any part of the string, not just the beginning.
         * @param {Boolean} [caseSensitive=false] True for case sensitive comparison.
         * @return {Number} The matched index or -1
         * @since 2.3.0
         */
        findIndex(property: string, value: string|RegExp, start?: number, anyMatch?: boolean, caseSensitive?: boolean): number;

        /**
         * Find the index of the first matching object in this collection by a function.
         * If the function returns <i>true</i> it is considered a match.
         * @param {Function} fn The function to be called.
         * @param {Mixed} fn.item The collection item.
         * @param {String} fn.key The key of collection item.
         * @param {Object} [scope] The scope (<code>this</code> reference) in which the function is executed. Defaults to this MixedCollection.
         * @param {Number} [start=0] The index to start searching at.
         * @return {Number} The matched index or -1
         * @since 2.3.0
         */
        findIndexBy(fn: Function, fn_item: any, fn_key: string, scope?: any, start?: number): number;

        /**
         * Returns the first item in the collection.
         * @return {Object} the first item in the collection..
         * @since 1.1.0
         */
        first(): any;

        /**
         * Returns the item associated with the passed key OR index.
         * Key has priority over index.  This is the equivalent
         * of calling {@link #getByKey} first, then if nothing matched calling {@link #getAt}.
         * @param {String/Number} key The key or index of the item.
         * @return {Object} If the item is found, returns the item.  If the item was not found, returns <code>undefined</code>.
         * If an item was found, but is a Class, returns <code>null</code>.
         * @since 1.1.0
         */
        get(key: string|number): any;

        /**
         * Returns the item at the specified index.
         * @param {Number} index The index of the item.
         * @return {Object} The item at the specified index.
         */
        getAt(index: number): any;

        /**
         * Returns the item associated with the passed key.
         * @param {String/Number} key The key of the item.
         * @return {Object} The item associated with the passed key.
         */
        getByKey(key: string|number): any;

        /**
         * Returns the number of items in the collection.
         * @return {Number} the number of items in the collection.
         * @since 1.1.0
         */
        getCount(): number;

        /**
         * A function which will be called, passing a newly added object
         * when the object is added without a separate id.  The function
         * should yield the key by which that object will be indexed.
         *
         * If no key is yielded, then the object will be added, but it
         * cannot be accessed or removed quickly. Finding it in this
         * collection for interrogation or removal will require a linear
         * scan of this collection's items.
         *
         * The default implementation simply returns 'item.id' but you can
         * provide your own implementation to return a different value as
         * in the following examples:
         *
         *     // normal way
         *     var mc = new Ext.util.MixedCollection();
         *     mc.add(someEl.dom.id, someEl);
         *     mc.add(otherEl.dom.id, otherEl);
         *     //and so on
         *
         *     // using getKey
         *     var mc = new Ext.util.MixedCollection({
         *         getKey: function(el){
         *             return el.dom.id;
         *         }
         *     });
         *     mc.add(someEl);
         *     mc.add(otherEl);
         *
         * @param {Object} item The item for which to find the key.
         * @return {Object} The key for the passed item.
         * @since 1.1.0
         */
        getKey(item: any): any;

        /**
         * Returns a range of items in this collection
         * @param {Number} startIndex (optional) The starting index. Defaults to 0.
         * @param {Number} endIndex (optional) The ending index. Defaults to the last item.
         * @return {Array} An array of items
         * @since 1.1.0
         */
        getRange(startIndex: number, endIndex: number): any[];

        /**
         * Returns index within the collection of the passed Object.
         * @param {Object} o The item to find the index of.
         * @return {Number} index of the item. Returns -1 if not found.
         * @since 1.1.0
         */
        indexOf(o: any): number;

        /**
         * Returns index within the collection of the passed key.
         * @param {String} key The key to find the index of.
         * @return {Number} index of the key.
         * @since 1.1.0
         */
        indexOfKey(key: string): number;

        /**
         * Inserts an item at the specified index in the collection. Fires the {@link #event-add} event when complete.
         * @param {Number} index The index to insert the item at.
         * @param {String/Object/String[]/Object[]} key The key to associate with the new item, or the item itself.
         * May also be an array of either to insert multiple items at once.
         * @param {Object/Object[]} o (optional) If the second parameter was a key, the new item.
         * May also be an array to insert multiple items at once.
         * @return {Object} The item inserted or an array of items inserted.
         * @since 1.1.0
         */
        insert(index: number, key: string|any, o: any): any;

        /**
         * Returns the last item in the collection.
         * @return {Object} the last item in the collection..
         * @since 1.1.0
         */
        last(): any;

        /**
         * Remove an item from the collection.
         * @param {Object} o The item to remove.
         * @return {Object} The item removed or false if no item was removed.
         * @since 1.1.0
         */
        remove(o: any): any;

        /**
         * Remove all items in the collection. Can also be used
         * to remove only the items in the passed array.
         * @param {Array} [items] An array of items to be removed.
         * @return {Ext.util.MixedCollection} this object
         */
        removeAll(items?: any[]): Ext.util.MixedCollection;

        /**
         * Remove an item from a specified index in the collection. Fires the {@link #event-remove} event when complete.
         * @param {Number} index The index within the collection of the item to remove.
         * @return {Object} The item removed or false if no item was removed.
         * @since 1.1.0
         */
        removeAt(index: number): any;

        /**
         * Removes an item associated with the passed key fom the collection.
         * @param {String} key The key of the item to remove. If 'null' is passed,
         * all objects which yielded no key from the configured {@link #getKey} function are removed.
         * @return {Object} Only returned if removing at a specified key. The item removed or false if no item was removed.
         */
        removeAtKey(key: string): any;

        /**
         * Remove a range of items starting at a specified index in the collection.
         * Does not fire the remove event.
         * @param {Number} index The index within the collection of the item to remove.
         * @param {Number} [removeCount=1] The nuber of items to remove beginning at the specified index.
         * @return {Object} The last item removed or false if no item was removed.
         */
        removeRange(index: number, removeCount?: number): any;

        /**
         * Reorders each of the items based on a mapping from old index to new index. Internally this
         * just translates into a sort. The 'sort' event is fired whenever reordering has
         * occurred.
         * @param {Object} mapping Mapping from old item index to new item index
         *
         *     // example of moving the last of 4 items to the front of the collection
         *     // and moving each one before it forward one
         *     collection.reorder({
         *         0: 1,
         *         1: 2,
         *         2: 3,
         *         3: 0,
         *     });
         */
        reorder(mapping: any);

        /**
         * Replaces an item in the collection. Fires the {@link #event-replace} event when complete.
         * @param {String} key The key associated with the item to replace, or the replacement item.
         *
         * If you supplied a {@link #getKey} implementation for this MixedCollection, or if the key
         * of your stored items is in a property called *'id'*, then the MixedCollection
         * will be able to <i>derive</i> the key of the replacement item. If you want to replace an item
         * with one having the same key value, then just pass the replacement item in this parameter.
         *
         * @param o {Object} o (optional) If the first parameter passed was a key, the item to associate
         * with that key.
         * @return {Object}  The new item.
         * @since 1.1.0
         */
        replace(key: string): any;

        /**
         * Collects all of the values of the given property and returns their sum
         * @param {String} property The property to sum by
         * @param {String} [root] 'root' property to extract the first argument from. This is used mainly when
         * summing fields in records, where the fields are all stored inside the 'data' object
         * @param {Number} [start=0] The record index to start at
         * @param {Number} [end=-1] The record index to end at
         * @return {Number} The total
         */
        sum(property: string, root?: string, start?: number, end?: number): number;

        /**
         * Change the key for an existing item in the collection. If the old key
         * does not exist this is a no-op.
         * @param {Object} oldKey The old key
         * @param {Object} newKey The new key
         */
        updateKey(oldKey: any, newKey: any);
    }

    export class Audio {
    }

    /**
     * This class provides an **unordered** collection similar to 'Ext.util.Collection'. The
     * removal of order maintenance provides a significant performance increase. Further, this
     * class does not provide events or other high-level features. It maintains an array of
     * 'items' and a map to quickly find items by their 'id'.
     *
     * @since 5.1.1
     */
    export class Bag extends Ext.Base {
        /**
         * Mutation counter which is incremented when the collection changes.
         * @readonly
         * @since 5.1.1
         */
        generation: number;

        /**
         * The count of items in the collection.
         * @readonly
         * @since 5.1.1
         */
        length: number;

        constructor();

        destroy();
    }

    /**
     * Base64 is a group of similar binary-to-text encoding schemes that represent binary data in an ASCII string format by
     * translating it into a radix-64 representation.
     *
     * This class is an implementation of base64 encoding and decoding functions and is UTF-8 safe.
     */
    export class Base64 {
        /**
         * Decodes given base64 formatted string
         * @return {string}
         */
        static decode(): string;

        /**
         * Encodes given string in to base64 formatted string
         * @return {string}
         */
        static encode(): string;
    }

    /**
     * @extends Ext.util.Collection
     * Description
     */
    export class BufferedCollection extends Ext.util.Collection {
        getAutoFilter();

        getAutoSort();

        getPageSize();

        getTotalCount();

        setAutoFilter();

        setAutoSort();

        setPageSize();

        setTotalCount();
    }

    interface CacheConfig {
        /**
         * The maximum size the cache is allowed to grow to before
         * further additions cause removal of the least recently used entry.
         */
        maxSize?: number;
    }

    /**
     * This class is used to manage simple, LRU caches. It provides an absolutely minimal
     * container interface. It is created like this:
     *
     *      this.itemCache = new Ext.util.Cache({
     *          miss: function (key) {
     *              return new CacheItem(key);
     *          }
     *      });
     *
     * The '{@link #miss}' abstract method must be implemented by either a derived class or
     * at the instance level as shown above.
     *
     * Once the cache exists and it can handle cache misses, the cache is used like so:
     *
     *      var item = this.itemCache.get(key);
     *
     * The 'key' is some value that uniquely identifies the cached item.
     *
     * In some cases, creating the cache item may require more than just the lookup key. In
     * that case, any extra arguments passed to 'get' will be passed to 'miss'.
     *
     *      this.otherCache = new Ext.util.Cache({
     *          miss: function (key, extra) {
     *              return new CacheItem(key, extra);
     *          }
     *      });
     *
     *      var item = this.otherCache.get(key, extra);
     *
     * To process items as they are removed, you can provide an '{@link #evict}' method. The
     * stock method is 'Ext.emptyFn' and so does nothing.
     *
     * For example:
     *
     *      this.itemCache = new Ext.util.Cache({
     *          miss: function (key) {
     *              return new CacheItem(key);
     *          },
     *
     *          evict: function (key, cacheItem) {
     *              cacheItem.destroy();
     *          }
     *      });
     *
     * @since 5.1.0
     */
    export class Cache implements Ext.util.CacheConfig {
        /**
         * The number of items in this cache.
         * @readonly
         */
        count: number;

        /**
         * The maximum size the cache is allowed to grow to before
         * further additions cause removal of the least recently used entry.
         */
        maxSize: number;

        /**
         * Removes all items from this cache.
         */
        clear();

        /**
         * Calls the given function 'fn' for each item in the cache. The items will be passed
         * to 'fn' from most-to-least recently used.
         * @param {Function} fn The function to call for each cache item.
         * @param {String} fn.key The cache key for the item.
         * @param {Object} fn.value The value in the cache for the item.
         * @param {Object} [scope] The 'this' pointer to use for 'fn'.
         */
        each(fn: Function, fn_key: string, fn_value: any, scope?: any);

        /**
         * This method is called internally from '{@link #get}' when the cache is full and
         * the least-recently-used (LRU) item has been removed.
         *
         * @param {String} key The cache lookup key for the item being removed.
         * @param {Object} value The cache value (returned by '{@link #miss}') for the item
         * being removed.
         */
        protected evict(key: string, value: any);

        /**
         * Finds an item in this cache and returns its value. If the item is present, it is
         * shuffled into the MRU (most-recently-used) position as necessary. If the item is
         * missing, the '{@link #miss}' method is called to create the item.
         *
         * @param {String} key The cache key of the item.
         * @param {Object...} args Arguments for the 'miss' method should it be needed.
         * @return {Object} The cached object.
         */
        get(key: string, args: any): any;

        /**
         * This method is called by '{@link #get}' when the key is not found in the cache.
         * The implementation of this method should create the (expensive) value and return
         * it. Whatever arguments were passed to '{@link #get}' will be passed on to this
         * method.
         *
         * @param {String} key The cache lookup key for the item.
         * @param {Object...} args Any other arguments originally passed to '{@link #get}'.
         * @abstract
         */
        protected miss(key: string, args: any);
    }

    interface CollectionConfig {
        /**
         * A function that can convert newly added items to a proper type before being
         * added to this collection.
         */
        decoder?: Function;

        /**
         * The default sort direction to use if one is not specified.
         */
        defaultSortDirection?: string;

        /**
         * One or more 'Ext.util.CollectionKey' configuration objects or key properties.
         * Each property of the given object is the name of the 'CollectionKey' instance
         * that is stored on this collection. The value of each property configures the
         * 'CollectionKey' instance.
         *
         *      var collection = new Ext.util.Collection({
         *          extraKeys: {
         *              byName: 'name' // based on "name" property of each item
         *          }
         *      });
         *
         * Or equivalently:
         *
         *      var collection = new Ext.util.Collection({
         *          extraKeys: {
         *              byName: {
         *                  property: 'name'
         *              }
         *          }
         *      });
         *
         * To provide a custom key extraction function instead:
         *
         *      var collection = new Ext.util.Collection({
         *          extraKeys: {
         *              byName: {
         *                  keyFn: function (item) {
         *                      return item.name;
         *                  }
         *              }
         *          }
         *      });
         *
         * Or to call a key getter method from each item:
         *
         *      var collection = new Ext.util.Collection({
         *          extraKeys: {
         *              byName: {
         *                  keyFn: 'getName'
         *              }
         *          }
         *      });
         *
         * To use the above:
         *
         *      var item = collection.byName.get('somename');
         *
         * **NOTE** Either a 'property' or 'keyFn' must be be specified to define each
         * key.
         * @since 5.0.0
         */
        extraKeys?: any;

        /**
         * The collection of {@link Ext.util.Filter Filters} for this collection. At the
         * time a collection is created 'filters' can be specified as a unit. After that
         * time the normal 'setFilters' method can also be given a set of replacement
         * filters for the collection.
         *
         * Individual filters can be specified as an 'Ext.util.Filter' instance, a config
         * object for 'Ext.util.Filter' or simply a function that will be wrapped in a
         * instance with its {@Ext.util.Filter#filterFn filterFn} set.
         *
         * For fine grain control of the filters collection, call 'getFilters' to return
         * the 'Ext.util.Collection' instance that holds this collection's filters.
         *
         *      var collection = new Ext.util.Collection();
         *      var filters = collection.getFilters(); // an Ext.util.FilterCollection
         *
         *      function legalAge (item) {
         *          return item.age >= 21;
         *      }
         *
         *      filters.add(legalAge);
         *
         *      //...
         *
         *      filters.remove(legalAge);
         *
         * Any changes to the 'filters' collection will cause this collection to adjust
         * its items accordingly (if 'autoFilter' is 'true').
         * @since 5.0.0
         */
        filters?: any[]|Ext.util.FilterCollection;

        /**
         * A configuration object for this collection's {@link Ext.util.Grouper grouper}.
         *
         * For example, to group items by the first letter of the last name:
         *
         *      var collection = new Ext.util.Collection({
         *          grouper: {
         *              groupFn: function (item) {
         *                  return item.lastName.substring(0, 1);
         *              }
         *          }
         *      });
         */
        grouper?: any;

        /**
         * The collection of to hold each group container. This collection is created and
         * removed dynamically based on 'grouper'. Application code should only need to
         * call 'getGroups' to retrieve the collection and not 'setGroups'.
         */
        groups?: Ext.util.GroupCollection;

        /**
         * A function to retrieve the key of an item in the collection. If provided,
         * this replaces the default 'getKey' method. The default 'getKey' method handles
         * items that have either an "id" or "_id" property or failing that a 'getId'
         * method to call.
         * @since 5.0.0
         *
         * Optional
         */
        keyFn?: Function;

        /**
         * The maximum number of sorters which may be applied to this Sortable when using
         * the "multi" insertion position when adding sorters.
         *
         * New sorters added using the "multi" insertion position are inserted at the top
         * of the sorters list becoming the new primary sort key.
         *
         * If the sorters collection has grown to longer then **'multiSortLimit'**, then
         * the it is trimmed.
         *
         * Optional, Defaults to: 3
         */
        multiSortLimit?: number;

        /**
         * The root property to use for aggregation, filtering and sorting. By default
         * this is 'null' but when containing things like {@link Ext.data.Model records}
         * this config would likely be set to "data" so that property names are applied
         * to the fields of each record.
         */
        rootProperty?: string;

        /**
         * Array of {@link Ext.util.Sorter sorters} for this collection. At the time a
         * collection is created the 'sorters' can be specified as a unit. After that time
         * the normal 'setSorters' method can be also be given a set of replacement
         * sorters.
         *
         * Individual sorters can be specified as an 'Ext.util.Sorter' instance, a config
         * object for 'Ext.util.Sorter' or simply the name of a property by which to sort.
         *
         * An alternative way to extend the sorters is to call the 'sort' method and pass
         * a property or sorter config to add to the sorters.
         *
         * For fine grain control of the sorters collection, call 'getSorters' to return
         * the 'Ext.util.Collection' instance that holds this collection's sorters.
         *
         *      var collection = new Ext.util.Collection();
         *      var sorters = collection.getSorters(); // an Ext.util.SorterCollection
         *
         *      sorters.add('name');
         *
         *      //...
         *
         *      sorters.remove('name');
         *
         * Any changes to the 'sorters' collection will cause this collection to adjust
         * its items accordingly (if 'autoSort' is 'true').
         *
         * @since 5.0.0
         */
        sorters?: any[]|Ext.util.SorterCollection;

        /**
         * The base 'Collection'. This collection contains the items to which filters
         * are applied to populate this collection. In this configuration, only the
         * root 'source' collection can have items truly added or removed.
         * @since 5.0.0
         */
        source?: Ext.util.Collection;
    }

    /**
     * This class manages uniquely keyed objects such as {@link Ext.data.Model records} or
     * {@link Ext.Component components}.
     *
     * ## Keys
     *
     * Unlike 'Ext.util.MixedCollection' this class can only manage objects whose key can be
     * extracted from the instance. That is, this class does not support "external" keys. This
     * makes this class more efficient because it does not need to track keys in parallel with
     * items. It also means key-to-item lookup will be optimal and never need to perform a
     * linear search.
     *
     * ### Extra Keys
     *
     * In some cases items may need to be looked up by multiple property values. To enable this
     * there is the 'extraKeys' config.
     *
     * For example, to quickly look up items by their "name" property:
     *
     *      var collection = new Ext.util.Collection({
     *          extraKeys: {
     *              byName: 'name' // based on "name" property of each item
     *          }
     *      });
     *
     * ## Ranges
     *
     * When methods accept index arguments to indicate a range of items, these are either an
     * index and a number of items or a "begin" and "end" index.
     *
     * In the case of "begin" and "end", the "end" is the first item outside the range. This
     * definition makes it simple to expression empty ranges because "length = end - begin".
     *
     * ### Negative Indices
     *
     * When an item index is provided, negative values are treated as offsets from the end of
     * the collection. In other words the follow are equivalent:
     *
     *      +---+---+---+---+---+---+
     *      |   |   |   |   |   |   |
     *      +---+---+---+---+---+---+
     *        0   1   2   3   4   5
     *       -6  -5  -4  -3  -2  -1
     *
     * ## Legacy Classes
     *
     * The legacy classes 'Ext.util.MixedCollection' and 'Ext.util.AbstractMixedCollection'
     * may be needed if external keys are required, but for all other situations this class
     * should be used instead.
     */
    export class Collection extends Ext.Base implements Ext.util.CollectionConfig {
        /**
         * A read-only flag indicating if this object is filtered.
         * @readonly
         */
        filtered: boolean;

        /**
         * Mutation counter which is incremented when the collection changes.
         * @readonly
         * @since 5.0.0
         */
        generation: number;

        /**
         * A read-only flag indicating if this object is grouped.
         * @readonly
         */
        grouped: boolean;

        /**
         * 'true' in this class to identify an object as an instantiated Collection, or subclass
         * thereof.
         * @readonly
         */
        isCollection: boolean;

        /**
         * The count of items in the collection.
         * @readonly
         * @since 5.0.0
         */
        length: number;

        /**
         * A read-only flag indicating if this object is sorted. This flag may not be correct
         * during an update of the sorter collection but will be correct before 'onSortChange'
         * is called. This flag is 'true' if 'grouped' is 'true' because the collection is at
         * least sorted by the 'grouper'.
         * @readonly
         */
        sorted: boolean;

        /**
         * A counter that is increased by 'beginUpdate' and decreased by 'endUpdate'. When
         * this transitions from 0 to 1 the '{@link #event-beginupdate beginupdate}' event is
         * fired. When it transitions back from 1 to 0 the '{@link #event-endupdate endupdate}'
         * event is fired.
         * @readonly
         * @since 5.0.0
         */
        updating: number;

        /**
         * A function that can convert newly added items to a proper type before being
         * added to this collection.
         */
        decoder: Function;

        /**
         * The default sort direction to use if one is not specified.
         */
        defaultSortDirection: string;

        /**
         * One or more 'Ext.util.CollectionKey' configuration objects or key properties.
         * Each property of the given object is the name of the 'CollectionKey' instance
         * that is stored on this collection. The value of each property configures the
         * 'CollectionKey' instance.
         *
         *      var collection = new Ext.util.Collection({
         *          extraKeys: {
         *              byName: 'name' // based on "name" property of each item
         *          }
         *      });
         *
         * Or equivalently:
         *
         *      var collection = new Ext.util.Collection({
         *          extraKeys: {
         *              byName: {
         *                  property: 'name'
         *              }
         *          }
         *      });
         *
         * To provide a custom key extraction function instead:
         *
         *      var collection = new Ext.util.Collection({
         *          extraKeys: {
         *              byName: {
         *                  keyFn: function (item) {
         *                      return item.name;
         *                  }
         *              }
         *          }
         *      });
         *
         * Or to call a key getter method from each item:
         *
         *      var collection = new Ext.util.Collection({
         *          extraKeys: {
         *              byName: {
         *                  keyFn: 'getName'
         *              }
         *          }
         *      });
         *
         * To use the above:
         *
         *      var item = collection.byName.get('somename');
         *
         * **NOTE** Either a 'property' or 'keyFn' must be be specified to define each
         * key.
         * @since 5.0.0
         */
        extraKeys: any;

        /**
         * The collection of {@link Ext.util.Filter Filters} for this collection. At the
         * time a collection is created 'filters' can be specified as a unit. After that
         * time the normal 'setFilters' method can also be given a set of replacement
         * filters for the collection.
         *
         * Individual filters can be specified as an 'Ext.util.Filter' instance, a config
         * object for 'Ext.util.Filter' or simply a function that will be wrapped in a
         * instance with its {@Ext.util.Filter#filterFn filterFn} set.
         *
         * For fine grain control of the filters collection, call 'getFilters' to return
         * the 'Ext.util.Collection' instance that holds this collection's filters.
         *
         *      var collection = new Ext.util.Collection();
         *      var filters = collection.getFilters(); // an Ext.util.FilterCollection
         *
         *      function legalAge (item) {
         *          return item.age >= 21;
         *      }
         *
         *      filters.add(legalAge);
         *
         *      //...
         *
         *      filters.remove(legalAge);
         *
         * Any changes to the 'filters' collection will cause this collection to adjust
         * its items accordingly (if 'autoFilter' is 'true').
         * @since 5.0.0
         */
        filters: any[]|Ext.util.FilterCollection;

        /**
         * A configuration object for this collection's {@link Ext.util.Grouper grouper}.
         *
         * For example, to group items by the first letter of the last name:
         *
         *      var collection = new Ext.util.Collection({
         *          grouper: {
         *              groupFn: function (item) {
         *                  return item.lastName.substring(0, 1);
         *              }
         *          }
         *      });
         */
        grouper: any;

        /**
         * The collection of to hold each group container. This collection is created and
         * removed dynamically based on 'grouper'. Application code should only need to
         * call 'getGroups' to retrieve the collection and not 'setGroups'.
         */
        groups: Ext.util.GroupCollection;

        /**
         * A function to retrieve the key of an item in the collection. If provided,
         * this replaces the default 'getKey' method. The default 'getKey' method handles
         * items that have either an "id" or "_id" property or failing that a 'getId'
         * method to call.
         * @since 5.0.0
         *
         * Optional
         */
        keyFn: Function;

        /**
         * The maximum number of sorters which may be applied to this Sortable when using
         * the "multi" insertion position when adding sorters.
         *
         * New sorters added using the "multi" insertion position are inserted at the top
         * of the sorters list becoming the new primary sort key.
         *
         * If the sorters collection has grown to longer then **'multiSortLimit'**, then
         * the it is trimmed.
         *
         * Optional, Defaults to: 3
         */
        multiSortLimit: number;

        /**
         * The root property to use for aggregation, filtering and sorting. By default
         * this is 'null' but when containing things like {@link Ext.data.Model records}
         * this config would likely be set to "data" so that property names are applied
         * to the fields of each record.
         */
        rootProperty: string;

        /**
         * Array of {@link Ext.util.Sorter sorters} for this collection. At the time a
         * collection is created the 'sorters' can be specified as a unit. After that time
         * the normal 'setSorters' method can be also be given a set of replacement
         * sorters.
         *
         * Individual sorters can be specified as an 'Ext.util.Sorter' instance, a config
         * object for 'Ext.util.Sorter' or simply the name of a property by which to sort.
         *
         * An alternative way to extend the sorters is to call the 'sort' method and pass
         * a property or sorter config to add to the sorters.
         *
         * For fine grain control of the sorters collection, call 'getSorters' to return
         * the 'Ext.util.Collection' instance that holds this collection's sorters.
         *
         *      var collection = new Ext.util.Collection();
         *      var sorters = collection.getSorters(); // an Ext.util.SorterCollection
         *
         *      sorters.add('name');
         *
         *      //...
         *
         *      sorters.remove('name');
         *
         * Any changes to the 'sorters' collection will cause this collection to adjust
         * its items accordingly (if 'autoSort' is 'true').
         *
         * @since 5.0.0
         */
        sorters: any[]|Ext.util.SorterCollection;

        /**
         * The base 'Collection'. This collection contains the items to which filters
         * are applied to populate this collection. In this configuration, only the
         * root 'source' collection can have items truly added or removed.
         * @since 5.0.0
         */
        source: Ext.util.Collection;

        /**
         * Adds an item to the collection. If the item already exists or an item with the
         * same key exists, the old item will be removed and the new item will be added to
         * the end.
         *
         * This method also accepts an array of items or simply multiple items as individual
         * arguments. The following 3 code sequences have the same end result:
         *
         *      // Call add() once per item (not optimal - best avoided):
         *      collection.add(itemA);
         *      collection.add(itemB);
         *      collection.add(itemC);
         *      collection.add(itemD);
         *
         *      // Call add() with each item as an argument:
         *      collection.add(itemA, itemB, itemC, itemD);
         *
         *      // Call add() with the items as an array:
         *      collection.add([ itemA, itemB, itemC, itemD ]);
         *
         * The first form should be avoided where possible because the collection and all
         * parties "watching" it will be updated 4 times.
         *
         * @param {Object/Object[]} item The item or items to add.
         * @return {Object/Object[]} The item or items added.
         * @since 5.0.0
         */
        add(item: any): any;

        /**
         * Returns the result of the specified aggregation operation against all items in this
         * collection.
         *
         * This method is not typically called directly because there are convenience methods
         * for each of the supported 'operation' values. These are:
         *
         *   * **average** - Returns the average value.
         *   * **bounds**  - Returns an array of '[min, max]'.
         *   * **max**     - Returns the maximum value or 'undefined' if empty.
         *   * **min**     - Returns the minimum value or 'undefined' if empty.
         *   * **sum**     - Returns the sum of all values.
         *
         * For example:
         *
         *      result = collection.aggregate('age', 'sum');
         *
         *      result = collection.aggregate('age', 'sum', 2, 10); // the 8 items at index 2
         *
         * To provide a custom operation function:
         *
         *      function averageAgeOfMinors (items, values) {
         *          var sum = 0,
         *              count = 0;
         *
         *          for (var i = 0; i < values.length; ++i) {
         *              if (values[i] < 18) {
         *                  sum += values[i];
         *                  ++count;
         *              }
         *          }
         *
         *          return count ? sum / count : 0;
         *      }
         *
         *      result = collection.aggregate('age', averageAgeOfMinors);
         *
         * @param {String} property The name of the property to aggregate from each item.
         * @param {String/Function} operation The operation to perform.
         * @param {Array} operation.items The items on which the 'operation' function is to
         * operate.
         * @param {Array} operation.values The values on which the 'operation' function is to
         * operate.
         * @param {Number} [begin] The index of the first item in 'items' to include in the
         * aggregation.
         * @param {Number} [end] The index at which to stop aggregating 'items'. The item at
         * this index will *not* be included in the aggregation.
         * @param {Object} [scope] The 'this' pointer to use if 'operation' is a function.
         * Defaults to this collection.
         * @return {Object}
         */
        aggregate(property: string, operation: string|Function, operation_items: any[], operation_values: any[], begin?: number, end?: number, scope?: any): any;

        /**
         * See {@link #aggregate}. The functionality is the same, however the aggregates are
         * provided per group. Assumes this collection has an active {@link #grouper}.
         *
         * @param {String} property The name of the property to aggregate from each item.
         * @param {String/Function} operation The operation to perform.
         * @param {Array} operation.items The items on which the 'operation' function is to
         * operate.
         * @param {Array} operation.values The values on which the 'operation' function is to
         * operate.
         * @param {Object} [scope] The 'this' pointer to use if 'operation' is a function.
         * Defaults to this collection.
         * @return {Object}
         */
        aggregateByGroup(property: string, operation: string|Function, operation_items: any[], operation_values: any[], scope?: any): any;

        /**
         * Averages property values from some or all of the items in this collection.
         *
         * @param {String} property The name of the property to average from each item.
         * @param {Number} [begin] The index of the first item to include in the average.
         * @param {Number} [end] The index at which to stop averaging 'items'. The item at
         * this index will *not* be included in the average.
         * @return {Object} The result of averaging the specified property from the indicated
         * items.
         * @since 5.0.0
         */
        average(property: string, begin?: number, end?: number): any;

        /**
         * See {@link #average}. The result is partitioned by group.
         *
         * @param {String} property The name of the property to average from each item.
         * @return {Object} The result of {@link #average}, partitioned by group. See {@link #aggregateByGroup}.
         * @since 5.0.0
         */
        averageByGroup(property: string): any;

        /**
         * This method is called to indicate the start of multiple changes to the collection.
         * Application code should seldom need to call this method as it is called internally
         * when needed. If multiple collection changes are needed, consider wrapping them in
         * an 'update' call rather than calling 'beginUpdate' directly.
         *
         * Internally this method increments a counter that is decremented by 'endUpdate'. It
         * is important, therefore, that if you call 'beginUpdate' directly you match that
         * call with a call to 'endUpdate' or you will prevent the collection from updating
         * properly.
         *
         * For example:
         *
         *      var collection = new Ext.util.Collection();
         *
         *      collection.beginUpdate();
         *
         *      collection.add(item);
         *      // ...
         *
         *      collection.insert(index, otherItem);
         *      //...
         *
         *      collection.endUpdate();
         *
         * @since 5.0.0
         */
        beginUpdate();

        /**
         * Determines the minimum and maximum values for the specified property over some or
         * all of the items in this collection.
         *
         * @param {String} property The name of the property from each item.
         * @param {Number} [begin] The index of the first item to include in the bounds.
         * @param {Number} [end] The index at which to stop in 'items'. The item at this index
         * will *not* be included in the bounds.
         * @return {Array} An array '[min, max]' with the minimum and maximum of the specified
         * property.
         * @since 5.0.0
         */
        bounds(property: string, begin?: number, end?: number): any[];

        /**
         * See {@link #bounds}. The result is partitioned by group.
         *
         * @param {String} property The name of the property from each item.
         * @return {Object} The result of {@link #bounds}, partitioned by group. See {@link #aggregateByGroup}.
         * @since 5.0.0
         */
        boundsByGroup(property: string): any;

        /**
         * Removes all items from the collection. This is similar to 'removeAll' except that
         * 'removeAll' fire events to inform listeners. This means that this method should be
         * called only when you are sure there are no listeners.
         * @since 5.0.0
         */
        clear();

        /**
         * Creates a shallow copy of this collection
         * @return {Ext.util.Collection}
         * @since 5.0.0
         */
        clone(): Ext.util.Collection;

        /**
         * Collects unique values of a particular property in this Collection.
         * @param {String} property The property to collect on
         * @param {String} root (optional) 'root' property to extract the first argument from. This is used mainly when
         * summing fields in records, where the fields are all stored inside the 'data' object
         * @param {Boolean} [allowNull] Pass 'true' to include 'null', 'undefined' or empty
         * string values.
         * @return {Array} The unique values
         * @since 5.0.0
         */
        collect(property: string, root: string, allowNull?: boolean): any[];

        /**
         * Returns true if the collection contains the passed Object as an item.
         * @param {Object} item The Object to look for in the collection.
         * @return {Boolean} 'true' if the collection contains the Object as an item.
         * @since 5.0.0
         */
        contains(item: any): boolean;

        /**
         * Returns true if the collection contains the passed Object as a key.
         * @param {String} key The key to look for in the collection.
         * @return {Boolean} True if the collection contains the Object as a key.
         * @since 5.0.0
         */
        containsKey(key: string): boolean;

        /**
         * Determines the number of items in the collection.
         *
         * @return {Number} The number of items.
         * @since 5.0.0
         */
        count(): number;

        /**
         * See {@link #count}. The result is partitioned by group.
         *
         * @return {Object} The result of {@link #count}, partitioned by group. See {@link #aggregateByGroup}.
         * @since 5.0.0
         */
        countByGroup(): any;

        /**
         * Creates a new collection that is a filtered subset of this collection. The filter
         * passed can be a function, a simple property name and value, an 'Ext.util.Filter'
         * instance, an array of 'Ext.util.Filter' instances.
         *
         * If the passed filter is a function the second argument is its "scope" (or "this"
         * pointer). The function should return 'true' given each item in the collection if
         * that item should be included in the filtered collection.
         *
         *      var people = new Ext.util.Collection();
         *
         *      people.add([
         *          { id: 1, age: 25, name: 'Ed' },
         *          { id: 2, age: 24, name: 'Tommy' },
         *          { id: 3, age: 24, name: 'Arne' },
         *          { id: 4, age: 26, name: 'Aaron' }
         *      ]);
         *
         *      // Create a collection of people who are older than 24:
         *      var oldPeople = people.createFiltered(function (item) {
         *          return item.age > 24;
         *      });
         *
         * If the passed filter is a 'Ext.util.Filter' instance or array of 'Ext.util.Filter'
         * instances the filter(s) are used to produce the filtered collection and there are
         * no further arguments.
         *
         * If the passed filter is a string it is understood as the name of the property by
         * which to filter. The second argument is the "value" used to compare each item's
         * property value. This comparison can be further tuned with the 'anyMatch' and
         * 'caseSensitive' (optional) arguments.
         *
         *    // Create a new Collection containing only the items where age == 24
         *    var middleAged = people.createFiltered('age', 24);
         *
         * Alternatively you can apply 'filters' to this Collection by calling 'setFilters'
         * or modifying the filter collection returned by 'getFilters'.
         *
         * @param {Ext.util.Filter[]/String/Function} property A property on your objects, an
         * array of {@link Ext.util.Filter Filter} objects or a filter function.
         *
         * @param {Object} value If 'property' is a function, this argument is the "scope"
         * (or "this" pointer) for the function. Otherwise this is either a 'RegExp' to test
         * property values or the value with which to compare.
         *
         * @param {Boolean} [anyMatch=false] True to match any part of the string, not just
         * the beginning.
         *
         * @param {Boolean} [caseSensitive=false] True for case sensitive comparison.
         *
         * @param {Boolean} [exactMatch=false] 'true' to force exact match (^ and $ characters added to the regex).
         *
         * @return {Ext.util.Collection} The new, filtered collection.
         *
         * @since 5.0.0
         */
        createFiltered(property: Ext.util.Filter|string|Function, value: any, anyMatch?: boolean, caseSensitive?: boolean, exactMatch?: boolean): Ext.util.Collection;

        /**
         * This method is an alias for 'decodeItems' but is called when items are being
         * removed. If a 'decoder' is provided it may be necessary to also override this
         * method to achieve symmetry between adding and removing items. This is the case
         * for 'Ext.util.FilterCollection' and 'Ext.util.SorterCollection' for example.
         *
         * @since 5.0.0
         */
        protected decodeRemoveItems();

        /**
         * Destroys this collection. This is only necessary if this collection uses a 'source'
         * collection as that relationship will keep a reference from the 'source' to this
         * collection and potentially leak memory.
         * @since 5.0.0
         */
        destroy();

        /**
         * Executes the specified function once for every item in the collection. If the value
         * returned by 'fn' is 'false' the iteration stops. In all cases, the last value that
         * 'fn' returns is returned by this method.
         *
         * @param {Function} fn The function to execute for each item.
         * @param {Object} fn.item The collection item.
         * @param {Number} fn.index The index of item.
         * @param {Number} fn.len Total length of collection.
         * @param {Object} [scope=this] The scope ('this' reference) in which the function
         * is executed. Defaults to this collection.
         * @since 5.0.0
         */
        each(fn: Function, fn_item: any, fn_index: number, fn_len: number, scope?: any);

        /**
         * Executes the specified function once for every key in the collection, passing each
         * key, and its associated item as the first two parameters. If the value returned by
         * 'fn' is 'false' the iteration stops. In all cases, the last value that 'fn' returns
         * is returned by this method.
         *
         * @param {Function} fn The function to execute for each item.
         * @param {String} fn.key The key of collection item.
         * @param {Object} fn.item The collection item.
         * @param {Number} fn.index The index of item.
         * @param {Number} fn.len Total length of collection.
         * @param {Object} [scope=this] The scope ('this' reference) in which the function
         * is executed. Defaults to this collection.
         * @since 5.0.0
         */
        eachKey(fn: Function, fn_key: string, fn_item: any, fn_index: number, fn_len: number, scope?: any);

        /**
         * This method is called after modifications are complete on a collection. For details
         * see 'beginUpdate'.
         * @since 5.0.0
         */
        endUpdate();

        /**
         * Finds the items with the minimum and maximum for the specified property over some
         * or all of the items in this collection.
         *
         * @param {String} property The name of the property from each item.
         * @param {Number} [begin] The index of the first item to include.
         * @param {Number} [end] The index at which to stop in 'items'. The item at this index
         * will *not* be included.
         * @return {Array} An array '[minItem, maxItem]' with the items that have the minimum
         * and maximum of the specified property.
         * @since 5.0.0
         */
        extremes(property: string, begin?: number, end?: number): any[];

        /**
         * See {@link #extremes}. The result is partitioned by group.
         *
         * @param {String} property The name of the property from each item.
         * @return {Object} The result of {@link #extremes}, partitioned by group. See {@link #aggregateByGroup}.
         * @since 5.0.0
         */
        extremesByGroup(property: string): any;

        /**
         * Filter by a function. Returns a <i>new</i> collection that has been filtered.
         * The passed function will be called with each object in the collection.
         * If the function returns true, the value is included otherwise it is filtered.
         * @param {Function} fn The function to be called.
         * @param {Mixed} fn.item The collection item.
         * @param {String} fn.key The key of collection item.
         * @param {Object} scope (optional) The scope (<code>this</code> reference) in
         * which the function is executed. Defaults to this Collection.
         * @return {Ext.util.Collection} The new filtered collection
         * @since 5.0.0
         * @deprecated
         */
        filterBy(fn: Function, fn_item: any, fn_key: string, scope: any): Ext.util.Collection;

        /**
         * Finds the first matching object in this collection by a specific property/value.
         *
         * @param {String} property The name of a property on your objects.
         * @param {String/RegExp} value A string that the property values
         * should start with or a RegExp to test against the property.
         * @param {Number} [start=0] The index to start searching at.
         * @param {Boolean} [startsWith=true] Pass 'false' to allow a match start anywhere in
         * the string. By default the 'value' will match only at the start of the string.
         * @param {Boolean} [endsWith=true] Pass 'false' to allow the match to end before the
         * end of the string. By default the 'value' will match only at the end of the string.
         * @param {Boolean} [ignoreCase=true] Pass 'false' to make the 'RegExp' case
         * sensitive (removes the 'i' flag).
         * @return {Object} The first item in the collection which matches the criteria or
         * 'null' if none was found.
         * @since 5.0.0
         */
        find(property: string, value: string|RegExp, start?: number, startsWith?: boolean, endsWith?: boolean, ignoreCase?: boolean): any;

        /**
         * Returns the first item in the collection which elicits a true return value from the
         * passed selection function.
         * @param {Function} fn The selection function to execute for each item.
         * @param {Object} fn.item The collection item.
         * @param {String} fn.key The key of collection item.
         * @param {Object} [scope=this] The scope ('this' reference) in which the function
         * is executed. Defaults to this collection.
         * @param {Number} [start=0] The index at which to start searching.
         * @return {Object} The first item in the collection which returned true from the selection
         * function, or null if none was found.
         * @since 5.0.0
         */
        findBy(fn: Function, fn_item: any, fn_key: string, scope?: any, start?: number): any;

        /**
         * Finds the index of the first matching object in this collection by a specific
         * property/value.
         *
         * @param {String} property The name of a property on your objects.
         * @param {String/RegExp} value A string that the property values
         * should start with or a RegExp to test against the property.
         * @param {Number} [start=0] The index to start searching at.
         * @param {Boolean} [startsWith=true] Pass 'false' to allow a match start anywhere in
         * the string. By default the 'value' will match only at the start of the string.
         * @param {Boolean} [endsWith=true] Pass 'false' to allow the match to end before the
         * end of the string. By default the 'value' will match only at the end of the string.
         * @param {Boolean} [ignoreCase=true] Pass 'false' to make the 'RegExp' case
         * sensitive (removes the 'i' flag).
         * @return {Number} The matched index or -1 if not found.
         * @since 5.0.0
         */
        findIndex(property: string, value: string|RegExp, start?: number, startsWith?: boolean, endsWith?: boolean, ignoreCase?: boolean): number;

        /**
         * Find the index of the first matching object in this collection by a function.
         * If the function returns 'true' it is considered a match.
         * @param {Function} fn The function to be called.
         * @param {Object} fn.item The collection item.
         * @param {String} fn.key The key of collection item.
         * @param {Object} [scope=this] The scope ('this' reference) in which the function
         * is executed. Defaults to this collection.
         * @param {Number} [start=0] The index at which to start searching.
         * @return {Number} The matched index or -1
         * @since 5.0.0
         */
        findIndexBy(fn: Function, fn_item: any, fn_key: string, scope?: any, start?: number): number;

        /**
         * Returns the first item in the collection.
         * @param {Boolean} [grouped] 'true' to extract the first item in each group. Only applies if
         * a {@link #grouper} is active in the collection.
         * @return {Object} The first item in the collection. If the grouped parameter is passed,
         * see {@link #aggregateByGroup} for information on the return type.
         * @since 5.0.0
         */
        first(grouped?: boolean): any;

        /**
         * Returns the item associated with the passed key.
         * @param {String/Number} key The key of the item.
         * @return {Object} The item associated with the passed key.
         * @since 5.0.0
         */
        get(key: string|number): any;

        /**
         * Returns the item at the specified index.
         * @param {Number} index The index of the item.
         * @return {Object} The item at the specified index.
         * @since 5.0.0
         */
        getAt(index: number): any;

        getAutoFilter();

        /**
         * Returns the item associated with the passed key.
         * @param {String/Number} key The key of the item.
         * @return {Object} The item associated with the passed key.
         * @since 5.0.0
         */
        getByKey(key: string|number): any;

        /**
         * Returns the number of items in the collection.
         * @return {Number} the number of items in the collection.
         * @since 5.0.0
         */
        getCount(): number;

        getDecoder();

        getDefaultSortDirection();

        getExtraKeys();

        /**
         * Returns the filter function.
         * @return {Function} sortFn The sort function.
         */
        getFilterFn(): Function;

        /**
         * Returns the 'Ext.util.FilterCollection'. Unless 'autoCreate' is explicitly passed
         * as 'false' this collection will be automatically created if it does not yet exist.
         * @param [autoCreate=true] Pass 'false' to disable auto-creation of the collection.
         * @return {Ext.util.FilterCollection} The collection of filters.
         */
        getFilters(): Ext.util.FilterCollection;

        getGrouper();

        /**
         * A function which will be called, passing an object belonging to this collection.
         * The function should return the key by which that object will be indexed. This key
         * must be unique to this item as only one item with this key will be retained.
         *
         * The default implementation looks basically like this (give or take special case
         * handling of 0):
         *
         *      function getKey (item) {
         *          return item.id || item._id || item.getId();
         *      }
         *
         * You can provide your own implementation by passing the 'keyFn' config.
         *
         * For example, to hold items that have a unique "name" property:
         *
         *     var elementCollection = new Ext.util.Collection({
         *         keyFn: function (item) {
         *             return item.name;
         *         }
         *     });
         *
         * The collection can have 'extraKeys' if items need to be quickly looked up by other
         * (potentially non-unique) properties.
         *
         * @param {Object} item The item.
         * @return {Object} The key for the passed item.
         * @since 5.0.0
         */
        getKey(item: any): any;

        getMultiSortLimit();

        /**
         * Returns a range of items in this collection
         * @param {Number} [begin=0] The index of the first item to get.
         * @param {Number} [end] The ending index. The item at this index is *not* included.
         * @return {Array} An array of items
         * @since 5.0.0
         */
        getRange(begin?: number, end?: number): any[];

        getRootProperty();

        /**
         * Returns the 'Ext.util.SorterCollection'. Unless 'autoCreate' is explicitly passed
         * as 'false' this collection will be automatically created if it does not yet exist.
         * @param [autoCreate=true] Pass 'false' to disable auto-creation of the collection.
         * @return {Ext.util.SorterCollection} The collection of sorters.
         */
        getSorters(): Ext.util.SorterCollection;

        /**
         * Returns an up to date sort function.
         * @return {Function} The sort function.
         */
        getSortFn(): Function;

        /**
         * Returns all unfiltered items in the Collection when the Collection has been
         * filtered.  Returns 'null' when the Collection is not filtered.
         * @return {Ext.util.Collection} items All unfiltered items (or 'null' when the
         * Collection is not filtered)
         */
        getSource(): Ext.util.Collection;

        /**
         * Returns an array of values for the specified (sub) property.
         *
         * For example, to get an array of "name" properties from a collection of records (of
         * 'Ext.data.Model' objects):
         *
         *      var names = collection.getValues('name', 'data');
         *
         * @param {String} property The property to collect on
         * @param {String} [root] 'root' property to extract the first argument from. This is
         * used mainly when operating on fields in records, where the fields are all stored
         * inside the 'data' object.
         * @return {Array} The values.
         * @param {Number} [start=0] The index of the first item to include.
         * @param {Number} [end] The index at which to stop getting values. The value of this
         * item is *not* included.
         * @return {Object[]} The array of values.
         * @since 5.0.0
         */
        getValues(property: string, root?: string, start?: number, end?: number): any[];

        /**
         * Returns index within the collection of the passed Object.
         * @param {Object} item The item to find.
         * @return {Number} The index of the item or -1 if not found.
         * @since 5.0.0
         */
        indexOf(item: any): number;

        /**
         * Returns index within the collection of the passed key.
         * @param {Object} key The key to find.
         * @return {Number} The index of the item or -1 if not found.
         * @since 5.0.0
         */
        indexOfKey(key: any): number;

        /**
         * Inserts one or more items to the collection. The 'index' value is the position at
         * which the first item will be placed. The items starting at that position will be
         * shifted to make room.
         *
         * @param {Number} index The index at which to insert the item(s).
         * @param {Object/Object[]} item The item or items to add.
         * @return {Object/Object[]} The item or items added.
         * @since 5.0.0
         */
        insert(index: number, item: any): any;

        /**
         * This method can be used to conveniently test whether an individual item would be
         * removed due to the current filter.
         * @param {Object} item The item to test.
         * @return {Boolean} The value 'true' if the item would be "removed" from the
         * collection due to filters or 'false' otherwise.
         */
        isItemFiltered(item: any): boolean;

        /**
         * This method should be called when an item in this collection has been modified. If
         * the collection is sorted or filtered the result of modifying an item needs to be
         * reflected in the collection. If the item's key is also being modified, it is best
         * to pass the 'oldKey' to this same call rather than call 'updateKey' separately.
         *
         * @param {Object} item The item that was modified.
         * @param {String[]} [modified] The names of the modified properties of the item.
         * @param {String/Number} [oldKey] Passed if the item's key was also modified.
         * @since 5.0.0
         */
        itemChanged(item: any, modified?: string, oldKey?: string|number);

        /**
         * Returns the last item in the collection.
         * @param {Boolean} [grouped] 'true' to extract the first item in each group. Only applies if
         * a {@link #grouper} is active in the collection.
         * @return {Object} The last item in the collection. If the grouped parameter is passed,
         * see {@link #aggregateByGroup} for information on the return type.
         * @since 5.0.0
         */
        last(grouped?: boolean): any;

        /**
         * Determines the maximum value for the specified property over some or all of the
         * items in this collection.
         *
         * @param {String} property The name of the property from each item.
         * @param {Number} [begin] The index of the first item to include in the maximum.
         * @param {Number} [end] The index at which to stop in 'items'. The item at this index
         * will *not* be included in the maximum.
         * @return {Object} The maximum of the specified property from the indicated items.
         * @since 5.0.0
         */
        max(property: string, begin?: number, end?: number): any;

        /**
         * See {@link #max}. The result is partitioned by group.
         *
         * @param {String} property The name of the property from each item.
         * @return {Object} The result of {@link #max}, partitioned by group. See {@link #aggregateByGroup}.
         * @since 5.0.0
         */
        maxByGroup(property: string): any;

        /**
         * Finds the item with the maximum value for the specified property over some or all
         * of the items in this collection.
         *
         * @param {String} property The name of the property from each item.
         * @param {Number} [begin] The index of the first item to include in the maximum.
         * @param {Number} [end] The index at which to stop in 'items'. The item at this index
         * will *not* be included in the maximum.
         * @return {Object} The item with the maximum of the specified property from the
         * indicated items.
         * @since 5.0.0
         */
        maxItem(property: string, begin?: number, end?: number): any;

        /**
         * See {@link #maxItem}. The result is partitioned by group.
         *
         * @param {String} property The name of the property from each item.
         * @return {Object} The result of {@link #maxItem}, partitioned by group. See {@link #aggregateByGroup}.
         * @since 5.0.0
         */
        maxItemByGroup(property: string): any;

        /**
         * Determines the minimum value for the specified property over some or all of the
         * items in this collection.
         *
         * @param {String} property The name of the property from each item.
         * @param {Number} [begin] The index of the first item to include in the minimum.
         * @param {Number} [end] The index at which to stop in 'items'. The item at this index
         * will *not* be included in the minimum.
         * @return {Object} The minimum of the specified property from the indicated items.
         * @since 5.0.0
         */
        min(property: string, begin?: number, end?: number): any;

        /**
         * See {@link #min}. The result is partitioned by group.
         *
         * @param {String} property The name of the property from each item.
         * @return {Object} The result of {@link #min}, partitioned by group. See {@link #aggregateByGroup}.
         * @since 5.0.0
         */
        minByGroup(property: string): any;

        /**
         * Finds the item with the minimum value for the specified property over some or all
         * of the items in this collection.
         *
         * @param {String} property The name of the property from each item.
         * @param {Number} [begin] The index of the first item to include in the minimum.
         * @param {Number} [end] The index at which to stop in 'items'. The item at this index
         * will *not* be included in the minimum.
         * @return {Object} The item with the minimum of the specified property from the
         * indicated items.
         * @since 5.0.0
         */
        minItem(property: string, begin?: number, end?: number): any;

        /**
         * See {@link #minItem}. The result is partitioned by group.
         *
         * @param {String} property The name of the property from each item.
         * @return {Object} The result of {@link #minItem}, partitioned by group. See {@link #aggregateByGroup}.
         * @since 5.0.0
         */
        minItemByGroup(property: string): any;

        /**
         * Called after a change of the filter is complete.
         *
         * For example:
         *
         *      onFilterChange: function (filters) {
         *          if (this.filtered) {
         *              // process filters
         *          } else {
         *              // no filters present
         *          }
         *      }
         *
         * @param {Ext.util.FilterCollection} filters The filters collection.
         */
        onFilterChange(filters: Ext.util.FilterCollection);

        /**
         * Called after a change of the sort is complete.
         *
         * For example:
         *
         *      onSortChange: function (sorters) {
         *          if (this.sorted) {
         *              // process sorters
         *          } else {
         *              // no sorters present
         *          }
         *      }
         *
         * @param {Ext.util.SorterCollection} sorters The sorters collection.
         */
        onSortChange(sorters: Ext.util.SorterCollection);

        /**
         * Remove an item from the collection.
         * @param {Object/Object[]} item The item or items to remove.
         * @return {Number} The number of items removed.
         * @since 5.0.0
         */
        remove(item: any): number;

        /**
         * Remove all items in the collection.
         * @return {Ext.util.Collection} This object.
         * @since 5.0.0
         */
        removeAll(): Ext.util.Collection;

        /**
         * Remove an item from a specified index in the collection.
         * @param {Number} index The index within the collection of the item to remove.
         * @param {Number} [count=1] The number of items to remove.
         * @return {Object/Number} If 'count' was 1 and the item was removed, that item is
         * returned. Otherwise the number of items removed is returned.
         * @since 5.0.0
         */
        removeAt(index: number, count?: number): any|number;

        /**
         * Removes the item associated with the passed key from the collection.
         * @param {String} key The key of the item to remove.
         * @return {Object} Only returned if removing at a specified key. The item removed or
         * 'false' if no item was removed.
         * @since 5.0.0
         */
        removeByKey(key: string): any;

        /**
         * Adds an item to the collection while removing any existing items. Similar to {@link #method-add}.
         * @param {Object/Object[]} item The item or items to add.
         * @return {Object/Object[]} The item or items added.
         * @since 5.0.0
         */
        replaceAll(item: any): any;

        setAutoFilter();

        setDecoder();

        setDefaultSortDirection();

        setExtraKeys();

        setFilters();

        setGrouper();

        setGroups();

        setMultiSortLimit();

        setRootProperty();

        setSorters();

        setSource();

        /**
         * Updates the sorters collection and triggers sorting of this Sortable.
         *
         * For example:
         *
         *     //sort by a single field
         *     myStore.sort('myField', 'DESC');
         *
         *     //sorting by multiple fields
         *     myStore.sort([{
         *         property : 'age',
         *         direction: 'ASC'
         *     }, {
         *         property : 'name',
         *         direction: 'DESC'
         *     }]);
         *
         * When passing a single string argument to sort, the 'direction' is maintained for
         * each field and is toggled automatically. So this code:
         *
         *     store.sort('myField');
         *     store.sort('myField');
         *
         * Is equivalent to the following:
         *
         *     store.sort('myField', 'ASC');
         *     store.sort('myField', 'DESC');
         *
         * @param {String/Function/Ext.util.Sorter[]} [property] Either the name of a property
         * (such as a field of a 'Ext.data.Model' in a 'Store'), an array of configurations
         * for 'Ext.util.Sorter' instances or just a comparison function.
         * @param {String} [direction] The direction by which to sort the data. This parameter
         * is only valid when 'property' is a String, otherwise the second parameter is the
         * 'mode'.
         * @param {String} [mode="replace"] Where to put new sorters in the collection. This
         * should be one the following values:
         *
         * * '**replace**' : The new sorter(s) become the sole sorter set for this Sortable.
         *   This is the most useful call mode to programmatically sort by multiple fields.
         *
         * * '**prepend**' : The new sorters are inserted as the primary sorters. The sorter
         *   collection length must be controlled by the developer.
         *
         * * '**multi**' : Similar to '**prepend**' the new sorters are inserted at the front
         *   of the collection of sorters. Following the insertion, however, this mode trims
         *   the sorter collection to enforce the 'multiSortLimit' config. This is useful for
         *   implementing intuitive "Sort by this" user interfaces.
         *
         * * '**append**' : The new sorters are added at the end of the collection.
         * @return {Ext.util.Collection} This instance.
         */
        sort(property?: string|Function|Ext.util.Sorter, direction?: string, mode?: string): Ext.util.Collection;

        /**
         * Sorts the collection by a single sorter function
         * @param {Function} sorterFn The function to sort by
         * @deprecated
         */
        sortBy(sorterFn: Function);

        /**
         * This method will sort an array based on the currently configured {@link #sorters}.
         * @param {Array} data The array you want to have sorted.
         * @return {Array} The array you passed after it is sorted.
         */
        sortData(data: any[]): any[];

        /**
         * Sorts the items of the collection using the supplied function. This should only be
         * called for collections that have no 'sorters' defined.
         * @param {Function} sortFn The function by which to sort the items.
         * @since 5.0.0
         */
        sortItems(sortFn: Function);

        /**
         * This method is basically the same as the JavaScript Array splice method.
         *
         * Negative indexes are interpreted starting at the end of the collection. That is,
         * a value of -1 indicates the last item, or equivalent to 'length - 1'.
         *
         * @param {Number} index The index at which to add or remove items.
         * @param {Number/Object[]} toRemove The number of items to remove or an array of the
         * items to remove.
         * @param {Object[]} [toAdd] The items to insert at the given 'index'.
         * @since 5.0.0
         */
        splice(index: number, toRemove: number|any, toAdd?: any);

        /**
         * Sums property values from some or all of the items in this collection.
         *
         * @param {String} property The name of the property to sum from each item.
         * @param {Number} [begin] The index of the first item to include in the sum.
         * @param {Number} [end] The index at which to stop summing 'items'. The item at this
         * index will *not* be included in the sum.
         * @return {Object} The result of summing the specified property from the indicated
         * items.
         * @since 5.0.0
         */
        sum(property: string, begin?: number, end?: number): any;

        /**
         * See {@link #sum}. The result is partitioned by group.
         *
         * @param {String} property The name of the property to sum from each item.
         * @return {Object} The result of {@link #sum}, partitioned by group. See {@link #aggregateByGroup}.
         * @since 5.0.0
         */
        sumByGroup(property: string): any;

        /**
         * This method calls the supplied function 'fn' between 'beginUpdate' and 'endUpdate'
         * calls.
         *
         *      collection.update(function () {
         *          // Perform multiple collection updates...
         *
         *          collection.add(item);
         *          // ...
         *
         *          collection.insert(index, otherItem);
         *          //...
         *
         *          collection.remove(someItem);
         *      });
         *
         * @param {Function} fn The function to call that will modify this collection.
         * @param {Ext.util.Collection} fn.collection This collection.
         * @param {Object} [scope=this] The 'this' pointer to use when calling 'fn'.
         * @return {Object} Returns the value returned from 'fn' (typically 'undefined').
         * @since 5.0.0
         */
        update(fn: Function, fn_collection: Ext.util.Collection, scope?: any): any;

        /**
         * Change the key for an existing item in the collection. If the old key does not
         * exist this call does nothing. Even so, it is highly recommended to *avoid* calling
         * this method for an 'item' that is not a member of this collection.
         *
         * @param {Object} item The item whose key has changed. The 'item' should be a member
         * of this collection.
         * @param {String} oldKey The old key for the 'item'.
         * @since 5.0.0
         */
        updateKey(item: any, oldKey: string);

        /**
         * This event fires before an item change is reflected in the collection. This event
         * is always followed by an 'itemchange' event and, depending on the change, possibly
         * an 'add', 'remove' and/or 'updatekey' event.
         *
         * @param {Ext.util.Collection} collection The collection being modified.
         *
         * @param {Object} details An object describing the change.
         *
         * @param {Object} details.item The item that has changed.
         *
         * @param {String} details.key The key of the item that has changed.
         *
         * @param {Boolean} details.filterChanged This is 'true' if the filter status of the
         * 'item' has changed. That is, the item was previously filtered out and is no longer
         * or the opposite.
         *
         * @param {Boolean} details.keyChanged This is 'true' if the item has changed keys. If
         * so, check 'oldKey' for the old key. An 'updatekey' event will follow.
         *
         * @param {Boolean} details.indexChanged This is 'true' if the item needs to move to
         * a new index in the collection due to sorting. The index can be seen in 'index'.
         * The old index is in 'oldIndex'.
         *
         * @param {String[]} [details.modified] If known this property holds the array of names
         * of the modified properties of the item.
         *
         * @param {Boolean} [details.filtered] This value is 'true' if the item will be filtered
         * out of the collection.
         *
         * @param {Number} [details.index] The new index in the collection for the item if
         * the item is being moved (see 'indexChanged'). If the item is being removed due to
         * filtering, this will be -1.
         *
         * @param {Number} [details.oldIndex] The old index in the collection for the item if
         * the item is being moved (see 'indexChanged'). If the item was being removed due to
         * filtering, this will be -1.
         *
         * @param {Object} [details.oldKey] The old key for the 'item' if the item's key has
         * changed (see 'keyChanged').
         *
         * @param {Boolean} [details.wasFiltered] This value is 'true' if the item was filtered
         * out of the collection.
         *
         * @since 5.0.0
         */
        beforeitemchange(collection: Ext.util.Collection, details: any, details_item: any, details_key: string, details_filterChanged: boolean, details_keyChanged: boolean, details_indexChanged: boolean, details_modified?: string, details_filtered?: boolean, details_index?: number, details_oldIndex?: number, details_oldKey?: any, details_wasFiltered?: boolean);

        /**
         * Fired before changes are made to the collection. This event fires when the
         * 'beginUpdate' method is called and the counter it manages transitions from 0 to 1.
         *
         * All '{@link #event-add add}' and '{@link #event-remove remove}' events occur between
         * '{@link #event-beginupdate beginupdate}' and '{@link #event-endupdate endupdate}'
         * events so it is best to do only the minimal amount of work in response to these
         * events and move the more expensive side-effects to an 'endupdate' listener.
         *
         * @param {Ext.util.Collection} collection The collection being modified.
         *
         * @since 5.0.0
         */
        beginupdate(collection: Ext.util.Collection);

        /**
         * Fired after changes are made to the collection. This event fires when the 'endUpdate'
         * method is called and the counter it manages transitions from 1 to 0.
         *
         * All '{@link #event-add add}' and '{@link #event-remove remove}' events occur between
         * '{@link #event-beginupdate beginupdate}' and '{@link #event-endupdate endupdate}'
         * events so it is best to do only the minimal amount of work in response to these
         * events and move the more expensive side-effects to an 'endupdate' listener.
         *
         * @param {Ext.util.Collection} collection The collection being modified.
         *
         * @since 5.0.0
         */
        endupdate(collection: Ext.util.Collection);

        /**
         * This event fires after an item change is reflected in the collection. This event
         * always follows a 'beforeitemchange' event and its corresponding 'add', 'remove'
         * and/or 'updatekey' events.
         *
         * @param {Ext.util.Collection} collection The collection being modified.
         *
         * @param {Object} details An object describing the change.
         *
         * @param {Object} details.item The item that has changed.
         *
         * @param {String} details.key The key of the item that has changed.
         *
         * @param {Boolean} details.filterChanged This is 'true' if the filter status of the
         * 'item' has changed. That is, the item was previously filtered out and is no longer
         * or the opposite.
         *
         * @param {Object} details.keyChanged This is 'true' if the item has changed keys. If
         * so, check 'oldKey' for the old key. An 'updatekey' event will have been sent.
         *
         * @param {Boolean} details.indexChanged This is 'true' if the item was moved to a
         * new index in the collection due to sorting. The index can be seen in 'index'.
         * The old index is in 'oldIndex'.
         *
         * @param {String[]} [details.modified] If known this property holds the array of names
         * of the modified properties of the item.
         *
         * @param {Boolean} [details.filtered] This value is 'true' if the item is filtered
         * out of the collection.
         *
         * @param {Number} [details.index] The new index in the collection for the item if
         * the item has been moved (see 'indexChanged'). If the item is removed due to
         * filtering, this will be -1.
         *
         * @param {Number} [details.oldIndex] The old index in the collection for the item if
         * the item has been moved (see 'indexChanged'). If the item was being removed due to
         * filtering, this will be -1.
         *
         * @param {Object} [details.oldKey] The old key for the 'item' if the item's key has
         * changed (see 'keyChanged').
         *
         * @param {Boolean} [details.wasFiltered] This value is 'true' if the item was filtered
         * out of the collection.
         *
         * @since 5.0.0
         */
        itemchange(collection: Ext.util.Collection, details: any, details_item: any, details_key: string, details_filterChanged: boolean, details_keyChanged: any, details_indexChanged: boolean, details_modified?: string, details_filtered?: boolean, details_index?: number, details_oldIndex?: number, details_oldKey?: any, details_wasFiltered?: boolean);

        /**
         * This event fires when the collection has changed entirely. This event is fired in
         * cases where the collection's filter is updated or the items are sorted. While the
         * items previously in the collection may remain the same, the order at a minimum has
         * changed in ways that cannot be simply translated to other events.
         *
         * @param {Ext.util.Collection} collection The collection being modified.
         */
        refresh(collection: Ext.util.Collection);

        /**
         * Fires after the key for an item has changed.
         *
         * @param {Ext.util.Collection} collection The collection being modified.
         *
         * @param {Object} details An object describing the update.
         *
         * @param {Object} details.item The item whose key has changed.
         *
         * @param {Object} details.newKey The new key for the 'item'.
         *
         * @param {Object} details.oldKey The old key for the 'item'.
         *
         * @since 5.0.0
         */
        updatekey(collection: Ext.util.Collection, details: any, details_item: any, details_newKey: any, details_oldKey: any);
    }

    interface CollectionKeyConfig {
        /**
         * A function to retrieve the key of an item in the collection. This can be normal
         * function that takes an item and returns the key or it can be the name of the
         * method to call on an item to get the key.
         *
         * For example:
         *
         *      new Ext.util.Collection({
         *          keys: {
         *              byName: {
         *                  keyFn: 'getName' // each item has a "getName" method
         *              }
         *          }
         *      });
         *
         * Or equivalently:
         *
         *      new Ext.util.Collection({
         *          keys: {
         *              byName: {
         *                  keyFn: function (item) {
         *                      return item.getName();
         *                  }
         *              }
         *          }
         *      });
         *
         * @since 5.0.0
         *
         * Optional
         */
        keyFn?: Function|string;

        /**
         * The name of the property on each item that is its key.
         *
         *      new Ext.util.Collection({
         *          keys: {
         *              byName: 'name'
         *          }
         *      });
         *
         * Or equivalently:
         *
         *      new Ext.util.Collection({
         *          keys: {
         *              byName: {
         *                  property: 'name'
         *              }
         *          }
         *      });
         *
         *      var item = collection.byName.get('fooname');
         */
        property?: string;

        /**
         * The name of the sub-object property on each item that is its key. This value
         * overrides '{@link Ext.util.Collection#rootProperty}'.
         *
         *      new Ext.util.Collection({
         *          keys: {
         *              byName: {
         *                  property: 'name',
         *                  rootProperty: 'data'
         *              }
         *          }
         *      });
         *
         *      var item = collection.byName.get('fooname');
         */
        rootProperty?: string;
    }

    /**
     * Maintains an additional key map for an 'Ext.util.Collection'. Instances of this class
     * are seldom created manually. Rather they are created by the 'Ext.util.Collection' when
     * given an 'extraKeys' config.
     *
     * @since 5.0.0
     */
    export class CollectionKey extends Ext.Base implements Ext.util.CollectionKeyConfig {
        /**
         * This property is set by 'Ext.util.Collection' when added via 'extraKeys'.
         * @readonly
         */
        name: string;

        /**
         * A function to retrieve the key of an item in the collection. This can be normal
         * function that takes an item and returns the key or it can be the name of the
         * method to call on an item to get the key.
         *
         * For example:
         *
         *      new Ext.util.Collection({
         *          keys: {
         *              byName: {
         *                  keyFn: 'getName' // each item has a "getName" method
         *              }
         *          }
         *      });
         *
         * Or equivalently:
         *
         *      new Ext.util.Collection({
         *          keys: {
         *              byName: {
         *                  keyFn: function (item) {
         *                      return item.getName();
         *                  }
         *              }
         *          }
         *      });
         *
         * @since 5.0.0
         *
         * Optional
         */
        keyFn: Function|string;

        /**
         * The name of the property on each item that is its key.
         *
         *      new Ext.util.Collection({
         *          keys: {
         *              byName: 'name'
         *          }
         *      });
         *
         * Or equivalently:
         *
         *      new Ext.util.Collection({
         *          keys: {
         *              byName: {
         *                  property: 'name'
         *              }
         *          }
         *      });
         *
         *      var item = collection.byName.get('fooname');
         */
        property: string;

        /**
         * The name of the sub-object property on each item that is its key. This value
         * overrides '{@link Ext.util.Collection#rootProperty}'.
         *
         *      new Ext.util.Collection({
         *          keys: {
         *              byName: {
         *                  property: 'name',
         *                  rootProperty: 'data'
         *              }
         *          }
         *      });
         *
         *      var item = collection.byName.get('fooname');
         */
        rootProperty: string;

        /**
         * Returns the item or, if not 'unique' possibly array of items that have the given
         * key.
         * @param {Mixed} key The key that will match the 'keyFn' return value or value of
         * the specified 'property'.
         * @return {Object}
         */
        get(key: any): any;

        getCollection();

        getKeyFn();

        getProperty();

        getUnique();

        /**
         * Returns the index of the item with the given key in the collection. If this is not
         * a 'unique' result, the index of the first item in the collection with the matching
         * key.
         *
         * To iterate the indices of all items with a matching (not 'unique') key:
         *
         *      for (index = collection.byName.indexOf('foo');
         *              index >= 0;
         *              index = collection.byName.indexOf('foo', index)) {
         *          // process item at "index"
         *      }
         *
         * @param {Mixed} key The key that will match the 'keyFn' return value or value of
         * the specified 'property'.
         * @param {Number} [startAt=-1] The index at which to start. Only occurrences beyond
         * this index are returned.
         * @return {Number} The index of the first item with the given 'key' beyond the given
         * 'startAt' index or -1 if there are no such items.
         */
        indexOf(key: any, startAt?: number): number;

        setCollection();

        setKeyFn();

        setProperty();

        setRootProperty();

        setUnique();

        /**
         * Change the key for an existing item in the collection. If the old key does not
         * exist this call does nothing.
         * @param {Object} item The item whose key has changed.
         * @param {String} oldKey The old key for the 'item'.
         * @since 5.0.0
         */
        updateKey(item: any, oldKey: string);
    }

    /**
     * This class contains utility methods for dealing with CSV (Comma Separated Values) as
     * specified in <a href="http://tools.ietf.org/html/rfc4180">RFC 4180</a>.
     *
     * For details see '{@link Ext.util.DelimitedValue}'.
     *
     * @since 5.1.0
     */
    export class CSV {
        constructor(config: Ext.util.DelimitedValueConfig);
    }

    export class DelayedTask {
        /**
         * The id of the currently pending invocation.  Will be set to 'null' if there is no
         * invocation pending.
         */
        id: number;

        /**
         * Cancel the last queued timeout
         */
        cancel();

        /**
         * The DelayedTask class provides a convenient way to "buffer" the execution of a method,
         * performing setTimeout where a new timeout cancels the old timeout. When called, the
         * task will wait the specified time period before executing. If durng that time period,
         * the task is called again, the original call will be cancelled. This continues so that
         * the function is only called a single time for each iteration.
         *
         * This method is especially useful for things like detecting whether a user has finished
         * typing in a text field. An example would be performing validation on a keypress. You can
         * use this class to buffer the keypress events for a certain number of milliseconds, and
         * perform only if they stop for that amount of time.
         *
         * ## Usage
         *
         *     var task = new Ext.util.DelayedTask(function(){
         *         alert(Ext.getDom('myInputField').value.length);
         *     });
         *
         *     // Wait 500ms before calling our function. If the user presses another key
         *     // during that 500ms, it will be cancelled and we'll wait another 500ms.
         *     Ext.get('myInputField').on('keypress', function() {
         *         task.delay(500);
         *     });
         *
         * Note that we are using a DelayedTask here to illustrate a point. The configuration
         * option 'buffer' for {@link Ext.util.Observable#addListener addListener/on} will
         * also setup a delayed task for you to buffer events.
         *
         * @constructor The parameters to this constructor serve as defaults and are not required.
         * @param {Function} fn (optional) The default function to call. If not specified here, it must be specified during the {@link #delay} call.
         * @param {Object} scope (optional) The default scope (The **'this'** reference) in which the
         * function is called. If not specified, 'this' will refer to the browser window.
         * @param {Array} args (optional) The default Array of arguments.
         * @param {Boolean} [cancelOnDelay=true] By default, each call to {@link #delay} cancels any pending invocation and reschedules a new
         * invocation. Specifying this as 'false' means that calls to {@link #delay} when an invocation is pending just update the call settings,
         * 'newDelay', 'newFn', 'newScope' or 'newArgs', whichever are passed.
         */
        constructor(fn: Function, scope: any, args: any[], cancelOnDelay?: boolean);

        /**
         * By default, cancels any pending timeout and queues a new one.
         *
         * If the 'cancelOnDelay' parameter was specified as 'false' in the constructor, this does not cancel and
         * reschedule, but just updates the call settings, 'newDelay', 'newFn', 'newScope' or 'newArgs', whichever are passed.
         *
         * @param {Number} newDelay The milliseconds to delay
         * @param {Function} newFn (optional) Overrides function passed to constructor
         * @param {Object} newScope (optional) Overrides scope passed to constructor. Remember that if no scope
         * is specified, <code>this</code> will refer to the browser window.
         * @param {Array} newArgs (optional) Overrides args passed to constructor
         */
        delay(newDelay: number, newFn: Function, newScope: any, newArgs: any[]);
    }

    interface DelimitedValueConfig {
        /**
         * The {@link Ext.Date#format format} to use for dates
         */
        dateFormat?: string;

        /**
         * The string used to separate the values in a row. Common values for this config
         * are comma (",") and tab ("\t"). See '{@link Ext.util.CSV}' and  '{@link Ext.util.TSV}'
         * for pre-configured instances of these formats.
         */
        delimiter?: string;

        /**
         * The string used by '{@link #encode}' to separate each row. The '{@link #decode}'
         * method accepts all forms of line break.
         */
        lineBreak?: string;

        /**
         * The character to use as to quote values that contain the special 'delimiter'
         * or '{@link #lineBreak}' characters.
         */
        quote?: string;
    }

    /**
     * This base class contains utility methods for dealing with formats such as CSV (Comma
     * Separated Values) as specified in <a href="http://tools.ietf.org/html/rfc4180">RFC 4180</a>.
     *
     * The base class implements the mechanics and is governed by these config options:
     *
     *  * '{@link #delimiter}'
     *  * '{@link #lineBreak}'
     *  * '{@link #quote}'
     *
     * These options affect the '{@link #method-encode}' and '{@link #method-decode}' methods.
     * When *decoding*, however, '{@link #lineBreak}' is ignored and instead each line can
     * be separated by any standard line terminator character or character sequence:
     *
     *  * '''\u000a'''
     *  * '''\u000d'''
     *  * '''\u000d\u000a'''
     *
     * Strings which contain the {@link #delimiter} character are quoted using the
     * {@link #quote} character, and any internal {@link #quote} characters are doubled.
     *
     * *Important*
     * While the primary use case is to encode strings, other atomic data types can be encoded
     * as values within a line such as:
     *
     *  * Number
     *  * Boolean
     *  * Date (encoded as an <a href="http://www.iso.org/iso/home/standards/iso8601.htm">ISO 8601</a> date string.)
     *  * null (encoded as an empty string.)
     *  * undefined (encoded as an empty string.)
     *
     * Not that when *decoding*, all data is read as strings. This class does not convert
     * incoming data. To do that, use an {@link Ext.data.reader.Array ArrayReader}.
     *
     * See '{@link Ext.util.CSV}' and  '{@link Ext.util.TSV}' for pre-configured instances.
     *
     * @since 5.1.0
     */
    export class DelimitedValue extends Ext.Base implements Ext.util.DelimitedValueConfig {
        /**
         * The {@link Ext.Date#format format} to use for dates
         */
        dateFormat: string;

        /**
         * The string used to separate the values in a row. Common values for this config
         * are comma (",") and tab ("\t"). See '{@link Ext.util.CSV}' and  '{@link Ext.util.TSV}'
         * for pre-configured instances of these formats.
         */
        delimiter: string;

        /**
         * The string used by '{@link #encode}' to separate each row. The '{@link #decode}'
         * method accepts all forms of line break.
         */
        lineBreak: string;

        /**
         * The character to use as to quote values that contain the special 'delimiter'
         * or '{@link #lineBreak}' characters.
         */
        quote: string;

        constructor(config: Ext.util.DelimitedValueConfig);

        /**
         * Decodes a string of encoded values into an array of rows. Each row is an array of
         * strings.
         *
         * Note that this function does not convert the string values in each column into
         * other data types. To do that, use an {@link Ext.data.reader.Array ArrayReader}.
         *
         * For example:
         *
         *     Ext.util.CSV.decode('"foo ""bar"", bletch",Normal String,2010-01-01T21:45:32.004Z\u000a3.141592653589793,1,false');
         *
         * produces the following array of string arrays:
         *
         *     [
         *         ['foo "bar", bletch','Normal String', '2010-01-01T21:45:32.004Z'],
         *         ['3.141592653589793', '1', 'false']
         *     ]
         *
         * @param {String} input The string to parse.
         *
         * @param {String} [delimiter] The column delimiter to use if the default value
         * of {@link #cfg-delimiter delimiter} is not desired.
         *
         * @return {String[][]} An array of rows where each row is an array of Strings.
         */
        decode(input: string, delimiter?: string): string;

        /**
         * Converts a two-dimensional array into an encoded string.
         *
         * For example:
         *
         *     Ext.util.CSV.encode([
         *         ['foo "bar", bletch', 'Normal String', new Date()],
         *         [Math.PI, 1, false]
         *     ]);
         *
         * The above produces the following string:
         *
         *     '"foo ""bar"", bletch",Normal String,2010-01-01T21:45:32.004Z\u000a3.141592653589793,1,false'
         *
         * @param {Mixed[][]} input An array of row data arrays.
         *
         * @param {String} [delimiter] The column delimiter to use if the default value
         * of {@link #cfg-delimiter delimiter} is not desired.
         *
         * @return {String} A string in which data items are separated by {@link #delimiter}
         * characters, and rows are separated by {@link #lineBreak} characters.
         */
        encode(input: any, delimiter?: string): string;
    }

    interface DraggableConfig {
        /**
         * Possible values: 'vertical', 'horizontal', or 'both'
         */
        direction?: string;

        /**
         * The initial draggable offset.  When specified as Number,
         * both x and y will be set to that value.
         */
        initialOffset?: any|number;
    }

    /**
     * A core util class to bring Draggable behavior to a Component. This class is specifically designed only for
     * absolutely positioned elements starting from top: 0, left: 0. The initialOffset can then be set via configuration
     * to have the elements in a different position.
     */
    export class Draggable extends Ext.Base implements Ext.util.DraggableConfig {
        /**
         * Possible values: 'vertical', 'horizontal', or 'both'
         */
        direction: string;

        /**
         * The initial draggable offset.  When specified as Number,
         * both x and y will be set to that value.
         */
        initialOffset: any|number;

        /**
         * Creates new Draggable.
         * @param {Object} config The configuration object for this Draggable.
         */
        constructor(config: Ext.util.DraggableConfig);

        destroy();

        /**
         * Disable the Draggable.
         * @return {Ext.util.Draggable} This Draggable instance
         */
        disable(): Ext.util.Draggable;

        /**
         * Enable the Draggable.
         * @return {Ext.util.Draggable} This Draggable instance
         */
        enable(): Ext.util.Draggable;

        getCls();

        getConstraint();

        getDirection();

        getDisabled();

        getDraggingCls();

        getElement();

        getInitialOffset();

        getTranslatable();

        setCls();

        setConstraint();

        setDirection();

        setDisabled();

        setDraggingCls();

        setElement();

        setInitialOffset();

        setTranslatable();

        /**
         * Fires whenever the component is dragged
         * @param {Ext.event.Event} e the event object
         * @param {Number} offsetX The new offset value on the x axis
         * @param {Number} offsetY The new offset value on the y axis
         */
        drag(that: Ext.util.Draggable, e: Ext.event.Event, offsetX: number, offsetY: number);

        /**
         * Fires whenever the component is dragged
         * @param {Ext.event.Event} e the event object
         * @param {Number} offsetX The current offset value on the x axis
         * @param {Number} offsetY The current offset value on the y axis
         */
        dragend(that: Ext.util.Draggable, e: Ext.event.Event, offsetX: number, offsetY: number);

        /**
         * Fires whenever the component starts to be dragged
         * @param {Ext.event.Event} e the event object
         * @param {Number} offsetX The current offset value on the x axis
         * @param {Number} offsetY The current offset value on the y axis
         */
        dragstart(that: Ext.util.Draggable, e: Ext.event.Event, offsetX: number, offsetY: number);
    }

    interface DroppableConfig {
        /**
         * The CSS added to a Droppable when a Draggable in the same group is being
         * dragged.
         */
        activeCls?: string;

        /**
         * The base CSS class to apply to this component's element.
         * This will also be prepended to other elements within this component.
         */
        baseCls?: any;

        disabled?: boolean;

        /**
         * Draggable and Droppable objects can participate in a group which are
         * capable of interacting.
         */
        group?: string;

        /**
         * The CSS class to add to the droppable when hovering over a valid drop.
         */
        hoverCls?: string;

        /**
         * The CSS class to add to the droppable when dragging a draggable that is
         * not in the same group.
         */
        invalidCls?: string;

        /**
         * Determines when a drop is considered 'valid' whether it simply need to
         * intersect the region or if it needs to be contained within the region.
         * Valid values are: 'intersects' or 'contains'
         */
        validDropMode?: string;
    }

    export class Droppable extends Ext.Base implements Ext.util.DroppableConfig {
        /**
         * The CSS added to a Droppable when a Draggable in the same group is being
         * dragged.
         */
        activeCls: string;

        /**
         * The base CSS class to apply to this component's element.
         * This will also be prepended to other elements within this component.
         */
        baseCls: any;

        disabled: boolean;

        /**
         * Draggable and Droppable objects can participate in a group which are
         * capable of interacting.
         */
        group: string;

        /**
         * The CSS class to add to the droppable when hovering over a valid drop.
         */
        hoverCls: string;

        /**
         * The CSS class to add to the droppable when dragging a draggable that is
         * not in the same group.
         */
        invalidCls: string;

        /**
         * Determines when a drop is considered 'valid' whether it simply need to
         * intersect the region or if it needs to be contained within the region.
         * Valid values are: 'intersects' or 'contains'
         */
        validDropMode: string;

        /**
         * Creates new Droppable.
         * @param {Mixed} el String, HtmlElement or Ext.Element representing an
         * element on the page.
         * @param {Object} config Configuration options for this class.
         */
        constructor(el: any, config: Ext.util.DroppableConfig);

        /**
         * Disable the Droppable target.
         */
        disable();

        /**
         * Enable the Droppable target.
         * This is invoked immediately after constructing a Droppable if the
         * disabled parameter is NOT set to true.
         */
        enable();

        getBaseCls();

        /**
         * Method to determine whether this Component is currently disabled.
         * @return {Boolean} the disabled state of this Component.
         */
        isDisabled(): boolean;

        /**
         * Method to determine whether this Droppable is currently monitoring drag operations of Draggables.
         * @return {Boolean} the monitoring state of this Droppable
         */
        isMonitoring(): boolean;

        setBaseCls();

        drop(that: Ext.util.Droppable, draggable: Ext.util.Draggable, e: Ext.event.Event);

        dropactivate(that: Ext.util.Droppable, draggable: Ext.util.Draggable, e: Ext.event.Event);

        dropdeactivate(that: Ext.util.Droppable, draggable: Ext.util.Draggable, e: Ext.event.Event);

        dropenter(that: Ext.util.Droppable, draggable: Ext.util.Draggable, e: Ext.event.Event);

        dropleave(that: Ext.util.Droppable, draggable: Ext.util.Draggable, e: Ext.event.Event);
    }

    /**
     * Represents single event type that an Observable object listens to.
     * All actual listeners are tracked inside here.  When the event fires,
     * it calls all the registered listener functions.
     */
    export class Event extends Ext.Base {
        /**
         * 'true' in this class to identify an object as an instantiated Event, or subclass thereof.
         */
        isEvent: boolean;
    }

    export class FilterCollection extends Ext.util.Collection {
        /**
         * This is the cached filter function.
         * @readonly
         */
        filterFn: any;

        constructor(config: any);

        /**
         * This method will filter an array based on the currently configured 'filters'.
         * @param {Array} data The array you want to have filtered.
         * @return {Array} The array you passed after it is filtered.
         */
        filterData(data: any[]): any[];

        /**
         * Returns the filter function.
         * @return {Function} The filter function.
         */
        getFilterFn(): Function;
    }

    interface FilterConfig {
        /**
         * True to allow any match - no regex start/end line anchors will be added.
         */
        anyMatch?: boolean;

        /**
         * True to make the regex case sensitive (adds 'i' switch to regex).
         *
         * Optional, Defaults to: false
         */
        caseSensitive?: boolean;

        /**
         * 'true' to not have this filter participate in the filtering process when the {@link #value} of
         * this the filter is empty according to {@link Ext#isEmpty}.
         *
         * @since 5.1.0
         */
        disableOnEmpty?: boolean;

        /**
         * Setting this property to 'true' disables this individual Filter so that it no longer contributes to a {@link Ext.data.Store#cfg-filters Store's filter set}
         *
         * When disabled, the next time the store is filtered, the Filter plays no part in filtering and records eliminated by it may rejoin the dataset.
         */
        disabled?: boolean;

        /**
         * True to force exact match (^ and $ characters added to the regex). Ignored if anyMatch is true.
         *
         * Optional, Defaults to: false
         */
        exactMatch?: boolean;

        /**
         * A custom filter function which is passed each item in the {@link Ext.util.MixedCollection} in turn. Should return
         * 'true' to accept each item or 'false' to reject it.
         */
        filterFn?: Function;

        /**
         * An identifier by which this Filter is indexed in a {@link Ext.data.Store#cfg-filters Store's filters collection}
         *
         * Identified Filters may be individually removed from a Store's filter set by using {@link Ext.data.Store#removeFilter}.
         *
         * Anonymous Filters may be removed en masse by passing 'null' to {@link Ext.data.Store#removeFilter}.
         *
         * Optional
         */
        id?: string;

        /**
         * The operator to use to compare the {@link #cfg-property} to this Filter's {@link #cfg-value}
         *
         * Possible values are:
         *
         *    * '<'
         *    * '<='
         *    * '='
         *    * '>='
         *    * '>'
         *    * '!='
         *    * 'in'
         *    * 'notin'
         *    * 'like'
         *    * /=
         *
         * The 'in' and 'notin' operator expects this filter's {@link #cfg-value} to be an array and matches
         * values that are present in that array.
         *
         * The 'like' operator matches values that contain this filter's {@link #cfg-value} as a
         * substring.
         *
         * The ''*='' operator uses the {@link #cfg-value} as the source for a 'RegExp' and tests whether the
         * candidate value matches the regular expression.
         *
         * Optional
         */
        operator?: string;

        /**
         * The property to filter on. Required unless a {@link #filterFn} is passed.
         *
         * Optional, Defaults to: null
         */
        property?: string;

        /**
         * Optional root property. This is mostly useful when filtering a Store, in which case we set the root to 'data' to
         * make the filter pull the {@link #property} out of the data object of each item
         *
         * Optional, Defaults to: null
         */
        root?: string;

        /**
         * The context ('this' property) in which the filtering function is called. Defaults
         * to this Filter object.
         *
         * Optional
         */
        scope?: any;

        /**
         * The value you want to match against. Required unless a {@link #filterFn} is passed.
         *
         * Can be a regular expression which will be used as a matcher or any other value
         * such as an object or an array of objects. This value is compared using the configured
         * {@link #operator}.
         *
         * Optional, Defaults to: null
         */
        value?: RegExp|any;
    }

    /**
     * Represents a filter that can be applied to a {@link Ext.util.MixedCollection MixedCollection}. Can either simply
     * filter on a property/value pair or pass in a filter function with custom logic. Filters are always used in the
     * context of MixedCollections, though {@link Ext.data.Store Store}s frequently create them when filtering and searching
     * on their records. Example usage:
     *
     *     // Set up a fictional MixedCollection containing a few people to filter on
     *     var allNames = new Ext.util.MixedCollection();
     *     allNames.addAll([
     *         { id: 1, name: 'Peter',  age: 25 },
     *         { id: 2, name: 'Egon',   age: 37 },
     *         { id: 3, name: 'Ray',    age: 32 },
     *         { id: 4, name: 'Winston',age: 26 }
     *     ]);
     *
     *     var ageFilter = new Ext.util.Filter({
     *         property: 'age',
     *         value   : 32
     *     });
     *
     *     var longNameFilter = new Ext.util.Filter({
     *         filterFn: function(item) {
     *             return item.name.length > 4;
     *         }
     *     });
     *
     *     // a new MixedCollection with the 3 names longer than 4 characters
     *     var longNames = allNames.filter(longNameFilter);
     *
     *     // a new MixedCollection with the 2 people of age 32:
     *     var youngFolk = allNames.filter(ageFilter);
     */
    export class Filter extends Ext.Base implements Ext.util.FilterConfig {
        /**
         * True to allow any match - no regex start/end line anchors will be added.
         */
        anyMatch: boolean;

        /**
         * True to make the regex case sensitive (adds 'i' switch to regex).
         *
         * Optional, Defaults to: false
         */
        caseSensitive: boolean;

        /**
         * Setting this property to 'true' disables this individual Filter so that it no longer contributes to a {@link Ext.data.Store#cfg-filters Store's filter set}
         *
         * When disabled, the next time the store is filtered, the Filter plays no part in filtering and records eliminated by it may rejoin the dataset.
         */
        disabled: boolean;

        /**
         * 'true' to not have this filter participate in the filtering process when the {@link #value} of
         * this the filter is empty according to {@link Ext#isEmpty}.
         *
         * @since 5.1.0
         */
        disableOnEmpty: boolean;

        /**
         * True to force exact match (^ and $ characters added to the regex). Ignored if anyMatch is true.
         *
         * Optional, Defaults to: false
         */
        exactMatch: boolean;

        /**
         * A custom filter function which is passed each item in the {@link Ext.util.MixedCollection} in turn. Should return
         * 'true' to accept each item or 'false' to reject it.
         */
        filterFn: Function;

        /**
         * An identifier by which this Filter is indexed in a {@link Ext.data.Store#cfg-filters Store's filters collection}
         *
         * Identified Filters may be individually removed from a Store's filter set by using {@link Ext.data.Store#removeFilter}.
         *
         * Anonymous Filters may be removed en masse by passing 'null' to {@link Ext.data.Store#removeFilter}.
         *
         * Optional
         */
        id: string;

        /**
         * The operator to use to compare the {@link #cfg-property} to this Filter's {@link #cfg-value}
         *
         * Possible values are:
         *
         *    * '<'
         *    * '<='
         *    * '='
         *    * '>='
         *    * '>'
         *    * '!='
         *    * 'in'
         *    * 'notin'
         *    * 'like'
         *    * /=
         *
         * The 'in' and 'notin' operator expects this filter's {@link #cfg-value} to be an array and matches
         * values that are present in that array.
         *
         * The 'like' operator matches values that contain this filter's {@link #cfg-value} as a
         * substring.
         *
         * The ''*='' operator uses the {@link #cfg-value} as the source for a 'RegExp' and tests whether the
         * candidate value matches the regular expression.
         *
         * Optional
         */
        operator: string;

        /**
         * The property to filter on. Required unless a {@link #filterFn} is passed.
         *
         * Optional, Defaults to: null
         */
        property: string;

        /**
         * Optional root property. This is mostly useful when filtering a Store, in which case we set the root to 'data' to
         * make the filter pull the {@link #property} out of the data object of each item
         *
         * Optional, Defaults to: null
         */
        root: string;

        /**
         * The context ('this' property) in which the filtering function is called. Defaults
         * to this Filter object.
         *
         * Optional
         */
        scope: any;

        /**
         * The value you want to match against. Required unless a {@link #filterFn} is passed.
         *
         * Can be a regular expression which will be used as a matcher or any other value
         * such as an object or an array of objects. This value is compared using the configured
         * {@link #operator}.
         *
         * Optional, Defaults to: null
         */
        value: RegExp|any;

        /**
         * Creates new Filter.
         * @param {Object} config Config object
         */
        constructor(config: Ext.util.FilterConfig);

        getAnyMatch();

        getCaseSensitive();

        getDisabled();

        getDisableOnEmpty();

        getExactMatch();

        getOperator();

        getProperty();

        getRoot();

        /**
         * Returns this filter's state.
         * @return {Object}
         */
        getState(): any;

        getValue();

        /**
         * Returns this filter's serialized state. This is used when transmitting this filter
         * to a server.
         * @return {Object}
         */
        serialize(): any;

        setAnyMatch();

        setCaseSensitive();

        setDisabled();

        setDisableOnEmpty();

        setExactMatch();

        setFilterFn();

        setId();

        setOperator();

        setProperty();

        setRoot();

        setValue();

        /**
         * Creates a single filter function which encapsulates the passed Filter array or
         * Collection.
         * @param {Ext.util.Filter[]/Ext.util.Collection} filters The filters from which to
         * create a filter function.
         * @return {Function} A function, which when passed a candidate object returns 'true'
         * if the candidate passes all the specified Filters.
         */
        static createFilterFn(filters: Ext.util.Filter|Ext.util.Collection): Function;
    }

    /**
     * This class is a centralized place for formatting functions. It includes
     * functions to format various different types of data, such as text, dates and numeric values.
     *
     * ## Localization
     *
     * This class contains several options for localization. These can be set once the library has loaded,
     * all calls to the functions from that point will use the locale settings that were specified.
     *
     * Options include:
     *
     * - thousandSeparator
     * - decimalSeparator
     * - currenyPrecision
     * - currencySign
     * - currencyAtEnd
     *
     * This class also uses the default date format defined here: {@link Ext.Date#defaultFormat}.
     *
     * ## Using with renderers
     *
     * There are two helper functions that return a new function that can be used in conjunction with
     * grid renderers:
     *
     *     columns: [{
     *         dataIndex: 'date',
     *         renderer: Ext.util.Format.dateRenderer('Y-m-d')
     *     }, {
     *         dataIndex: 'time',
     *         renderer: Ext.util.Format.numberRenderer('0.000')
     *     }]
     *
     * Functions that only take a single argument can also be passed directly:
     *
     *     columns: [{
     *         dataIndex: 'cost',
     *         renderer: Ext.util.Format.usMoney
     *     }, {
     *         dataIndex: 'productCode',
     *         renderer: Ext.util.Format.uppercase
     *     }]
     *
     * ## Using with XTemplates
     *
     * XTemplates can also directly use Ext.util.Format functions:
     *
     *     new Ext.XTemplate([
     *         'Date: {startDate:date("Y-m-d")}',
     *         'Cost: {cost:usMoney}'
     *     ]);
     */
    export class Format {
        /**
         * This may be set to <code>true</code> to make the {@link #currency} function
         * append the currency sign to the formatted value.
         *
         * This may be overridden in a locale file.
         */
        static currencyAtEnd: boolean;

        /**
         * The number of decimal places that the {@link #currency} function displays.
         *
         * This may be overridden in a locale file.
         */
        static currencyPrecision: number;

        /**
         * The currency sign that the {@link #currency} function displays.
         *
         * This may be overridden in a locale file.
         */
        static currencySign: string;

        /**
         * The character that the {@link #number} function uses as a decimal point.
         *
         * This may be overridden in a locale file.
         */
        static decimalSeparator: string;

        /**
         * The global default date format.
         */
        static defaultDateFormat: any;

        /**
         * The percent sign that the {@link #percent} function displays.
         *
         * This may be overridden in a locale file.
         */
        static percentSign: string;

        /**
         * The character that the {@link #number} function uses as a thousand separator.
         *
         * This may be overridden in a locale file.
         */
        static thousandSeparator: string;

        /**
         * Formats an object of name value properties as HTML element attribute values suitable for using when creating textual markup.
         * @param {Object} attributes An object containing the HTML attributes as properties eg: '{height:40, vAlign:'top'}'
         */
        static attributes(attributes: any);

        /**
         * Alias for {@link Ext.String#capitalize}.
         */
        static capitalize();

        /**
         * Format a number as a currency.
         * @param {Number/String} value The numeric value to format
         * @param {String} [sign] The currency sign to use (defaults to {@link #currencySign})
         * @param {Number} [decimals] The number of decimals to use for the currency
         * (defaults to {@link #currencyPrecision})
         * @param {Boolean} [end] True if the currency sign should be at the end of the string
         * (defaults to {@link #currencyAtEnd})
         * @return {String} The formatted currency string
         */
        static currency(value: number|string, sign?: string, decimals?: number, end?: boolean): string;

        /**
         * Formats the passed date using the specified format pattern.
         * Note that this uses the native Javascript Date.parse() method and is therefore subject to its idiosyncrasies.
         * Most formats assume the local timezone unless specified. One notable exception is 'YYYY-MM-DD' (note the dashes)
         * which is typically interpreted in UTC and can cause date shifting.
         *
         * @param {String/Date} value The value to format. Strings must conform to the format
         * expected by the JavaScript Date object's
         * [parse() method](http://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/parse).
         * @param {String} [format] Any valid date format string. Defaults to {@link Ext.Date#defaultFormat}.
         * @return {String} The formatted date string.
         */
        static date(value: string|Date, format?: string): string;

        /**
         * Returns a date rendering function that can be reused to apply a date format multiple times efficiently.
         * @param {String} format Any valid date format string. Defaults to {@link Ext.Date#defaultFormat}.
         * @return {Function} The date formatting function
         */
        static dateRenderer(format: string): Function;

        /**
         * Checks a reference and converts it to the default value if it's empty.
         * @param {Object} value Reference to check
         * @param {String} [defaultValue=""] The value to insert of it's undefined.
         * @return {String}
         */
        static defaultValue(value: any, defaultValue?: string): string;

        /**
         * Alias for {@link Ext.String#ellipsis}.
         */
        static ellipsis();

        /**
         * Alias for {@link Ext.String#escape}.
         */
        static escape();

        /**
         * Alias for {@link Ext.String#escapeRegex}.
         */
        static escapeRegex();

        /**
         * Simple format for a file size (xxx bytes, xxx KB, xxx MB).
         * @param {Number/String} size The numeric value to format
         * @return {String} The formatted file size
         */
        static fileSize(size: number|string): string;

        /**
         * Alias for {@link Ext.String#format}.
         */
        static format();

        /**
         * Returns the given number as a base 16 string at least 'digits' in length. If
         * the number is fewer digits, 0's are prepended as necessary. If 'digits' is
         * negative, the absolute value is the *exact* number of digits to return. In this
         * case, if then number has more digits, only the least significant digits are
         * returned.
         *
         *      expect(Ext.util.Format.hex(0x12e4, 2)).toBe('12e4');
         *      expect(Ext.util.Format.hex(0x12e4, -2)).toBe('e4');
         *      expect(Ext.util.Format.hex(0x0e, 2)).toBe('0e');
         *
         * @param {Number} value The number to format in hex.
         * @return {string}
         */
        static hex(value: number, digits: number): string;

        /**
         * Alias for {@link Ext.String#htmlDecode}.
         */
        static htmlDecode();

        /**
         * Alias for {@link Ext.String#htmlEncode}.
         */
        static htmlEncode();

        /**
         * Alias for {@link Ext.String#leftPad}.
         */
        static leftPad();

        /**
         * Converts a string to all lower case letters.
         * @param {String} value The text to convert
         * @return {String} The converted text
         */
        static lowercase(value: string): string;

        /**
         * It does simple math for use in a template, for example:
         *
         *     var tpl = new Ext.Template('{value} * 10 = {value:math("* 10")}');
         *
         * @return {Function} A function that operates on the passed value.
         */
        static math(): Function;

        /**
         * Converts newline characters to the HTML tag '<br/>'
         *
         * @param {String} v The string value to format.
         * @return {String} The string with embedded '<br/>' tags in place of newlines.
         */
        static nl2br(v: string): string;

        /**
         * Formats the passed number according to the passed format string.
         *
         * The number of digits after the decimal separator character specifies the number of
         * decimal places in the resulting string. The *local-specific* decimal character is
         * used in the result.
         *
         * The *presence* of a thousand separator character in the format string specifies that
         * the *locale-specific* thousand separator (if any) is inserted separating thousand groups.
         *
         * By default, "," is expected as the thousand separator, and "." is expected as the decimal separator.
         *
         * Locale-specific characters are always used in the formatted output when inserting
         * thousand and decimal separators. These can be set using the {@link #thousandSeparator} and
         * {@link #decimalSeparator} options.
         *
         * The format string must specify separator characters according to US/UK conventions ("," as the
         * thousand separator, and "." as the decimal separator)
         *
         * To allow specification of format strings according to local conventions for separator characters, add
         * the string '/i' to the end of the format string. This format depends on the {@link #thousandSeparator} and
         * {@link #decimalSeparator} options. For example, if using European style separators, then the format string
         * can be specified as ''0.000,00''. This would be equivalent to using ''0,000.00'' when using US style formatting.
         *
         * Examples (123456.789):
         *
         * - '0' - (123457) show only digits, no precision
         * - '0.00' - (123456.79) show only digits, 2 precision
         * - '0.0000' - (123456.7890) show only digits, 4 precision
         * - '0,000' - (123,457) show comma and digits, no precision
         * - '0,000.00' - (123,456.79) show comma and digits, 2 precision
         * - '0,0.00' - (123,456.79) shortcut method, show comma and digits, 2 precision
         * - '0.####' - (123,456.789) Allow maximum 4 decimal places, but do not right pad with zeroes
         * - '0.00##' - (123456.789) Show at least 2 decimal places, maximum 4, but do not right pad with zeroes
         *
         * @param {Number} v The number to format.
         * @param {String} formatString The way you would like to format this text.
         * @return {String} The formatted number.
         */
        static number(v: number, formatString: string): string;

        /**
         * Returns a number rendering function that can be reused to apply a number format multiple
         * times efficiently.
         *
         * @param {String} format Any valid number format string for {@link #number}
         * @return {Function} The number formatting function
         */
        static numberRenderer(format: string): Function;

        /**
         * Returns this result:
         *
         *      value || orValue
         *
         * The usefulness of this formatter method is in templates. For example:
         *
         *      {foo:or("bar")}
         *
         * @param {Boolean} value The "if" value.
         */
        static or(value: boolean, orValue: any);

        /**
         * Parses a number or string representing margin sizes into an object.
         * Supports CSS-style margin declarations (e.g. 10, "10", "10 10", "10 10 10" and
         * "10 10 10 10" are all valid options and would return the same result).
         *
         * @param {Number/String} box The encoded margins
         * @return {Object} An object with margin sizes for top, right, bottom and left
         */
        static parseBox(box: number|string): any;

        /**
         * Formats the passed number as a percentage according to the passed format string.
         * The number should be between 0 and 1 to represent 0% to 100%.
         *
         * @param {Number} value The percentage to format.
         * @param {String} [formatString="0"] See {@link #number} for details.
         * @return {String} The formatted percentage.
         */
        static percent(value: number, formatString?: string): string;

        /**
         * If 'value' is a number, returns the argument from that index. For example
         *
         *      var s = Ext.util.Format.pick(2, 'zero', 'one', 'two');
         *      // s === 'two'
         *
         * Otherwise, 'value' is treated in a truthy/falsey manner like so:
         *
         *      var s = Ext.util.Format.pick(null, 'first', 'second');
         *      // s === 'first'
         *
         *      s = Ext.util.Format.pick({}, 'first', 'second');
         *      // s === 'second'
         *
         * The usefulness of this formatter method is in templates. For example:
         *
         *      {foo:pick("F","T")}
         *
         *      {bar:pick("first","second","third")}
         *
         * @param {Boolean} value The "if" value.
         */
        static pick(value: boolean, firstValue: any, secondValue: any);

        /**
         * Selectively return the plural form of a word based on a numeric value.
         *
         * For example, the following template would result in "1 Comment".  If the
         * value of 'count' was 0 or greater than 1, the result would be "x Comments".
         *
         *     var tpl = new Ext.XTemplate('{count:plural("Comment")}');
         *
         *     tpl.apply({
         *         count: 1
         *     }); // returns "1 Comment"
         *
         * Examples using the static 'plural' method call:
         *
         *     Ext.util.Format.plural(2, 'Comment');
         *     // returns "2 Comments"
         *
         *     Ext.util.Format.plural(4, 'person', 'people');
         *     // returns "4 people"
         *
         * @param {Number} value The value to compare against
         * @param {String} singular The singular form of the word
         * @param {String} [plural] The plural form of the word (defaults to the
         * singular form with an "s" appended)
         * @return {String} output The pluralized output of the passed singular form
         */
        static plural(value: number, singular: string, plural?: string): string;

        /**
         * Rounds the passed number to the required decimal precision.
         * @param {Number/String} value The numeric value to round.
         * @param {Number} [precision] The number of decimal places to which to round the
         * first parameter's value. If 'undefined' the 'value' is passed to 'Math.round'
         * otherwise the value is returned unmodified.
         * @return {Number} The rounded value.
         */
        static round(value: number|string, precision?: number): number;

        /**
         * Strips all script tags.
         * @param {Object} value The text from which to strip script tags
         * @return {String} The stripped text
         */
        static stripScripts(value: any): string;

        /**
         * Strips all HTML tags.
         * @param {Object} value The text from which to strip tags
         * @return {String} The stripped text
         */
        static stripTags(value: any): string;

        /**
         * Returns a substring from within an original string.
         * @param {String} value The original text
         * @param {Number} start The start index of the substring
         * @param {Number} length The length of the substring
         * @return {String} The substring
         */
        static substr(value: string, start: number, length: number): string;

        /**
         * Alias for {@link Ext.String#toggle}.
         */
        static toggle();

        /**
         * Alias for {@link Ext.String#trim}.
         */
        static trim();

        /**
         * Alias for {@link Ext.String#uncapitalize}.
         */
        static uncapitalize();

        /**
         * Checks a reference and converts it to empty string if it is undefined.
         * @param {Object} value Reference to check
         * @return {Object} Empty string if converted, otherwise the original value
         */
        static undef(value: any): any;

        /**
         * Converts a string to all upper case letters.
         * @param {String} value The text to convert
         * @return {String} The converted text
         */
        static uppercase(value: string): string;

        /**
         * Format a number as US currency.
         * @param {Number/String} value The numeric value to format
         * @return {String} The formatted currency string
         */
        static usMoney(value: number|string): string;
    }

    interface GeolocationConfig {
        /**
         * Read-only property representing the last retrieved
         * accuracy level of the latitude and longitude coordinates,
         * specified in meters.
         *
         * This will always be a non-negative number.
         *
         * This corresponds to a 95% confidence level.
         * @readonly
         */
        accuracy?: number;

        /**
         * When set to 'true', provide a hint that the application would like to receive
         * the best possible results. This may result in slower response times or increased power consumption.
         * The user might also deny this capability, or the device might not be able to provide more accurate
         * results than if this option was set to 'false'.
         */
        allowHighAccuracy?: boolean;

        /**
         * Read-only property representing the last retrieved
         * height of the position, specified in meters above the ellipsoid
         * [WGS84](http://dev.w3.org/geo/api/spec-source.html#ref-wgs).
         * @readonly
         */
        altitude?: number;

        /**
         * Read-only property representing the last retrieved
         * accuracy level of the altitude coordinate, specified in meters.
         *
         * If altitude is not null then this will be a non-negative number.
         * Otherwise this returns 'null'.
         *
         * This corresponds to a 95% confidence level.
         * @readonly
         */
        altitudeAccuracy?: number;

        /**
         * When set to 'true', continually monitor the location of the device (beginning immediately)
         * and fire {@link #locationupdate} and {@link #locationerror} events.
         */
        autoUpdate?: boolean;

        /**
         * The frequency of each update if {@link #autoUpdate} is set to 'true'.
         */
        frequency?: number;

        /**
         * Read-only property representing the last retrieved
         * direction of travel of the hosting device,
         * specified in non-negative degrees between 0 and 359,
         * counting clockwise relative to the true north.
         *
         * If speed is 0 (device is stationary), then this returns 'NaN'.
         * @readonly
         */
        heading?: number;

        /**
         * Read-only property representing the last retrieved
         * geographical coordinate specified in degrees.
         * @readonly
         */
        latitude?: number;

        /**
         * Read-only property representing the last retrieved
         * geographical coordinate specified in degrees.
         * @readonly
         */
        longitude?: number;

        /**
         * This option indicates that the application is willing to accept cached location information whose age
         * is no greater than the specified time in milliseconds. If 'maximumAge' is set to 0, an attempt to retrieve
         * new location information is made immediately.
         *
         * Setting the 'maximumAge' to Infinity returns a cached position regardless of its age.
         *
         * If the device does not have cached location information available whose age is no
         * greater than the specified 'maximumAge', then it must acquire new location information.
         *
         * For example, if location information no older than 10 minutes is required, set this property to 600000.
         */
        maximumAge?: number;

        /**
         * Read-only property representing the last retrieved
         * current ground speed of the device, specified in meters per second.
         *
         * If this feature is unsupported by the device, this returns 'null'.
         *
         * If the device is stationary, this returns 0,
         * otherwise it returns a non-negative number.
         * @readonly
         */
        speed?: number;

        /**
         * The maximum number of milliseconds allowed to elapse between a location update operation
         * and the corresponding {@link #locationupdate} event being raised.  If a location was not successfully
         * acquired before the given timeout elapses (and no other internal errors have occurred in this interval),
         * then a {@link #locationerror} event will be raised indicating a timeout as the cause.
         *
         * Note that the time that is spent obtaining the user permission is **not** included in the period
         * covered by the timeout.  The 'timeout' attribute only applies to the location acquisition operation.
         *
         * In the case of calling 'updateLocation', the {@link #locationerror} event will be raised only once.
         *
         * If {@link #autoUpdate} is set to 'true', the {@link #locationerror} event could be raised repeatedly.
         * The first timeout is relative to the moment {@link #autoUpdate} was set to 'true'
         * (or this {@link Ext.util.Geolocation} was initialized with the {@link #autoUpdate} config option set to 'true').
         * Subsequent timeouts are relative to the moment when the device determines that it's position has changed.
         */
        timeout?: number;

        /**
         * Read-only property representing when the last retrieved
         * positioning information was acquired by the device.
         * @readonly
         */
        timestamp?: Date;
    }

    /**
     * Provides a cross browser class for retrieving location information.
     *
     * Based on the [Geolocation API Specification](http://dev.w3.org/geo/api/spec-source.html)
     *
     * When instantiated, by default this class immediately begins tracking location information,
     * firing a {@link #locationupdate} event when new location information is available.  To disable this
     * location tracking (which may be battery intensive on mobile devices), set {@link #autoUpdate} to 'false'.
     *
     * When this is done, only calls to {@link #updateLocation} will trigger a location retrieval.
     *
     * A {@link #locationerror} event is raised when an error occurs retrieving the location, either due to a user
     * denying the application access to it, or the browser not supporting it.
     *
     * The below code shows a GeoLocation making a single retrieval of location information.
     *
     *     var geo = Ext.create('Ext.util.Geolocation', {
     *         autoUpdate: false,
     *         listeners: {
     *             locationupdate: function(geo) {
     *                 alert('New latitude: ' + geo.getLatitude());
     *             },
     *             locationerror: function(geo, bTimeout, bPermissionDenied, bLocationUnavailable, message) {
     *                 if(bTimeout){
     *                     alert('Timeout occurred.');
     *                 } else {
     *                     alert('Error occurred.');
     *                 }
     *             }
     *         }
     *     });
     *     geo.updateLocation();
     */
    export class Geolocation extends Ext.Evented implements Ext.util.GeolocationConfig {
        /**
         * Read-only property representing the last retrieved
         * accuracy level of the latitude and longitude coordinates,
         * specified in meters.
         *
         * This will always be a non-negative number.
         *
         * This corresponds to a 95% confidence level.
         * @readonly
         */
        accuracy: number;

        /**
         * When set to 'true', provide a hint that the application would like to receive
         * the best possible results. This may result in slower response times or increased power consumption.
         * The user might also deny this capability, or the device might not be able to provide more accurate
         * results than if this option was set to 'false'.
         */
        allowHighAccuracy: boolean;

        /**
         * Read-only property representing the last retrieved
         * height of the position, specified in meters above the ellipsoid
         * [WGS84](http://dev.w3.org/geo/api/spec-source.html#ref-wgs).
         * @readonly
         */
        altitude: number;

        /**
         * Read-only property representing the last retrieved
         * accuracy level of the altitude coordinate, specified in meters.
         *
         * If altitude is not null then this will be a non-negative number.
         * Otherwise this returns 'null'.
         *
         * This corresponds to a 95% confidence level.
         * @readonly
         */
        altitudeAccuracy: number;

        /**
         * When set to 'true', continually monitor the location of the device (beginning immediately)
         * and fire {@link #locationupdate} and {@link #locationerror} events.
         */
        autoUpdate: boolean;

        /**
         * The frequency of each update if {@link #autoUpdate} is set to 'true'.
         */
        frequency: number;

        /**
         * Read-only property representing the last retrieved
         * direction of travel of the hosting device,
         * specified in non-negative degrees between 0 and 359,
         * counting clockwise relative to the true north.
         *
         * If speed is 0 (device is stationary), then this returns 'NaN'.
         * @readonly
         */
        heading: number;

        /**
         * Read-only property representing the last retrieved
         * geographical coordinate specified in degrees.
         * @readonly
         */
        latitude: number;

        /**
         * Read-only property representing the last retrieved
         * geographical coordinate specified in degrees.
         * @readonly
         */
        longitude: number;

        /**
         * This option indicates that the application is willing to accept cached location information whose age
         * is no greater than the specified time in milliseconds. If 'maximumAge' is set to 0, an attempt to retrieve
         * new location information is made immediately.
         *
         * Setting the 'maximumAge' to Infinity returns a cached position regardless of its age.
         *
         * If the device does not have cached location information available whose age is no
         * greater than the specified 'maximumAge', then it must acquire new location information.
         *
         * For example, if location information no older than 10 minutes is required, set this property to 600000.
         */
        maximumAge: number;

        /**
         * Read-only property representing the last retrieved
         * current ground speed of the device, specified in meters per second.
         *
         * If this feature is unsupported by the device, this returns 'null'.
         *
         * If the device is stationary, this returns 0,
         * otherwise it returns a non-negative number.
         * @readonly
         */
        speed: number;

        /**
         * The maximum number of milliseconds allowed to elapse between a location update operation
         * and the corresponding {@link #locationupdate} event being raised.  If a location was not successfully
         * acquired before the given timeout elapses (and no other internal errors have occurred in this interval),
         * then a {@link #locationerror} event will be raised indicating a timeout as the cause.
         *
         * Note that the time that is spent obtaining the user permission is **not** included in the period
         * covered by the timeout.  The 'timeout' attribute only applies to the location acquisition operation.
         *
         * In the case of calling 'updateLocation', the {@link #locationerror} event will be raised only once.
         *
         * If {@link #autoUpdate} is set to 'true', the {@link #locationerror} event could be raised repeatedly.
         * The first timeout is relative to the moment {@link #autoUpdate} was set to 'true'
         * (or this {@link Ext.util.Geolocation} was initialized with the {@link #autoUpdate} config option set to 'true').
         * Subsequent timeouts are relative to the moment when the device determines that it's position has changed.
         */
        timeout: number;

        /**
         * Read-only property representing when the last retrieved
         * positioning information was acquired by the device.
         * @readonly
         */
        timestamp: Date;

        constructor(config: Ext.util.GeolocationConfig);

        destroy();

        getAccuracy();

        getAllowHighAccuracy();

        getAltitude();

        getAltitudeAccuracy();

        getAutoUpdate();

        getFrequency();

        getHeading();

        getLatitude();

        getLongitude();

        getMaximumAge();

        getSpeed();

        getTimeout();

        getTimestamp();

        setAccuracy();

        setAllowHighAccuracy();

        setAltitude();

        setAltitudeAccuracy();

        setAutoUpdate();

        setFrequency();

        setHeading();

        setLatitude();

        setLongitude();

        setMaximumAge();

        setSpeed();

        setTimeout();

        setTimestamp();

        /**
         * Executes a onetime location update operation,
         * raising either a {@link #locationupdate} or {@link #locationerror} event.
         *
         * Does not interfere with or restart ongoing location monitoring.
         * A callback method to be called when the location retrieval has been completed.
         *
         * Will be called on both success and failure.
         *
         * The method will be passed one parameter, {@link Ext.util.Geolocation}
         * (**this** reference), set to 'null' on failure.
         *
         *     geo.updateLocation(function (geo) {
         *         alert('Latitude: ' + (geo !== null ? geo.latitude : 'failed'));
         *     });
         *
         * @param {Object} [scope]
         * The scope (**this** reference) in which the handler function is executed.
         *
         * **If omitted, defaults to the object which fired the event.**
         *
         * <!--positonOptions undocumented param, see W3C spec-->
         */
        updateLocation(callback: Function, scope?: any);

        /**
         * Raised when a location retrieval operation failed.
         *
         * In the case of calling updateLocation, this event will be raised only once.
         *
         * If {@link #autoUpdate} is set to 'true', this event could be raised repeatedly.
         * The first error is relative to the moment {@link #autoUpdate} was set to 'true'
         * (or this {@link Ext.util.Geolocation} was initialized with the {@link #autoUpdate} config option set to 'true').
         * Subsequent errors are relative to the moment when the device determines that it's position has changed.
         * Boolean indicating a timeout occurred
         * Boolean indicating the user denied the location request
         * Boolean indicating that the location of the device could not be determined.
         * For instance, one or more of the location providers used in the location acquisition
         * process reported an internal error that caused the process to fail entirely.
         * @param {String} message An error message describing the details of the error encountered.
         *
         * This attribute is primarily intended for debugging and should not be used
         * directly in an application user interface.
         */
        locationerror(that: Ext.util.Geolocation, timeout: boolean, permissionDenied: boolean, locationUnavailable: boolean, message: string);

        /**
         * Raised when a location retrieval operation has been completed successfully.
         * Retrieve the current location information from the GeoLocation object by using the read-only
         * properties: {@link #latitude}, {@link #longitude}, {@link #accuracy}, {@link #altitude}, {@link #altitudeAccuracy}, {@link #heading}, and {@link #speed}.
         */
        locationupdate(that: Ext.util.Geolocation);
    }

    /**
     * Encapsulates a grouped collection of records within a {@link Ext.util.Collection}
     */
    export class Group extends Ext.util.Collection {
        getGroupKey();

        setGroupKey();
    }

    interface GroupCollectionConfig extends Ext.util.CollectionConfig {
        grouper?: any;
    }

    /**
     * A collection containing the result of applying grouping to the records in the store.
     */
    export class GroupCollection extends Ext.util.Collection implements Ext.util.GroupCollectionConfig {
        grouper: any;

        constructor(config: Ext.util.GroupCollectionConfig);

        destroy();

        getGrouper();

        getItemRoot();

        setGrouper();

        setItemRoot();
    }

    interface GrouperConfig extends Ext.util.SorterConfig {
        /**
         * This function is called for each item in the collection
         * to determine the group to which it belongs. By default the 'property' value is
         * used to group items.
         * The current item from the collection.
         * The group identifier for the item.
         */
        groupFn?: Function;

        /**
         * The field by which records are grouped. Groups are
         * sorted alphabetically by group value as the default. To sort groups by a different
         * property, use the {@link #sortProperty} configuration.
         */
        property?: string;

        /**
         * You can set this configuration if you want the groups
         * to be sorted on something other then the group string returned by the 'groupFn'.
         * This serves the same role as 'property' on a normal 'Ext.util.Sorter'.
         */
        sortProperty?: string;
    }

    /**
     * Represents a grouping of items. The grouper works in a similar fashion as the
     * 'Ext.util.Sorter' except that groups must be able to extract a value by which all items
     * in the group can be collected. By default this is derived from the 'property' config
     * but can be customized using the 'groupFn' if necessary.
     *
     * All items with the same group value compare as equal. If the group values do not compare
     * equally, the sort can be controlled further by setting 'sortProperty' or 'sorterFn'.
     */
    export class Grouper extends Ext.util.Sorter implements Ext.util.GrouperConfig {
        /**
         * This function is called for each item in the collection
         * to determine the group to which it belongs. By default the 'property' value is
         * used to group items.
         * The current item from the collection.
         * The group identifier for the item.
         */
        groupFn: Function;

        /**
         * The field by which records are grouped. Groups are
         * sorted alphabetically by group value as the default. To sort groups by a different
         * property, use the {@link #sortProperty} configuration.
         */
        property: string;

        /**
         * You can set this configuration if you want the groups
         * to be sorted on something other then the group string returned by the 'groupFn'.
         * This serves the same role as 'property' on a normal 'Ext.util.Sorter'.
         */
        sortProperty: string;

        constructor(config: Ext.util.GrouperConfig);

        getGroupFn();

        /**
         * Returns the value for grouping to be used.
         * @param {Ext.data.Model} item The Model instance
         * @return {String}
         */
        getGroupString(item: Ext.data.Model): string;

        getSortProperty();

        setGroupFn();

        setSortProperty();
    }

    interface HashMapConfig {
        /**
         * A function that is used to retrieve a default key for a passed object.
         * A default is provided that returns the 'id' property on the object. This function is only used
         * if the 'add' method is called with a single argument.
         */
        keyFn?: Function;
    }

    /**
     * Represents a collection of a set of key and value pairs. Each key in the HashMap
     * must be unique, the same key cannot exist twice. Access to items is provided via
     * the key only. Sample usage:
     *
     *     var map = new Ext.util.HashMap();
     *     map.add('key1', 1);
     *     map.add('key2', 2);
     *     map.add('key3', 3);
     *
     *     map.each(function(key, value, length){
     *         console.log(key, value, length);
     *     });
     *
     * The HashMap is an unordered class,
     * there is no guarantee when iterating over the items that they will be in any particular
     * order. If this is required, then use a {@link Ext.util.MixedCollection}.
     */
    export class HashMap extends Ext.Base implements Ext.util.HashMapConfig {
        /**
         * Mutation counter which is incremented upon add and remove.
         * @readonly
         */
        generation: any;

        /**
         * A function that is used to retrieve a default key for a passed object.
         * A default is provided that returns the 'id' property on the object. This function is only used
         * if the 'add' method is called with a single argument.
         */
        keyFn: Function;

        /**
         * Adds an item to the collection. Fires the {@link #event-add} event when complete.
         *
         * @param {String/Object} key The key to associate with the item, or the new item.
         *
         * If a {@link #getKey} implementation was specified for this HashMap,
         * or if the key of the stored items is in a property called 'id',
         * the HashMap will be able to *derive* the key for the new item.
         * In this case just pass the new item in this parameter.
         *
         * @param {Object} [o] The item to add.
         *
         * @return {Object} The item added.
         */
        add(key: string|any, o?: any): any;

        /**
         * Performs a shallow copy on this hash.
         * @return {Ext.util.HashMap} The new hash object.
         */
        clone(): Ext.util.HashMap;

        /**
         * Creates new HashMap.
         * @param {Object} config (optional) Config object.
         */
        constructor(config: Ext.data.PageMapConfig);

        /**
         * Checks whether a value exists in the hash.
         * @param {Object} value The value to check for.
         * @return {Boolean} True if the value exists in the dictionary.
         */
        contains(value: any): boolean;

        /**
         * Checks whether a key exists in the hash.
         * @param {String} key The key to check for.
         * @return {Boolean} True if they key exists in the hash.
         */
        containsKey(key: string): boolean;

        destroy();

        /**
         * Executes the specified function once for each item in the hash.
         * Returning false from the function will cease iteration.
         *
         * @param {Function} fn The function to execute.
         * @param {String} fn.key The key of the item.
         * @param {Number} fn.value The value of the item.
         * @param {Number} fn.length The total number of items in the hash.
         * @param {Object} [scope] The scope to execute in. Defaults to <tt>this</tt>.
         * @return {Ext.util.HashMap} this
         */
        each(fn: Function, fn_key: string, fn_value: number, fn_length: number, scope?: any): Ext.util.HashMap;

        /**
         * Retrieves an item with a particular key.
         * @param {String} key The key to lookup.
         * @return {Object} The value at that key. If it doesn't exist, 'undefined' is returned.
         */
        get(key: string): any;

        /**
         * Gets the number of items in the hash.
         * @return {Number} The number of items in the hash.
         */
        getCount(): number;

        /**
         * Extracts the key from an object. This is a default implementation, it may be overridden
         * @param {Object} o The object to get the key from
         * @return {String} The key to use.
         */
        getKey(o: any): string;

        getKeyFn();

        /**
         * Return all of the keys in the hash.
         * @return {Array} An array of keys.
         */
        getKeys(): any[];

        /**
         * Return all of the values in the hash.
         * @return {Array} An array of values.
         */
        getValues(): any[];

        /**
         * Remove an item from the hash.
         * @param {Object} o The value of the item to remove.
         * @return {Boolean} True if the item was successfully removed.
         */
        remove(o: any): boolean;

        /**
         * Remove an item from the hash.
         * @param {String} key The key to remove.
         * @return {Boolean} True if the item was successfully removed.
         */
        removeAtKey(key: string): boolean;

        /**
         * An alias for {@link #removeAtKey}
         */
        removeByKey();

        /**
         * Replaces an item in the hash. If the key doesn't exist, the
         * {@link #method-add} method will be used.
         * @param {String} key The key of the item.
         * @param {Object} value The new value for the item.
         * @return {Object} The new value of the item.
         */
        replace(key: string, value: any): any;

        setKeyFn();

        /**
         * Fires when the hash is cleared.
         */
        clear(that: Ext.util.HashMap);
    }

    /**
     * History management component that allows you to register arbitrary tokens that signify application
     * history state on navigation actions.  You can then handle the history {@link #change} event in order
     * to reset your application UI to the appropriate state when the user navigates forward or backward through
     * the browser history stack.
     *
     * ## Initializing
     *
     * The {@link #init} method of the History object must be called before using History. This sets up the internal
     * state and must be the first thing called before using History.
     */
    export class History {
        /**
         * True to use 'window.top.location.hash' or false to use 'window.location.hash'. Must be set before {@link #init} is called
         * because the 'hashchange' event listener is added to the window at initialization time.
         */
        static useTopWindow: any;

        /**
         * Add a new token to the history stack. This can be any arbitrary value, although it would
         * commonly be the concatenation of a component id and another id marking the specific history
         * state of that component. Example usage:
         *
         *     // Handle tab changes on a TabPanel
         *     tabPanel.on('tabchange', function(tabPanel, tab){
         *          Ext.History.add(tabPanel.id + ':' + tab.id);
         *     });
         *
         * @param {String} token The value that defines a particular application-specific history state
         * @param {Boolean} [preventDuplicates=true] When true, if the passed token matches the current token
         * it will not save a new history step. Set to false if the same state can be saved more than once
         * at the same history stack location.
         */
        static add(token: string, preventDuplicates?: boolean);

        /**
         * Programmatically steps back one step in browser history (equivalent to the user pressing the Back button).
         */
        static back();

        /**
         * Programmatically steps forward one step in browser history (equivalent to the user pressing the Forward button).
         */
        static forward();

        /**
         * Retrieves the currently-active history token.
         * @return {String} The token
         */
        static getToken(): string;

        /**
         * Initializes the global History instance.
         * @param {Function} [onReady] A callback function that will be called once the history
         * component is fully initialized.
         * @param {Object} [scope] The scope ('this' reference) in which the callback is executed.
         * Defaults to the browser window.
         */
        static init(onReady?: Function, scope?: any);

        /**
         * Fires when navigation back or forwards within the local page's history occurs.
         * @param {String} token An identifier associated with the page state at that point in its history.
         */
        static change(token: string);

        /**
         * Fires when the Ext.util.History singleton has been initialized and is ready for use.
         * @param {Ext.util.History} history The Ext.util.History singleton.
         */
        static ready(history: Ext.util.History);
    }

    /**
     * General purpose inflector class that {@link #pluralize pluralizes}, {@link #singularize singularizes} and
     * {@link #ordinalize ordinalizes} words. Sample usage:
     *
     *     //turning singular words into plurals
     *     Ext.util.Inflector.pluralize('word'); //'words'
     *     Ext.util.Inflector.pluralize('person'); //'people'
     *     Ext.util.Inflector.pluralize('sheep'); //'sheep'
     *
     *     //turning plurals into singulars
     *     Ext.util.Inflector.singularize('words'); //'word'
     *     Ext.util.Inflector.singularize('people'); //'person'
     *     Ext.util.Inflector.singularize('sheep'); //'sheep'
     *
     *     //ordinalizing numbers
     *     Ext.util.Inflector.ordinalize(11); //"11th"
     *     Ext.util.Inflector.ordinalize(21); //"21st"
     *     Ext.util.Inflector.ordinalize(1043); //"1043rd"
     *
     * # Customization
     *
     * The Inflector comes with a default set of US English pluralization rules. These can be augmented with additional
     * rules if the default rules do not meet your application's requirements, or swapped out entirely for other languages.
     * Here is how we might add a rule that pluralizes "ox" to "oxen":
     *
     *     Ext.util.Inflector.plural(/^(ox)$/i, "$1en");
     *
     * Each rule consists of two items - a regular expression that matches one or more rules, and a replacement string. In
     * this case, the regular expression will only match the string "ox", and will replace that match with "oxen". Here's
     * how we could add the inverse rule:
     *
     *     Ext.util.Inflector.singular(/^(ox)en$/i, "$1");
     *
     * Note that the ox/oxen rules are present by default.
     */
    export class Inflector {
        /**
         * Returns the correct {@link Ext.data.Model Model} name for a given string. Mostly used internally by the data
         * package
         * @param {String} word The word to classify
         * @return {String} The classified version of the word
         */
        static classify(word: string): string;

        /**
         * Removes all registered pluralization rules
         */
        static clearPlurals();

        /**
         * Removes all registered singularization rules
         */
        static clearSingulars();

        /**
         * Returns true if the given word is transnumeral (the word is its own singular and plural form - e.g. sheep, fish)
         * @param {String} word The word to test
         * @return {Boolean} True if the word is transnumeral
         */
        static isTransnumeral(word: string): boolean;

        /**
         * Ordinalizes a given number by adding a prefix such as 'st', 'nd', 'rd' or 'th' based on the last digit of the
         * number. 21 -> 21st, 22 -> 22nd, 23 -> 23rd, 24 -> 24th etc
         * @param {Number} number The number to ordinalize
         * @return {String} The ordinalized number
         */
        static ordinalize(number: number): string;

        /**
         * Adds a new pluralization rule to the Inflector. See the intro docs for more information
         * @param {RegExp} matcher The matcher regex
         * @param {String} replacer The replacement string, which can reference matches from the matcher argument
         */
        static plural(matcher: RegExp, replacer: string);

        /**
         * Returns the pluralized form of a word (e.g. Ext.util.Inflector.pluralize('word') returns 'words')
         * @param {String} word The word to pluralize
         * @return {String} The pluralized form of the word
         */
        static pluralize(word: string): string;

        /**
         * Adds a new singularization rule to the Inflector. See the intro docs for more information
         * @param {RegExp} matcher The matcher regex
         * @param {String} replacer The replacement string, which can reference matches from the matcher argument
         */
        static singular(matcher: RegExp, replacer: string);

        /**
         * Returns the singularized form of a word (e.g. Ext.util.Inflector.singularize('words') returns 'word')
         * @param {String} word The word to singularize
         * @return {String} The singularized form of the word
         */
        static singularize(word: string): string;
    }

    /**
     * A utility class to disable input fields in WP7,8 because they stay still clickable even if they are under other elements.
     */
    export class InputBlocker {
    }

    export class ItemCollection extends Ext.util.MixedCollection {
        /**
         * Creates new MixedCollection.
         * @param {Object} config A configuration object.
         *  @param {Boolean} [config.allowFunctions=false] Specify 'true' if the {@link #addAll}
         * function should add function references to the collection.
         *  @param {Function} [config.getKey] A function that can accept an item of the type(s) stored in this MixedCollection
         * and return the key value for that item.  This is used when available to look up the key on items that
         * were passed without an explicit key parameter to a MixedCollection method.  Passing this parameter is
         * equivalent to overriding the {@link #method-getKey} method.
         */
        constructor(config: Ext.util.MixedCollectionConfig);
    }

    /**
     * Utility class that represents a line segment, constructed by two {@link Ext.util.Point}
     */
    export class LineSegment extends Ext.Base {
        /**
         * Creates new LineSegment out of two points.
         */
        constructor(point1: Ext.util.Point, point2: Ext.util.Point);

        /**
         * Returns the point where two lines intersect.
         * @param {Ext.util.LineSegment} lineSegment The line to intersect with.
         * @return {Ext.util.Point}
         */
        intersects(lineSegment: Ext.util.LineSegment): Ext.util.Point;

        /**
         * Returns string representation of the line. Useful for debugging.
         * @return {String} For example 'Point[12,8] Point[0,0]'
         */
        toString(): string;
    }

    interface LocalStorageConfig {
        /**
         * The number of milliseconds to delay writing changes to the underlying store.
         * This applies only to legacy IE mode and helps batch multiple writes into one
         * flush to storage.
         *
         * Optional, Defaults to: 1
         */
        flushDelay?: number;

        /**
         * The unique identifier for this store. This config is required to scope this storage
         * distinctly from others. Ultimately, this is used to set a prefix on all keys.
         */
        id?: string;

        /**
         * Determines if the keys collection is continuously maintained by this object. By
         * default the keys array is lazily fetched from the underlying store and when keys
         * are removed, the array is discarded. This heuristic tends to be safer than doing
         * the linear removal and array rippling to remove keys from the array on each call
         * to 'removeItem'. If the cost of scanning 'localStorage' for keys is high enough
         * and if the keys are frequently needed, then this flag can be set to 'false' to
         * instruct this class to maintain the keys array once it has been determined.
         *
         * Optional, Defaults to: true
         */
        lazyKeys?: boolean;

        /**
         * The prefix to apply to all 'localStorage' keys manages by this instance. This does
         * not apply to the legacy IE mechanism but only to the HTML5 'localStorage' keys. If
         * not provided, the 'id' property initializes this value with '"id-"'.
         *
         * Optional
         */
        prefix?: string;

        /**
         * Specify this as 'true' to use 'sessionStorage' instead of the default 'localStoreage'.
         * This option is not supported in legacy IE browsers (IE 6 and 7) and is ignored.
         *
         * Optional, Defaults to: false
         */
        session?: boolean;
    }

    /**
     * This class provides a common API to LocalStorage with backwards compatibility for IE.
     *
     * The primary aspects of this API match the HTML5 standard API except that this class
     * provides a scoping mechanism to isolate property values by instance. This scope is
     * determined from the 'id' property. Further, this class does not expose the number of
     * keys in the store as a 'length' property as this cannot be maintained reliably without
     * undue cost. Instead there is a 'getKeys' method that returns the cached array of keys
     * which is lazily populated on first call.
     *
     * For example:
     *
     *      var store = new Ext.util.LocalStorage({
     *              id: 'foo'
     *          });
     *
     *      store.setItem('bar', 'stuff');
     *
     *      // Equivalent to:
     *      window.localStorage.setItem('foo-bar', 'stuff');
     *
     * In all cases, the 'id' property is only used by the underlying storage and should not
     * be needed in item access calls or appear when enumerating keys.
     *
     * To continue with the previous example:
     *
     *      var keys = store.getKeys();
     *      console.log(keys.length);   // logs 1
     *      console.log(store.key(0));  // logs "bar"
     *
     * ## Sharing Instances
     *
     * The management of the underlying storage can be broken if multiple instances of this
     * class are created with the same 'id' simultaneously. To avoid creating multiple instances
     * with the same 'id', use the 'get' method and it will lazily create and share a single
     * instance. When you are done with the shared instance, call 'release'.
     *
     *      var storage = Ext.util.LocalStorage.get('id');
     *
     *      ...
     *
     *      storage.release(); // do not call 'destroy' as others may be using this object
     *
     * **IMPORTANT:** Do not mix direction instantiation and 'get' with the same 'id'.
     *
     * ## Legacy IE
     *
     * Older IE browsers (specifically IE7 and below) do not support 'localStorage' so this
     * class provides equivalent support using the IE proprietary persistence mechanism: the
     * ['userData' behavior](http://msdn.microsoft.com/en-us/library/ms531424(VS.85).aspx). In
     * this mode, the 'id' serves as name passed to the 'load' and 'save' methods and as the
     * suffix on the DOM element added to the 'head'.
     *
     * In this mode, writes to the underlying storage are buffered and delayed for performance
     * reasons. This can be managed using the 'flushDelay' config or by directly calling the
     * 'save' method.
     *
     * @since 4.2.2
     */
    export class LocalStorage extends Ext.Base implements Ext.util.LocalStorageConfig {
        /**
         * The number of milliseconds to delay writing changes to the underlying store.
         * This applies only to legacy IE mode and helps batch multiple writes into one
         * flush to storage.
         *
         * Optional, Defaults to: 1
         */
        flushDelay: number;

        /**
         * The unique identifier for this store. This config is required to scope this storage
         * distinctly from others. Ultimately, this is used to set a prefix on all keys.
         */
        id: string;

        /**
         * Determines if the keys collection is continuously maintained by this object. By
         * default the keys array is lazily fetched from the underlying store and when keys
         * are removed, the array is discarded. This heuristic tends to be safer than doing
         * the linear removal and array rippling to remove keys from the array on each call
         * to 'removeItem'. If the cost of scanning 'localStorage' for keys is high enough
         * and if the keys are frequently needed, then this flag can be set to 'false' to
         * instruct this class to maintain the keys array once it has been determined.
         *
         * Optional, Defaults to: true
         */
        lazyKeys: boolean;

        /**
         * The prefix to apply to all 'localStorage' keys manages by this instance. This does
         * not apply to the legacy IE mechanism but only to the HTML5 'localStorage' keys. If
         * not provided, the 'id' property initializes this value with '"id-"'.
         *
         * Optional
         */
        prefix: string;

        /**
         * Specify this as 'true' to use 'sessionStorage' instead of the default 'localStoreage'.
         * This option is not supported in legacy IE browsers (IE 6 and 7) and is ignored.
         *
         * Optional, Defaults to: false
         */
        session: boolean;

        /**
         * Removes all of the keys of this storage.
         * **NOTE:** This method conforms to the standard HTML5 Storage interface.
         */
        clear();

        constructor(config: Ext.util.LocalStorageConfig);

        /**
         * Destroys this instance and for legacy IE, ensures data is flushed to persistent
         * storage. This method should not be called directly on instances returned by the
         * 'get' method. Call 'release' instead for such instances.
         *
         * *NOTE:* For non-legacy IE browsers, there is no harm in failing to call this
         * method. In legacy IE, however, failing to call this method can result in memory
         * leaks.
         */
        destroy();

        /**
         * Returns the value associated with the given 'key'.
         * **NOTE:** This method conforms to the standard HTML5 Storage interface.
         * @param {String} key The key.
         * @return {String} The value associated with the given 'key'.
         */
        getItem(key: string): string;

        /**
         * Returns the keys for this storage.
         * @return {String[]} The keys for this storage. This array should be considered as
         * readonly.
         */
        getKeys(): string;

        /**
         * Returns the specified key given its 'index'. These keys have the scoping prefix
         * removed so they match what was passed to 'setItem'.
         * **NOTE:** This method conforms to the standard HTML5 Storage interface.
         * @param {Number} index The index of the desired key.
         * @return {String} The key.
         */
        key(index: number): string;

        /**
         * Call this method when finished with an instance returned by 'get' instead of calling
         * 'destroy'. When the last shared use of this instance calls 'release', the 'destroy'
         * method is called automatically.
         *
         * *NOTE:* Failing to call this method will result in memory leaks.
         */
        release();

        /**
         * Removes the value associated with the given 'key'.
         * **NOTE:** This method conforms to the standard HTML5 Storage interface.
         * @param {String} key The key.
         */
        removeItem(key: string);

        /**
         * This method ensures the content of the store is saved to the underlying storage.
         * This applies only to legacy IE. This is not normally called by user code but can
         * be called to ensure storage is saved.
         * @param {Number} [delay=0]
         */
        save(delay?: number);

        /**
         * Sets the value associated with the given 'key'.
         * **NOTE:** This method conforms to the standard HTML5 Storage interface.
         * @param {String} key The key.
         * @param {String} value The new associated value for 'key'.
         */
        setItem(key: string, value: string);

        /**
         * This will be 'true' if some form of local storage is supported or 'false' if not.
         * @readonly
         */
        static supported: boolean;

        /**
         * Returns a shared instance of the desired local store given its 'id'. When you
         * are finished with the returned object call the 'release' method:
         *
         *      var store = Ext.util.LocalStorage.get('foo');
         *
         *      // .. use store
         *
         *      store.release();
         *
         * **NOTE:** Do not mix this call with direct instantiation of the same 'id'.
         * @param {String/Object} id The 'id' of the desired instance or a config object
         * with an 'id' property at a minimum.
         * @return {Ext.util.LocalStorage} The desired instance, created if needed.
         */
        static get(id: string|any): Ext.util.LocalStorage;
    }

    interface LruCacheConfig extends Ext.util.HashMapConfig {
        /**
         * The maximum size the cache is allowed to grow to before further additions cause
         * removal of the least recently used entry.
         */
        maxSize?: number;
    }

    /**
     * @extend Ext.util.HashMap
     * A linked {@link Ext.util.HashMap HashMap} implementation which maintains most recently accessed
     * items at the end of the list, and purges the cache down to the most recently accessed {@link #maxSize} items
     * upon add.
     */
    export class LruCache extends Ext.util.HashMap implements Ext.util.LruCacheConfig {
        /**
         * The maximum size the cache is allowed to grow to before further additions cause
         * removal of the least recently used entry.
         */
        maxSize: number;

        /**
         * Performs a shallow copy on this haLruCachesh.
         * @return {Ext.util.HashMap} The new hash object.
         */
        clone(): Ext.util.HashMap;

        /**
         * Creates new HashMap.
         * @param {Object} config (optional) Config object.
         */
        constructor(config: Ext.data.PageMapConfig);

        destroy();

        getMaxSize();

        /**
         * Purge the least recently used entries if the maxSize has been exceeded.
         */
        prune();

        setMaxSize();
    }

    interface MixedCollectionConfig extends Ext.util.AbstractMixedCollectionConfig {
        /**
         * Configure as 'true' if the {@link #addAll} function should add function references to the collection.
         */
        allowFunctions?: boolean;
    }

    /**
     * Represents a collection of a set of key and value pairs. Each key in the MixedCollection
     * must be unique, the same key cannot exist twice. This collection is ordered, items in the
     * collection can be accessed by index  or via the key. Newly added items are added to
     * the end of the collection. This class is similar to {@link Ext.util.HashMap} however it
     * is heavier and provides more functionality. Sample usage:
     *
     *     var coll = new Ext.util.MixedCollection();
     *     coll.add('key1', 'val1');
     *     coll.add('key2', 'val2');
     *     coll.add('key3', 'val3');
     *
     *     console.log(coll.get('key1')); // prints 'val1'
     *     console.log(coll.indexOfKey('key3')); // prints 2
     *
     * The MixedCollection also has support for sorting and filtering of the values in the collection.
     *
     *     var coll = new Ext.util.MixedCollection();
     *     coll.add('key1', 100);
     *     coll.add('key2', -100);
     *     coll.add('key3', 17);
     *     coll.add('key4', 0);
     *     var biggerThanZero = coll.filterBy(function(value){
     *         return value > 0;
     *     });
     *     console.log(biggerThanZero.getCount()); // prints 2
     */
    export class MixedCollection extends Ext.util.AbstractMixedCollection implements Ext.util.MixedCollectionConfig {
        /**
         * Configure as 'true' if the {@link #addAll} function should add function references to the collection.
         */
        allowFunctions: boolean;

        /**
         * Creates new MixedCollection.
         * @param {Object} config A configuration object.
         *  @param {Boolean} [config.allowFunctions=false] Specify 'true' if the {@link #addAll}
         * function should add function references to the collection.
         *  @param {Function} [config.getKey] A function that can accept an item of the type(s) stored in this MixedCollection
         * and return the key value for that item.  This is used when available to look up the key on items that
         * were passed without an explicit key parameter to a MixedCollection method.  Passing this parameter is
         * equivalent to overriding the {@link #method-getKey} method.
         */
        constructor(config: Ext.util.MixedCollectionConfig);

        /**
         * Calculates the insertion index of the new item based upon the comparison function passed, or the current sort order.
         * @param {Object} newItem The new object to find the insertion position of.
         * @param {Function} [sorterFn] The function to sort by. This is the same as the sorting function
         * passed to {@link #sortBy}. It accepts 2 items from this MixedCollection, and returns -1 0, or 1
         * depending on the relative sort positions of the 2 compared items.
         *
         * If omitted, a function {@link #generateComparator generated} from the currently defined set of
         * {@link #cfg-sorters} will be used.
         *
         * @return {Number} The insertion point to add the new item into this MixedCollection at using {@link #insert}
         */
        findInsertionIndex(newItem: any, sorterFn?: Function): number;

        /**
         * Sorts the collection by a single sorter function
         * @param {Function} sorterFn The function to sort by
         */
        sortBy(sorterFn: Function);

        /**
         * Sorts this collection by <b>key</b>s.
         * @param {String} direction (optional) 'ASC' or 'DESC'. Defaults to 'ASC'.
         * @param {Function} fn (optional) Comparison function that defines the sort order.
         * Defaults to sorting by case insensitive string.
         */
        sortByKey(direction: string, fn: Function);
    }

    /**
     * This class accepts an object that serves as a template for creating new objects. Like
     * other templates ('Ext.XTemplate') this creation step requires a context object to give
     * the template its values.
     *
     * For example:
     *
     *      var tpl = new Ext.util.ObjectTemplate({
     *          property: 'Hello {name}',
     *          data: {
     *              value: '{age}'
     *          }
     *      });
     *
     *      var obj = tpl.apply({
     *          name: 'Bill',
     *          age: 42
     *      });
     *
     *      // obj = {
     *      //     property: 'Hello Bill',
     *      //     data: {
     *      //         value: 42
     *      //     }
     *      // }
     *
     * @since 5.0.0
     */
    export class ObjectTemplate extends Ext.Base {
        /**
         * Applies the given 'context' object to this template and returns a new object with
         * the appropriate pieces replaced.
         * @param {Object} context The data used to populate the template.
         * @return {Object}
         * @since 5.0.0
         */
        apply(context: any): any;

        /**
         * Compiles the  given template into an 'apply' method that is ready to run. This
         * method is used recursively to process object properties and array elements.
         * @return {Function}
         * @since 5.0.0
         */
        compile(template: any): Function;

        /**
         * Constructs the 'ObjectTemplate'. The actual compilation of the object to a ready to
         * apply form happens on the first call to 'apply'.
         * @param {Object} [options]
         * @since 5.0.0
         */
        constructor(template: any, options?: any);
    }

    /**
     * A Ext.mixin.Observable subclass that is provided for backward compatibility.
     * Applications should avoid using this class, and use Ext.mixin.Observable instead.
     */
    export class Observable extends Ext.mixin.Observable {
    }

    export class Offset extends Ext.Base {
        constructor();
    }

    /**
     * This class defines the operators that are shared by DomQuery and ComponentQuery
     */
    export class Operators {
    }

    export class PaintMonitor extends Ext.Base {
        constructor(config: any);
    }

    /**
     * Represents a 2D point with x and y properties, useful for comparison and instantiation
     * from an event:
     *
     *     var point = Ext.util.Point.fromEvent(e);
     */
    export class Point extends Ext.util.Region {
        /**
         * Copy a new instance of this point.
         * @return {Ext.util.Point} The new point.
         */
        clone(): Ext.util.Point;

        /**
         * Creates point on 2D plane.
         * @param {Number} [x=0] X coordinate.
         * @param {Number} [y=0] Y coordinate.
         */
        constructor(x?: number, y?: number);

        /**
         * Returns 'true' if the passed point is within a certain distance of this point.
         * @param {Ext.util.Point/Object} point The point to check with, either an instance
         * of {@link Ext.util.Point} or an object with 'x' and 'y' properties.
         * @param {Object/Number} threshold Can be either an object with 'x' and 'y' properties or a number.
         * @return {Boolean}
         */
        isCloseTo(point: Ext.util.Point|any, threshold: any|number): boolean;

        /**
         * Determins whether this Point contained by the passed Region, Component or element.
         * The rectangle to check that this Point is within.
         * @return {Boolean}
         */
        isContainedBy(region: Ext.util.Region|Ext.Component|Ext.dom.Element|HTMLElement): boolean;

        /**
         * Returns 'true' if this point is close to another one.
         * @deprecated 2.0.0 Please use {@link #isCloseTo} instead.
         * @return {Boolean}
         */
        isWithin(): boolean;

        /**
         * Compare this point with another point when the 'x' and 'y' values of both points are rounded. For example:
         * [100.3,199.8] will equals to [100, 200].
         * @param {Ext.util.Point/Object} point The point to compare with, either an instance
         * of Ext.util.Point or an object with 'x' and 'y' properties.
         * @return {Boolean}
         */
        roundedEquals(point: Ext.util.Point|any): boolean;

        /**
         * Returns a human-eye-friendly string that represents this point,
         * useful for debugging.
         * @return {String} For example 'Point[12,8]'.
         */
        toString(): string;

        /**
         * Alias for {@link #translateBy}
         */
        translate();

        /**
         * Returns a new instance of {@link Ext.util.Point} based on the 'pageX' / 'pageY' values of the given event.
         * @param {Event} e The event.
         * @return {Ext.util.Point}
         */
        static fromEvent(e: Event): Ext.util.Point;

        /**
         * Returns a new instance of {@link Ext.util.Point} based on the 'pageX' / 'pageY' values of the given touch.
         * @return {Ext.util.Point}
         */
        static fromTouch(touch: Event): Ext.util.Point;
    }

    /**
     * This mixin provides a common interface for objects that can be positioned, e.g.
     * {@link Ext.Component Components} and {@link Ext.dom.Element Elements}
     */
    export class Positionable extends Ext.Base {
        /**
         * Aligns the element with another element relative to the specified anchor points. If
         * the other element is the document it aligns it to the viewport. The position
         * parameter is optional, and can be specified in any one of the following formats:
         *
         * - **Blank**: Defaults to aligning the element's top-left corner to the target's
         *   bottom-left corner ("tl-bl").
         * - **One anchor (deprecated)**: The passed anchor position is used as the target
         *   element's anchor point.  The element being aligned will position its top-left
         *   corner (tl) to that point. *This method has been deprecated in favor of the newer
         *   two anchor syntax below*.
         * - **Two anchors**: If two values from the table below are passed separated by a dash,
         *   the first value is used as the element's anchor point, and the second value is
         *   used as the target's anchor point.
         *
         * In addition to the anchor points, the position parameter also supports the "?"
         * character. If "?" is passed at the end of the position string, the element will
         * attempt to align as specified, but the position will be adjusted to constrain to
         * the viewport if necessary. Note that the element being aligned might be swapped to
         * align to a different position than that specified in order to enforce the viewport
         * constraints. Following are all of the supported anchor positions:
         *
         * <pre>
         * Value  Description
         * -----  -----------------------------
         * tl     The top left corner (default)
         * t      The center of the top edge
         * tr     The top right corner
         * l      The center of the left edge
         * c      In the center of the element
         * r      The center of the right edge
         * bl     The bottom left corner
         * b      The center of the bottom edge
         * br     The bottom right corner
         * </pre>
         *
         * Example Usage:
         *
         *     // align el to other-el using the default positioning
         *     // ("tl-bl", non-constrained)
         *     el.alignTo("other-el");
         *
         *     // align the top left corner of el with the top right corner of other-el
         *     // (constrained to viewport)
         *     el.alignTo("other-el", "tr?");
         *
         *     // align the bottom right corner of el with the center left edge of other-el
         *     el.alignTo("other-el", "br-l?");
         *
         *     // align the center of el with the bottom left corner of other-el and
         *     // adjust the x position by -6 pixels (and the y position by 0)
         *     el.alignTo("other-el", "c-bl", [-6, 0]);
         *
         * @param {Ext.util.Positionable/HTMLElement/String} element The Positionable,
         * HTMLElement, or id of the element to align to.
         * @param {String} [position="tl-bl?"] The position to align to
         * @param {Number[]} [offsets] Offset the positioning by [x, y]
         * Element animation config object
         * @return {Ext.util.Positionable} this
         */
        alignTo(element: Ext.util.Positionable|HTMLElement|string, position?: string, offsets?: number): Ext.util.Positionable;

        /**
         * Gets the x,y coordinates to align this element with another element. See
         * {@link #alignTo} for more info on the supported position values.
         * @param {Ext.util.Positionable/HTMLElement/String} element The Positionable,
         * HTMLElement, or id of the element to align to.
         * @param {String} [position="tl-bl?"] The position to align to
         * @param {Number[]} [offsets] Offset the positioning by [x, y]
         * @return {Number[]} [x, y]
         */
        getAlignToXY(element: Ext.util.Positionable|HTMLElement|string, position?: string, offsets?: number): number;

        /**
         * Gets the x,y coordinates specified by the anchor position on the element.
         * @param {String} [anchor='tl'] The specified anchor position.
         * See {@link #alignTo} for details on supported anchor positions.
         * @param {Boolean} [local] True to get the local (element top/left-relative) anchor
         * position instead of page coordinates
         * @param {Object} [size] An object containing the size to use for calculating anchor
         * position {width: (target width), height: (target height)} (defaults to the
         * element's current size)
         * @return {Number[]} [x, y] An array containing the element's x and y coordinates
         */
        getAnchorXY(anchor?: string, local?: boolean, size?: any): number;

        /**
         * Return an object defining the area of this Element which can be passed to
         * {@link #setBox} to set another Element's size/location to match this element.
         *
         * @param {Boolean} [contentBox] If true a box for the content of the element is
         * returned.
         * @param {Boolean} [local] If true the element's left and top relative to its
         * 'offsetParent' are returned instead of page x/y.
         * @return {Object} An object in the format
         * @return {Number} return.x The element's X position.
         * @return {Number} return.y The element's Y position.
         * @return {Number} return.width The element's width.
         * @return {Number} return.height The element's height.
         * @return {Number} return.bottom The element's lower bound.
         * @return {Number} return.right The element's rightmost bound.
         *
         * The returned object may also be addressed as an Array where index 0 contains the X
         * position and index 1 contains the Y position. The result may also be used for
         * {@link #setXY}
         */
        getBox(contentBox?: boolean, local?: boolean): any;

        /**
         * Returns the content region of this element for purposes of constraining or clipping floating
         * children.  That is the region within the borders and scrollbars, but not within the padding.
         */
        getConstrainRegion();

        /**
         * Returns the '[X, Y]' vector by which this Positionable's element must be translated to make a best
         * attempt to constrain within the passed constraint. Returns 'false' if the element
         * does not need to be moved.
         *
         * Priority is given to constraining the top and left within the constraint.
         *
         * The constraint may either be an existing element into which the element is to be
         * constrained, or a {@link Ext.util.Region Region} into which this element is to be
         * constrained.
         *
         * By default, any extra shadow around the element is **not** included in the constrain calculations - the edges
         * of the element are used as the element bounds. To constrain the shadow within the constrain region, set the
         * 'constrainShadow' property on this element to 'true'.
         *
         * @param {Ext.util.Positionable/HTMLElement/String/Ext.util.Region} [constrainTo] The
         * Positionable, HTMLElement, element id, or Region into which the element is to be
         * constrained.
         * @param {Number[]} [proposedPosition] A proposed '[X, Y]' position to test for validity
         * and to produce a vector for instead of using the element's current position
         * @param {Number[]} [proposedSize] A proposed '[width, height]' size to constrain
         * instead of using the element's current size
         * @return {Number[]/Boolean} **If** the element *needs* to be translated, an '[X, Y]'
         * vector by which this element must be translated. Otherwise, 'false'.
         */
        getConstrainVector(constrainTo?: Ext.util.Positionable|HTMLElement|string|Ext.util.Region, proposedPosition?: number, proposedSize?: number): number|boolean;

        /**
         * Returns the x coordinate of this element reletive to its 'offsetParent'.
         * @return {Number} The local x coordinate
         */
        getLocalX(): number;

        /**
         * Returns the x and y coordinates of this element relative to its 'offsetParent'.
         * @return {Number[]} The local XY position of the element
         */
        getLocalXY(): number;

        /**
         * Returns the y coordinate of this element reletive to its 'offsetParent'.
         * @return {Number} The local y coordinate
         */
        getLocalY(): number;

        /**
         * Returns the offsets of this element from the passed element. The element must both
         * be part of the DOM tree and not have display:none to have page coordinates.
         * @param {Ext.util.Positionable/HTMLElement/String} offsetsTo The Positionable,
         * HTMLElement, or element id to get get the offsets from.
         * @return {Number[]} The XY page offsets (e.g. '[100, -200]')
         */
        getOffsetsTo(offsetsTo: Ext.util.Positionable|HTMLElement|string): number;

        /**
         * Returns a region object that defines the area of this element.
         * @return {Ext.util.Region} A Region containing "top, left, bottom, right" properties.
         */
        getRegion(): Ext.util.Region;

        /**
         * Returns the **content** region of this element. That is the region within the borders
         * and padding.
         * @return {Ext.util.Region} A Region containing "top, left, bottom, right" member data.
         */
        getViewRegion(): Ext.util.Region;

        /**
         * Gets the current X position of the DOM element based on page coordinates.
         * @return {Number} The X position of the element
         */
        getX(): number;

        /**
         * Gets the current position of the DOM element based on page coordinates.
         * @return {Number[]} The XY position of the element
         */
        getXY(): number;

        /**
         * Gets the current Y position of the DOM element based on page coordinates.
         * @return {Number} The Y position of the element
         */
        getY(): number;

        /**
         * Move the element relative to its current position.
         * @param {String} direction Possible values are:
         *
         * - '"l"' (or '"left"')
         * - '"r"' (or '"right"')
         * - '"t"' (or '"top"', or '"up"')
         * - '"b"' (or '"bottom"', or '"down"')
         *
         * @param {Number} distance How far to move the element in pixels
         */
        move(direction: string, distance: number);

        /**
         * Sets the element's box.
         * @param {Object} box The box to fill {x, y, width, height}
         * @return {Ext.util.Positionable} this
         */
        setBox(box: any): Ext.util.Positionable;

        /**
         * Sets the local x coordinate of this element using CSS style. When used on an
         * absolute positioned element this method is symmetrical with {@link #getLocalX}, but
         * may not be symmetrical when used on a relatively positioned element.
         * @param {Number} x The x coordinate. A value of 'null' sets the left style to 'auto'.
         * @return {Ext.util.Positionable} this
         */
        setLocalX(x: number): Ext.util.Positionable;

        /**
         * Sets the local x and y coordinates of this element using CSS style. When used on an
         * absolute positioned element this method is symmetrical with {@link #getLocalXY}, but
         * may not be symmetrical when used on a relatively positioned element.
         * @param {Number/Array} x The x coordinate or an array containing [x, y]. A value of
         * 'null' sets the left style to 'auto'
         * @param {Number} [y] The y coordinate, required if x is not an array. A value of
         * 'null' sets the top style to 'auto'
         * @return {Ext.util.Positionable} this
         */
        setLocalXY(x: number|any[], y?: number): Ext.util.Positionable;

        /**
         * Sets the local y coordinate of this element using CSS style. When used on an
         * absolute positioned element this method is symmetrical with {@link #getLocalY}, but
         * may not be symmetrical when used on a relatively positioned element.
         * @param {Number} y The y coordinate. A value of 'null' sets the top style to 'auto'.
         * @return {Ext.util.Positionable} this
         */
        setLocalY(y: number): Ext.util.Positionable;

        /**
         * Sets the X position of the DOM element based on page coordinates.
         * @param {Number} x The X position
         * @return {Ext.util.Positionable} this
         */
        setX(x: number): Ext.util.Positionable;

        /**
         * Sets the position of the DOM element in page coordinates.
         * @param {Number[]} pos Contains X & Y [x, y] values for new position (coordinates
         * are page-based)
         * @return {Ext.util.Positionable} this
         */
        setXY(pos: number): Ext.util.Positionable;

        /**
         * Sets the Y position of the DOM element based on page coordinates.
         * @param {Number} y The Y position
         * @return {Ext.util.Positionable} this
         */
        setY(y: number): Ext.util.Positionable;

        /**
         * Translates the passed page coordinates into left/top css values for the element
         * @param {Number/Array} x The page x or an array containing [x, y]
         * @param {Number} [y] The page y, required if x is not an array
         * @return {Object} An object with left and top properties. e.g.
         * {left: (value), top: (value)}
         */
        translatePoints(x: number|any[], y?: number): any;
    }

    export class PositionMap extends Ext.Base {
        constructor(config: any);

        getMinimumHeight();

        setMinimumHeight();
    }

    /**
     * This class represents a rectangular region in X,Y space, and performs geometric
     * transformations or tests upon the region.
     *
     * This class may be used to compare the document regions occupied by elements.
     */
    export class Region extends Ext.Base {
        /**
         * Modifies the current region to be adjusted by offsets.
         * @param {Number} top Top offset
         * @param {Number} right Right offset
         * @param {Number} bottom Bottom offset
         * @param {Number} left Left offset
         * @return {Ext.util.Region} this
         */
        adjust(top: number, right: number, bottom: number, left: number): Ext.util.Region;

        /**
         * Modifies the current region to be constrained to the targetRegion.
         * @return {Ext.util.Region} this
         */
        constrainTo(targetRegion: Ext.util.Region): Ext.util.Region;

        /**
         * Creates a region from the bounding sides.
         * @param {Number} top The topmost pixel of the Region.
         * @param {Number} right The rightmost pixel of the Region.
         * @param {Number} bottom The bottom pixel of the Region.
         * @param {Number} left The leftmost pixel of the Region.
         */
        constructor(top: number, right: number, bottom: number, left: number);

        /**
         * Checks if this region completely contains the region that is passed in.
         * @return {Boolean}
         */
        contains(region: Ext.util.Region): boolean;

        /**
         * Create a copy of this Region.
         * @return {Ext.util.Region}
         */
        copy(): Ext.util.Region;

        /**
         * Copy the values of another Region to this Region
         * @param {Ext.util.Region} p The region to copy from.
         * @return {Ext.util.Region} This Region
         */
        copyFrom(p: Ext.util.Region): Ext.util.Region;

        /**
         * Check whether this region is equivalent to the given region
         * @param {Ext.util.Region} region The region to compare with
         * @return {Boolean}
         */
        equals(region: Ext.util.Region): boolean;

        /**
         * Get the offset amount of a point outside the region
         * @param {String} [axis]
         * @param {Ext.util.Point} [p] the point
         * @return {Ext.util.Offset}
         */
        getOutOfBoundOffset(axis?: string, p?: Ext.util.Point): Ext.util.Offset;

        /**
         * Get the offset amount on the x-axis
         * @param {Number} p the offset
         * @return {Number}
         */
        getOutOfBoundOffsetX(p: number): number;

        /**
         * Get the offset amount on the y-axis
         * @param {Number} p the offset
         * @return {Number}
         */
        getOutOfBoundOffsetY(p: number): number;

        /**
         * Checks if this region intersects the region passed in.
         * @return {Ext.util.Region/Boolean} Returns the intersected region or false if there is no intersection.
         */
        intersect(region: Ext.util.Region): Ext.util.Region|boolean;

        /**
         * Check whether the point / offset is out of bound
         * @param {String} [axis]
         * @param {Ext.util.Point/Number} [p] the point / offset
         * @return {Boolean}
         */
        isOutOfBound(axis?: string, p?: Ext.util.Point|number): boolean;

        /**
         * Check whether the offset is out of bound in the x-axis
         * @param {Number} p the offset
         * @return {Boolean}
         */
        isOutOfBoundX(p: number): boolean;

        /**
         * Check whether the offset is out of bound in the y-axis
         * @param {Number} p the offset
         * @return {Boolean}
         */
        isOutOfBoundY(p: number): boolean;

        /**
         * Round all the properties of this region
         * @return {Ext.util.Region} this This Region
         */
        round(): Ext.util.Region;

        /**
         * Translate this Region by the given offset amount
         * @param {Ext.util.Offset/Object} x Object containing the 'x' and 'y' properties.
         * Or the x value is using the two argument form.
         * @param {Number} y The y value unless using an Offset object.
         * @return {Ext.util.Region} this This Region
         */
        translateBy(x: Ext.util.Offset|any, y: number): Ext.util.Region;

        /**
         * Returns the smallest region that contains the current AND targetRegion.
         * @return {Ext.util.Region} a new region
         */
        union(region: Ext.util.Region): Ext.util.Region;

        /**
         * Creates a Region from a "box" Object which contains four numeric properties 'top', 'right', 'bottom' and 'left'.
         * @param {Object} o An object with 'top', 'right', 'bottom' and 'left' properties.
         * @return {Ext.util.Region} region The Region constructed based on the passed object
         */
        static from(o: any): Ext.util.Region;

        /**
         * Retrieves an Ext.util.Region for a particular element.
         * @param {String/HTMLElement/Ext.dom.Element} el An element ID, htmlElement or Ext.Element representing an element in the document.
         * @return {Ext.util.Region} region
         */
        static getRegion(el: string|HTMLElement|Ext.dom.Element): Ext.util.Region;
    }

    /**
     * This is a base class for objects that can be managed by 'Ext.util.Scheduler'.
     */
    export class Schedulable extends Ext.Base {
        constructor();

        destroy();

        /**
         * This method returns the 'Scheduler' for this item.
         * @return {Ext.util.Scheduler}
         */
        getScheduler(): Ext.util.Scheduler;

        /**
         * Schedules this item with the associated 'Ext.util.Scheduler'.
         */
        schedule();

        /**
         * This method should be overridden by items that have dependencies to insert. The
         * standard form would be:
         *
         *      sort: function () {
         *          this.getScheduler().sortItems(this.dependencies);
         *      }
         *
         * This example assumes the item has a "dependencies" array to pass to the scheduler.
         */
        sort();

        /**
         * Unschedules this item with the associated 'Ext.util.Scheduler'.
         */
        unschedule();
    }

    interface SchedulerConfig {
        /**
         * If provided the 'Schedulable' items will be pre-sorted by this function or
         * property value before the dependency sort.
         */
        preSort?: string|Function;

        /**
         * The number of milliseconds to delay notification after the first 'schedule'
         * request.
         */
        tickDelay?: number;
    }

    /**
     * This class is used to bulk schedule a set of 'Ext.util.Schedulable' items. The items
     * in the scheduler request time by calling their 'schedule' method and when the time has
     * arrived its 'react' method is called.
     *
     * The 'react' methods are called in dependency order as determined by the sorting process.
     * The sorting process relies on each item to implement its own 'sort' method.
     */
    export class Scheduler extends Ext.Base implements Ext.util.SchedulerConfig {
        protected destroyed: boolean;

        /**
         * 'true' to suspend layouts when the scheduler is triggering bindings. Setting this to 'false'
         * may mean multiple layout runs on a single bind call which could affect performance.
         */
        suspendOnNotify: boolean;

        /**
         * If provided the 'Schedulable' items will be pre-sorted by this function or
         * property value before the dependency sort.
         */
        preSort: string|Function;

        /**
         * The number of milliseconds to delay notification after the first 'schedule'
         * request.
         */
        tickDelay: number;

        /**
         * This method should be called when items become busy or idle. These changes are
         * useful outside to do things like update modal masks or status indicators. The
         * changes are delivered as 'busy' and 'idle' events.
         *
         * @param {Number} adjustment Should be '1' or '-1' only to indicate transition to
         * busy state or from busy state, respectively.
         * @since 5.0.0
         */
        adjustBusy(adjustment: number);

        constructor(config: Ext.util.SchedulerConfig);

        destroy();

        getPreSort();

        getTickDelay();

        /**
         * Returns 'true' if this object contains one or more busy items.
         * @return {Boolean}
         * @since 5.0.0
         */
        isBusy(): boolean;

        /**
         * Returns 'true' if this object contains no busy items.
         * @return {Boolean}
         * @since 5.0.0
         */
        isIdle(): boolean;

        /**
         * This method can be called to force the delivery of any scheduled items. This is
         * called automatically on a timer when items request service.
         *
         * @since 5.0.0
         */
        notify();

        setPreSort();

        setTickDelay();

        /**
         * Adds one item to the sorted items array. This can be called by the 'sort' method of
         * '{@link Ext.util.Sortable sortable}' objects to add an item on which it depends.
         *
         * @param {Object} item The item to add.
         * @return {Ext.util.Scheduler} This instance.
         * @since 5.0.0
         */
        sortItem(item: any): Ext.util.Scheduler;

        /**
         * Adds multiple items to the sorted items array. This can be called by the 'sort'
         * method of '{@link Ext.util.Sortable sortable}' objects to add items on which it
         * depends.
         *
         * @param {Object/Object[]} items The items to add. If this is an object, the values
         * are considered the items and the keys are ignored.
         * @return {Ext.util.Scheduler} This instance.
         * @since 5.0.0
         */
        sortItems(items: any): Ext.util.Scheduler;
    }

    export class SizeMonitor extends Ext.Base {
        constructor(config: any);
    }

    interface SortableConfig {
        /**
         * The default sort direction to use if one is not specified.
         */
        defaultSortDirection?: string;

        /**
         * The maximum number of sorters which may be applied to this Sortable when using the "multi" insertion position
         * when adding sorters.
         *
         * New sorters added using the "multi" insertion position are inserted at the top of the sorters list becoming the
         * new primary sort key.
         *
         * If the sorters collection has grown to longer then **'multiSortLimit'**, then the it is trimmed.
         *
         * Optional, Defaults to: 3
         */
        multiSortLimit?: number;

        /**
         * The property in each item that contains the data to sort.
         */
        sortRoot?: string;

        /**
         * The initial set of {@link Ext.util.Sorter Sorters}.
         *
         *     sorters: [{
         *         property: 'age',
         *         direction: 'DESC'
         *     }, {
         *         property: 'firstName',
         *         direction: 'ASC'
         *     }]
         */
        sorters?: Ext.util.Sorter|any;
    }

    /**
     * A mixin which allows a data component to be sorted. This is used by e.g. {@link Ext.data.Store} and {@link Ext.data.TreeStore}.
     *
     * **NOTE**: This mixin is mainly for internal use and most users should not need to use it directly. It
     * is more likely you will want to use one of the component classes that import this mixin, such as
     * {@link Ext.data.Store} or {@link Ext.data.TreeStore}.
     */
    export class Sortable extends Ext.Base implements Ext.util.SortableConfig {
        /**
         * 'true' in this class to identify an object as an instantiated Sortable, or subclass thereof.
         */
        isSortable: boolean;

        /**
         * The default sort direction to use if one is not specified.
         */
        defaultSortDirection: string;

        /**
         * The maximum number of sorters which may be applied to this Sortable when using the "multi" insertion position
         * when adding sorters.
         *
         * New sorters added using the "multi" insertion position are inserted at the top of the sorters list becoming the
         * new primary sort key.
         *
         * If the sorters collection has grown to longer then **'multiSortLimit'**, then the it is trimmed.
         *
         * Optional, Defaults to: 3
         */
        multiSortLimit: number;

        /**
         * The initial set of {@link Ext.util.Sorter Sorters}.
         *
         *     sorters: [{
         *         property: 'age',
         *         direction: 'DESC'
         *     }, {
         *         property: 'firstName',
         *         direction: 'ASC'
         *     }]
         */
        sorters: Ext.util.Sorter|any;

        /**
         * The property in each item that contains the data to sort.
         */
        sortRoot: string;

        /**
         * Returns a comparator function which compares two items and returns -1, 0, or 1 depending
         * on the currently defined set of {@link #cfg-sorters}.
         *
         * If there are no {@link #cfg-sorters} defined, it returns a function which returns '0' meaning
         * that no sorting will occur.
         */
        generateComparator();

        /**
         * Gets the first sorter from the sorters collection, excluding
         * any groupers that may be in place
         * @return {Ext.util.Sorter} The sorter, null if none exist
         */
        protected getFirstSorter(): Ext.util.Sorter;

        /**
         * Returns the number of Sorters which apply to this Sortable.
         *
         * May be overridden in subclasses. {@link Ext.data.Store Store} in particlar overrides
         * this because its groupers must contribute to the sorter count so that the sort method above executes doSort.
         */
        protected getSorterCount();

        getSorters();

        setSorters();

        /**
         * Updates the sorters collection and triggers sorting of this Sortable. Example usage:
         *
         *     //sort by a single field
         *     myStore.sort('myField', 'DESC');
         *
         *     //sorting by multiple fields
         *     myStore.sort([{
         *         property : 'age',
         *         direction: 'ASC'
         *     }, {
         *         property : 'name',
         *         direction: 'DESC'
         *     }]);
         *
         * Classes which use this mixin must implement a **'soSort'** method which accepts a comparator function computed from
         * the full sorter set which performs the sort in an implementation-specific way.
         *
         * When passing a single string argument to sort, Store maintains a ASC/DESC toggler per field, so this code:
         *
         *     store.sort('myField');
         *     store.sort('myField');
         *
         * Is equivalent to this code, because Store handles the toggling automatically:
         *
         *     store.sort('myField', 'ASC');
         *     store.sort('myField', 'DESC');
         *
         * @param {String/Ext.util.Sorter[]} [sorters] Either a string name of one of the fields in this Store's configured {@link Ext.data.Model Model}, or an array of sorter configurations.
         * @param {String} [direction="ASC"] The overall direction to sort the data by.
         * @param {String} [insertionPosition="replace"] Where to put the new sorter in the collection of sorters.
         * This may take the following values:
         *
         * * 'replace' : This means that the new sorter(s) becomes the sole sorter set for this Sortable. This is the most useful call mode
         *           to programatically sort by multiple fields.
         *
         * * 'prepend' : This means that the new sorters are inserted as the primary sorters, unchanged, and the sorter list length must be controlled by the developer.
         *
         * * 'multi' :  This is mainly useful for implementing intuitive "Sort by this" user interfaces such as the {@link Ext.grid.Panel GridPanel}'s column sorting UI.
         *
         *     This mode is only supported when passing a property name and a direction.
         *
         *     This means that the new sorter is becomes the primary sorter. If the sorter was **already** the primary sorter, the direction
         *     of sort is toggled if no direction parameter is specified.
         *
         *     The number of sorters maintained is limited by the {@link #multiSortLimit} configuration.
         *
         * * 'append' : This means that the new sorter becomes the last sorter.
         * @return {Ext.util.Sorter[]} The new sorters.
         */
        sort(sorters?: string|Ext.util.Sorter, direction?: string, insertionPosition?: string): Ext.util.Sorter;

        /**
         * Fires before a sort occurs.
         * @param {Ext.util.Sortable} me This object.
         * @param {Ext.util.Sorter[]} sorters The collection of Sorters being used to generate the comparator function.
         */
        beforesort(me: Ext.util.Sortable, sorters: Ext.util.Sorter);

        /**
         * Creates a single comparator function which encapsulates the passed Sorter array.
         * @param {Ext.util.Sorter[]} sorters The sorter set for which to create a comparator function
         * @return {Function} a function, which when passed two comparable objects returns the result
         * of the whole sorter comparator functions.
         */
        static createComparator(sorters: Ext.util.Sorter): Function;
    }

    export class SorterCollection extends Ext.util.Collection {
        /**
         * This is the cached sorting function which is a generated function that calls all the
         * configured sorters in the correct order.
         * @readonly
         */
        sortFn: any;

        clear();

        constructor(config: any);

        /**
         * Returns an up to date sort function.
         * @return {Function} The sort function.
         */
        getSortFn(): Function;
    }

    interface SorterConfig {
        /**
         * The direction to sort by. Valid values are "ASC", and "DESC".
         */
        direction?: string;

        /**
         * An optional id this sorter can be keyed by in Collections. If
         * no id is specified it will use the property name used in this Sorter. If no
         * property is specified, e.g. when adding a custom sorter function we will generate
         * a random id.
         */
        id?: any;

        /**
         * The property to sort by. Required unless 'sorterFn' is provided
         */
        property?: string;

        /**
         * Optional root property. This is mostly useful when sorting a Store, in which case we set the
         * root to 'data' to make the filter pull the {@link #property} out of the data object of each item
         */
        root?: string;

        /**
         * A specific sorter function to execute. Can be passed instead of {@link #property}.
         * This function should compare the two passed arguments, returning -1, 0 or 1 depending on if item 1 should be
         * sorted before, at the same level, or after item 2.
         *
         *     sorterFn: function(person1, person2) {
         *         return (person1.age > person2.age) ? 1 : (person1.age === person2.age ? 0 : -1);
         *     }
         */
        sorterFn?: Function;

        /**
         * A function that will be run on each value before
         * it is compared in the sorter. The function will receive a single argument,
         * the value.
         */
        transform?: Function;
    }

    /**
     * Represents a single sorter that can be used as part of the sorters configuration in Ext.mixin.Sortable.
     *
     * A common place for Sorters to be used are {@link Ext.data.Store Stores}. For example:
     *
     *      @example
     *      var store = Ext.create('Ext.data.Store', {
     *           fields: ['firstName', 'level'],
     *           sorters: 'level',
     *
     *           data: [
     *               { firstName: 'Mitch',  level: 9000},
     *               { firstName: 'Seth',   level: 42},
     *               { firstName: 'Fred',   level: 510},
     *               { firstName: 'Israel', level: 690},
     *               { firstName: 'Greg',   level: 101},
     *               { firstName: 'Pat',    level: 0},
     *               { firstName: 'Kevin',  level: 17},
     *               { firstName: 'Brandon',level: 690},
     *               { firstName: 'Gary',   level: 409},
     *               { firstName: 'Scott',  level: 789}
     *           ]
     *        });
     *
     *        Ext.create('Ext.grid.Panel', {
     *            title: 'Support',
     *            store: store,
     *            columns: [
     *                { text: 'Name',  dataIndex: 'firstName' },
     *                { text: 'Level', dataIndex: 'level' }
     *            ],
     *            height: 300,
     *            width: 200,
     *            renderTo: Ext.getBody()
     *        });
     *
     * In the next example, we specify a custom sorter function:
     *
     *        @example
     *        var store = Ext.create('Ext.data.Store', {
     *           fields: ['firstName', 'spiritAnimal'],
     *            sorters: [
     *                {
     *                    // Sort by first letter of second word of spirit animal, in descending order
     *                    sorterFn: function(record1, record2) {
     *                        var name1 = record1.data.spiritAnimal.split(' ')[1].substr(0,1),
     *                            name2 = record2.data.spiritAnimal.split(' ')[1].substr(0,1);
     *
     *                        return name1 > name2 ? 1 : (name1 === name2) ? 0 : -1;
     *                    },
     *                    direction: 'DESC'
     *                }
     *            ],
     *
     *           data: [
     *               { firstName: 'Mitch',  spiritAnimal: "Panda Bear"},
     *               { firstName: 'Seth',   spiritAnimal: "Tina Belcher"},
     *               { firstName: 'Fred',   spiritAnimal: "Honey Badger"},
     *               { firstName: 'Israel', spiritAnimal: "Mysterious Capybara"},
     *               { firstName: 'Greg',   spiritAnimal: "Majestic Platypus"},
     *               { firstName: 'Kevin',  spiritAnimal: "Sparkling Unicorn"},
     *               { firstName: 'Brandon',spiritAnimal: "Pygmy Goat"},
     *               { firstName: 'Gary',   spiritAnimal: "Suri Alpaca"},
     *               { firstName: 'Scott',  spiritAnimal: "Ripe Armadillo"},
     *               { firstName: 'Pat',    spiritAnimal: "The Cougar"}
     *           ]
     *        });
     *
     *        Ext.create('Ext.grid.Panel', {
     *            title: 'Support',
     *            store: store,
     *            columns: [
     *                { text: 'Name',          dataIndex: 'firstName' },
     *                { text: 'Spirit Animal', dataIndex: 'spiritAnimal', flex: 1 }
     *            ],
     *            height: 310,
     *            renderTo: Ext.getBody()
     *        });
     */
    export class Sorter extends Ext.Base implements Ext.util.SorterConfig {
        /**
         * The direction to sort by. Valid values are "ASC", and "DESC".
         */
        direction: string;

        /**
         * An optional id this sorter can be keyed by in Collections. If
         * no id is specified it will use the property name used in this Sorter. If no
         * property is specified, e.g. when adding a custom sorter function we will generate
         * a random id.
         */
        id: any;

        /**
         * The property to sort by. Required unless 'sorterFn' is provided
         */
        property: string;

        /**
         * Optional root property. This is mostly useful when sorting a Store, in which case we set the
         * root to 'data' to make the filter pull the {@link #property} out of the data object of each item
         */
        root: string;

        /**
         * A specific sorter function to execute. Can be passed instead of {@link #property}.
         * This function should compare the two passed arguments, returning -1, 0 or 1 depending on if item 1 should be
         * sorted before, at the same level, or after item 2.
         *
         *     sorterFn: function(person1, person2) {
         *         return (person1.age > person2.age) ? 1 : (person1.age === person2.age ? 0 : -1);
         *     }
         */
        sorterFn: Function;

        /**
         * A function that will be run on each value before
         * it is compared in the sorter. The function will receive a single argument,
         * the value.
         */
        transform: Function;

        constructor(config: Ext.util.SorterConfig);

        getDirection();

        getProperty();

        getRoot();

        getSorterFn();

        /**
         * Returns this sorter's state.
         * @return {Object}
         */
        getState(): any;

        getTransform();

        /**
         * Returns this sorter's serialized state. This is used when transmitting this sorter
         * to a server.
         * @return {Object}
         */
        serialize(): any;

        setDirection();

        setId();

        setProperty();

        setRoot();

        setSorterFn();

        setTransform();

        /**
         * Toggles the direction of this Sorter. Note that when you call this function,
         * the Collection this Sorter is part of does not get refreshed automatically.
         */
        toggle();

        /**
         * Creates a comparator function (a function that can be passed to 'Array.sort')
         * given one or more 'Sorter' instances.
         *
         * The returned function retains a reference to the collection or array of sorters
         * passed. This means the function will produce a comparison based on the current
         * content of the collection or array, and not based on the content at the time of
         * this call.
         *
         * @param {Ext.util.Sorter[]/Ext.util.Collection} sorters The 'Sorter' instances.
         * @param [nextFn] The next comparator function to call if all the 'sorters' end
         * with equality.
         * @return {Function} The comparator function.
         */
        static createComparator(sorters: Ext.util.Sorter|Ext.util.Collection): Function;
    }

    /**
     * A wrapper class which can be applied to any element. Fires a "tap" event while
     * touching the device. The interval between firings may be specified in the config but
     * defaults to 20 milliseconds.
     */
    export class TapRepeater extends Ext.Base {
        /**
         * Creates new TapRepeater.
         */
        constructor(config: any);

        destroy();

        getAccelerate();

        getDelay();

        getEl();

        getInterval();

        getPressCls();

        getPreventDefault();

        getStopDefault();

        getTimer();

        setAccelerate();

        setDelay();

        setEl();

        setInterval();

        setPressCls();

        setPreventDefault();

        setStopDefault();

        setTimer();

        /**
         * Fires on a specified interval during the time the element is pressed.
         */
        tap(that: Ext.util.TapRepeater, e: Ext.event.Event);

        /**
         * Fires when the touch is ended.
         */
        touchend(that: Ext.util.TapRepeater, e: Ext.event.Event);

        /**
         * Fires when the touch is started.
         */
        touchstart(that: Ext.util.TapRepeater, e: Ext.event.Event);
    }

    /**
     * A static {@link Ext.util.TaskRunner} instance that can be used to start and stop
     * arbitrary tasks. See {@link Ext.util.TaskRunner} for supported methods and task
     * config properties.
     *
     *     @example
     *     var task, clock;
     *
     *     clock = Ext.getBody().appendChild({
     *         id: 'clock'
     *     });
     *
     *     // Start a simple clock task that updates a div once per second
     *     task = {
     *         run: function() {
     *             clock.setHtml(Ext.Date.format(new Date(), 'g:i:s A'));
     *         },
     *         interval: 1000
     *     };
     *
     *     Ext.TaskManager.start(task);
     *
     * See the {@link #start} method for details about how to configure a task object.
     */
    export class TaskManager {
        /**
         * Provides the ability to execute one or more arbitrary tasks in an asynchronous manner.
         *
         * Generally, you can use the singleton {@link Ext.TaskManager}.  Or you can create
         * separate TaskRunner instances to start and stop unique tasks independent of one
         * another.
         *
         * Example usage:
         *
         *     @example
         *     var runner = new Ext.util.TaskRunner(),
         *         clock, updateClock, task;
         *
         *     clock = Ext.getBody().appendChild({
         *         id: 'clock'
         *     });
         *
         *     // Start a simple clock task that updates a div once per second
         *     updateClock = function() {
         *         clock.setHtml(Ext.Date.format(new Date(), 'g:i:s A'));
         *     };
         *
         *     task = runner.start({
         *         run: updateClock,
         *         interval: 1000
         *     });
         *
         * The equivalent using TaskManager:
         *
         *     @example
         *     var clock, updateClock, task;
         *
         *     clock = Ext.getBody().appendChild({
         *         id: 'clock'
         *     });
         *
         *     // Start a simple clock task that updates a div once per second
         *     updateClock = function() {
         *         clock.setHtml(Ext.Date.format(new Date(), 'g:i:s A'));
         *     };
         *
         *     var task = Ext.TaskManager.start({
         *         run: updateClock,
         *         interval: 1000
         *     });
         *
         * To end a running task:
         *
         *      task.destroy();
         *
         * If a task needs to be started and stopped repeated over time, you can create a
         * {@link Ext.util.TaskRunner.Task Task} instance.
         *
         *     var runner = new Ext.util.TaskRunner(),
         *         task;
         *
         *     task = runner.newTask({
         *         run: function() {
         *             // useful code
         *         },
         *         interval: 1000
         *     });
         *
         *     task.start();
         *
         *     // ...
         *
         *     task.stop();
         *
         *     // ...
         *
         *     task.start();
         *
         * A re-usable, single-run task can be managed similar to the above:
         *
         *     var runner = new Ext.util.TaskRunner(),
         *         task;
         *
         *     task = runner.newTask({
         *         run: function() {
         *             // useful code
         *         },
         *         interval: 1000,
         *         repeat: 1
         *     });
         *
         *     task.start();
         *
         *     // ...
         *
         *     task.stop();
         *
         *     // ...
         *
         *     task.start();
         *
         * See the {@link #start} method for details about how to configure a Task.
         *
         * Also see {@link Ext.util.DelayedTask}.
         *
         * @constructor
         * @param {Number/Object} [interval=10] The minimum precision in milliseconds supported by
         * this TaskRunner instance. Alternatively, a config object to apply to the new instance.
         */
        constructor(interval?: number|any);
    }

    interface TaskRunnerConfig {
        /**
         * This may be configured 'false' to inhibit firing of the {@link
         * Ext.GlobalEvents#idle idle event} after task invocation.
         *
         * Optional, Defaults to: true
         */
        fireIdleEvent?: boolean;

        /**
         * How often to run the task in milliseconds. Defaults to every 10ms.
         */
        interval?: number;
    }

    export class TaskRunner extends Ext.Base implements Ext.util.TaskRunnerConfig {
        /**
         * This may be configured 'false' to inhibit firing of the {@link
         * Ext.GlobalEvents#idle idle event} after task invocation.
         *
         * Optional, Defaults to: true
         */
        fireIdleEvent: boolean;

        /**
         * How often to run the task in milliseconds. Defaults to every 10ms.
         */
        interval: number;

        /**
         * Provides the ability to execute one or more arbitrary tasks in an asynchronous manner.
         *
         * Generally, you can use the singleton {@link Ext.TaskManager}.  Or you can create
         * separate TaskRunner instances to start and stop unique tasks independent of one
         * another.
         *
         * Example usage:
         *
         *     @example
         *     var runner = new Ext.util.TaskRunner(),
         *         clock, updateClock, task;
         *
         *     clock = Ext.getBody().appendChild({
         *         id: 'clock'
         *     });
         *
         *     // Start a simple clock task that updates a div once per second
         *     updateClock = function() {
         *         clock.setHtml(Ext.Date.format(new Date(), 'g:i:s A'));
         *     };
         *
         *     task = runner.start({
         *         run: updateClock,
         *         interval: 1000
         *     });
         *
         * The equivalent using TaskManager:
         *
         *     @example
         *     var clock, updateClock, task;
         *
         *     clock = Ext.getBody().appendChild({
         *         id: 'clock'
         *     });
         *
         *     // Start a simple clock task that updates a div once per second
         *     updateClock = function() {
         *         clock.setHtml(Ext.Date.format(new Date(), 'g:i:s A'));
         *     };
         *
         *     var task = Ext.TaskManager.start({
         *         run: updateClock,
         *         interval: 1000
         *     });
         *
         * To end a running task:
         *
         *      task.destroy();
         *
         * If a task needs to be started and stopped repeated over time, you can create a
         * {@link Ext.util.TaskRunner.Task Task} instance.
         *
         *     var runner = new Ext.util.TaskRunner(),
         *         task;
         *
         *     task = runner.newTask({
         *         run: function() {
         *             // useful code
         *         },
         *         interval: 1000
         *     });
         *
         *     task.start();
         *
         *     // ...
         *
         *     task.stop();
         *
         *     // ...
         *
         *     task.start();
         *
         * A re-usable, single-run task can be managed similar to the above:
         *
         *     var runner = new Ext.util.TaskRunner(),
         *         task;
         *
         *     task = runner.newTask({
         *         run: function() {
         *             // useful code
         *         },
         *         interval: 1000,
         *         repeat: 1
         *     });
         *
         *     task.start();
         *
         *     // ...
         *
         *     task.stop();
         *
         *     // ...
         *
         *     task.start();
         *
         * See the {@link #start} method for details about how to configure a Task.
         *
         * Also see {@link Ext.util.DelayedTask}.
         *
         * @constructor
         * @param {Number/Object} [interval=10] The minimum precision in milliseconds supported by
         * this TaskRunner instance. Alternatively, a config object to apply to the new instance.
         */
        constructor(interval?: number|any);

        /**
         * Destroys this instance, stopping all tasks that are currently running.
         */
        destroy();

        /**
         * Creates a new {@link Ext.util.TaskRunner.Task Task} instance. These instances can
         * be easily started and stopped.
         * @param {Object} config The config object. For details on the supported properties,
         * see {@link #start}.
         *
         * @return {Ext.util.TaskRunner.Task}
         * Ext.util.TaskRunner.Task instance, which can be useful for method chaining.
         */
        newTask(config: Ext.util.TaskRunnerConfig): Ext.util.TaskRunner.Task;

        /**
         * Starts a new task.
         *
         * Before each invocation, Ext injects the property 'taskRunCount' into the task object
         * so that calculations based on the repeat count can be performed.
         *
         * The returned task will contain a 'destroy' method that can be used to destroy the
         * task and cancel further calls. This is equivalent to the {@link #stop} method.
         *
         * @param {Object} task A config object that supports the following properties:
         * @param {Function} task.run The function to execute each time the task is invoked. The
         * function will be called at each interval and passed the 'args' argument if specified,
         * and the current invocation count if not.
         *
         * If a particular scope ('this' reference) is required, be sure to specify it using
         * the 'scope' argument.
         *
         * @param {Function} task.onError The function to execute in case of unhandled
         * error on task.run.
         *
         * @param {Boolean} task.run.return 'false' from this function to terminate the task.
         *
         * @param {Number} task.interval The frequency in milliseconds with which the task
         * should be invoked.
         *
         * @param {Object[]} [task.args] An array of arguments to be passed to the function
         * specified by 'run'. If not specified, the current invocation count is passed.
         *
         * @param {Object} [task.scope] The scope ('this' reference) in which to execute the
         * 'run' function. Defaults to the task config object.
         *
         * @param {Number} [task.duration] The length of time in milliseconds to invoke the task
         * before stopping automatically (defaults to indefinite).
         *
         * @param {Number} [task.repeat] The number of times to invoke the task before stopping
         * automatically (defaults to indefinite).
         *
         * @param {Number} [task.fireIdleEvent=true] If all tasks in a TaskRunner's execution
         * sweep are configured with 'fireIdleEvent: false', then the
         * {@link Ext.GlobalEvents#idle idleEvent} is not fired when the TaskRunner's execution
         * sweep finishes.
         *
         * @param {Boolean} [task.fireOnStart=false] True to run the task immediately instead of
         * waiting for the _interval's_ initial pass to call the _run_ function.
         */
        start(task: any, task_run: Function, task_onError: Function, task_run_return: boolean, task_interval: number, task_args?: any, task_scope?: any, task_duration?: number, task_repeat?: number, task_fireIdleEvent?: number, task_fireOnStart?: boolean);

        /**
         * Stops an existing running task.
         * @param {Object} task The task to stop
         * @return {Object} The task
         */
        stop(task: any): any;

        /**
         * Stops all tasks that are currently running.
         */
        stopAll();
    }

    /**
     * Provides precise pixel measurements for blocks of text so that you can determine
     * the exact pixel height and width of a block of text.
     *
     * **Note:** The TextMetrics tool should only be utilized to measure plain text. Attempting to
     * measure text that includes HTML may return inaccurate results.
     *
     * This measurement works by copying the relevant font-related CSS styles from the element
     * param to the TextMetrics' cached measurement element.  This returns the dimensions of the cached
     * element wrapping the text.  By default, the wrapping element is auto-sized.
     * You must provide a **fixed width** if the passed text is multi-lined.
     *
     * When multiple measurements are being done with the same element styling, you should
     * create a single, reusable TextMetrics instance.  This is more efficient than using the
     * static {@link #measure} method.  The element styles are copied to the cached
     * TextMetrics element once during instantiation versus repeated copying using
     * _measure()_.
     *
     * The following example demonstrates the recommended use of TextMetrics where the custom
     * textfield class sets up a reusable TextMetrics instance used to measure the label
     * width. This example assumes that all instances of _mytextfield_ have the same
     * {@link Ext.form.Labelable#labelClsExtra labelClsExtra} and
     * {@link Ext.form.Labelable#labelStyle labelStyle} configs.
     *
     *     Ext.define('MyApp.view.MyTextField', {
     *         extend: 'Ext.form.field.Text',
     *         xtype: 'mytextfield',
     *
     *         initComponent: function () {
     *             var me = this,
     *                 tm = me.getTextMetrics();
     *
     *             me.labelWidth = tm.getWidth(me.fieldLabel + me.labelSeparator);
     *             me.callParent();
     *         },
     *
     *         getTextMetrics: function () {
     *             var me = this,
     *                 // Using me.self allows labelCls etc. to vary by derived
     *                 // class, but not by instance.
     *                 cls = me.self,
     *                 tm = cls.measurer,
     *                 el;
     *
     *             if (!tm) {
     *                 el = Ext.getBody().createChild();
     *                 el.addCls(me.labelCls + ' ' + me.labelClsExtra).
     *                     applyStyles(me.labelStyle);
     *
     *                 cls.measurer = tm = new Ext.util.TextMetrics(el);
     *             }
     *
     *             return tm;
     *         }
     *     });
     *
     *     Ext.create('Ext.form.Panel', {
     *         title: 'Contact Info',
     *         width: 600,
     *         bodyPadding: 10,
     *         renderTo: Ext.getBody(),
     *         items: [{
     *             xtype: 'mytextfield',
     *             fieldLabel: 'Name',
     *             labelStyle: 'font-size: 10px;'
     *         }, {
     *             xtype: 'mytextfield',
     *             fieldLabel: 'Email Address',
     *             labelStyle: 'font-size: 10px;'
     *         }]
     *     });
     *
     * While less efficient than the preceding example, this example allows each instance of
     * _mytextfield2_ to have unique labelClsExtra and labelStyle configs.  Each custom
     * textfield instance uses the static TextMetrics measure method which will copy the
     * label styles repeatedly, thus being less efficient but more versatile.
     *
     *     Ext.define('MyApp.view.MyTextField2', {
     *         extend: 'Ext.form.field.Text',
     *         xtype: 'mytextfield2',
     *
     *         initComponent: function () {
     *             var me = this,
     *                 el = me.getMeasurementEl(),
     *                 tm = Ext.util.TextMetrics;
     *
     *             me.labelWidth = tm.measure(el, me.fieldLabel + me.labelSeparator).width;
     *             me.callParent();
     *         },
     *
     *         getMeasurementEl: function () {
     *             var me = this,
     *                 cls = MyApp.view.MyTextField2,
     *                 el = cls.measureEl;
     *
     *             if (!el) {
     *                 cls.measureEl = el = Ext.getBody().createChild();
     *             }
     *
     *             el.dom.removeAttribute('style');
     *             el.removeCls(el.dom.className).
     *                 addCls(me.labelCls + ' ' + me.labelClsExtra).
     *                 applyStyles(me.labelStyle);
     *
     *             return el;
     *         }
     *     });
     *
     *     Ext.create('Ext.form.Panel', {
     *         title: 'Contact Info',
     *         width: 600,
     *         bodyPadding: 10,
     *         renderTo: Ext.getBody(),
     *         items: [{
     *             xtype: 'mytextfield2',
     *             fieldLabel: 'Name',
     *             labelStyle: 'font-size: 14px;font-weight: bold;',
     *             labelClsExtra: 'nameLabel'
     *         }, {
     *             xtype: 'mytextfield2',
     *             fieldLabel: 'Email Address',
     *             labelStyle: 'font-size: 10px;',
     *             labelClsExtra: 'emailLabel'
     *         }]
     *     });
     */
    export class TextMetrics extends Ext.Base {
        /**
         * Binds this TextMetrics instance to a new element
         * @param {String/HTMLElement/Ext.dom.Element} el The element or its ID.
         */
        bind(el: string|HTMLElement|Ext.dom.Element);

        /**
         * Creates new TextMetrics.
         * @param {String/HTMLElement/Ext.dom.Element} bindTo The element or its ID to bind to.
         * @param {Number} [fixedWidth] A fixed width to apply to the measuring element.
         */
        constructor(bindTo: string|HTMLElement|Ext.dom.Element, fixedWidth?: number);

        /**
         * Returns the measured height of the specified text
         * @param {String} text The text to measure
         * @return {Number} height The height in pixels
         */
        getHeight(text: string): number;

        /**
         * Returns the size of the specified text based on the internal element's style and width properties
         * @param {String} text The text to measure
         * @return {Object} An object containing the text's size '{width: (width), height: (height)}'
         */
        getSize(text: string): any;

        /**
         * Returns the measured width of the specified text
         * @param {String} text The text to measure
         * @return {Number} width The width in pixels
         */
        getWidth(text: string): number;

        /**
         * Sets a fixed width on the internal measurement element.  If the text will be multiline, you have
         * to set a fixed width in order to accurately measure the text height.
         * @param {Number} width The width to set on the element
         */
        setFixedWidth(width: number);

        /**
         * Measures the size of the specified text
         * @param {String/HTMLElement} el The element, dom node or id from which to copy existing CSS styles
         * that can affect the size of the rendered text
         * @param {String} text The text to measure
         * @param {Number} fixedWidth (optional) If the text will be multiline, you have to set a fixed width
         * in order to accurately measure the text height
         * @return {Object} An object containing the text's size '{width: (width), height: (height)}'
         */
        static measure(el: string|HTMLElement, text: string, fixedWidth: number): any;
    }

    /**
     * The utility class to abstract different implementations to have the best performance when applying 2D translation
     * on any DOM element.
     */
    export class Translatable extends Ext.Base {
        constructor(config: any);
    }

    export class TranslatableGroup extends Ext.util.translatable.Abstract {
        constructor(config: any);

        getActiveIndex();

        getItemLength();

        getItems();

        setActiveIndex();

        setItemLength();

        setItems();
    }

    export class TranslatableList extends Ext.util.translatable.Abstract {
        constructor(config: any);

        getItems();

        setItems();
    }

    /**
     * This class contains utility methods for dealing with TSV (Tab Separated Values) as
     * specified in <a href="http://tools.ietf.org/html/rfc4180">RFC 4180</a>.
     *
     * For details see '{@link Ext.util.DelimitedValue}'.
     *
     * @since 5.1.0
     */
    export class TSV {
        constructor(config: Ext.util.DelimitedValueConfig);
    }

    export class Wrapper extends Ext.Base {
        constructor(elementConfig: any, wrappedElement: any);

        destroy();
    }

    /**
     * This class compiles the XTemplate syntax into a function object. The function is used
     * like so:
     *
     *      function (out, values, parent, xindex, xcount) {
     *          // out is the output array to store results
     *          // values, parent, xindex and xcount have their historical meaning
     *      }
     */
    export class XTemplateCompiler extends Ext.util.XTemplateParser {
        constructor(config: any);

        doDefault();

        doElse();
    }

    /**
     * This class parses the XTemplate syntax and calls abstract methods to process the parts.
     */
    export class XTemplateParser extends Ext.Base {
        /**
         * The 'for' or 'foreach' loop context level. This is adjusted
         * up by one prior to calling {@link #doFor} or {@link #doForEach} and down by one after
         * calling the corresponding {@link #doEnd} that closes the loop. This will be 1 on the
         * first {@link #doFor} or {@link #doForEach} call.
         */
        level: number;

        constructor(config: any);

        /**
         * This method is called to process '<tpl case="action">'. If there are other attributes,
         * these are passed in the actions object.
         * @param {Object} actions Other actions keyed by the attribute name (such as 'exec').
         */
        doCase(action: string, actions: any);

        /**
         * This method is called to process '<tpl default>'.
         */
        doDefault();

        /**
         * This method is called to process '<tpl else>'.
         */
        doElse();

        /**
         * This method is called to process '<tpl elseif="action">'. If there are other attributes,
         * these are passed in the actions object.
         * @param {Object} actions Other actions keyed by the attribute name (such as 'exec').
         */
        doElseIf(action: string, actions: any);

        /**
         * This method is called to process '</tpl>'. It is given the action type that started
         * the tpl and the set of additional actions.
         * @param {String} type The type of action that is being ended.
         * @param {Object} actions The other actions keyed by the attribute name (such as 'exec').
         */
        doEnd(type: string, actions: any);

        /**
         * This method is called to process '{% text %}'.
         */
        doEval(text: string);

        /**
         * This method is called to process '<tpl exec="action">'. If there are other attributes,
         * these are passed in the actions object.
         * @param {Object} actions Other actions keyed by the attribute name.
         */
        doExec(action: string, actions: any);

        /**
         * This method is called to process expressions (like '{[expr]}').
         * @param {String} expr The body of the expression (inside "{[" and "]}").
         */
        doExpr(expr: string);

        /**
         * This method is called to process '<tpl for="action">'. If there are other attributes,
         * these are passed in the actions object.
         * @param {Object} actions Other actions keyed by the attribute name (such as 'exec').
         */
        doFor(action: string, actions: any);

        /**
         * This method is called to process '<tpl foreach="action">'. If there are other
         * attributes, these are passed in the actions object.
         * @param {Object} actions Other actions keyed by the attribute name (such as 'exec').
         */
        doForEach(action: string, actions: any);

        /**
         * This method is called to process '<tpl if="action">'. If there are other attributes,
         * these are passed in the actions object.
         * @param {Object} actions Other actions keyed by the attribute name (such as 'exec').
         */
        doIf(action: string, actions: any);

        /**
         * This method is called to process '<tpl switch="action">'. If there are other attributes,
         * these are passed in the actions object.
         * @param {Object} actions Other actions keyed by the attribute name (such as 'exec').
         */
        doSwitch(action: string, actions: any);

        /**
         * This method is called to process simple tags (like '{tag}').
         */
        doTag();

        /**
         * This method is called to process a piece of raw text from the tpl.
         */
        doText(text: string);

        /**
         * This method is called to process an empty '<tpl>'. This is unlikely to need to be
         * implemented, so a default (do nothing) version is provided.
         */
        doTpl();
    }
}

declare module Ext.util.paintmonitor {
    export class Abstract extends Ext.Base {
        constructor(config: any);

        destroy();

        getArgs();

        getCallback();

        getElement();

        getScope();

        setArgs();

        setCallback();

        setElement();

        setScope();
    }

    export class CssAnimation extends Ext.util.paintmonitor.Abstract {
        constructor(config: any);
    }

    export class OverflowChange extends Ext.util.paintmonitor.Abstract {
        constructor(config: any);
    }
}

declare module Ext.util.sizemonitor {
    export class Abstract extends Ext.Base {
        constructor(config: any);

        destroy();

        getArgs();

        getCallback();

        getElement();

        getScope();

        setArgs();

        setCallback();

        setElement();

        setScope();
    }

    export class OverflowChange extends Ext.util.sizemonitor.Abstract {
        constructor(config: any);
    }

    export class Scroll extends Ext.util.sizemonitor.Abstract {
        constructor(config: any);
    }
}

declare module Ext.util.TaskRunner {
    /**
     * Instances of this class are created by {@link Ext.util.TaskRunner#newTask} method.
     *
     * For details on config properties, see {@link Ext.util.TaskRunner#start}.
     */
    export class Task {
        /**
         * Destroys this instance, stopping this task's execution.
         */
        destroy();

        /**
         * Restarts this task, clearing it duration, expiration and run count.
         * @param {Number} [interval] Optionally reset this task's interval.
         */
        restart(interval?: number);

        /**
         * Starts this task if it is not already started.
         * @param {Number} [interval] Optionally reset this task's interval.
         */
        start(interval?: number);

        /**
         * Stops this task.
         */
        stop();
    }
}

declare module Ext.util.translatable {
    /**
     * The abstract class. Sub-classes are expected, at the very least, to implement translation logics inside
     * the 'translate' method
     */
    export class Abstract extends Ext.Evented {
        constructor(config: any);

        destroy();

        getEasing();

        getEasingX();

        getEasingY();

        /**
         * Returns the translatable object's current position.
         * @return {Object} position An object with x and y properties
         */
        getPosition(): any;

        getUseWrapper();

        setEasing();

        setEasingX();

        setEasingY();

        setUseWrapper();

        /**
         * Fires whenever the animation is ended
         * @param {Number} x The current translation on the x axis
         * @param {Number} y The current translation on the y axis
         */
        animationend(that: Ext.util.translatable.Abstract, x: number, y: number);

        /**
         * Fires for each animation frame
         * @param {Number} x The new translation on the x axis
         * @param {Number} y The new translation on the y axis
         */
        animationframe(that: Ext.util.translatable.Abstract, x: number, y: number);

        /**
         * Fires whenever the animation is started
         * @param {Number} x The current translation on the x axis
         * @param {Number} y The current translation on the y axis
         */
        animationstart(that: Ext.util.translatable.Abstract, x: number, y: number);
    }

    export class CssPosition extends Ext.util.translatable.Dom {
        constructor(config: any);

        destroy();
    }

    /**
     * CSS Transform implementation
     */
    export class CssTransform extends Ext.util.translatable.Dom {
        constructor(config: any);

        destroy();
    }

    export class Dom extends Ext.util.translatable.Abstract {
        constructor(config: any);

        getElement();

        setElement();
    }

    /**
     * Translates the element by setting the scroll position of its parent node.
     */
    export class ScrollParent extends Ext.util.translatable.Dom {
        constructor(config: any);
    }

    /**
     * Scroll position implementation
     */
    export class ScrollPosition extends Ext.util.translatable.Dom {
        constructor(config: any);

        destroy();

        getUseWrapper();

        setUseWrapper();
    }
}

declare module Ext.ux.ajax {
    /**
     * This base class is used to handle data preparation (e.g., sorting, filtering and
     * group summary).
     */
    export class DataSimlet extends Ext.Base {
    }

    /**
     * JSON Simlet.
     */
    export class JsonSimlet extends Ext.ux.ajax.DataSimlet {
    }

    interface SimletConfig {
        responseHeaders?: any;

        responseText?: number;

        responseXML?: number;

        status?: number;

        statusText?: string;
    }

    /**
     * This is a base class for more advanced "simlets" (simulated servers). A simlet is asked
     * to provide a response given a {@link Ext.ux.ajax.SimXhr} instance.
     */
    export class Simlet extends Ext.Base implements Ext.ux.ajax.SimletConfig {
        responseHeaders: any;

        responseText: number;

        responseXML: number;

        status: number;

        statusText: string;

        /**
         * Performs the action requested by the given XHR and returns an object to be applied
         * on to the XHR (containing 'status', 'responseText', etc.). For the most part,
         * this is delegated to 'doMethod' methods on this class, such as 'doGet'.
         *
         * @param {Ext.ux.ajax.SimXhr} xhr The simulated XMLHttpRequest instance.
         * @return {Object} The response properties to add to the XMLHttpRequest.
         */
        exec(xhr: Ext.ux.ajax.SimXhr): any;
    }

    /**
     * This singleton manages simulated Ajax responses. This allows application logic to be
     * written unaware that its Ajax calls are being handled by simulations ("simlets"). This
     * is currently done by hooking {@link Ext.data.Connection} methods, so all users of that
     * class (and {@link Ext.Ajax} since it is a derived class) qualify for simulation.
     *
     * The requires hooks are inserted when either the {@link #init} method is called or the
     * first {@link Ext.ux.ajax.Simlet} is registered. For example:
     *
     *      Ext.onReady(function () {
     *          initAjaxSim();
     *
     *          // normal stuff
     *      });
     *
     *      function initAjaxSim () {
     *          Ext.ux.ajax.SimManager.init({
     *              delay: 300
     *          }).register({
     *              '/app/data/url': {
     *                  type: 'json',  // use JsonSimlet (type is like xtype for components)
     *                  data: [
     *                      { foo: 42, bar: 'abc' },
     *                      ...
     *                  ]
     *              }
     *          });
     *      }
     *
     * As many URL's as desired can be registered and associated with a {@link Ext.ux.ajax.Simlet}. To make
     * non-simulated Ajax requests once this singleton is initialized, add a 'nosim:true' option
     * to the Ajax options:
     *
     *      Ext.Ajax.request({
     *          url: 'page.php',
     *          nosim: true, // ignored by normal Ajax request
     *          params: {
     *              id: 1
     *          },
     *          success: function(response){
     *              var text = response.responseText;
     *              // process server response here
     *          }
     *      });
     */
    export class SimManager {
        /**
         * The {@link Ext.ux.ajax.Simlet} instance to use for non-matching URL's. By default, this will
         * return 404. Set this to null to use real Ajax calls for non-matching URL's.
         */
        static defaultSimlet: Ext.ux.ajax.Simlet;

        /**
         * The default 'type' to apply to generic {@link Ext.ux.ajax.Simlet} configuration objects. The
         * default is 'basic'.
         */
        static defaultType: string;

        /**
         * The number of milliseconds to delay before delivering a response to an async request.
         */
        static delay: number;

        /**
         * Initializes this singleton and applies configuration options.
         * @param {Object} config An optional object with configuration properties to apply.
         * @return {Ext.ux.ajax.SimManager} this
         */
        static init(config: any): Ext.ux.ajax.SimManager;

        /**
         * Registeres one or more {@link Ext.ux.ajax.Simlet} instances.
         * @param {Array/Object} simlet Either a {@link Ext.ux.ajax.Simlet} instance or config, an Array
         * of such elements or an Object keyed by URL with values that are {@link Ext.ux.ajax.Simlet}
         * instances or configs.
         */
        static register(simlet: any[]|any);
    }

    /**
     * Simulates an XMLHttpRequest object's methods and properties but is backed by a
     * {@link Ext.ux.ajax.Simlet} instance that provides the data.
     */
    export class SimXhr extends Ext.Base {
        constructor(config: any);
    }

    /**
     * This class simulates XML-based requests.
     */
    export class XmlSimlet extends Ext.ux.ajax.DataSimlet {
        /**
         * This template is used to populate the XML response. The configuration of the Reader
         * is available so that its 'root' and 'record' properties can be used as well as the
         * 'fields' of the associated 'model'. But beyond that, the way these pieces are put
         * together in the document requires the flexibility of a template.
         */
        xmlTpl: any;
    }
}

declare module Ext.ux.event {
    /**
     * This is the base class for {@link Ext.ux.event.Recorder} and {@link Ext.ux.event.Player}.
     */
    export class Driver extends Ext.util.Observable {
        /**
         * Returns the number of milliseconds since start was called.
         */
        getTimestamp();

        /**
         * Starts this object. If this object is already started, nothing happens.
         */
        start();

        /**
         * Stops this object. If this object is not started, nothing happens.
         */
        stop();
    }

    /**
     * Event maker.
     */
    export class Maker extends Ext.Base {
        constructor(config: any);
    }

    interface PlayerConfig extends Ext.mixin.ObservableConfig {
        /**
         * The event queue to playback. This must be provided before
         * the {@link #method-start} method is called.
         */
        eventQueue?: any[];

        /**
         * An object that describes the events that should generate
         * keyframe events. For example, '{ click: true }' would generate keyframe events after
         * each 'click' event.
         */
        keyFrameEvents?: any;

        /**
         * True to pause event playback during animations, false
         * to ignore animations. Default is true.
         */
        pauseForAnimations?: boolean;

        /**
         * The playback speed multiplier. Default is 1.0 (to playback at the
         * recorded speed). A value of 2 would playback at 2x speed.
         */
        speed?: number;
    }

    /**
     * @extends Ext.ux.event.Driver
     * This class manages the playback of an array of "event descriptors". For details on the
     * contents of an "event descriptor", see {@link Ext.ux.event.Recorder}. The events recorded by the
     * {@link Ext.ux.event.Recorder} class are designed to serve as input for this class.
     *
     * The simplest use of this class is to instantiate it with an {@link #eventQueue} and call
     * {@link #method-start}. Like so:
     *
     *      var player = Ext.create('Ext.ux.event.Player', {
     *          eventQueue: [ ... ],
     *          speed: 2,  // play at 2x speed
     *          listeners: {
     *              stop: function () {
     *                  player = null; // all done
     *              }
     *          }
     *      });
     *
     *      player.start();
     *
     * A more complex use would be to incorporate keyframe generation after playing certain
     * events.
     *
     *      var player = Ext.create('Ext.ux.event.Player', {
     *          eventQueue: [ ... ],
     *          keyFrameEvents: {
     *              click: true
     *          },
     *          listeners: {
     *              stop: function () {
     *                  // play has completed... probably time for another keyframe...
     *                  player = null;
     *              },
     *              keyframe: onKeyFrame
     *          }
     *      });
     *
     *      player.start();
     *
     * If a keyframe can be handled immediately (synchronously), the listener would be:
     *
     *      function onKeyFrame () {
     *          handleKeyFrame();
     *      }
     *
     *  If the keyframe event is always handled asynchronously, then the event listener is only
     *  a bit more:
     *
     *      function onKeyFrame (p, eventDescriptor) {
     *          eventDescriptor.defer(); // pause event playback...
     *
     *          handleKeyFrame(function () {
     *              eventDescriptor.finish(); // ...resume event playback
     *          });
     *      }
     *
     * Finally, if the keyframe could be either handled synchronously or asynchronously (perhaps
     * differently by browser), a slightly more complex listener is required.
     *
     *      function onKeyFrame (p, eventDescriptor) {
     *          var async;
     *
     *          handleKeyFrame(function () {
     *              // either this callback is being called immediately by handleKeyFrame (in
     *              // which case async is undefined) or it is being called later (in which case
     *              // async will be true).
     *
     *              if (async) {
     *                  eventDescriptor.finish();
     *              } else {
     *                  async = false;
     *              }
     *          });
     *
     *          // either the callback was called (and async is now false) or it was not
     *          // called (and async remains undefined).
     *
     *          if (async !== false) {
     *              eventDescriptor.defer();
     *              async = true; // let the callback know that we have gone async
     *          }
     *      }
     */
    export class Player extends Ext.ux.event.Driver implements Ext.ux.event.PlayerConfig {
        /**
         * The event queue to playback. This must be provided before
         * the {@link #method-start} method is called.
         */
        eventQueue: any[];

        /**
         * An object that describes the events that should generate
         * keyframe events. For example, '{ click: true }' would generate keyframe events after
         * each 'click' event.
         */
        keyFrameEvents: any;

        /**
         * True to pause event playback during animations, false
         * to ignore animations. Default is true.
         */
        pauseForAnimations: boolean;

        /**
         * The playback speed multiplier. Default is 1.0 (to playback at the
         * recorded speed). A value of 2 would playback at 2x speed.
         */
        speed: number;

        /**
         * Returns the element given is XPath-like description.
         * @param {String} xpath The XPath-like description of the element.
         * @return {HTMLElement}
         */
        getElementFromXPath(xpath: string): HTMLElement;

        /**
         * Called to inject the given event on the specified target.
         * @param {HTMLElement} target The target of the event.
         * @param {Object} event The event to inject. The properties of this object should be
         * those of standard DOM events but vary based on the 'type' property. For details on
         * event types and their properties, see the class documentation.
         */
        injectEvent(target: HTMLElement, event: any);

        /**
         * This method is called after an event has been played to prepare for the next event.
         * @param {Object} eventDescriptor The descriptor of the event just played.
         */
        nextEvent(eventDescriptor: any);

        /**
         * This method returns the event descriptor at the front of the queue. This does not
         * dequeue the event. Repeated calls return the same object (until {@link #nextEvent}
         * is called).
         */
        peekEvent();

        /**
         * This method dequeues and injects events until it has arrived at the time index. If
         * no events are ready (based on the time index), this method does nothing.
         * @return {Boolean} True if there is more to do; false if not (at least for now).
         */
        processEvents(): boolean;

        /**
         * This method is called when a keyframe is reached. This will fire the keyframe event.
         * If the keyframe has been handled, true is returned. Otherwise, false is returned.
         * @param {Object} eventDescriptor The event descriptor of the keyframe.
         * @return {Boolean} True if the keyframe was handled, false if not.
         */
        processKeyFrame(eventDescriptor: any): boolean;

        /**
         * Replaces an event in the queue with an array of events. This is often used to roll
         * up a multi-step pseudo-event and expand it just-in-time to be played. The process
         * for doing this in a derived class would be this:
         *
         *      Ext.define('My.Player', {
         *          extend: 'Ext.ux.event.Player',
         *
         *          peekEvent: function () {
         *              var event = this.callParent();
         *
         *              if (event.multiStepSpecial) {
         *                  this.replaceEvent(null, [
         *                      ... expand to actual events
         *                  ]);
         *
         *                  event = this.callParent(); // get the new next event
         *              }
         *
         *              return event;
         *          }
         *      });
         *
         * This method ensures that the 'beforeplay' hook (if any) from the replaced event is
         * placed on the first new event and the 'afterplay' hook (if any) is placed on the
         * last new event.
         *
         * @param {Number} index The queue index to replace. Pass 'null' to replace the event
         * at the current 'queueIndex'.
         * @param {Event[]} events The array of events with which to replace the specified
         * event.
         */
        replaceEvent(index: number, events: Event);

        /**
         * Fires before an event is played.
         * @param {Object} eventDescriptor The event descriptor about to be played.
         */
        beforeplay(that: Ext.ux.event.Player, eventDescriptor: any);

        /**
         * Fires when this player reaches a keyframe. Typically, this is after events
         * like 'click' are injected and any resulting animations have been completed.
         * @param {Object} eventDescriptor The keyframe event descriptor.
         */
        keyframe(that: Ext.ux.event.Player, eventDescriptor: any);
    }

    /**
     * @extends Ext.ux.event.Driver
     * Event recorder.
     */
    export class Recorder extends Ext.ux.event.Driver {
        /**
         * Fires when an event is added to the recording.
         * @param {Object} eventDescriptor The event descriptor.
         */
        add(that: Ext.ux.event.Recorder, eventDescriptor: any);

        /**
         * Fires when an event is coalesced. This edits the tail of the recorded
         * event list.
         * @param {Object} eventDescriptor The event descriptor that was coalesced.
         */
        coalesce(that: Ext.ux.event.Recorder, eventDescriptor: any);
    }
}

declare module Ext.ux.google {
    /**
     * This base class can be used by derived classes to dynamically require Google API's.
     */
    export class Api extends Ext.Base {
    }

    /**
     * This class, when required, ensures that the Google RSS Feeds API is available.
     */
    export class Feeds extends Ext.ux.google.Api {
    }
}

declare module Ext.viewport {
    /**
     * Android version of viewport.
     */
    export class Android extends Ext.viewport.Default {
        constructor();

        getTranslatable();

        setTranslatable();
    }

    interface DefaultConfig extends Ext.ContainerConfig {
        id?: any;

        /**
         * Configuration for this Container's layout. Example:
         *
         *     Ext.create('Ext.Container', {
         *         layout: {
         *             type: 'hbox',
         *             align: 'middle'
         *         },
         *         items: [
         *             {
         *                 xtype: 'panel',
         *                 flex: 1,
         *                 style: 'background-color: red;'
         *             },
         *             {
         *                 xtype: 'panel',
         *                 flex: 2,
         *                 style: 'background-color: green'
         *             }
         *         ]
         *     });
         */
        layout?: any|string;

        /**
         * Whether or not to always prevent default panning behavior of the
         * browser's viewport.
         */
        preventPanning?: boolean;

        /**
         * 'true' to attempt to stop zooming when you double tap on the screen on mobile devices,
         * typically HTC devices with HTC Sense UI.
         */
        preventZooming?: boolean;
    }

    /**
     * Base class for iOS and Android viewports.
     */
    export class Default extends Ext.Container implements Ext.viewport.DefaultConfig {
        /**
         * 'true' if the DOM is ready.
         */
        isReady: boolean;

        id: string;

        /**
         * Configuration for this Container's layout. Example:
         *
         *     Ext.create('Ext.Container', {
         *         layout: {
         *             type: 'hbox',
         *             align: 'middle'
         *         },
         *         items: [
         *             {
         *                 xtype: 'panel',
         *                 flex: 1,
         *                 style: 'background-color: red;'
         *             },
         *             {
         *                 xtype: 'panel',
         *                 flex: 2,
         *                 style: 'background-color: green'
         *             }
         *         ]
         *     });
         */
        layout: any|string;

        /**
         * Whether or not to always prevent default panning behavior of the
         * browser's viewport.
         */
        preventPanning: boolean;

        /**
         * 'true' to attempt to stop zooming when you double tap on the screen on mobile devices,
         * typically HTC devices with HTC Sense UI.
         */
        preventZooming: boolean;

        constructor(config: Ext.viewport.DefaultConfig);

        getLayout();

        getPreventPanning();

        getPreventZooming();

        getUseBodyElement();

        /**
         * Retrieves the document height.
         * @return {Number} height in pixels.
         */
        getWindowHeight(): number;

        /**
         * Retrieves the document width.
         * @return {Number} width in pixels.
         */
        getWindowWidth(): number;

        /**
         * Hides all visible menus.
         */
        hideAllMenus();

        /**
         * Hides a menu specified by the menu's side.
         * @param {String} side The side which the menu is placed.
         */
        hideMenu(side: string);

        /**
         * Hides all menus except for the side specified
         * @param {String} side         Side(s) not to hide
         * @param {String} animation    Animation to hide with
         */
        hideOtherMenus(side: string, animation: string);

        protected initialize();

        protected initInheritedState(inheritedState: any, inheritedStateInner: any);

        /**
         * Removes a menu from a specified side.
         * @param {String} side The side to remove the menu from
         */
        removeMenu(side: string);

        setLayout();

        /**
         * Sets a menu for a given side of the Viewport.
         *
         * Adds functionality to show the menu by swiping from the side of the screen from the given side.
         *
         * If a menu is already set for a given side, it will be removed.
         *
         * Available sides are: 'left', 'right', 'top', and 'bottom'.
         *
         * **Note:** The 'cover' and 'reveal' animation configs are mutually exclusive.
         * Include only one animation config or omit both to default to 'cover'.
         *
         * @param {Ext.Menu/Object} menu The menu instance or config to assign to the viewport.
         * @param {Object} config The configuration for the menu.
         * @param {String} config.side The side to put the menu on.
         * @param {Boolean} config.cover True to cover the viewport content. Defaults to 'true'.
         * @param {Boolean} config.reveal True to push the menu alongside the viewport
         * content. Defaults to 'false'.
         *
         * @return {Ext.Menu} The menu.
         */
        setMenu(menu: Ext.Menu|any, config: Ext.viewport.DefaultConfig, config_side: string, config_cover: boolean, config_reveal: boolean): Ext.Menu;

        setPreventPanning();

        setPreventZooming();

        setUseBodyElement();

        /**
         * Shows a menu specified by the menu's side.
         * @param {String} side The side which the menu is placed.
         */
        showMenu(side: string);

        /**
         * Toggles the menu specified by side
         * @param {String} side The side which the menu is placed.
         */
        toggleMenu(side: string);

        /**
         * Fires when the Viewport is maximized.
         */
        maximize(that: Ext.Viewport);

        /**
         * Fires when the Viewport is in the DOM and ready.
         */
        ready(that: Ext.Viewport);
    }

    /**
     * iOS version of viewport.
     */
    export class Ios extends Ext.viewport.Default {
        constructor();
    }

    /**
     * This class acts as a factory for environment-specific viewport implementations.
     *
     * Please refer to the {@link Ext.Viewport} documentation about using the global instance.
     */
    export class Viewport {
    }

    /**
     * Windows Phone version of Viewport.
     */
    export class WindowsPhone extends Ext.viewport.Default {
        constructor(config: Ext.viewport.DefaultConfig);

        getTranslatable();

        protected initialize();

        setTranslatable();
    }
}
